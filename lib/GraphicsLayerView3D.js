var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp(a2, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop))
        __defNormalProp(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps = (a2, b2) => __defProps(a2, __getOwnPropDescs(b2));
import { N as e$c, O as y$c, P as n$d, g4 as g$b, K as n$e, g5 as j$5, bm as f$a, g6 as o$6, ce as v$b, r as k$7, a2 as t$7, g7 as a$9, g8 as N$4, bj as l$c, C as r$d, e8 as l$d, g9 as h$9, ga as c$e, gb as b$e, gc as u$f, gd as S$e, ge as a$a, gf as c$f, gg as f$b, gh as e$d, gi as c$g, gj as i$7, al as m$8, a8 as n$f, gk as O$7, cE as pn, gl as t$8, gm as s$9, bO as n$g, aS as o$7, f7 as t$9, ep as Zn, bA as e$e, a1 as n$h, ch as xn, bg as r$e, fF as k$8, cd as a$b, f9 as d$f, fa as q$6, bD as O$9, be as u$g, gn as P$7, cf as A$6, ck as p$9, z as i$a, go as V$4, gp as j$7, gq as p$a, gr as u$i, cz as n$i, gs as d$g, ea as s$a, A as e$f, el as l$e, bY as r$f, cW as gn, gt as E$c, ee as u$j, ef as c$h, dw as o$8, br as r$g, bw as n$k, bK as l$f, gu as t$c, f8 as f$d, fK as u$n, gv as l$h, gw as i$c, e2 as e$k, gx as w$7, gy as D$4, eh as u$o, gz as J$2, aN as E$f, gA as vn, Z as v$d, gB as nt$1, gC as t$e, gD as w$8, bc as g$d, bt as l$i, gE as c$j, gF as f$e, gG as l$j, gH as M$8, gI as B$7, fO as w$9, s as s$d, gJ as q$7, ej as e$l, ah as L$5, X as y$e, gK as t$f, gL as e$m, cQ as h$d, gM as g$e, b_ as M$9, gN as R$9, bE as z$5, b9 as e$n, bb as _$d, cN as e$o, gO as h$e, bd as a$g, eu as r$i, cH as s$e, cI as u$p, c1 as i$d, bz as c$l, cM as r$j, e1 as m$9, da as b$f, ek as l$l, cA as a$h, gP as m$a, gQ as g$f, gR as nt$2, dc as has, gS as It, gT as b$g, gU as w$a, w as d$j, gV as o$e, gW as j$8, bM as w$b, bU as a$i, bJ as r$k, b$ as f$h, bH as n$m, gX as e$q, bo as G$4, af as o$j, cg as r$m, ei as t$k, ec as _$e, e4 as r$n, gY as Hn, bf as P$9, c0 as x$e, gZ as o$l, aG as An, g_ as c$q, cj as e$v, g$ as p$e, h0 as u$r, h1 as w$c, bI as R$b, e5 as l$p, h2 as p$f, h3 as g$h, L as s$j, h4 as c$s, h5 as F$a, h6 as t$m, ba as s$k, dI as n$q, bV as j$a, h7 as c$t, h8 as a$n, h9 as t$n, bB as p$h, bG as _$f, cC as q$8, bN as p$i, d7 as g$i, dZ as j$b, ha as _$g, bW as o$n, bv as s$l, bs as v$i, hb as q$9, eS as l$q, hc as F$b, et as r$s, hd as u$u, he as e$A, cJ as u$v, ew as ee$1, hf as b$j, a_ as q$a, b2 as Y$5, hg as b$k, fn as C$d, a4 as $$3, hh as D$6, hi as m$g, hj as l$r, hk as r$t, hl as d$p, hm as C$e, hn as G$7, bQ as t$o, er as r$u, ho as o$s, hp as y$f, e7 as l$s, hq as S$h, ad as l$t, dd as f$n, bn as a$s, ai as w$d, f6 as F$c, f4 as I$a, dt as h$l, E as E$l, f3 as n$t, hr as t$p, hs as A$9, aQ as jn, I as w$e, ht as m$h, hu as d$q, hv as T$7, hw as Bn, hx as M$a, hy as b$l, hz as m$i, hA as f$o, hB as f$p, hC as s$m, eq as i$o, m as b$m, hD as C$f, hE as v$m, hF as S$i, hG as u$w, eA as a$t, hH as y$g, hI as h$m, hJ as R$d, hK as b$n, aR as x$i, eb as R$e, dq as H$6, fu as O$b, hL as P$a, ft as A$a, hM as p$k, eP as h$n, dC as U$8, bX as h$o, dr as d$r, hN as c$v, hO as x$j, J as g$j, k as j$d, hP as M$b } from "./index.js";
import { h as h$8, t as d$d, u as u$e, w as d$e, y as j$6, U as U$4, z as t$a, D as i$9, G as X$2, I as D$3, L as L$4, n as E$b, C as C$a, K as v$c, R as R$7, M as x$a, N as f$c, O as B$5, P as x$b, x as x$c, S as h$a, A as A$7, V as c$i, W as u$k, Y as a$d, _ as p$b, $ as p$c, a0 as g$c, a1 as s$c, f as f$f, a2 as ue$4, a3 as S$f, a4 as v$e, E as E$g, a5 as I$8, a6 as e$p, o as o$d, Q as Q$1, b as b$h, T as T$6, a as a$j, a7 as r$l, a8 as p$d, a9 as s$f, aa as i$f, ab as s$g, ac as t$i, ad as o$g, ae as e$t, af as a$l, ag as f$k, ah as a$m, H as H$5, i as i$h, d as m$c, s as s$i, F as F$8, ai as r$o, J as J$3, aj as e$w, ak as i$j, al as t$l, am as U$5, an as I$9, ao as G$6, ap as J$4, aq as r$r, ar as V$6, m as m$e, v as v$l, c as m$f, as as d$o, at as f$m, au as x$h, av as j$c, l as l$u, e as e$C, aw as z$6 } from "./NativeLineMaterial.js";
import { i as i$8 } from "./optimizedFeatureQueryEngineAdapter.js";
import { O as O$8 } from "./VertexAttribute.js";
import { u as u$h, W as W$3, a as a$e, e as l$g, _ as _$c, f as a$f, n as n$l, j as c$m, o as o$h, c as c$n, A as A$8, l as l$m, E as E$h, C as C$c, m as o$r, b as _$h, h as h$i, d as a$q, S as S$g, i as i$n } from "./OrderIndependentTransparency.js";
import { A as A$5, a as a$c, f as f$g } from "./edgeUtils.js";
import { d as o$9, C as u$l, m as e$g, o as o$a, b as e$h, aj as i$b, c as n$j, t as t$b, h as e$i, i as o$b, E as E$d, j as e$j, J as s$b, K as d$h, q as E$e, z as h$b, N as t$d, O as h$c, Q as y$d, au as B$6, aw as u$m, s as o$c, w as d$i, L as L$6, a6 as o$f, a1 as a$k, F as v$f, a8 as t$h, G as d$k, g as e$r, a9 as n$n, H as n$o, f as f$i, D as e$s, I as t$j, T as e$u, U as o$i, V as f$j, aa as s$h, ab as m$b, ac as l$n, ad as P$8, ae as i$g, W as h$f, ag as v$g, r as r$p, aZ as U$6, a_ as p$g, a$ as v$j, e as e$x, _ as o$o, $ as o$p, a0 as e$y, b0 as o$q, A as r$q, aP as v$k, aL as d$m, an as a$o, az as i$k, y as c$u, aJ as a$p, aO as d$n, aQ as i$m, b1 as O$a, x as f$l, P as m$d, ay as e$B, M as x$g, av as h$j } from "./SSAOHelper.js";
import { T as T$4 } from "./InterleavedLayout.js";
import { I as I$7, R as R$8, D as D$5, F as F$9 } from "./enums.js";
import { x as x$d } from "./earcut.js";
import { T as T$5, i as i$i, b as b$i, l as l$o, u as u$s, h as h$g, c as c$r, d as d$l, x as x$f, a as a$r } from "./BufferView.js";
import { t as t$g, r as r$h } from "./vec33.js";
import { l as l$k, c as c$k } from "./triangulationUtils.js";
import { C as C$b, c as c$p, E as E$j, B as B$8, Y as Y$4, p as p$j, n as n$r, e as e$z, h as h$h, u as u$t, i as i$l } from "./objectResourceUtils.js";
import { i as i$e } from "./callExpressionWithFeature.js";
import { g as g$g, c as c$o } from "./MeshComponent.js";
import { R as R$a, v as v$h, j as j$9, V as V$5, k as k$9 } from "./projection.js";
import { n as n$p, o as o$k } from "./symbolColorUtils.js";
import { u as u$q } from "./Indices.js";
import { o as o$m } from "./glUtil.js";
import { G as G$5, U as U$7 } from "./Octree.js";
import { E as E$i, R as R$c, b as E$k } from "./VertexArrayObject.js";
import { n as n$s } from "./vec3f32.js";
import { h as h$k } from "./PooledRBush.js";
import { v as v$n, b as b$o } from "./lineSegment.js";
import { projectGeometry as a$u } from "./geometryServiceUtils.js";
import { u as u$x } from "./LayerView.js";
const n$c = (n2) => {
  let c2 = class extends n2 {
    constructor() {
      super(...arguments), this.slicePlaneEnabled = false, this.supportsHeightUnitConversion = false;
    }
    postscript(e2) {
      super.postscript(e2), g$b(this.layer) && this.addResolvingPromise(this._validateHeightModelInfo());
    }
    async _validateHeightModelInfo() {
      const e2 = new AbortController(), o2 = e2.signal;
      this.handles.add(n$e(() => e2.abort())), await j$5(() => {
        var _a;
        return (_a = this.view.defaultsFromMap) == null ? void 0 : _a.heightModelInfoReady;
      }, o2), f$a(o2);
      const i2 = o$6(this.layer, this.view.heightModelInfo, this.supportsHeightUnitConversion);
      if (i2)
        throw i2;
    }
    canResume() {
      const e2 = this.layer && "effectiveScaleRange" in this.layer ? this.layer.effectiveScaleRange : null;
      return super.canResume() && (!e2 || !e2.minScale || !e2.maxScale || e2.minScale >= e2.maxScale);
    }
    getSuspendInfo() {
      const e2 = super.getSuspendInfo(), s2 = this.layer && "effectiveScaleRange" in this.layer ? this.layer.effectiveScaleRange : null;
      return s2 && s2.minScale && s2.maxScale && s2.minScale < s2.maxScale && (e2.outsideScaleRange = true), e2;
    }
  };
  return e$c([y$c()], c2.prototype, "view", void 0), e$c([y$c()], c2.prototype, "slicePlaneEnabled", void 0), c2 = e$c([n$d("esri.views.3d.layers.LayerView3D")], c2), c2;
};
async function m$7(t2, n2, i2, f2, m2) {
  const { elevationProvider: j2, renderCoordsHelper: u2, spatialReference: y2 } = t2, { elevationInfo: v2 } = n2, I2 = d$d(v2, true), g2 = await u$e(I2, y2, m2);
  f$a(m2);
  const x2 = [], h2 = new Set(), w2 = new Set();
  for (const { objectId: o2, points: a2 } of f2) {
    const p2 = i2(o2);
    if (t$7(p2)) {
      for (const e2 of a2)
        x2.push(e2[2]);
      h2.add(o2);
      continue;
    }
    p2.isDraped && w2.add(o2);
    const f3 = p2.graphic.geometry;
    c$d.setFromElevationInfo(a$9(f3, v2)), c$d.updateFeatureExpressionInfoContext(g2, p2.graphic, n2), l$b.spatialReference = t2.spatialReference;
    for (const { x: e2, y: o3, z: t3 } of a2)
      l$b.x = e2, l$b.y = o3, l$b.z = t3 != null ? t3 : 0, d$e(l$b, j2, c$d, u2, d$c), x2.push(d$c.z);
  }
  return { elevations: x2, drapedObjectIds: w2, failedObjectIds: h2 };
}
const c$d = new h$8(), l$b = v$b(0, 0, 0, k$7.WGS84), d$c = new j$6();
function i$6(e2, o2) {
  if (!e2 || e2.symbol)
    return null;
  const r2 = o2 && o2.renderer;
  return e2 && r$d(r2) && r2.getObservationRenderer ? r2.getObservationRenderer(e2) : r2;
}
function n$b(e2, o2) {
  if (r$d(e2.symbol))
    return e2.symbol;
  const r2 = i$6(e2, o2);
  return r$d(r2) && r2.type !== "dot-density" ? r2.getSymbol(e2, o2) : null;
}
function a$8(e2, t2) {
  var _a;
  const a2 = i$6(e2, t2), l2 = n$b(e2, t2);
  if (t$7(l2))
    return null;
  const s2 = { renderer: a2, symbol: l2 };
  if (t$7(a2) || !("visualVariables" in a2) || !a2.visualVariables)
    return s2;
  const u2 = (_a = N$4(a2, e2, t2)) != null ? _a : [], c2 = ["proportional", "proportional", "proportional"];
  for (const { variable: o2, value: r2 } of u2)
    switch (o2.type) {
      case "color":
        s2.color = r2.toRgba();
        break;
      case "size":
        if (o2.target === "outline")
          s2.outlineSize = r2;
        else {
          const e3 = o2.axis, t3 = o2.useSymbolValue ? "symbol-value" : r2;
          switch (e3) {
            case "width":
              c2[0] = t3;
              break;
            case "depth":
              c2[1] = t3;
              break;
            case "height":
              c2[2] = t3;
              break;
            case "width-and-depth":
              c2[0] = c2[1] = t3;
              break;
            default:
              c2[0] = c2[1] = c2[2] = t3;
          }
        }
        break;
      case "opacity":
        s2.opacity = r2;
        break;
      case "rotation":
        switch (o2.axis) {
          case "tilt":
            s2.tilt = r2;
            break;
          case "roll":
            s2.roll = r2;
            break;
          default:
            s2.heading = r2;
        }
    }
  return c2[0] === "proportional" && c2[1] === "proportional" && c2[2] === "proportional" || (s2.size = c2), s2;
}
async function l$a(e2, o2) {
  if (r$d(e2.symbol))
    return e2.symbol;
  const r2 = i$6(e2, o2);
  return r$d(r2) ? r2.getSymbolAsync(e2, o2) : null;
}
async function s$8(t2, o2) {
  var _a;
  const n2 = i$6(t2, o2), a2 = await l$a(t2, o2);
  if (!a2)
    return null;
  const s2 = { renderer: n2, symbol: a2 };
  if (!n2 || !("visualVariables" in n2) || !n2.visualVariables)
    return s2;
  const u2 = (_a = N$4(n2, t2, o2)) != null ? _a : [], c2 = ["proportional", "proportional", "proportional"];
  for (const { variable: r2, value: i2 } of u2)
    if (r2.type === "color")
      s2.color = l$c.toUnitRGBA(i2);
    else if (r2.type === "size")
      if (r2.target === "outline")
        s2.outlineSize = i2;
      else {
        const e2 = r2.axis, t3 = r2.useSymbolValue ? "symbol-value" : i2;
        e2 === "width" ? c2[0] = t3 : e2 === "depth" ? c2[1] = t3 : e2 === "height" ? c2[2] = t3 : c2[0] = c2[1] = e2 === "width-and-depth" ? t3 : c2[2] = t3;
      }
    else
      r2.type === "opacity" ? s2.opacity = i2 : r2.type === "rotation" && r2.axis === "tilt" ? s2.tilt = i2 : r2.type === "rotation" && r2.axis === "roll" ? s2.roll = i2 : r2.type === "rotation" && (s2.heading = i2);
  return (isFinite(c2[0]) || isFinite(c2[1]) || isFinite(c2[2])) && (s2.size = c2), s2;
}
function u$d(e2, t2 = 0) {
  const o2 = e2[t2];
  return typeof o2 == "number" && isFinite(o2) ? o2 : null;
}
function c$c(e2) {
  for (let t2 = 0; t2 < 3; t2++) {
    const o2 = e2[t2];
    if (typeof o2 == "number")
      return isFinite(o2) ? o2 : 0;
  }
  return 0;
}
const s$7 = 1.2, c$b = l$d;
const a$7 = h$9.fromSimpleMarkerSymbol(c$e), c$a = b$e.fromSimpleLineSymbol(u$f), S$d = S$e.fromSimpleFillSymbol(a$a), u$c = new c$f({ symbolLayers: [new f$b({ material: { color: e$d }, edges: new c$g({ size: "1px", color: i$7 }) })] });
function b$d(r2) {
  if (t$7(r2))
    return null;
  switch (r2.type) {
    case "mesh":
      return u$c;
    case "point":
    case "multipoint":
      return a$7;
    case "polyline":
      return c$a;
    case "polygon":
    case "extent":
      return S$d;
  }
  return null;
}
class n$a {
  constructor(e2, t2) {
    this.spatialReference = e2, this._view = t2;
  }
  getElevation(e2, t2, r2) {
    return this._view.elevationProvider.getElevation(e2, t2, 0, this.spatialReference, r2);
  }
  async queryElevation(e2, t2, r2, s2, i2) {
    return this._view.elevationProvider.queryElevation(e2, t2, 0, this.spatialReference, i2, r2, s2);
  }
}
var E$a, C$9;
!function(E2) {
  E2[E2.GRAPHIC = 0] = "GRAPHIC", E2[E2.LABEL = 1] = "LABEL", E2[E2._COUNT = 2] = "_COUNT";
}(E$a || (E$a = {})), function(E2) {
  E2[E2.USER_SETTING = 0] = "USER_SETTING", E2[E2.SCALE_RANGE = 1] = "SCALE_RANGE", E2[E2.FILTER = 2] = "FILTER", E2[E2.DECONFLICTION = 3] = "DECONFLICTION", E2[E2._COUNT = 4] = "_COUNT";
}(C$9 || (C$9 = {}));
let l$9 = class extends m$8 {
  constructor(t2) {
    super(t2), this.events = new n$f(), this.hasZ = null, this.hasM = null, this.objectIdField = null, this.viewSpatialReference = null, this.featureAdapter = { getAttribute: (t3, e2) => "graphic" in t3 ? t3.graphic.attributes[e2] : i$8.getAttribute(t3, e2), getAttributes: (t3) => "graphic" in t3 ? t3.graphic.attributes : i$8.getAttributes(t3), getObjectId: (t3) => "graphic" in t3 ? O$7(t3.graphic, this.objectIdField) : i$8.getObjectId(t3), getGeometry: (t3) => "graphic" in t3 ? t3.getAsOptimizedGeometry(this.hasZ, this.hasM) : i$8.getGeometry(t3), getCentroid: (t3, e2) => {
      if ("graphic" in t3) {
        let r2 = null;
        r$d(t3.centroid) ? r2 = t3.centroid : t3.graphic.geometry.type === "point" && pn(t3.graphic.geometry, u$b, this.viewSpatialReference) && (r2 = u$b);
        const i2 = new Array(2 + (e2.hasZ ? 1 : 0) + (e2.hasM ? 1 : 0));
        return t$7(r2) ? (i2[0] = 0, i2[1] = 0, i2[2] = 0, i2[3] = 0) : (i2[0] = r2.x, i2[1] = r2.y, e2.hasZ && (i2[2] = r2.hasZ ? r2.z : 0), e2.hasM && (i2[e2.hasZ ? 3 : 2] = r2.hasM ? r2.m : 0)), new t$8([], i2);
      }
      return i$8.getCentroid(t3, e2);
    }, cloneWithGeometry: (t3, e2) => "graphic" in t3 ? new s$9(e2, this.featureAdapter.getAttributes(t3), null, this.featureAdapter.getObjectId(t3)) : i$8.cloneWithGeometry(t3, e2) };
  }
  forEachInBounds(t2, e2) {
    this.getSpatialIndex().forEachInBounds(t2, e2);
  }
  forEachBounds(t2, e2, r2) {
    const s2 = this.getSpatialIndex();
    for (const i2 of t2) {
      const t3 = this.featureAdapter.getObjectId(i2);
      r$d(s2.getBounds(t3, r2)) && e2(r2);
    }
  }
};
e$c([y$c({ constructOnly: true })], l$9.prototype, "getSpatialIndex", void 0), e$c([y$c({ constructOnly: true })], l$9.prototype, "toArray", void 0), e$c([y$c({ constructOnly: true })], l$9.prototype, "forEach", void 0), e$c([y$c({ constructOnly: true })], l$9.prototype, "hasZ", void 0), e$c([y$c({ constructOnly: true })], l$9.prototype, "hasM", void 0), e$c([y$c({ constructOnly: true })], l$9.prototype, "objectIdField", void 0), e$c([y$c({ constructOnly: true })], l$9.prototype, "viewSpatialReference", void 0), e$c([y$c({ constructOnly: true })], l$9.prototype, "featureSpatialReference", void 0), l$9 = e$c([n$d("esri.views.3d.layers.graphics.Graphics3DFeatureStore")], l$9);
const u$b = { type: "point", x: 0, y: 0, hasZ: false, hasM: false, spatialReference: null };
class r$c {
  constructor(r2, s2, t2) {
    this.graphic = r2, this.renderingInfo = s2, this.layer = t2;
  }
}
class e$b {
  constructor(e2) {
    this.schedule = e2, this.sharedResources = null, this.streamDataRequester = null, this.elevationProvider = null, this.renderer = null, this.stage = null, this.clippingExtent = null, this.renderCoordsHelper = null, this.overlaySR = null, this.layer = null, this.drapeSourceRenderer = null, this.graphicsCoreOwner = null, this.localOriginFactory = null, this.featureExpressionInfoContext = null, this.screenSizePerspectiveEnabled = true, this.slicePlaneEnabled = false, this.physicalBasedRenderingEnabled = false, this.skipHighSymbolLods = false, this.isAsync = false;
  }
}
function p$8(t2, e2, o2, a2) {
  const r2 = t2.stageObject, n2 = r2.geometryRecords;
  let s2 = 0;
  for (const i2 of n2) {
    const { update: t3, averageGeometrySampledElevation: n3 } = O$6(i2, e2, o2, a2);
    s2 += n3, t3 && r2.geometryVertexAttrsUpdated(i2);
  }
  return s2 / n2.length;
}
function d$b(t2, o2, r2, s2) {
  const l2 = t2.stageObject, f2 = o2.centerPointInElevationSR;
  let u2 = 0;
  if (l2.metadata.usesVerticalDistanceToGround)
    d$e(f2, r2, o2, s2, M$7), U$4(l2, M$7.verticalDistanceToGround), u2 = M$7.sampledElevation;
  else {
    d$e(f2, r2, o2, s2, M$7);
    o2.mode !== "absolute-height" && (u2 = M$7.sampledElevation);
  }
  const p2 = n$g(g$a, l2.transformation), d2 = o$7(E$9, p2[12], p2[13], p2[14]);
  t$9.TESTS_DISABLE_OPTIMIZATIONS ? (T$3[0] = f2.x, T$3[1] = f2.y, T$3[2] = M$7.z, Zn(f2.spatialReference, T$3, p2, s2.spatialReference) && (l2.transformation = p2)) : s2.setAltitudeOfTransformation(M$7.z, p2);
  const I2 = S$c / s2.unitInMeters;
  return (Math.abs(p2[12] - d2[0]) >= I2 || Math.abs(p2[13] - d2[1]) >= I2 || Math.abs(p2[14] - d2[2]) >= I2) && (l2.transformation = p2), u2;
}
const g$a = e$e();
function I$6(e2, o2, r2, s2) {
  const l2 = e2.graphics3DSymbolLayer.lodRenderer;
  if (t$7(l2))
    return 0;
  const c2 = o2.centerPointInElevationSR;
  d$e(c2, r2, o2, s2, M$7);
  const f2 = o2.mode !== "absolute-height" ? M$7.sampledElevation : 0, u2 = l2.instanceData, p2 = e2.instanceIndex, d2 = A$4;
  u2.getGlobalTransform(p2, d2);
  const g2 = o$7(E$9, d2[12], d2[13], d2[14]);
  t$9.TESTS_DISABLE_OPTIMIZATIONS ? (T$3[0] = c2.x, T$3[1] = c2.y, T$3[2] = M$7.z, Zn(c2.spatialReference, T$3, d2, s2.spatialReference) && u2.setGlobalTransform(p2, d2)) : s2.setAltitudeOfTransformation(M$7.z, d2);
  const I2 = S$c / s2.unitInMeters;
  return (t$9.TESTS_DISABLE_OPTIMIZATIONS || Math.abs(d2[12] - g2[0]) >= I2 || Math.abs(d2[13] - g2[1]) >= I2 || Math.abs(d2[14] - g2[2]) >= I2) && u2.setGlobalTransform(p2, d2), f2;
}
function b$c(t2, e2, o2, a2) {
  const r2 = t2.stageObject, n2 = r2.geometryRecords;
  if (n2.length === 0)
    return 0;
  let s2 = 0, i2 = null, l2 = 0, c2 = false;
  for (const m2 of n2) {
    const t3 = m2.geometry.vertexAttributes.get(O$8.POSITION);
    if (t3 !== i2) {
      const { update: r3, averageGeometrySampledElevation: n3 } = O$6(m2, e2, o2, a2);
      l2 = n3, i2 = t3, c2 = r3;
    }
    c2 && r2.geometryVertexAttrsUpdated(m2), s2 += l2;
  }
  return s2 / n2.length;
}
const S$c = 0.01, T$3 = n$h(), h$7 = n$h(), v$a = n$h(), A$4 = e$e(), E$9 = n$h(), M$7 = new j$6();
function O$6(t2, e2, o2, a2) {
  let r2 = false;
  const n2 = o2.spatialReference, l2 = t2.geometry, c2 = t2.getShaderTransformation(), p2 = e2.requiresSampledElevationInfo;
  h$7[0] = c2[12], h$7[1] = c2[13], h$7[2] = c2[14], l2.invalidateBoundingInfo();
  const d2 = l2.getMutableAttribute(O$8.POSITION), g2 = d2.data, I2 = l2.vertexAttributes.get(O$8.MAPPOS).data, b2 = d2.size, A2 = g2.length / b2, E2 = new t$a(I2, n2);
  let O2 = 0, y2 = 0;
  for (let f2 = 0; f2 < A2; f2++) {
    if (v$a[0] = g2[O2], v$a[1] = g2[O2 + 1], v$a[2] = g2[O2 + 2], d$e(E2, o2, e2, a2, M$7), p2 && (y2 += M$7.sampledElevation), t$9.TESTS_DISABLE_OPTIMIZATIONS)
      g2[O2] = E2.array[E2.offset], g2[O2 + 1] = E2.array[E2.offset + 1], g2[O2 + 2] = M$7.z, xn(g2, n2, O2, g2, a2.spatialReference, O2, 1), g2[O2] -= h$7[0], g2[O2 + 1] -= h$7[1], g2[O2 + 2] -= h$7[2], r2 = true;
    else {
      T$3[0] = g2[O2] + h$7[0], T$3[1] = g2[O2 + 1] + h$7[1], T$3[2] = g2[O2 + 2] + h$7[2], a2.setAltitude(T$3, M$7.z), g2[O2] = T$3[0] - h$7[0], g2[O2 + 1] = T$3[1] - h$7[1], g2[O2 + 2] = T$3[2] - h$7[2];
      const t3 = S$c / a2.unitInMeters;
      (Math.abs(v$a[0] - g2[O2]) >= t3 || Math.abs(v$a[1] - g2[O2 + 1]) >= t3 || Math.abs(v$a[2] - g2[O2 + 2]) >= t3) && (r2 = true);
    }
    O2 += b2, E2.offset += 3;
  }
  return y2 /= A2, { update: r2, averageGeometrySampledElevation: y2 };
}
class _$b {
  constructor(e2, t2, s2, i2, a2, r2, n2, o2 = null) {
    this.graphics3DSymbolLayer = e2, this.stageObject = t2, this._uniqueGeometries = s2, this._uniqueMaterials = i2, this._sharedResource = a2, this.elevationAligner = r2, this.elevationContext = n2, this._edgeState = o2, this.type = "object3d", this._stageLayer = null, this._stage = null, this._visible = false, this._addedToStage = false, this.alignedSampledElevation = 0, this.needsElevationUpdates = false, this.useObjectOriginAsAttachmentOrigin = false, this.graphics3DSymbolLayer = e2, this.stageObject = t2;
  }
  get isElevationSource() {
    return !(!this.stageObject.metadata || !this.stageObject.metadata.isElevationSource);
  }
  initialize(e2, t2) {
    this._stageLayer = t2, this._stage = e2, e2.addMany(this._uniqueMaterials), e2.addMany(this._uniqueGeometries), e2.add(this.stageObject);
  }
  destroy() {
    const t2 = this._stage;
    this._stageLayer && (t2.removeMany(this._uniqueMaterials), t2.removeMany(this._uniqueGeometries)), t2.remove(this.stageObject), this._addedToStage && (this._stageLayer.remove(this.stageObject), this._addedToStage = false);
    const s2 = this._stage.renderView.ensureEdgeView();
    s2.hasObject(this.stageObject) && s2.removeObject(this.stageObject), this.stageObject.dispose(), r$d(this._sharedResource) && this._sharedResource.release(), this._visible = false, this._stageLayer = null, this._stage = null;
  }
  layerOpacityChanged(e2, s2) {
    if (t$7(this._edgeState))
      return;
    const i2 = v$9(this._edgeState.baseMaterial);
    let a2 = false;
    for (const t2 of this._edgeState.edgeMaterials)
      t2.objectTransparency !== i2 && (t2.objectTransparency = i2, a2 = true);
    a2 && this._resetEdgeObject(s2);
    this._stage.renderView.ensureEdgeView().updateAllComponentOpacities(this.stageObject, [e2]);
  }
  slicePlaneEnabledChanged(e2, s2) {
    if (t$7(this._edgeState))
      return;
    this._stage.renderView.ensureEdgeView().updateAllComponentMaterials(this.stageObject, this._edgeState.edgeMaterials, { hasSlicePlane: e2 }, !s2), this._edgeState.properties.hasSlicePlane = e2;
  }
  setVisibility(t2) {
    if (this._stage != null && this._visible !== t2 && (this._visible = t2, this._visible ? this._addedToStage ? this.stageObject.setVisible(true) : (this._stageLayer.add(this.stageObject), this._addedToStage = true) : this.stageObject.setVisible(false), r$d(this._edgeState))) {
      const e2 = this._stage.renderView.ensureEdgeView();
      e2.hasObject(this.stageObject) ? e2.updateObjectVisibility(this.stageObject, t2) : t2 && this._addOrUpdateEdgeObject(e2, false);
    }
  }
  get visible() {
    return this._visible;
  }
  alignWithElevation(t2, s2, i2, a2) {
    this.elevationAligner != null && (r$d(i2) && i$9(this.elevationContext.featureExpressionInfoContext, i2), this.alignedSampledElevation = this.elevationAligner(this, this.elevationContext, t2, s2), this._resetEdgeObject(a2));
  }
  getCenterObjectSpace(e2 = n$h()) {
    return r$e(e2, k$8(this.stageObject.boundingVolumeObjectSpace.bounds));
  }
  getBoundingBoxObjectSpace(e2 = a$b()) {
    const t2 = this.stageObject.boundingVolumeObjectSpace;
    return d$f(e2, t2.min), q$6(e2, t2.max), e2;
  }
  computeAttachmentOrigin(e2) {
    if (this.useObjectOriginAsAttachmentOrigin) {
      const t2 = this.stageObject.transformation;
      e2.render.origin[0] += t2[12], e2.render.origin[1] += t2[13], e2.render.origin[2] += t2[14], e2.render.num++;
    } else
      for (const t2 of this.stageObject.geometryRecords)
        t2.computeAttachmentOrigin(y$b) && (O$9(y$b, y$b, this.stageObject.transformation), u$g(e2.render.origin, e2.render.origin, y$b), e2.render.num++);
  }
  async getProjectedBoundingBox(e2, t2, i2, r2, n2) {
    const o2 = this.getBoundingBoxObjectSpace(n2), c2 = E$8, h2 = P$7(o2) ? 1 : c2.length;
    for (let s2 = 0; s2 < h2; s2++) {
      const e3 = c2[s2];
      S$b[0] = o2[e3[0]], S$b[1] = o2[e3[1]], S$b[2] = o2[e3[2]], O$9(S$b, S$b, this.stageObject.transformation), f$9[3 * s2 + 0] = S$b[0], f$9[3 * s2 + 1] = S$b[1], f$9[3 * s2 + 2] = S$b[2];
    }
    if (!e2(f$9, 0, h2))
      return null;
    A$6(o2);
    let u2 = null;
    this.calculateRelativeScreenBounds && (u2 = this.calculateRelativeScreenBounds());
    for (let s2 = 0; s2 < 3 * h2; s2 += 3) {
      for (let e3 = 0; e3 < 3; e3++)
        o2[e3] = Math.min(o2[e3], f$9[s2 + e3]), o2[e3 + 3] = Math.max(o2[e3 + 3], f$9[s2 + e3]);
      u2 && i2.push({ location: f$9.slice(s2, s2 + 3), screenSpaceBoundingRect: u2 });
    }
    if (t2 && t2.service && this.elevationContext.mode !== "absolute-height") {
      p$9(o2, y$b);
      const e3 = this.elevationContext.mode === "relative-to-scene" ? "scene" : "ground";
      let i3 = 0;
      if (t2.useViewElevation)
        i3 = i$a(t2.service.getElevation(y$b[0], y$b[1], e3), 0);
      else
        try {
          const a2 = X$2(o2, t2.service.spatialReference, t2);
          i3 = i$a(await t2.service.queryElevation(y$b[0], y$b[1], r2, a2, e3), 0);
        } catch (O2) {
        }
      V$4(o2, 0, 0, -this.alignedSampledElevation + i3);
    }
    return o2;
  }
  addObjectState(e2, t2) {
    e2 === u$h.Highlight && t2.addObject(this.stageObject, this.stageObject.highlight()), e2 === u$h.MaskOccludee && t2.addObject(this.stageObject, this.stageObject.maskOccludee());
  }
  removeObjectState(e2) {
    e2.removeObject(this.stageObject);
  }
  _resetEdgeObject(e2) {
    if (t$7(this._edgeState))
      return;
    const s2 = this._stage.renderView.ensureEdgeView();
    this._visible ? this._addOrUpdateEdgeObject(s2, e2) : s2.removeObject(this.stageObject);
  }
  _addOrUpdateEdgeObject(e2, s2) {
    const i2 = this._edgeState;
    if (t$7(i2))
      return;
    const a2 = v$9(i2.baseMaterial);
    for (const t2 of i2.edgeMaterials)
      t2.objectTransparency = a2;
    e2.addOrUpdateObject3D(this.stageObject, i2.edgeMaterials, i2.properties, !s2).then(() => {
      var _a;
      return (_a = this._stageLayer) == null ? void 0 : _a.sync();
    });
  }
}
function v$9(e2) {
  return e2.isVisible ? e2.parameters.transparent ? A$5.TRANSPARENT : A$5.OPAQUE : A$5.INVISIBLE;
}
const f$9 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], S$b = n$h(), y$b = n$h(), E$8 = [[0, 1, 2], [3, 1, 2], [0, 4, 2], [3, 4, 2], [0, 1, 5], [3, 1, 5], [0, 4, 5], [3, 4, 5]];
var e$a;
!function(e2) {
  e2[e2.Recreate_Symbol = 0] = "Recreate_Symbol", e2[e2.Recreate_Graphics = 1] = "Recreate_Graphics", e2[e2.Fast_Update = 2] = "Fast_Update";
}(e$a || (e$a = {}));
class a$6 {
  constructor(t2) {
    this.schedule = t2, this._abortController = null, this._loadStatus = e$9.LOADING, this._loadError = null, this._loader = null, this.logger = null;
  }
  destroy() {
    this.abortLoad();
  }
  get loadStatus() {
    return this._loadStatus;
  }
  load(r2, l2) {
    return this._loadStatus === e$9.LOADED ? (r2 && r2(), i$a(this._loader, Promise.resolve())) : this._loadStatus === e$9.FAILED ? (l2 && l2(this._loadError), i$a(this._loader, Promise.resolve())) : (t$7(this._loader) && (this._abortController = new AbortController(), this._loader = this.doLoad(this._abortController.signal).then(() => {
      this._abortController = null, this._loadStatus = e$9.LOADED;
    }, (t2) => {
      throw this._loadError = t2, this._abortController = null, this._loadStatus = e$9.FAILED, !j$7(t2) && this.logger && t2.message && this.logger.warn(t2.message), t2;
    })), this._loader.then(r2, l2).catch(() => {
    }), this._loader);
  }
  abortLoad() {
    r$d(this._abortController) ? this._abortController = p$a(this._abortController) : this._loadStatus === e$9.LOADING && (this._loadStatus = e$9.FAILED), this._loader = null;
  }
}
var e$9;
!function(t2) {
  t2[t2.LOADING = 0] = "LOADING", t2[t2.LOADED = 1] = "LOADED", t2[t2.FAILED = 2] = "FAILED";
}(e$9 || (e$9 = {}));
function r$b(e2) {
  switch (e2) {
    case "sphere":
    case "cube":
    case "diamond":
    case "cylinder":
    case "cone":
    case "inverted-cone":
    case "tetrahedron":
      return true;
  }
  return false;
}
function o$5(r2, o2) {
  const S2 = (n2, s2, a2 = false) => ({ levels: n2.map((n3) => {
    const t2 = s2(n3.tesselation);
    return a2 && D$3(t2), { components: [{ geometry: t2, material: o2 }], faceCount: t2.indexCount / 3, minScreenSpaceRadius: n3.minScreenSpaceRadius };
  }) });
  switch (r2) {
    case "sphere":
      return S2([{ tesselation: 0, minScreenSpaceRadius: 0 }, { tesselation: 1, minScreenSpaceRadius: 8 }, { tesselation: 2, minScreenSpaceRadius: 16 }, { tesselation: 3, minScreenSpaceRadius: 50 }, { tesselation: 4, minScreenSpaceRadius: 250 }], (e2) => R$7(0.5, e2, true));
    case "cube":
      return S2([{ tesselation: 0, minScreenSpaceRadius: 0 }], () => v$c(1));
    case "cone":
      return S2(u$a, (e2) => C$a(1, 0.5, e2, false), true);
    case "inverted-cone":
      return S2(u$a, (e2) => C$a(1, 0.5, e2, true), true);
    case "cylinder":
      return S2(u$a, (e2) => E$b(1, 0.5, e2, [0, 0, 1], [0, 0, 0.5]));
    case "tetrahedron":
      return S2([{ tesselation: 0, minScreenSpaceRadius: 0 }], () => L$4(1), true);
    case "diamond":
      return S2([{ tesselation: 0, minScreenSpaceRadius: 0 }], () => x$a(1), true);
    default:
      return;
  }
}
const u$a = [{ tesselation: 6, minScreenSpaceRadius: 0 }, { tesselation: 18, minScreenSpaceRadius: 7 }, { tesselation: 64, minScreenSpaceRadius: 65 }];
function r$a(r2) {
  const e2 = [];
  return r2.levels.forEach((o2) => {
    o2.components.forEach((o3) => {
      e2.push(o3.material);
    });
  }), u$i(e2);
}
function e$8(r2) {
  const e2 = new Array();
  return r2.levels.forEach((o2) => {
    o2.components.forEach((o3) => {
      o3.textures && e2.push(...o3.textures);
    });
  }), u$i(e2);
}
function n$9(r2) {
  const e2 = [];
  return r2.components.forEach((o2) => {
    e2.push(o2.geometry);
  }), u$i(e2);
}
function t$6(r2) {
  const e2 = [];
  return r2.levels.forEach((o2) => {
    o2.components.forEach((o3) => {
      e2.push(o3.geometry);
    });
  }), u$i(e2);
}
function c$9(o2) {
  return n$9(o2).reduce((o3, r2) => o3 + r2.indexCount / 3, 0);
}
const b$b = { primitivesPerFeature: 0, primitivesPerCoordinate: 0, drawCallsPerFeature: 0, estimated: true, memory: { bytesPerFeature: 0, bytesPerCoordinate: 0, bytesPerFeatureLabel: 0, resourceBytes: 0, draped: { bytesPerFeature: 0, bytesPerFeatureLabel: 0, bytesPerCoordinate: 0 } } };
function y$a(e2) {
  if (e2.type === "web-style")
    return b$b;
  return P$6(e2.symbolLayers.toArray().map((r2) => m$6(e2, r2)));
}
function P$6(e2) {
  let t2 = 0, a2 = 0, s2 = 0, i2 = false, o2 = 0;
  const u2 = { bytesPerFeature: 0, bytesPerFeatureLabel: 0, bytesPerCoordinate: 0, resourceBytes: 0, draped: { bytesPerFeature: 0, bytesPerFeatureLabel: 0, bytesPerCoordinate: 0 } };
  for (const b2 of e2)
    t$7(b2) || (t2 += b2.primitivesPerFeature, a2 += b2.primitivesPerCoordinate, s2 += b2.drawCallsPerFeature, u2.bytesPerFeature += b2.memory.bytesPerFeature, u2.bytesPerFeatureLabel += b2.memory.bytesPerFeatureLabel, u2.bytesPerCoordinate += b2.memory.bytesPerCoordinate, u2.resourceBytes += b2.memory.resourceBytes, u2.draped.bytesPerFeature += b2.memory.bytesPerFeature, u2.draped.bytesPerFeatureLabel += b2.memory.bytesPerFeatureLabel, u2.draped.bytesPerCoordinate += b2.memory.bytesPerCoordinate, i2 = i2 || b2.estimated, ++o2);
  return { primitivesPerFeature: t2, primitivesPerCoordinate: a2, drawCallsPerFeature: s2, estimated: i2, memory: u2, numComplexities: o2 };
}
function d$a(e2) {
  const r2 = P$6(e2);
  return r2.numComplexities > 0 && (r2.primitivesPerFeature /= r2.numComplexities, r2.primitivesPerCoordinate /= r2.numComplexities, r2.drawCallsPerFeature /= r2.numComplexities, r2.memory.bytesPerFeature /= r2.numComplexities, r2.memory.bytesPerFeatureLabel /= r2.numComplexities, r2.memory.bytesPerCoordinate /= r2.numComplexities, r2.memory.resourceBytes /= r2.numComplexities, r2.memory.draped.bytesPerFeature /= r2.numComplexities, r2.memory.draped.bytesPerFeatureLabel /= r2.numComplexities, r2.memory.draped.bytesPerCoordinate /= r2.numComplexities), r2;
}
const n$8 = {};
function m$6(r2, s2) {
  const o2 = l$8(r2, s2), u2 = a$c(s2) ? 2 : 0;
  switch (s2.type) {
    case "extrude":
      return { primitivesPerFeature: -4, primitivesPerCoordinate: 4, drawCallsPerFeature: u2, estimated: false, memory: o2 };
    case "fill":
      return r2.type === "mesh-3d" ? { primitivesPerFeature: 0, primitivesPerCoordinate: 0, drawCallsPerFeature: u2, estimated: false, memory: o2 } : r$d(s2.outline) && s2.outline.size > 0 ? { primitivesPerFeature: -4, primitivesPerCoordinate: 3, drawCallsPerFeature: 0, estimated: false, memory: o2 } : { primitivesPerFeature: -2, primitivesPerCoordinate: 1, drawCallsPerFeature: 0, estimated: false, memory: o2 };
    case "water":
      return { primitivesPerFeature: -2, primitivesPerCoordinate: 1, drawCallsPerFeature: 0, estimated: false, memory: o2 };
    case "line":
      return { primitivesPerFeature: -2, primitivesPerCoordinate: 2, drawCallsPerFeature: 0, estimated: false, memory: o2 };
    case "object":
      if (s2.resource && s2.resource.href)
        return { primitivesPerFeature: 16, primitivesPerCoordinate: 0, drawCallsPerFeature: 0, estimated: true, memory: o2 };
      return __spreadProps(__spreadValues({}, F$7(s2.resource && s2.resource.primitive || d$g)), { memory: o2 });
    case "path": {
      const r3 = 3, t2 = 3, a2 = 10;
      let i2 = 0, u3 = 0;
      switch (s2.profile) {
        case "circle":
          i2 = a2;
          break;
        case "quad":
          i2 = 4;
          break;
        default:
          return void n$i(s2.profile);
      }
      switch (s2.join) {
        case "round":
          u3 = r3;
          break;
        case "miter":
        case "bevel":
          u3 = 1;
          break;
        default:
          return void n$i(s2.join);
      }
      const b2 = 2 * i2, y2 = i2 * u3 * 2;
      let P2 = -2 * y2 - b2;
      switch (s2.cap) {
        case "none":
          break;
        case "butt":
        case "square":
          P2 += 2 * (i2 - 1);
          break;
        case "round":
          P2 += 2 * (i2 * (t2 - 1) * 2 + i2);
          break;
        default:
          return;
      }
      return { primitivesPerFeature: P2, primitivesPerCoordinate: y2 + b2, drawCallsPerFeature: 0, estimated: false, memory: o2 };
    }
    case "text":
    case "icon":
      return { primitivesPerFeature: 2, primitivesPerCoordinate: 0, drawCallsPerFeature: 0, estimated: false, memory: o2 };
    default:
      return;
  }
}
function l$8(r2, a2) {
  const s2 = r2.type === "point-3d";
  switch (a2.type) {
    case "extrude":
      return a2.edges && a2.edges.size > 0 ? c$8.EXTRUDE_EDGES : c$8.EXTRUDE;
    case "fill":
      return r$d(a2.outline) && a2.outline.size > 0 ? c$8.FILL_OUTLINE : c$8.FILL;
    case "water":
      return c$8.FILL;
    case "line":
      return a2.join === "round" ? c$8.LINE_ROUND : c$8.LINE_MITER;
    case "path":
      switch (a2.join) {
        case "round":
          switch (a2.profile) {
            case "circle":
              return c$8.PATH_ROUND_CIRCLE;
            case "quad":
              return c$8.PATH_ROUND_QUAD;
            default:
              return void n$i(a2.profile);
          }
        case "miter":
        case "bevel":
          switch (a2.profile) {
            case "circle":
              return c$8.PATH_MITER_CIRCLE;
            case "quad":
              return c$8.PATH_MITER_QUAD;
            default:
              return void n$i(a2.profile);
          }
        default:
          return void n$i(a2.join);
      }
    case "object":
      return s2 ? c$8.OBJECT_POINT : c$8.OBJECT_POLYGON;
    case "icon":
    case "text":
      return s2 ? c$8.ICON_POINT : c$8.ICON_POLYGON;
    default:
      return;
  }
}
function F$7(e2) {
  let r2 = n$8[e2];
  if (r2)
    return r2;
  const t2 = o$5(e2, null);
  return r2 = { primitivesPerFeature: n$9(t2.levels[0]).reduce((e3, r3) => e3 + r3.indices.get(O$8.POSITION).length / 3, 0), primitivesPerCoordinate: 0, drawCallsPerFeature: 0, estimated: false }, n$8[e2] = r2, r2;
}
const c$8 = { ICON_POINT: { bytesPerFeature: 7127.413186968842, bytesPerFeatureLabel: 4826.302896296296, bytesPerCoordinate: 0, resourceBytes: 0, draped: { bytesPerFeature: 3929.4396628895197, bytesPerFeatureLabel: 3550.1332222222227, bytesPerCoordinate: 0 } }, ICON_POLYGON: { bytesPerFeature: 9329.452613976147, bytesPerFeatureLabel: 3675.3372604938268, bytesPerCoordinate: 60.177252982212096, resourceBytes: 0, draped: { bytesPerFeature: 6190.247450139383, bytesPerFeatureLabel: 3744.074358024691, bytesPerCoordinate: 59.488211068026104 } }, OBJECT_POINT: { bytesPerFeature: 2350.5884192634558, bytesPerFeatureLabel: 4446.651003703703, bytesPerCoordinate: 0, resourceBytes: 0, draped: { bytesPerFeature: 2350.5884192634558, bytesPerFeatureLabel: 4446.651003703703, bytesPerCoordinate: 0 } }, OBJECT_POLYGON: { bytesPerFeature: 4583.807620302299, bytesPerFeatureLabel: 3665.342685185186, bytesPerCoordinate: 60.11621818101506, resourceBytes: 0, draped: { bytesPerFeature: 4583.807620302299, bytesPerFeatureLabel: 3665.342685185186, bytesPerCoordinate: 60.11621818101506 } }, LINE_MITER: { bytesPerFeature: 7321.028181375921, bytesPerFeatureLabel: 4048.0226716049388, bytesPerCoordinate: 186.55621386363578, resourceBytes: 0, draped: { bytesPerFeature: 4246.856619435009, bytesPerFeatureLabel: 3852.3737679012347, bytesPerCoordinate: 163.47884002621583 } }, LINE_ROUND: { bytesPerFeature: 7482.205842738954, bytesPerFeatureLabel: 4045.886987654321, bytesPerCoordinate: 191.5452524171851, resourceBytes: 0, draped: { bytesPerFeature: 4473.481387957992, bytesPerFeatureLabel: 3842.1112395061728, bytesPerCoordinate: 167.27703460226945 } }, PATH_MITER_CIRCLE: { bytesPerFeature: 9010.489006415351, bytesPerFeatureLabel: 4230.9109, bytesPerCoordinate: 4618.2594178027275, resourceBytes: 0, draped: { bytesPerFeature: 9010.489006415351, bytesPerFeatureLabel: 4230.9109, bytesPerCoordinate: 4618.2594178027275 } }, PATH_ROUND_CIRCLE: { bytesPerFeature: 4104.727250200398, bytesPerFeatureLabel: 4251.8525, bytesPerCoordinate: 8019.043777064957, resourceBytes: 0, draped: { bytesPerFeature: 4104.727250200398, bytesPerFeatureLabel: 4251.8525, bytesPerCoordinate: 8019.043777064957 } }, PATH_MITER_QUAD: { bytesPerFeature: 9416.372942261387, bytesPerFeatureLabel: 4241.2757, bytesPerCoordinate: 3176.7222742582203, resourceBytes: 0, draped: { bytesPerFeature: 9416.372942261387, bytesPerFeatureLabel: 4241.2757, bytesPerCoordinate: 3176.7222742582203 } }, PATH_ROUND_QUAD: { bytesPerFeature: 6614.431545308682, bytesPerFeatureLabel: 4206.7461, bytesPerCoordinate: 5141.817789093826, resourceBytes: 0, draped: { bytesPerFeature: 6614.431545308682, bytesPerFeatureLabel: 4206.7461, bytesPerCoordinate: 5141.817789093826 } }, FILL: { bytesPerFeature: 9478.244183633637, bytesPerFeatureLabel: 3713.816824691358, bytesPerCoordinate: 95.9343604185578, resourceBytes: 0, draped: { bytesPerFeature: 6287.911108168086, bytesPerFeatureLabel: 3790.785032098766, bytesPerCoordinate: 83.08783220478168 } }, FILL_OUTLINE: { bytesPerFeature: 13085.871870349445, bytesPerFeatureLabel: 3392.613241975309, bytesPerCoordinate: 118.63968023169875, resourceBytes: 0, draped: { bytesPerFeature: 8437.199992480122, bytesPerFeatureLabel: 3973.5431172839503, bytesPerCoordinate: 106.33556817014312 } }, EXTRUDE: { bytesPerFeature: 19459.53727140414, bytesPerFeatureLabel: 3743.7045209876546, bytesPerCoordinate: 372.6819978900477, resourceBytes: 0, draped: { bytesPerFeature: 19459.53727140414, bytesPerFeatureLabel: 3743.7045209876546, bytesPerCoordinate: 372.6819978900477 } }, EXTRUDE_EDGES: { bytesPerFeature: 22266.888534913724, bytesPerFeatureLabel: 3064.3193358024696, bytesPerCoordinate: 374.3725221561312, resourceBytes: 0, draped: { bytesPerFeature: 22266.888534913724, bytesPerFeatureLabel: 3064.3193358024696, bytesPerCoordinate: 374.3725221561312 } } };
const f$8 = s$a.getLogger("esri.views.3d.layers.graphics.Graphics3DSymbolLayer");
class y$9 extends a$6 {
  constructor(e2, t2, i2, o2) {
    super(i2.schedule), this._context = i2, this._elevationInfoOverride = null, this._ignoreDrivers = false, this._drivenProperties = { color: false, opacity: false, opacityAlwaysOpaque: true, size: false }, this.complexity = null, this.logger = f$8, this._elevationOptions = { supportsOffsetAdjustment: false, supportsOnTheGround: true }, this.symbol = e2, this.symbolLayer = t2, this._renderPriority = o2.renderPriority, this._renderPriorityStep = o2.renderPriorityStep, this._elevationContext = new h$8(), this.complexity = this.computeComplexity(), this._ignoreDrivers = o2.ignoreDrivers, this._ignoreDrivers || (this._drivenProperties = g$9(this._context.renderer)), this._updateElevationContext();
  }
  getCachedSize() {
    return null;
  }
  get extentPadding() {
    return 0;
  }
  _drivenPropertiesChanged(e2) {
    if (this._ignoreDrivers)
      return false;
    const t2 = this._drivenProperties, i2 = g$9(e2);
    return i2.color !== t2.color || i2.opacity !== t2.opacity || i2.opacityAlwaysOpaque !== t2.opacityAlwaysOpaque || i2.size !== t2.size;
  }
  get needsDrivenTransparentPass() {
    return this._drivenProperties.opacity && !this._drivenProperties.opacityAlwaysOpaque;
  }
  _logGeometryCreationWarnings(e2, t2, i2, o2) {
    const r2 = e2.projectionSuccess, n2 = "polygons" in e2 ? e2.polygons : null, s2 = `${o2} geometry failed to be created`;
    let a2 = null;
    r2 ? !this._logGeometryValidationWarnings(t2, i2, o2) && n2 && n2.length === 0 && i2 === "rings" && t2.length > 0 && t2[0].length > 2 && (a2 = `${s2} (filled rings should use clockwise winding - try reversing the order of vertices)`) : a2 = `${s2} (failed to project geometry to view spatial reference)`, a2 && f$8.warnOncePerTick(a2);
  }
  _logGeometryValidationWarnings(e2, t2, i2) {
    const o2 = `${i2} geometry failed to be created`;
    return !e2.length || e2.length === 1 && !e2[0].length ? (f$8.warnOncePerTick(`${o2} (no ${t2} were defined)`), true) : (!Array.isArray(e2) || !Array.isArray(e2[0])) && (f$8.warnOncePerTick(`${o2} (${t2} should be defined as a 2D array)`), true);
  }
  _validateGeometry(e2, t2 = null, o2 = null) {
    if (r$d(t2) && !t2.includes(e2.type))
      return this.logger.warn("unsupported geometry type for " + o2 + ` symbol: ${e2.type}`), false;
    if (e2.type === "point") {
      const t3 = e2;
      if (!isFinite(t3.x) || !isFinite(t3.y))
        return f$8.warn("point coordinate is not a valid number, graphic skipped"), false;
    }
    return true;
  }
  _defaultElevationInfoNoZ() {
    return m$5;
  }
  _defaultElevationInfoZ() {
    return _$a;
  }
  _updateElevationContext() {
    r$d(this._elevationInfoOverride) ? (this._elevationContext.setFromElevationInfo(this._elevationInfoOverride), this._elevationContext.updateFeatureExpressionInfoContext(null)) : this._context.layer.elevationInfo ? (this._elevationContext.setFromElevationInfo(this._context.layer.elevationInfo), this._elevationContext.updateFeatureExpressionInfoContext(this._context.featureExpressionInfoContext)) : this._elevationContext.reset();
  }
  getDefaultElevationInfo(e2) {
    return e2.hasZ ? this._defaultElevationInfoZ() : this._defaultElevationInfoNoZ();
  }
  getGeometryElevationMode(e2, t2 = this.getDefaultElevationInfo(e2)) {
    return this._elevationContext.mode || t2.mode;
  }
  setElevationInfoOverride(e2) {
    this._elevationInfoOverride = e2, this._updateElevationContext();
  }
  setGraphicElevationContext(e2, t2) {
    const i2 = e$f(e2.geometry), n2 = this.getDefaultElevationInfo(i2);
    t2.unit = this._elevationContext.unit != null ? this._elevationContext.unit : n2.unit, t2.mode = this.getGeometryElevationMode(i2, n2), t2.offsetMeters = i$a(this._elevationContext.meterUnitOffset, i$a(n2.offset, 0));
    const s2 = !this._elevationOptions.supportsOnTheGround && t2.mode === "on-the-ground";
    s2 && (t2.mode = "relative-to-ground", t2.offsetMeters = 0);
    const a2 = s2 ? f$c : this._elevationContext.featureExpressionInfoContext;
    return t2.updateFeatureExpressionInfoContext(a2, e2, this._context.layer), t2;
  }
  prepareSymbolLayerPatch(e2) {
  }
  updateGeometry(e2, t2) {
    return false;
  }
  onRemoveGraphic(e2) {
  }
  _getLayerOpacity() {
    if (this._context.graphicsCoreOwner && "fullOpacity" in this._context.graphicsCoreOwner)
      return this._context.graphicsCoreOwner.fullOpacity;
    const e2 = this._context.layer.opacity;
    return e2 != null ? e2 : 1;
  }
  _getCombinedOpacity(e2, t2 = x$9) {
    let o2 = 1;
    return this.draped || (o2 *= this._getLayerOpacity()), this._drivenProperties.opacity || (r$d(e2) ? o2 *= e2.a : t2.hasIntrinsicColor || (o2 = 0)), o2;
  }
  _getCombinedOpacityAndColor(t2, o2 = x$9) {
    const r2 = this._getCombinedOpacity(t2, o2);
    if (this._drivenProperties.color)
      return B$5(null, r2);
    const s2 = r$d(t2) ? l$c.toUnitRGB(t2) : l$e;
    return B$5(s2, r2);
  }
  _getVertexOpacityAndColor(e2, t2 = null) {
    const o2 = this._drivenProperties.color ? e2.color : null, r2 = this._drivenProperties.opacity ? e2.opacity : null, n2 = B$5(o2, r2);
    return r$d(t2) && (n2[0] *= t2, n2[1] *= t2, n2[2] *= t2, n2[3] *= t2), n2;
  }
  isFastUpdatesEnabled() {
    return this._fastUpdates && this._fastUpdates.enabled;
  }
  computeComplexity() {
    return m$6(this.symbol, this.symbolLayer);
  }
  globalPropertyChanged(e2, t2, i2) {
    switch (e2) {
      case "opacity":
        return this.layerOpacityChanged(t2, i2), true;
      case "elevationInfo": {
        const e3 = this._elevationContext.mode;
        this._updateElevationContext();
        return this.layerElevationInfoChanged(t2, i2, e3) !== x$b.RECREATE;
      }
      case "slicePlaneEnabled":
        return this.slicePlaneEnabledChanged(t2, i2);
      case "physicalBasedRenderingEnabled":
        return this.physicalBasedRenderingChanged();
      case "pixelRatio":
        return this.pixelRatioChanged();
      default:
        return false;
    }
  }
  updateGraphics3DGraphicElevationInfo(e2, t2, o2) {
    let r2 = x$b.UPDATE;
    return e2.forEach((e3) => {
      const n2 = t2(e3);
      if (r$d(n2)) {
        const t3 = e3.graphic;
        this.setGraphicElevationContext(t3, n2.elevationContext), n2.needsElevationUpdates = o2(n2.elevationContext.mode);
      } else
        r2 = x$b.RECREATE;
    }), r2;
  }
  applyRendererDiff(e2, t2) {
    return e$a.Recreate_Symbol;
  }
  getFastUpdateAttrValues(e2) {
    if (!this._fastUpdates.enabled)
      return null;
    const t2 = this._fastUpdates.visualVariables, i2 = t2.size ? v$8(t2.size.field, e2) : 0, o2 = t2.color ? v$8(t2.color.field, e2) : 0, r2 = t2.opacity ? v$8(t2.opacity.field, e2) : 0;
    return r$f(i2, o2, r2, 0);
  }
  get draped() {
    return this._draped;
  }
  ensureDrapedStatus(e2) {
    return this._draped == null ? (this._draped = e2, true) : (e2 !== this.draped && f$8.warnOnce("A symbol can only produce either draped or non-draped visualizations. Use two separate symbol instances for draped and non-draped graphics if necessary."), false);
  }
  test() {
    const e2 = () => {
      var _a, _b, _c, _d, _e2, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p;
      return { size: (_d = (_c = (_b = (_a = this._fastUpdates) == null ? void 0 : _a.visualVariables) == null ? void 0 : _b.size) == null ? void 0 : _c.field) != null ? _d : null, color: (_h = (_g = (_f = (_e2 = this._fastUpdates) == null ? void 0 : _e2.visualVariables) == null ? void 0 : _f.color) == null ? void 0 : _g.field) != null ? _h : null, opacity: (_l = (_k = (_j = (_i = this._fastUpdates) == null ? void 0 : _i.visualVariables) == null ? void 0 : _j.opacity) == null ? void 0 : _k.field) != null ? _l : null, rotation: (_p = (_o = (_n = (_m = this._fastUpdates) == null ? void 0 : _m.visualVariables) == null ? void 0 : _n.rotation) == null ? void 0 : _o.field) != null ? _p : null };
    };
    return { drivenProperties: this._drivenProperties, getVisVarFields: e2 };
  }
}
function v$8(e2, t2) {
  const i2 = e2 != null ? t2.attributes[e2] : 0;
  return i2 != null && isFinite(i2) ? i2 : 0;
}
function g$9(e2) {
  const t2 = { color: false, opacity: false, opacityAlwaysOpaque: true, size: false };
  return e2 && "visualVariables" in e2 && e2.visualVariables && e2.visualVariables.forEach((e3) => {
    switch (e3.type) {
      case "color":
        if (t2.color = true, e3.stops)
          for (let i2 = 0; i2 < e3.stops.length; i2++) {
            const o2 = e3.stops[i2].color;
            o2 && (t2.opacity = true, o2.a < 1 && (t2.opacityAlwaysOpaque = false));
          }
        break;
      case "opacity":
        t2.opacity = true, t2.opacityAlwaysOpaque = false;
        break;
      case "size":
        t2.size = true;
    }
  }), t2;
}
const m$5 = { mode: "on-the-ground", offset: 0, unit: "meters" }, _$a = { mode: "absolute-height", offset: 0, unit: "meters" }, x$9 = { hasIntrinsicColor: false };
const m$4 = n$h();
function u$9(t2, i2, s2, a2, l2, u2, f2, d2) {
  const g2 = s2 ? s2.length : 0, h2 = t2.clippingExtent;
  if (gn(i2, m$4, t2.elevationProvider.spatialReference), r$d(h2) && !E$c(h2, m$4))
    return null;
  gn(i2, m$4, t2.renderCoordsHelper.spatialReference);
  const j2 = t2.localOriginFactory.getOrigin(m$4), y2 = new x$c({ castShadow: false, metadata: { layerUid: u2, graphicUid: f2, usesVerticalDistanceToGround: true } });
  for (let e2 = 0; e2 < g2; e2++) {
    const t3 = o$8;
    y2.addGeometry(s2[e2], a2[e2], t3, j2, d2);
  }
  return { object: y2, sampledElevation: h$a(y2, i2, t2.elevationProvider, t2.renderCoordsHelper, l2) };
}
function f$7(r2, t2, n2) {
  const i2 = r2.elevationContext, s2 = n2.spatialReference;
  gn(t2, m$4, s2), i2.centerPointInElevationSR = v$b(m$4[0], m$4[1], t2.hasZ ? m$4[2] : 0, r$d(s2) ? s2 : null);
}
function d$9(e2) {
  switch (e2.type) {
    case "point":
      return e2;
    case "polygon":
    case "extent":
      return A$7(e2);
    case "polyline": {
      const r2 = e2.paths[0];
      if (!r2 || r2.length === 0)
        return null;
      const t2 = u$j(r2, c$h(r2) / 2);
      return v$b(t2[0], t2[1], t2[2], e2.spatialReference);
    }
    case "mesh":
      return e2.origin;
  }
  return null;
}
function S$a(o2) {
  const r2 = new o$9();
  r2.include(c$i), r2.include(u$k, o2), r2.include(u$l, o2), r2.attributes.add(O$8.UV0, "vec2");
  const { vertex: S2, fragment: u2 } = r2;
  return S2.uniforms.add([new e$g("viewport", (e2, i2) => i2.camera.fullViewport), new o$a("lineSize", (e2, i2) => Math.ceil(e2.size) * i2.camera.pixelRatio), new e$h("pixelToNDC", (e2, o3) => r$g(m$3, 2 / o3.camera.fullViewport[2], 2 / o3.camera.fullViewport[3])), new o$a("borderSize", (i2, o3) => r$d(i2.borderColor) ? o3.camera.pixelRatio : 0), new e$h("screenOffset", (e2, o3) => r$g(m$3, e2.screenOffset[0] * o3.camera.pixelRatio, e2.screenOffset[1] * o3.camera.pixelRatio))]), r2.varyings.add("coverageSampling", "vec4"), r2.varyings.add("lineSizes", "vec2"), o2.hasMultipassGeometry && r2.varyings.add("depth", "float"), o2.hasScreenSizePerspective && i$b(S2), S2.code.add(n$j`
    void main(void) {
      ProjectHUDAux projectAux;
      vec4 endPoint = projectPositionHUD(projectAux);

      vec3 vpos = projectAux.posModel;
      if (rejectBySlice(vpos)) {
        gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
        return;
      }
    ${o2.occlusionTestEnabled ? n$j`
      if (!testVisibilityHUD(endPoint)) {
        gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
        return;
      }` : ""}

    ${o2.hasScreenSizePerspective ? n$j`
      vec4 perspectiveFactor = screenSizePerspectiveScaleFactor(projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspectiveAlignment);
      vec2 screenOffsetScaled = applyScreenSizePerspectiveScaleFactorVec2(screenOffset, perspectiveFactor);
        ` : n$j`
      vec2 screenOffsetScaled = screenOffset;
        `}
      // Add view dependent polygon offset to get exact same original starting point. This is mostly
      // used to get the correct depth value
      vec3 posView = (view * vec4(position, 1.0)).xyz;
      ${o2.hasMultipassGeometry ? "depth = posView.z;" : ""}

      applyHUDViewDependentPolygonOffset(auxpos1.w, projectAux.absCosAngle, posView);
      vec4 startPoint = proj * vec4(posView, 1.0);
      // Apply screen offset to both start and end point
      vec2 screenOffsetNorm = screenOffsetScaled * 2.0 / viewport.zw;
      startPoint.xy += screenOffsetNorm * startPoint.w;
      endPoint.xy += screenOffsetNorm * endPoint.w;
      // Align start and end to pixel origin
      vec4 startAligned = alignToPixelOrigin(startPoint, viewport.zw);
      vec4 endAligned = alignToPixelOrigin(endPoint, viewport.zw);
    ${o2.depthHudEnabled ? o2.depthHudAlignStartEnabled ? n$j`endAligned = vec4(endAligned.xy / endAligned.w * startAligned.w, startAligned.zw);` : n$j`startAligned = vec4(startAligned.xy / startAligned.w * endAligned.w, endAligned.zw);` : ""}
      vec4 projectedPosition = mix(startAligned, endAligned, uv0.y);
      // The direction of the line in screen space
      vec2 screenSpaceDirection = normalize(endAligned.xy / endAligned.w - startAligned.xy / startAligned.w);
      vec2 perpendicularScreenSpaceDirection = vec2(screenSpaceDirection.y, -screenSpaceDirection.x);
    ${o2.hasScreenSizePerspective ? n$j`
      float lineSizeScaled = applyScreenSizePerspectiveScaleFactorFloat(lineSize, perspectiveFactor);
      float borderSizeScaled = applyScreenSizePerspectiveScaleFactorFloat(borderSize, perspectiveFactor);
        ` : n$j`
      float lineSizeScaled = lineSize;
      float borderSizeScaled = borderSize;
        `}
      float halfPixelSize = lineSizeScaled * 0.5;
      // Calculate a pixel offset from the edge of the pixel, s.t. we keep the line aligned
      // to pixels if it has a full pixel size. Since pixel aligned biases to the bottom-left,
      // we bias the size to the right (for odd sizes) to balance out the bias. Grow sub-pixel
      // sizes towards the left or right s.t. there is a smooth transition (e.g. from 2 to 3 px).
      float halfWholePixelSize = floor(lineSizeScaled) * 0.5;
      float halfPixelSizeInt = floor(halfWholePixelSize);

      // Sub-pixel offset if we need to grow sub-pixels to the left
      float subpixelOffset = -fract(lineSizeScaled) * float(halfWholePixelSize > 0.0);

      // Pixel offset aligning to whole pixels and adding subpixel offset if needed
      float pixelOffset = -halfPixelSizeInt + subpixelOffset;

      // Compute full ndc offset, adding 1px padding for doing anti-aliasing and the border size
      float padding = 1.0 + borderSizeScaled;
      vec2 ndcOffset = (pixelOffset - padding + uv0.x * (lineSizeScaled + padding + padding)) * pixelToNDC;

      // Offset x/y from the center of the line in screen space
      projectedPosition.xy += perpendicularScreenSpaceDirection * ndcOffset * projectedPosition.w;

      // Compute a coverage varying which we can use in the fragment shader to determine
      // how much a pixel is actually covered by the line (i.e. to anti alias the line).
      // This works by computing two coordinates that can be linearly interpolated and then
      // subtracted to find out how far away from the line edge we are.
      float edgeDirection = (uv0.x * 2.0 - 1.0);

      float halfBorderSize = 0.5 * borderSizeScaled;
      float halfPixelSizeAndBorder = halfPixelSize + halfBorderSize;
      float outerEdgeCoverageSampler = edgeDirection * (halfPixelSizeAndBorder + halfBorderSize + 1.0);

      float isOneSided = float(lineSizeScaled < 2.0 && borderSize < 2.0);

      coverageSampling = vec4(
        // Edge coordinate
        outerEdgeCoverageSampler,

        // Border edge coordinate
        outerEdgeCoverageSampler - halfPixelSizeAndBorder * isOneSided,

        // Line offset
        halfPixelSize - 0.5,

        // Border offset
        halfBorderSize - 0.5 + halfPixelSizeAndBorder * (1.0 - isOneSided)
      );

      lineSizes = vec2(lineSizeScaled, borderSizeScaled);

      gl_Position = projectedPosition;
    }
  `), u2.uniforms.add([new e$g("uColor", (e2) => v$7(e2.color)), new e$g("borderColor", (e2) => v$7(e2.borderColor))]), o2.hasMultipassGeometry && (u2.include(a$d, o2), u2.uniforms.add(new e$h("inverseViewport", (e2, i2) => i2.inverseViewport))), u2.code.add(n$j`
    void main() {
      ${o2.hasMultipassGeometry ? "if( geometryDepthTest(gl_FragCoord.xy * inverseViewport, depth) ){ discard; }" : ""}

      // Mix between line and border coverage offsets depending on whether we need
      // a border (based on the sidedness).
      vec2 coverage = min(1.0 - clamp(abs(coverageSampling.xy) - coverageSampling.zw, 0.0, 1.0), lineSizes);

      // Mix between border and line color based on the line coverage (conceptually the line
      // blends on top of the border background).
      //
      // Anti-alias by blending final result using the full (including optional border) coverage
      // and the color alpha
      float borderAlpha = uColor.a * borderColor.a * coverage.y;
      float colorAlpha = uColor.a * coverage.x;

      float finalAlpha = mix(borderAlpha, 1.0, colorAlpha);

    ${o2.depthHudEnabled ? n$j`
      if (finalAlpha < 0.01) {
        discard;
      }
      ` : n$j`
      vec3 finalRgb = mix(borderColor.rgb * borderAlpha, uColor.rgb, colorAlpha);
      gl_FragColor = vec4(finalRgb, finalAlpha);
      `}
  }
  `), r2;
}
function v$7(i2) {
  return r$d(i2) ? i2 : l$d;
}
const m$3 = n$k(), u$8 = Object.freeze(Object.defineProperty({ __proto__: null, build: S$a }, Symbol.toStringTag, { value: "Module" }));
class h$6 extends e$i {
  initializeConfiguration(i2, t2) {
    t2.spherical = i2.viewingMode === l$f.Global;
  }
  initializeProgram(e2) {
    return new o$b(e2.rctx, h$6.shader.get().build(this.configuration), E$d);
  }
  setPipelineState(e2) {
    const i2 = e2 ? I$7.ALWAYS : I$7.LESS;
    return this.configuration.depthHudEnabled ? W$3({ depthTest: { func: i2 }, depthWrite: a$e }) : W$3({ blending: l$g(R$8.ONE, R$8.SRC_ALPHA, R$8.ONE_MINUS_SRC_ALPHA, R$8.ONE_MINUS_SRC_ALPHA), depthTest: { func: i2 }, colorWrite: _$c });
  }
  initializePipeline() {
    return this.setPipelineState(this.configuration.hasMultipassGeometry);
  }
}
h$6.shader = new t$b(u$8, () => import("./LineCallout.glsl.js"));
class i$5 extends s$b {
  constructor() {
    super(...arguments), this.screenCenterOffsetUnitsEnabled = p$b.World, this.spherical = false, this.occlusionTestEnabled = true, this.hasVerticalOffset = false, this.hasScreenSizePerspective = false, this.depthHudEnabled = false, this.depthHudAlignStartEnabled = false, this.hasSlicePlane = false, this.hasMultipassGeometry = false;
  }
}
e$c([e$j({ count: p$b.COUNT })], i$5.prototype, "screenCenterOffsetUnitsEnabled", void 0), e$c([e$j()], i$5.prototype, "spherical", void 0), e$c([e$j()], i$5.prototype, "occlusionTestEnabled", void 0), e$c([e$j()], i$5.prototype, "hasVerticalOffset", void 0), e$c([e$j()], i$5.prototype, "hasScreenSizePerspective", void 0), e$c([e$j()], i$5.prototype, "depthHudEnabled", void 0), e$c([e$j()], i$5.prototype, "depthHudAlignStartEnabled", void 0), e$c([e$j()], i$5.prototype, "hasSlicePlane", void 0), e$c([e$j()], i$5.prototype, "hasMultipassGeometry", void 0), e$c([e$j({ constValue: true })], i$5.prototype, "hasSliceInVertexProgram", void 0), e$c([e$j({ constValue: false })], i$5.prototype, "isDraped", void 0);
class g$8 extends d$h {
  constructor(e2) {
    super(e2, new S$9()), this._configuration = new i$5(), this._uniqueMaterialIdentifier = g$8.uniqueMaterialIdentifier(this.parameters);
  }
  get uniqueMaterialIdentifier() {
    return this._uniqueMaterialIdentifier;
  }
  getPassParameters() {
    return this.parameters;
  }
  getConfiguration(t2, r2) {
    const i2 = (r2 == null ? void 0 : r2.slot) !== E$e.LINE_CALLOUTS;
    return this._configuration.occlusionTestEnabled = this.parameters.occlusionTest, this._configuration.hasVerticalOffset = r$d(this.parameters.verticalOffset), this._configuration.hasScreenSizePerspective = r$d(this.parameters.screenSizePerspective), this._configuration.depthHudEnabled = i2, this._configuration.depthHudAlignStartEnabled = !!this.parameters.depthHUDAlignStart, this._configuration.screenCenterOffsetUnitsEnabled = this.parameters.centerOffsetUnits === "screen" ? p$b.Screen : p$b.World, this._configuration.hasSlicePlane = this.parameters.hasSlicePlane, this._configuration.hasMultipassGeometry = r2.multipassGeometry.enabled, this._configuration;
  }
  intersect() {
  }
  requiresSlot(e2, t2) {
    if (t2 === h$b.Color)
      switch (e2) {
        case E$e.LINE_CALLOUTS:
        case E$e.LINE_CALLOUTS_HUD_DEPTH:
          return true;
      }
    return false;
  }
  createGLMaterial(e2) {
    return new O$5(e2);
  }
  createBufferWriter() {
    return new b$a();
  }
  validateParameters(e2) {
    const t2 = g$8.uniqueMaterialIdentifier(e2);
    t2 !== this._uniqueMaterialIdentifier && (this._uniqueMaterialIdentifier = t2);
  }
  static uniqueMaterialIdentifier(e2) {
    return JSON.stringify({ screenOffset: e2.screenOffset || [0, 0], centerOffsetUnits: e2.centerOffsetUnits || "world" });
  }
}
class O$5 extends t$d {
  beginSlot(e2) {
    return this.ensureTechnique(h$6, e2);
  }
}
class S$9 extends h$c {
  constructor() {
    super(...arguments), this.screenOffset = f$d, this.color = [0, 0, 0, 1], this.size = 1, this.occlusionTest = false, this.shaderPolygonOffset = 1e-5, this.depthHUDAlignStart = false, this.centerOffsetUnits = "world", this.hasSlicePlane = false;
  }
}
const L$3 = T$4().vec3f(O$8.POSITION).vec3f(O$8.NORMAL).vec2f(O$8.UV0).vec4f(O$8.AUXPOS1), I$5 = [t$c(0, 0), t$c(1, 0), t$c(0, 1), t$c(1, 0), t$c(1, 1), t$c(0, 1)];
class b$a {
  constructor() {
    this.vertexBufferLayout = L$3;
  }
  allocate(e2) {
    return this.vertexBufferLayout.createBuffer(e2);
  }
  elementCount(e2) {
    return 6 * e2.indices.get(O$8.POSITION).length;
  }
  write(e2, t2, r2, i2, s2) {
    y$d(r2.indices.get(O$8.POSITION), r2.vertexAttributes.get(O$8.POSITION).data, e2, i2.position, s2, 6), B$6(r2.indices.get(O$8.NORMAL), r2.vertexAttributes.get(O$8.NORMAL).data, t2, i2.normal, s2, 6), u$m(r2.indices.get(O$8.AUXPOS1), r2.vertexAttributes.get(O$8.AUXPOS1).data, i2.auxpos1, s2, 6);
    for (let n2 = 0; n2 < I$5.length; ++n2)
      i2.uv0.setVec(s2 + n2, I$5[n2]);
  }
}
class b$9 extends y$9 {
  constructor(e2, t2) {
    super(e2, null, t2, U$3), this._elevationOptions = { supportsOffsetAdjustment: true, supportsOnTheGround: false }, this.ensureDrapedStatus(false);
  }
  async doLoad() {
    this._material = new g$8(this._materialParameters), this._context.stage.add(this._material);
  }
  destroy() {
    super.destroy(), this._context.stage.remove(this._material), this._material = null;
  }
  _perInstanceMaterialParameters(e2) {
    const t2 = this._materialParameters;
    return t2.screenOffset = e2.screenOffset || f$d, t2.centerOffsetUnits = e2.centerOffsetUnits || "world", t2;
  }
  get _materialParameters() {
    const r2 = this.symbol, a2 = r2.callout, n2 = r$d(a2.color) ? l$c.toUnitRGBA(a2.color) : [0, 0, 0, 0];
    n2[3] *= this._getLayerOpacity();
    const s2 = u$n(a2.size || 0);
    let o2 = null;
    if (r2.verticalOffset) {
      const { screenLength: e2, minWorldLength: a3, maxWorldLength: n3 } = r2.verticalOffset;
      o2 = { screenLength: u$n(e2), minWorldLength: a3 || 0, maxWorldLength: r$d(n3) ? n3 : 1 / 0 };
    }
    const l2 = r$d(a2.border) && r$d(a2.border.color) ? l$c.toUnitRGBA(a2.border.color) : null, c2 = r2.symbolLayers.getItemAt(0).type === "object", m2 = !c2, d2 = c2 ? 0 : void 0, h2 = r2.type === "label-3d";
    return { color: n2, size: s2, verticalOffset: o2, screenSizePerspective: this._context.screenSizePerspectiveEnabled ? this._context.sharedResources.screenSizePerspectiveSettings : null, screenOffset: [0, 0], centerOffsetUnits: "world", borderColor: l2, occlusionTest: m2, shaderPolygonOffset: d2, depthHUDAlignStart: h2, hasSlicePlane: this._context.slicePlaneEnabled, renderOccluded: o$c.Occlude, __tagStrict: "NoParameters" };
  }
  _defaultElevationInfoNoZ() {
    return E$7;
  }
  createGraphics3DGraphic(e2) {
    const t2 = e2.renderingInfo, i2 = e2.graphic, a2 = this.setGraphicElevationContext(i2, new h$8(), t2.elevationOffset || 0), s2 = t2.symbol, o2 = this._elevationContext.mode === "on-the-ground" && (s2.type === "cim" || !s2.symbolLayers.some((e3) => e3.type === "object" || e3.type === "text"));
    if (s2.type !== "label-3d" && o2)
      return null;
    if (s2.type === "point-3d" && s2.symbolLayers.every((e3) => e3.type === "text" && !l$h(e3)))
      return null;
    const l2 = A$7(i2.geometry);
    return t$7(l2) ? null : this._createAs3DShape(l2, a2, t2, i2.uid);
  }
  layerOpacityChanged() {
    r$d(this._material) && this._material.setParameters(this._materialParameters);
  }
  layerElevationInfoChanged(e2, r2, i2) {
    const a2 = this._elevationContext.mode, n2 = p$c(b$9.elevationModeChangeTypes, i2, a2);
    return n2 !== x$b.UPDATE || e2.forEach((e3) => {
      const i3 = r2(e3);
      r$d(i3) && this.updateGraphicElevationContext(e3.graphic, i3);
    }), n2;
  }
  slicePlaneEnabledChanged() {
    return t$7(this._material) || this._material.setParameters({ hasSlicePlane: this._context.slicePlaneEnabled }), true;
  }
  physicalBasedRenderingChanged() {
    return true;
  }
  pixelRatioChanged() {
    return true;
  }
  setGraphicElevationContext(e2, t2, r2 = 0) {
    const i2 = super.setGraphicElevationContext(e2, t2);
    return i2.addOffsetRenderUnits(r2), i2;
  }
  updateGraphicElevationContext(e2, t2) {
    this.setGraphicElevationContext(e2, t2.elevationContext, t2.metadata.elevationOffset), t2.needsElevationUpdates = g$c(t2.elevationContext.mode);
  }
  computeComplexity() {
    return { primitivesPerFeature: 2, primitivesPerCoordinate: 0, drawCallsPerFeature: 0, estimated: false, memory: b$b.memory };
  }
  _createVertexData(e2) {
    const { translation: t2, centerOffset: r2 } = e2, i2 = t2 ? { size: 3, data: [t2[0], t2[1], t2[2]], exclusive: true } : { size: 3, data: [0, 0, 0], exclusive: true }, a2 = r2 ? { size: 4, data: [r2[0], r2[1], r2[2], r2[3]], exclusive: true } : { size: 4, data: [0, 0, 0, 1], exclusive: true };
    return [[O$8.POSITION, i2], [O$8.NORMAL, { size: 3, data: [0, 0, 1], exclusive: true }], [O$8.AUXPOS1, a2]];
  }
  _getOrCreateMaterial(e2) {
    const i2 = this._perInstanceMaterialParameters(e2), a2 = g$8.uniqueMaterialIdentifier(i2);
    if (r$d(this._material) && a2 === this._material.uniqueMaterialIdentifier)
      return { material: this._material, isUnique: false };
    if (e2.materialCollection) {
      let t2 = e2.materialCollection.get(a2);
      return t$7(t2) && (t2 = new g$8(i2), e2.materialCollection.add(a2, t2)), { material: t2, isUnique: false };
    }
    return { material: new g$8(i2), isUnique: true };
  }
  _createAs3DShape(e2, t2, r2, i2) {
    const a2 = this._context.stage.renderView._getObjectAndLayerIdColor({ graphicUid: i2, layerUid: this._context.layer.uid }), n2 = [new d$i(this._createVertexData(r2), P$5, a$f.Point, a2)], o2 = this._getOrCreateMaterial(r2), l2 = u$9(this._context, e2, n2, [o2.material], t2, this._context.layer.uid, i2);
    if (l2 === null)
      return null;
    const m2 = new _$b(this, l2.object, n2, o2.isUnique ? [o2.material] : null, null, d$b, t2);
    return m2.metadata = { elevationOffset: r2.elevationOffset || 0 }, m2.alignedSampledElevation = l2.sampledElevation, m2.needsElevationUpdates = g$c(t2.mode), f$7(m2, e2, this._context.elevationProvider), m2;
  }
}
b$9.elevationModeChangeTypes = { definedChanged: x$b.UPDATE, staysOnTheGround: x$b.UPDATE, onTheGroundChanged: x$b.RECREATE };
const C$8 = [0], P$5 = [[O$8.POSITION, C$8], [O$8.NORMAL, C$8], [O$8.AUXPOS1, C$8]], E$7 = { mode: "relative-to-ground", offset: 0 }, U$3 = { ignoreDrivers: true, renderPriority: 0, renderPriorityStep: 1 };
const t$5 = s$a.getLogger("esri.views.3d.layers.graphics.Graphics3DCalloutSymbolLayerFactory");
function e$7(o2, l2) {
  if (!i$c(o2))
    return t$5.error("Graphics3DCalloutSymbolLayerFactory#make", `symbol of type '${o2.type}' does not support callouts`), null;
  if (!o2.callout)
    return null;
  const e2 = a$5[o2.callout.type];
  return e2 ? new e2(o2, l2) : (t$5.error("Graphics3DCalloutSymbolLayerFactory#make", `unknown or unsupported callout type ${o2.callout.type}`), null);
}
const a$5 = { line: b$9 };
const S$8 = new e$k(Array, (e2) => w$7(e2, D$4), null, 10, 5), B$4 = u$o();
class V$3 {
  constructor(e2, i2, r2, s2, a2) {
    this.graphic = e2, this.graphics3DSymbol = i2, this.graphics = r2, this._labelGraphics = new Array(), this._auxiliaryGraphics = new Array(), this._visibilityFlags = z$4(E$a._COUNT, C$9._COUNT), this._featureExpressionFeature = null, this._optimizedGeometry = { geometry: null, hasZ: false, hasM: false }, this._extent = null, this.isElevationSource = false, ++i2.referenced, this._featureExpressionFeature = a2 ? s$c(a2, e2, s2) : null;
    for (const o2 of r2)
      r$d(o2) && (this.isElevationSource = this.isElevationSource || o2.isElevationSource);
  }
  get labelGraphics() {
    return this._labelGraphics;
  }
  get extent() {
    return this._extent;
  }
  initialize(e2, i2) {
    this._layer = i2, this._stage = e2, this._forEachSymbolLayerGraphic((t2) => {
      t2.initialize(e2, i2), t2.setVisibility(this.isVisible());
    });
  }
  destroy() {
    this._forEachSymbolLayerGraphic((e2) => e2.destroy()), this.graphics = null, this._auxiliaryGraphics = null, --this.graphics3DSymbol.referenced, this.graphics3DSymbol = null;
  }
  get destroyed() {
    return this.graphics == null;
  }
  clearLabelGraphics() {
    this._forEachLabelGraphic((e2) => e2.destroy()), this._labelGraphics.length = 0;
  }
  addLabelGraphic(e2, i2, t2) {
    this._labelGraphics.push(e2), e2.initialize(i2, t2), e2.setVisibility(this.isVisible(E$a.LABEL));
  }
  addAuxiliaryGraphic(e2) {
    this._auxiliaryGraphics.push(e2), this._layer && (e2.initialize(this._stage, this._layer), e2.setVisibility(this.isVisible()));
  }
  get isDraped() {
    let e2 = false;
    return this._forEachSymbolLayerGraphic((i2) => {
      i2.type === "draped" && (e2 = true);
    }), e2;
  }
  isVisible(e2 = E$a.GRAPHIC, i2) {
    for (let t2 = 0; t2 <= e2; t2++) {
      const e3 = this._visibilityFlags[t2];
      for (let t3 = 0; t3 < e3.length; ++t3)
        if (e3[t3] === false && t3 !== i2)
          return false;
    }
    return true;
  }
  hasVisibilityFlag(e2, i2) {
    return this._visibilityFlags[i2][e2] != null;
  }
  setVisibilityFlag(e2, i2, t2) {
    const r2 = this.isVisible(t2);
    this._visibilityFlags[t2][e2] = i2;
    const s2 = this.isVisible(t2);
    if (r2 === s2)
      return false;
    if (t2 === E$a.LABEL)
      this._forEachLabelGraphic((e3) => e3.setVisibility(s2));
    else {
      this._forEachSymbolLayerGraphic((e4) => e4.setVisibility(s2));
      const e3 = this.isVisible(E$a.LABEL);
      this._forEachLabelGraphic((i3) => i3.setVisibility(e3));
    }
    return true;
  }
  clearVisibilityFlag(e2, i2 = E$a.GRAPHIC) {
    return this.setVisibilityFlag(e2, void 0, i2);
  }
  computeExtent(e2) {
    if (!this._extent) {
      const i2 = this.graphic.geometry;
      if (t$7(i2))
        return false;
      this._extent = u$o(), J$2(i2, this._extent);
      const t2 = i2.spatialReference;
      if (!E$f(t2, e2) && !vn(this._extent, t2, this._extent, e2))
        return this._extent = null, false;
    }
    return true;
  }
  getAsOptimizedGeometry(e2, i2) {
    return r$d(this._optimizedGeometry.geometry) && this._optimizedGeometry.hasZ === e2 && this._optimizedGeometry.hasM === i2 || (this._optimizedGeometry.geometry = this._convertGraphicToOptimizedGeometry(this.graphic, e2, i2), this._optimizedGeometry.hasZ = e2, this._optimizedGeometry.hasM = i2), this._optimizedGeometry.geometry;
  }
  _convertGraphicToOptimizedGeometry(e2, i2, t2) {
    let r2 = e2.geometry;
    return r2.type !== "mesh" && r2.type !== "extent" || (r2 = v$d.fromExtent(r2.type === "mesh" ? r2.extent : r2)), nt$1(r2, i2, t2);
  }
  get usedMemory() {
    let e2 = t$e(this.graphic.attributes);
    return this._forEachSymbolLayerGraphic((i2) => {
      const t2 = i2.graphics3DSymbolLayer.complexity;
      if (t$7(t2))
        return;
      const s2 = i2.type === "draped" ? t2.memory.draped : t2.memory;
      e2 += s2.bytesPerFeature, s2.bytesPerCoordinate && (e2 += w$8(this.graphic.geometry) * s2.bytesPerCoordinate);
    }), e2;
  }
  computeAttachmentOrigin() {
    const e2 = { render: { origin: n$h(), num: 0 }, draped: { origin: n$k(), num: 0 } };
    for (const i2 of this.graphics)
      t$7(i2) || i2.computeAttachmentOrigin(e2);
    return e2.render.num && g$d(e2.render.origin, e2.render.origin, 1 / e2.render.num), e2.draped.num && l$i(e2.draped.origin, e2.draped.origin, 1 / e2.draped.num), e2;
  }
  async getProjectedBoundingBox(i2, t2, s2, a2, o2) {
    return o2 || (o2 = { boundingBox: null, requiresDrapedElevation: false, screenSpaceObjects: [] }), o2.boundingBox ? A$6(o2.boundingBox) : o2.boundingBox = A$6(), o2.requiresDrapedElevation = false, await c$j(this.graphics, async (e2) => {
      if (t$7(e2))
        return;
      const h2 = e2.type === "draped" ? t2 : i2, n2 = S$8.acquire(), c2 = await e2.getProjectedBoundingBox(h2, s2, o2.screenSpaceObjects, a2, n2);
      isFinite(c2[2]) && isFinite(c2[5]) || (o2.requiresDrapedElevation = true), c2 && f$e(o2.boundingBox, n2), S$8.release(n2);
    }), l$j(o2.boundingBox) || M$8(B$7(o2.boundingBox, B$4)) ? o2 : null;
  }
  needsElevationUpdates() {
    for (const e2 of this.graphics)
      if (r$d(e2) && (e2.type === "object3d" || e2.type === "lod-instance") && e2.needsElevationUpdates)
        return true;
    for (const e2 of this._labelGraphics)
      if (e2 && e2.needsElevationUpdates)
        return true;
    return false;
  }
  alignWithElevation(e2, i2, t2) {
    this._forEachRenderedGraphic((r2) => {
      r2.type !== "object3d" && r2.type !== "lod-instance" || r2.alignWithElevation(e2, i2, this._featureExpressionFeature, t2);
    });
  }
  addObjectStateSet(e2, i2) {
    this._forEachSymbolLayerGraphic((t2) => t2.addObjectState(e2, i2));
  }
  removeObjectState(e2) {
    this._forEachSymbolLayerGraphic((i2) => i2.removeObjectState(e2));
  }
  _forEachGraphicList(e2, i2) {
    e2.forEach((e3) => e3 && i2(e3));
  }
  _forEachSymbolLayerGraphic(e2) {
    this._forEachGraphicList(this.graphics, e2), this._forEachGraphicList(this._auxiliaryGraphics, e2);
  }
  _forEachLabelGraphic(e2) {
    this._forEachGraphicList(this._labelGraphics, e2);
  }
  _forEachRenderedGraphic(e2) {
    this._forEachSymbolLayerGraphic(e2), this._forEachLabelGraphic(e2);
  }
}
function z$4(e2, i2) {
  const t2 = new Array(e2);
  for (let r2 = 0; r2 < t2.length; r2++)
    t2[r2] = new Array(i2);
  return t2;
}
function n$7(r2) {
  const s2 = [[O$8.POSITION, r2.indices]], n2 = [[O$8.POSITION, { size: 3, data: r2.attributeData.position, exclusive: true }]];
  return r$d(r2.attributeData.color) && (n2.push([O$8.COLOR, { size: 4, data: r2.attributeData.color, exclusive: true }]), s2.push([O$8.COLOR, new Array(r2.indices.length).fill(0)])), r$d(r2.attributeData.uvMapSpace) && (n2.push([O$8.UVMAPSPACE, { size: 4, data: r2.attributeData.uvMapSpace, exclusive: true }]), s2.push([O$8.UVMAPSPACE, r2.indices])), r$d(r2.attributeData.boundingRect) && (n2.push([O$8.BOUNDINGRECT, { size: 9, data: r2.attributeData.boundingRect, exclusive: true }]), s2.push([O$8.BOUNDINGRECT, r2.indices])), r$d(r2.attributeData.mapPosition) && (n2.push([O$8.MAPPOS, { size: 3, data: r2.attributeData.mapPosition, exclusive: true }]), s2.push([O$8.MAPPOS, r2.indices])), new d$i(n2, s2, a$f.Triangle, r2.attributeData.objectAndLayerIdColor);
}
function o$4(e2) {
  const r2 = [[O$8.POSITION, e2.indices], [O$8.UV0, e2.indices]], s2 = [[O$8.POSITION, { size: 3, data: e2.attributeData.position, exclusive: true }], [O$8.UV0, { size: 2, data: e2.attributeData.uv0, exclusive: true }]];
  return r$d(e2.attributeData.mapPosition) && (s2.push([O$8.MAPPOS, { size: 3, data: e2.attributeData.mapPosition, exclusive: true }]), r2.push([O$8.MAPPOS, e2.indices])), new d$i(s2, r2);
}
function u$7(t2) {
  switch (t2.type) {
    case "extent":
      if (t2 instanceof w$9)
        return v$d.fromExtent(t2);
      break;
    case "polygon":
      return t2;
  }
  return null;
}
class c$7 {
  constructor(t2, e2, i2) {
    this.renderData = t2, this.layerUid = e2, this.graphicsUid = i2, this.outGeometries = new Array(), this.outMaterials = new Array(), this.outTransforms = new Array();
  }
}
function e$6(o2, s2, e2, r2) {
  const c2 = l$k(o2.rings, o2.hasZ, c$k.CCW_IS_HOLE), u2 = new Float64Array(c2.position.length), h2 = f$f(c2.position, o2.spatialReference, 0, u2, 0, c2.position, 0, c2.position.length / 3, s2, e2, r2), g2 = h2 != null;
  return new l$7(c2.position, u2, a$4(c2.polygons, c2.position, u2), p$7(c2.outlines, c2.position, u2), g2, h2);
}
function r$9(i2, e2) {
  const r2 = l$k(i2.rings, false, c$k.CCW_IS_HOLE), c2 = xn(r2.position, i2.spatialReference, 0, r2.position, e2, 0, r2.position.length / 3);
  for (let o2 = 2; o2 < r2.position.length; o2 += 3)
    r2.position[o2] = ue$4;
  return { position: r2.position, polygons: a$4(r2.polygons, r2.position), outlines: p$7(r2.outlines, r2.position), projectionSuccess: c2 };
}
function p$7(o2, t2, n2) {
  return o2.filter(({ count: o3 }) => o3 > 1).map(({ index: o3, count: i2 }) => {
    const s2 = 3 * o3, e2 = s2 + 3 * i2;
    return n2 ? new u$6(o3, i2, t2.subarray(s2, e2), n2.subarray(s2, e2)) : new c$6(o3, i2, t2.subarray(s2, e2));
  });
}
function a$4(o2, t2, n2) {
  const i2 = new Array();
  for (const { index: s2, count: e2, holeIndices: r2, pathLengths: p2 } of o2) {
    if (e2 <= 1)
      continue;
    const o3 = 3 * s2, a2 = o3 + 3 * e2, c2 = r2.map((o4) => o4 - s2);
    i2.push({ index: s2, count: e2, holeIndices: c2, pathLengths: p2, position: t2.subarray(o3, a2), mapPosition: n2 ? n2.subarray(o3, a2) : void 0 });
  }
  return i2;
}
class c$6 {
  constructor(o2, t2, n2) {
    this.index = o2, this.count = t2, this.position = n2;
  }
}
class u$6 extends c$6 {
  constructor(o2, t2, n2, i2) {
    super(o2, t2, n2), this.mapPosition = i2;
  }
}
class l$7 {
  constructor(o2, t2, n2, i2, s2, e2) {
    this.position = o2, this.mapPosition = t2, this.polygons = n2, this.outlines = i2, this.projectionSuccess = s2, this.sampledElevation = e2;
  }
}
const X$1 = ["polygon", "extent"];
class $$2 extends y$9 {
  constructor(e2, t2, r2, s2) {
    super(e2, t2, r2, s2), this.ensureDrapedStatus(false);
  }
  async doLoad() {
    if (!this._drivenProperties.size) {
      const t3 = S$f(this._getSymbolSize());
      if (t3)
        throw new s$d("graphics3dextrudesymbollayer:invalid-size", t3);
    }
    const t2 = q$7(this.symbolLayer, "material", "color"), s2 = this._getCombinedOpacityAndColor(t2), n2 = e$l(s2), i2 = s2[3], o2 = i2 < 1 || this.needsDrivenTransparentPass, a2 = { usePBR: this._context.physicalBasedRenderingEnabled, isSchematic: true, diffuse: n2, ambient: n2, opacity: i2, transparent: o2, cullFace: o2 ? n$l.None : n$l.Back, hasVertexColors: true, hasSlicePlane: this._context.slicePlaneEnabled, castShadows: this.symbolLayer.castShadows, offsetTransparentBackfaces: true };
    this._material = new C$b(a2), this._bottomMaterial = new C$b(__spreadProps(__spreadValues({}, a2), { cullFace: n$l.Back })), this._context.stage.add(this._material), this._context.stage.add(this._bottomMaterial);
  }
  destroy() {
    super.destroy(), this._material && (this._context.stage.remove(this._material), this._context.stage.remove(this._bottomMaterial));
  }
  createGraphics3DGraphic(e2) {
    const t2 = e2.graphic;
    if (!this._validateGeometry(t2.geometry, X$1, this.symbolLayer.type))
      return null;
    const r2 = this._getVertexOpacityAndColor(e2.renderingInfo, 255), s2 = this.setGraphicElevationContext(t2, new h$8());
    return this._createAs3DShape(t2, e2.renderingInfo, r2, s2, t2.uid);
  }
  layerOpacityChanged(e2, t2) {
    const n2 = q$7(this.symbolLayer, "material", "color"), i2 = this._getCombinedOpacity(n2), o2 = i2 < 1 || this.needsDrivenTransparentPass;
    this._material.setParameters({ opacity: i2, transparent: o2 }), this._bottomMaterial.setParameters({ opacity: i2, transparent: o2 });
    const a2 = this._getLayerOpacity();
    e2.forEach((e3) => {
      const r2 = t2(e3);
      r$d(r2) && r2.layerOpacityChanged(a2, this._context.isAsync);
    });
  }
  layerElevationInfoChanged(e2, t2) {
    return this.updateGraphics3DGraphicElevationInfo(e2, t2, v$e);
  }
  slicePlaneEnabledChanged(e2, t2) {
    return this._material.setParameters({ hasSlicePlane: this._context.slicePlaneEnabled }), this._bottomMaterial.setParameters({ hasSlicePlane: this._context.slicePlaneEnabled }), e2.forEach((e3) => {
      const r2 = t2(e3);
      r$d(r2) && r2.slicePlaneEnabledChanged(this._context.slicePlaneEnabled, this._context.isAsync);
    }), true;
  }
  physicalBasedRenderingChanged() {
    return this._material.setParameters({ usePBR: this._context.physicalBasedRenderingEnabled, isSchematic: true }), this._bottomMaterial.setParameters({ usePBR: this._context.physicalBasedRenderingEnabled, isSchematic: true }), true;
  }
  pixelRatioChanged() {
    return true;
  }
  _getExtrusionSize(e2) {
    var _a;
    let t2;
    return t2 = e2.size && this._drivenProperties.size ? (_a = u$d(e2.size, 2)) != null ? _a : 0 : this._getSymbolSize(), t2 /= this._context.renderCoordsHelper.unitInMeters, t2;
  }
  applyRendererDiff(e2, t2) {
    return this._drivenPropertiesChanged(t2) ? e$a.Recreate_Symbol : e$a.Recreate_Graphics;
  }
  async queryForSnapping(e2, r2, s2, n2) {
    var _a, _b, _c;
    const o2 = this._getExtrusionSize(s2) * this._context.renderCoordsHelper.unitInMeters / L$5(r2), { objectId: a2, target: l2 } = e2, c2 = y$e(l2);
    switch (c2.z = ((_a = c2.z) != null ? _a : 0) + o2, e2.type) {
      case "edge": {
        const { start: r3, end: s3 } = e2, n3 = y$e(r3), i2 = y$e(s3);
        return n3.z = ((_b = n3.z) != null ? _b : 0) + o2, i2.z = ((_c = i2.z) != null ? _c : 0) + o2, [e$m(a2, c2, 1 / 0, n3, i2)];
      }
      case "vertex":
        return [t$f(a2, c2, 1 / 0), e$m(a2, l2, 1 / 0, l2, c2)];
      default:
        return [];
    }
  }
  _getSymbolSize() {
    var _a;
    return (_a = this.symbolLayer.size) != null ? _a : 1;
  }
  _createAs3DShape(e2, t2, r2, i2, m2) {
    const d2 = u$7(e2.geometry);
    if (t$7(d2))
      return null;
    if (d2.rings.length === 0 || !d2.rings.some((e3) => e3.length > 0))
      return this._logGeometryValidationWarnings(d2.rings, "rings", "ExtrudeSymbol3DLayer"), null;
    const g2 = e$6(d2, this._context.elevationProvider, this._context.renderCoordsHelper, i2);
    this._logGeometryCreationWarnings(g2, d2.rings, "rings", "ExtrudeSymbol3DLayer");
    const u2 = A$7(d2);
    if (t$7(u2))
      return null;
    const f2 = new Array(), y2 = new Array(), _2 = new Array(), L2 = a$b(), M2 = e$e(), I2 = n$h(), B2 = this._context.renderCoordsHelper.viewingMode === l$f.Global;
    B2 || this._context.renderCoordsHelper.worldUpAtPosition(null, I2), Zn(d2.spatialReference, [u2.x, u2.y, 0], M2, this._context.renderCoordsHelper.spatialReference);
    const z2 = e$e();
    h$d(z2, M2);
    const R2 = e$o();
    g$e(R2, z2);
    const { polygons: D2, mapPosition: G2, position: k2 } = g2, V2 = k2.length / 3, H2 = new Float64Array(3 * V2 * 6), Z2 = new Float64Array(3 * V2 * 6), W2 = new Float64Array(3 * V2 * 6), q2 = new Float64Array(1 * V2 * 6);
    let K2 = 0;
    for (let s2 = 0; s2 < D2.length; ++s2) {
      const e3 = D2[s2], n2 = e3.count;
      if (this._context.clippingExtent && (A$6(L2), M$9(L2, e3.mapPosition), !R$9(L2, this._context.clippingExtent)))
        continue;
      const i3 = x$d(e3.mapPosition, e3.holeIndices, 3);
      if (i3.length === 0)
        continue;
      const a2 = 3 * n2 * 2 + i3.length, l2 = new Array(a2), c2 = new Array(i3.length), p2 = 6 * n2, d3 = 3 * H2.BYTES_PER_ELEMENT, g3 = new T$5(H2.buffer, K2 * d3, d3, (K2 + p2) * d3), u3 = 3 * Z2.BYTES_PER_ELEMENT, b2 = new T$5(Z2.buffer, K2 * u3, u3, (K2 + p2) * u3), x2 = new Float64Array(W2.buffer, 3 * K2 * W2.BYTES_PER_ELEMENT, 3 * p2), E2 = new Float64Array(q2.buffer, 1 * K2 * q2.BYTES_PER_ELEMENT, 1 * p2), M3 = this._getExtrusionSize(t2);
      te(k2, G2, i3, e3, g3.typedBuffer, x2, b2.typedBuffer, E2, l2, c2, M3, I2, B2), t$g(g3, g3, z2), r$h(b2, b2, R2), K2 += 6 * n2;
      const O2 = this._context.stage.renderView._getObjectAndLayerIdColor({ graphicUid: m2, layerUid: this._context.layer.uid }), C2 = ee(l2, l2.length - c2.length, { positions: g3.typedBuffer, elevation: x2, normals: b2.typedBuffer, heights: E2 }, r2, O2);
      f2.push(C2), y2.push(this._material), _2.push(o$8);
      const T2 = ee(c2, 0, { positions: g3.typedBuffer, elevation: x2, normals: b2.typedBuffer, heights: E2 }, r2, O2);
      f2.push(T2), y2.push(this._bottomMaterial), _2.push(o$8);
    }
    if (f2.length === 0)
      return null;
    const Q2 = new x$c({ geometries: f2, materials: y2, transformations: _2, metadata: { layerUid: this._context.layer.uid, graphicUid: m2, isElevationSource: true } });
    Q2.transformation = M2;
    const X2 = f$g(this.symbolLayer, { opacity: this._getLayerOpacity() }), $2 = r$d(X2) ? { baseMaterial: this._material, edgeMaterials: [X2], properties: { mergeGeometries: true, hasSlicePlane: this._context.slicePlaneEnabled } } : null, re2 = new _$b(this, Q2, f2, null, null, de$3, i2, $2);
    return re2.alignedSampledElevation = g2.sampledElevation, re2.needsElevationUpdates = v$e(i2.mode), re2;
  }
}
function ee(e2, t2, r2, s2, n2) {
  const i2 = new Array(e2.length).fill(0), o2 = [[O$8.POSITION, { size: 3, data: r2.positions, exclusive: true }], [O$8.NORMAL, { size: 3, data: r2.normals, exclusive: true }], [O$8.COLOR, { size: 4, data: s2, exclusive: true }], [O$8.SIZE, { size: 1, data: r2.heights, exclusive: true }]], a2 = [[O$8.POSITION, e2], [O$8.NORMAL, e2], [O$8.COLOR, i2]];
  return r2.elevation && (o2.push([O$8.MAPPOS, { size: 3, data: r2.elevation }]), a2.push([O$8.MAPPOS, e2])), new d$i(o2, a2, a$f.Triangle, n2, t2);
}
function te(e2, t2, r2, s2, n2, i2, o2, a2, l2, c2, h2, p2, m2) {
  const d2 = r2.length / 3;
  let g2 = 0, u2 = 2 * s2.count;
  re(e2, t2, s2.index, s2.count, r2, 0, d2, n2, i2, o2, a2, l2, c2, u2, h2, p2, m2);
  let f2 = 2 * s2.count;
  u2 = 0, ie(n2, i2, a2, o2, g2, s2.pathLengths[0], s2.count, f2, l2, u2, h2), f2 += 4 * s2.pathLengths[0], u2 += 2 * s2.pathLengths[0], g2 += s2.pathLengths[0];
  for (let y2 = 1; y2 < s2.pathLengths.length; ++y2)
    ie(n2, i2, a2, o2, g2, s2.pathLengths[y2], s2.count, f2, l2, u2, h2), f2 += 4 * s2.pathLengths[y2], u2 += 2 * s2.pathLengths[y2], g2 += s2.pathLengths[y2];
}
function re(e2, t2, r2, s2, n2, i2, o2, a2, l2, c2, h2, p2, g2, u2, f2, y2, _2) {
  r$e(ue$3, y2);
  const b2 = f2 > 0 ? 1 : -1;
  let x2 = 3 * r2, E2 = 0, P2 = 3 * E2, S2 = s2, j2 = 3 * S2;
  for (let m2 = 0; m2 < s2; ++m2)
    _2 && (ue$3[0] = e2[x2 + 0], ue$3[1] = e2[x2 + 1], ue$3[2] = e2[x2 + 2], z$5(ue$3, ue$3)), a2[P2 + 0] = e2[x2 + 0], a2[P2 + 1] = e2[x2 + 1], a2[P2 + 2] = e2[x2 + 2], l2[P2 + 0] = t2[x2 + 0], l2[P2 + 1] = t2[x2 + 1], l2[P2 + 2] = t2[x2 + 2], c2[P2 + 0] = -b2 * ue$3[0], c2[P2 + 1] = -b2 * ue$3[1], c2[P2 + 2] = -b2 * ue$3[2], h2[E2] = 0, a2[j2 + 0] = e2[x2 + 0] + f2 * ue$3[0], a2[j2 + 1] = e2[x2 + 1] + f2 * ue$3[1], a2[j2 + 2] = e2[x2 + 2] + f2 * ue$3[2], l2[j2 + 0] = t2[x2 + 0], l2[j2 + 1] = t2[x2 + 1], l2[j2 + 2] = t2[x2 + 2], c2[j2 + 0] = b2 * ue$3[0], c2[j2 + 1] = b2 * ue$3[1], c2[j2 + 2] = b2 * ue$3[2], h2[S2] = f2, P2 += 3, j2 += 3, x2 += 3, E2 += 1, S2 += 1;
  x2 = 3 * i2, P2 = 0, j2 = 3 * u2;
  const v2 = f2 < 0 ? _e$4 : ye$3, w2 = f2 < 0 ? ye$3 : _e$4;
  for (let m2 = 0; m2 < o2; ++m2)
    g2[P2 + 0] = n2[x2 + v2[0]], g2[P2 + 1] = n2[x2 + v2[1]], g2[P2 + 2] = n2[x2 + v2[2]], p2[j2 + 0] = n2[x2 + w2[0]] + s2, p2[j2 + 1] = n2[x2 + w2[1]] + s2, p2[j2 + 2] = n2[x2 + w2[2]] + s2, P2 += 3, j2 += 3, x2 += 3;
}
function se$2(e2, t2, r2, s2, n2, i2, o2) {
  s2[i2] = s2[o2], o2 *= 3, e2[(i2 *= 3) + 0] = e2[o2 + 0], e2[i2 + 1] = e2[o2 + 1], e2[i2 + 2] = e2[o2 + 2], t2[i2 + 0] = t2[o2 + 0], t2[i2 + 1] = t2[o2 + 1], t2[i2 + 2] = t2[o2 + 2], r2[i2 + 0] = n2[0], r2[i2 + 1] = n2[1], r2[i2 + 2] = n2[2];
}
const ne$2 = n$h();
function ie(e2, t2, r2, s2, n2, i2, o2, a2, l2, c2, h2) {
  let p2 = n2, m2 = n2 + 1, d2 = n2 + o2, g2 = n2 + o2 + 1, u2 = a2, f2 = a2 + 1, y2 = a2 + 2 * i2, _2 = a2 + 2 * i2 + 1;
  h2 < 0 && (p2 = n2 + o2 + 1, g2 = n2), c2 *= 3;
  for (let b2 = 0; b2 < i2; ++b2)
    b2 === i2 - 1 && (h2 > 0 ? (m2 = n2, g2 = n2 + o2) : (m2 = n2, p2 = n2 + o2)), pe$3(e2, p2, m2, d2, ne$2), se$2(e2, t2, s2, r2, ne$2, u2, p2), se$2(e2, t2, s2, r2, ne$2, f2, m2), se$2(e2, t2, s2, r2, ne$2, y2, d2), se$2(e2, t2, s2, r2, ne$2, _2, g2), l2[c2++] = u2, l2[c2++] = y2, l2[c2++] = _2, l2[c2++] = u2, l2[c2++] = _2, l2[c2++] = f2, p2++, m2++, d2++, g2++, u2 += 2, f2 += 2, y2 += 2, _2 += 2;
}
const oe$2 = n$h(), ae$2 = n$h(), le$2 = n$h(), ce$2 = n$h(), he$3 = n$h();
function pe$3(e2, t2, r2, s2, n2) {
  t2 *= 3, r2 *= 3, s2 *= 3, o$7(oe$2, e2[t2++], e2[t2++], e2[t2++]), o$7(ae$2, e2[r2++], e2[r2++], e2[r2++]), o$7(le$2, e2[s2++], e2[s2++], e2[s2++]), e$n(ce$2, ae$2, oe$2), e$n(he$3, le$2, oe$2), _$d(n2, he$3, ce$2), z$5(n2, n2);
}
const me$4 = n$h();
function de$3(e2, t2, r2, n2) {
  const i2 = e2.stageObject, o2 = i2.geometryRecords, a2 = o2.length, l2 = t2.mode !== "absolute-height";
  let h2 = 0;
  const m2 = i2.transformation, d2 = h$d(e$e(), m2);
  for (let c2 = 0; c2 < a2; c2 += 2) {
    const e3 = o2[c2].geometry, a3 = e3.getMutableAttribute(O$8.POSITION).data, p2 = e3.vertexAttributes.get(O$8.SIZE).data, u2 = e3.vertexAttributes.get(O$8.MAPPOS).data, f2 = new t$a(u2), _2 = a3.length / 3;
    let b2 = 0, x2 = false, E2 = 0;
    const P2 = r2.spatialReference;
    for (let i3 = 0; i3 < _2; i3++) {
      me$4[0] = a3[b2], me$4[1] = a3[b2 + 1], me$4[2] = a3[b2 + 2], d$e(f2, r2, t2, n2, fe$3), l2 && (E2 += fe$3.sampledElevation), t$9.TESTS_DISABLE_OPTIMIZATIONS ? (o$7(ge$2, f2.array[f2.offset + 0], f2.array[f2.offset + 1], fe$3.z + p2[b2 / 3]), r$d(P2) && n2.toRenderCoords(ge$2, P2, ge$2), O$9(ge$2, ge$2, d2)) : (o$7(ge$2, a3[b2 + 0], a3[b2 + 1], a3[b2 + 2]), O$9(ge$2, ge$2, m2), n2.setAltitude(ge$2, fe$3.z + p2[b2 / 3]), O$9(ge$2, ge$2, d2)), a3[b2] = ge$2[0], a3[b2 + 1] = ge$2[1], a3[b2 + 2] = ge$2[2];
      const e4 = be$2 / n2.unitInMeters;
      (Math.abs(me$4[0] - a3[b2]) >= e4 || Math.abs(me$4[1] - a3[b2 + 1]) >= e4 || Math.abs(me$4[2] - a3[b2 + 2]) >= e4) && (x2 = true), f2.offset += 3, b2 += 3;
    }
    x2 && (e3.invalidateBoundingInfo(), i2.geometryVertexAttrsUpdated(o2[c2]), o2[c2 + 1].geometry.invalidateBoundingInfo(), i2.geometryVertexAttrsUpdated(o2[c2 + 1])), h2 += E2 / _2;
  }
  return h2 / a2;
}
const ge$2 = n$h(), ue$3 = n$h(), fe$3 = new j$6(), ye$3 = [0, 2, 1], _e$4 = [0, 1, 2], be$2 = 0.01;
class l$6 {
  constructor(e2, t2, r2, i2) {
    this.graphics3DSymbolLayer = e2, this.renderGeometries = t2, this.boundingBox = r2, this._drapeSourceRenderer = i2, this.type = "draped", this.stage = null, this._visible = false, this._addedToStage = false, this.isElevationSource = false;
  }
  initialize(e2) {
    this.stage = e2;
  }
  setVisibility(e2) {
    if (this.stage != null && this._visible !== e2) {
      if (this._visible = e2, e2 && !this._addedToStage)
        return this._addedToStage = true, void this._drapeSourceRenderer.addGeometries(this.renderGeometries, E$g.ADD);
      if (e2 || this._addedToStage) {
        for (const e3 of this.renderGeometries)
          e3.instanceParameters.visible = this._visible;
        this._drapeSourceRenderer.modifyGeometries(this.renderGeometries, I$8.VISIBILITIES);
      }
    }
  }
  destroy() {
    this.stage && this._addedToStage && this._drapeSourceRenderer.removeGeometries(this.renderGeometries, E$g.REMOVE), this._addedToStage = false, this._visible = false, this.stage = null;
  }
  getCenterObjectSpace(e2 = n$h()) {
    return o$7(e2, 0, 0, 0);
  }
  getBoundingBoxObjectSpace(e2 = a$b()) {
    return A$6(e2);
  }
  addObjectState(e2, t2) {
    e2 === u$h.Highlight && (this.renderGeometries.forEach((e3) => {
      const r2 = e3.addHighlight();
      t2.addRenderGeometry(e3, r2, this);
    }), this._addedToStage && this._drapeSourceRenderer.modifyGeometries(this.renderGeometries, I$8.HIGHLIGHTS));
  }
  removeObjectState(e2) {
    this.renderGeometries.forEach((t2) => {
      e2.removeRenderGeometry(t2);
    });
  }
  removeRenderGeometryObjectState(e2, t2) {
    e2.removeHighlight(t2), this._addedToStage && this._drapeSourceRenderer.modifyGeometries(this.renderGeometries, I$8.HIGHLIGHTS);
  }
  computeAttachmentOrigin(e2) {
    for (const t2 of this.renderGeometries)
      t2.computeAttachmentOrigin(f$6) && (e2.draped.origin[0] += f$6[0], e2.draped.origin[1] += f$6[1], e2.draped.num++);
  }
  async getProjectedBoundingBox(t2, r2, i2, n2, a2) {
    A$6(a2);
    for (let e2 = 0; e2 < this.renderGeometries.length; e2++) {
      const r3 = this.renderGeometries[e2];
      this._getRenderGeometryProjectedBoundingRect(r3, t2, p$6, i2), h$e(a2, p$6);
    }
    if (r2) {
      let t3;
      p$9(a2, f$6);
      const i3 = X$2(a2, r2.service.spatialReference, r2);
      try {
        t3 = await r2.service.queryElevation(f$6[0], f$6[1], n2, i3, "ground");
      } catch (h2) {
      }
      r$d(t3) && (a2[2] = Math.min(a2[2], t3), a2[5] = Math.max(a2[5], t3));
    }
    return a2;
  }
  _getRenderGeometryProjectedBoundingRect(e2, t2, r2, i2) {
    if (this.boundingBox)
      w$7(S$7, this.boundingBox);
    else {
      const t3 = e2.boundingSphere, r3 = t3[3];
      S$7[0] = t3[0] - r3, S$7[1] = t3[1] - r3, S$7[2] = t3[2] - r3, S$7[3] = t3[0] + r3, S$7[4] = t3[1] + r3, S$7[5] = t3[2] + r3;
    }
    return t2(S$7, 0, 2), this.calculateRelativeScreenBounds && i2.push({ location: p$9(S$7), screenSpaceBoundingRect: this.calculateRelativeScreenBounds() }), B$7(S$7, r2);
  }
}
const p$6 = u$o(), S$7 = a$b(), f$6 = n$h();
class s$6 {
  constructor(t2, e2, i2, n2 = 2048) {
    this.text = t2, this._alignment = e2, this._parameters = i2, this._maxSize = n2, this._textWidths = [], this._lineWidths = [], this._renderPixelRatio = null, this._displayWidth = null, this._heightMetricsCached = null, this.key = `TextRenderer-${this._parameters.key}-${this._alignment}--${t2}`, this._lines = t2.split(/\r?\n/);
  }
  get displayWidth() {
    return Math.ceil(this._ensureTextWidth() + 2 * this._backgroundHorizontalPadding);
  }
  get displayHeight() {
    const t2 = this._lineSpacing * (this._lines.length - 1), e2 = this._lineHeight;
    return Math.ceil(t2 + e2 + 2 * this._haloSize + this._backgroundTopPadding + this._backgroundBottomPadding);
  }
  get renderedWidth() {
    return Math.ceil(this._toRenderUnit(this.displayWidth));
  }
  get renderedHeight() {
    return Math.ceil(this._toRenderUnit(this.displayHeight));
  }
  get firstRenderedBaselinePosition() {
    return this._toRenderUnit(this._firstLineYOffset + this._baselinePosition);
  }
  get _firstLineYOffset() {
    return this._backgroundTopPadding + this._haloSize;
  }
  get _heightMetrics() {
    return this._ensureHeightMetrics();
  }
  get _lineSpacing() {
    return (this._lineHeight + this._linePadding) * this._parameters.definition.lineSpacingFactor;
  }
  get _lineHeight() {
    return this._heightMetrics.lineHeight;
  }
  get _linePadding() {
    return this._lineHeight * d$8;
  }
  get _baselinePosition() {
    return this._heightMetrics.baselinePosition;
  }
  get _renderedFontSize() {
    return this._toRenderUnit(this._fontSize);
  }
  get _fontSize() {
    return this._parameters.definition.size;
  }
  get _renderedHaloSize() {
    return this._toRenderUnit(this._haloSize);
  }
  get _haloSize() {
    return this._parameters.haloSize;
  }
  get _backgroundHorizontalPadding() {
    return this._hasBackground ? this._parameters.definition.background.padding[0] : 0;
  }
  get _backgroundVerticalPadding() {
    return this._hasBackground ? this._parameters.definition.background.padding[1] : 0;
  }
  get _backgroundTopPadding() {
    return Math.max(0, this._backgroundVerticalPadding - this._heightMetrics.paddingTop);
  }
  get _backgroundBottomPadding() {
    return Math.max(0, this._backgroundVerticalPadding - this._heightMetrics.paddingBottom);
  }
  get _hasBackground() {
    return !!this._parameters.backgroundStyle;
  }
  get renderPixelRatio() {
    if (t$7(this._renderPixelRatio)) {
      const t2 = this._parameters.definition.pixelRatio;
      this._maxSize > 0 ? this._renderPixelRatio = Math.min(t2, Math.min(this._maxSize / this.displayWidth, this._maxSize / this.displayHeight)) : this._renderPixelRatio = t2;
    }
    return this._renderPixelRatio;
  }
  _getLineXOffset(t2) {
    switch (this._alignment) {
      case h$5.Left:
        return this._backgroundHorizontalPadding;
      case h$5.Center:
        return (this.displayWidth - this._lineWidths[t2]) / 2;
      case h$5.Right:
        return this.displayWidth - this._backgroundHorizontalPadding - this._lineWidths[t2];
    }
  }
  render(t2, e2 = 0, i2 = 0) {
    t2.save();
    const s2 = e2 /= this.renderPixelRatio, r2 = i2 /= this.renderPixelRatio, h2 = this._haloSize, o2 = this._firstLineYOffset;
    e2 += h2, i2 += o2 + this._baselinePosition;
    const a2 = this._haloSize > 0;
    a2 && this._renderHalo(t2, s2, r2, h2, o2), this._setFontProperties(t2, this._renderedFontSize);
    for (let n2 = 0; n2 < this._lines.length; ++n2) {
      const s3 = this._lines[n2], r3 = this._getLineXOffset(n2);
      a2 && (t2.globalCompositeOperation = "destination-out", t2.fillStyle = "rgb(0, 0, 0)", this._fillText(t2, s3, e2 + r3, i2), this._renderLineDecoration(t2, e2 + r3, i2, this._textWidths[n2])), t2.globalCompositeOperation = "source-over", t2.fillStyle = this._parameters.textStyle, this._fillText(t2, s3, e2 + this._getLineXOffset(n2), i2), this._renderLineDecoration(t2, e2 + r3, i2, this._textWidths[n2]), i2 += this._lineSpacing;
    }
    if (t$9.TEXT_SHOW_BASELINE) {
      t2.strokeStyle = _$9, t2.setLineDash([2, 2]), t2.lineWidth = 1;
      let e3 = r2 + o2;
      for (let i3 = 0; i3 < this._lines.length; ++i3) {
        const i4 = e3 + this._baselinePosition;
        this._drawLine(t2, [s2, i4], [s2 + this.displayWidth, i4]), e3 += this._lineSpacing;
      }
    }
    if (t$9.TEXT_SHOW_BORDER && (t2.strokeStyle = _$9, t2.setLineDash([]), t2.lineWidth = 1, this._drawBox(t2, [s2, r2], [this.displayWidth, this.displayHeight])), this._hasBackground) {
      const e3 = this._parameters.definition.background.borderRadius * this.renderPixelRatio;
      this._roundedRect(t2, s2, r2, e3), t2.globalCompositeOperation = "destination-over", t2.fillStyle = this._parameters.backgroundStyle, t2.fill();
    }
    t2.restore();
  }
  _renderLineDecoration(t2, e2, i2, n2, s2 = false) {
    if (this._parameters.definition.font.decoration === "none" || n2 === 0)
      return;
    const r2 = 1, h2 = Math.max(this._parameters.definition.size / 16, r2);
    switch (this._parameters.definition.font.decoration) {
      case "underline":
        i2 += 2 * h2;
        break;
      case "line-through":
        i2 -= 0.33 * this._baselinePosition;
    }
    const o2 = s2 ? this._haloSize : 0;
    t2.strokeStyle = s2 ? this._parameters.haloStyle : this._parameters.textStyle, t2.lineWidth = this._toRenderUnit(h2 + 2 * o2), t2.beginPath(), t2.moveTo(this._toRenderUnit(e2 - o2), this._toRenderUnit(i2)), t2.lineTo(this._toRenderUnit(e2 + n2 + o2), this._toRenderUnit(i2)), t2.stroke();
  }
  _roundedRect(e2, i2, n2, s2) {
    i2 = this._toRenderUnit(i2), n2 = this._toRenderUnit(n2);
    const r2 = this.renderedWidth, h2 = this.renderedHeight;
    s2 !== 0 ? (s2 = a$g(s2, 0, Math.floor(h2 / 2)), e2.beginPath(), e2.moveTo(i2, n2 + s2), e2.arcTo(i2, n2, i2 + s2, n2, s2), e2.lineTo(i2 + r2 - s2, n2), e2.arcTo(i2 + r2, n2, i2 + r2, n2 + s2, s2), e2.lineTo(i2 + r2, n2 + h2 - s2), e2.arcTo(i2 + r2, n2 + h2, i2 + r2 - s2, n2 + h2, s2), e2.lineTo(i2 + s2, n2 + h2), e2.arcTo(i2, n2 + h2, i2, n2 + h2 - s2, s2), e2.closePath()) : e2.rect(i2, n2, r2, h2);
  }
  _renderHalo(t2, e2, i2, n2, s2) {
    const r2 = this.renderedWidth, h2 = this.renderedHeight, d2 = o$3(a$3, Math.max(r2, l$5), Math.max(h2, l$5)), _2 = d2.getContext("2d");
    _2.clearRect(0, 0, r2, h2), this._setFontProperties(_2, this._renderedFontSize), _2.fillStyle = this._parameters.haloStyle, _2.strokeStyle = this._parameters.haloStyle;
    const g2 = this._renderedHaloSize < 3;
    _2.lineJoin = g2 ? "miter" : "round", g2 ? this._renderHaloEmulated(_2, n2, s2) : this._renderHaloNative(_2, n2, s2);
    let c2 = s2 + this._baselinePosition;
    for (let o2 = 0; o2 < this._lines.length; ++o2) {
      const t3 = this._getLineXOffset(o2);
      this._renderLineDecoration(_2, n2 + t3, c2, this._textWidths[o2], true), c2 += this._lineSpacing;
    }
    t2.globalAlpha = this._parameters.definition.halo.color[3], t2.drawImage(d2, 0, 0, r2, h2, this._toRenderUnit(e2), this._toRenderUnit(i2), r2, h2), t2.globalAlpha = 1;
  }
  _renderHaloEmulated(t2, e2, i2) {
    i2 += this._baselinePosition;
    for (let n2 = 0; n2 < this._lines.length; ++n2) {
      const s2 = this._lines[n2], h2 = this._getLineXOffset(n2);
      for (const [n3, o2] of r$8)
        this._fillText(t2, s2, e2 + h2 + this._haloSize * n3, i2 + this._haloSize * o2);
      i2 += this._lineSpacing;
    }
  }
  _renderHaloNative(t2, e2, i2) {
    const n2 = 2 * this._haloSize;
    i2 += this._baselinePosition;
    for (let s2 = 0; s2 < this._lines.length; ++s2) {
      const r2 = this._lines[s2], h2 = this._getLineXOffset(s2), o2 = 5, a2 = 0.1;
      for (let s3 = 0; s3 < o2; s3++) {
        const d2 = 1 - (o2 - 1) * a2 + s3 * a2;
        t2.lineWidth = this._toRenderUnit(d2 * n2), this._strokeText(t2, r2, e2 + h2, i2);
      }
      i2 += this._lineSpacing;
    }
  }
  _setFontProperties(t2, e2) {
    t2.font = this._parameters.fontString(e2), t2.textAlign = "left", t2.textBaseline = "alphabetic";
  }
  _ensureTextWidth() {
    if (r$d(this._displayWidth))
      return this._displayWidth;
    const t2 = o$3(a$3, l$5, l$5).getContext("2d");
    this._setFontProperties(t2, this._fontSize);
    let e2 = 2 * this._haloSize;
    const n2 = this._parameters.definition.font;
    n2.style !== "italic" && n2.style !== "oblique" && n2.weight !== "bold" && n2.weight !== "bolder" || (e2 += 0.3 * t2.measureText("A").width), this._textWidths.length = 0, this._lineWidths.length = 0;
    let s2 = 0;
    for (const i2 of this._lines) {
      const n3 = t2.measureText(i2).width, r2 = n3 + e2;
      this._textWidths.push(n3), this._lineWidths.push(r2), s2 = Math.max(s2, r2);
    }
    return this._displayWidth = s2, this._displayWidth;
  }
  _ensureHeightMetrics() {
    if (t$7(this._heightMetricsCached)) {
      const t2 = o$3(a$3, l$5, l$5).getContext("2d");
      this._setFontProperties(t2, this._fontSize);
      const e2 = t2.measureText(this.text + g$7), i2 = this._hasBackground ? t2.measureText(this._lines[0]) : e2, n2 = this._lines.length === 1 ? i2 : this._hasBackground ? t2.measureText(this._lines[this._lines.length - 1]) : e2, s2 = e2.actualBoundingBoxAscent + e2.actualBoundingBoxDescent;
      this._heightMetricsCached = { paddingTop: e2.actualBoundingBoxAscent - i2.actualBoundingBoxAscent, paddingBottom: e2.actualBoundingBoxDescent - n2.actualBoundingBoxDescent, lineHeight: s2, baselinePosition: e2.actualBoundingBoxAscent };
    }
    return this._heightMetricsCached;
  }
  _toRenderUnit(t2) {
    return t2 * this.renderPixelRatio;
  }
  _toRoundedRenderUnit(t2) {
    return Math.round(t2 * this.renderPixelRatio);
  }
  _fillText(t2, e2, i2, n2) {
    t2.fillText(e2, this._toRenderUnit(i2), this._toRenderUnit(n2));
  }
  _strokeText(t2, e2, i2, n2) {
    t2.strokeText(e2, this._toRenderUnit(i2), this._toRenderUnit(n2));
  }
  _drawLine(t2, e2, i2) {
    t2.beginPath(), t2.moveTo(this._toRoundedRenderUnit(e2[0]) + 0.5, this._toRoundedRenderUnit(e2[1]) + 0.5), t2.lineTo(this._toRoundedRenderUnit(i2[0]) + 0.5, this._toRoundedRenderUnit(i2[1]) + 0.5), t2.stroke();
  }
  _drawBox(t2, e2, i2) {
    const n2 = this._toRenderUnit(e2[0]), s2 = this._toRenderUnit(e2[1]), r2 = this._toRenderUnit(i2[0]), h2 = this._toRenderUnit(i2[1]), o2 = Math.floor(n2) + 0.5, a2 = Math.ceil(n2 + r2) - 0.5, d2 = Math.floor(s2) + 0.5, l2 = Math.ceil(s2 + h2) - 0.5;
    t2.beginPath(), t2.moveTo(o2, d2), t2.lineTo(a2, d2), t2.lineTo(a2, l2), t2.lineTo(o2, l2), t2.lineTo(o2, d2), t2.stroke();
  }
}
const r$8 = [];
{
  const t2 = 16;
  for (let e2 = 0; e2 < 360; e2 += 360 / t2)
    r$8.push([Math.cos(Math.PI * e2 / 180), Math.sin(Math.PI * e2 / 180)]);
}
var h$5;
function o$3(t2, e2, i2) {
  return t2.canvas || (t2.canvas = document.createElement("canvas")), t2.canvas.width = e2, t2.canvas.height = i2, t2.canvas;
}
!function(t2) {
  t2[t2.Left = 0] = "Left", t2[t2.Center = 1] = "Center", t2[t2.Right = 2] = "Right";
}(h$5 || (h$5 = {}));
const a$3 = { canvas: null }, d$8 = 0.2, l$5 = 512, _$9 = "rgb(255, 0, 255, 0.5)", g$7 = (() => {
  let t2 = "";
  for (let e2 = 32; e2 < 127; e2++)
    t2 += String.fromCharCode(e2);
  return t2;
})();
const r$7 = Object.freeze({ left: 0, center: 0.5, right: 1 }), o$2 = Object.freeze({ "bottom-left": r$i(0, 0), bottom: r$i(0.5, 0), "bottom-right": r$i(1, 0), left: r$i(0, 0.5), center: r$i(0.5, 0.5), right: r$i(1, 0.5), "top-left": r$i(0, 1), top: r$i(0.5, 1), "top-right": r$i(1, 1) });
function c$5(t2) {
  switch (t2) {
    case "left":
      return h$5.Left;
    case "right":
      return h$5.Right;
    default:
      return h$5.Center;
  }
}
function i$4(t2, e2) {
  switch (e2) {
    case "bottom":
      return t2 === "left" ? "bottom-left" : t2 === "right" ? "bottom-right" : "bottom";
    case "center":
      return t2;
    case "top":
      return t2 === "left" ? "top-left" : t2 === "right" ? "top-right" : "top";
  }
}
function f$5(t2) {
  return t2 === "middle" ? "center" : t2;
}
var S$6, y$8, h$4;
function x$8(e2) {
  return e2 != null;
}
function b$8(e2) {
  return typeof e2 == "number";
}
function C$7(e2) {
  return typeof e2 == "string";
}
function g$6(e2) {
  return e2 == null || C$7(e2);
}
function M$6(e2, o2) {
  e2 && e2.push(o2);
}
function V$2(e2, o2, t2, i2 = e$e()) {
  const n2 = e2 || 0, r2 = o2 || 0, s2 = t2 || 0;
  return n2 !== 0 && m$9(i2, i2, -n2 / 180 * Math.PI), r2 !== 0 && b$f(i2, i2, r2 / 180 * Math.PI), s2 !== 0 && l$l(i2, i2, s2 / 180 * Math.PI), i2;
}
function D$2(e2, o2, t2, i2, n2) {
  const r2 = e2.minSize, s2 = e2.maxSize;
  if (e2.expression)
    return M$6(n2, "Could not convert size info: expression not supported"), false;
  if (e2.useSymbolValue) {
    const e3 = i2.symbolSize[t2];
    return o2.minSize[t2] = e3, o2.maxSize[t2] = e3, o2.offset[t2] = o2.minSize[t2], o2.factor[t2] = 0, o2.type[t2] = S$6.DefinedSize, true;
  }
  if (x$8(e2.field))
    return x$8(e2.stops) ? e2.stops.length === 2 && b$8(e2.stops[0].size) && b$8(e2.stops[1].size) ? (T$2(e2.stops[0].size, e2.stops[1].size, e2.stops[0].value, e2.stops[1].value, o2, t2), o2.type[t2] = S$6.DefinedSize, true) : (M$6(n2, "Could not convert size info: stops only supported with 2 elements"), false) : b$8(r2) && b$8(s2) && x$8(e2.minDataValue) && x$8(e2.maxDataValue) ? (T$2(r2, s2, e2.minDataValue, e2.maxDataValue, o2, t2), o2.type[t2] = S$6.DefinedSize, true) : m$a[e2.valueUnit] != null ? (o2.minSize[t2] = -1 / 0, o2.maxSize[t2] = 1 / 0, o2.offset[t2] = 0, o2.factor[t2] = 1 / m$a[e2.valueUnit], o2.type[t2] = S$6.DefinedSize, true) : e2.valueUnit === "unknown" ? (M$6(n2, "Could not convert size info: proportional size not supported"), false) : (M$6(n2, "Could not convert size info: scale-dependent size not supported"), false);
  if (!x$8(e2.field)) {
    if (e2.stops && e2.stops[0] && b$8(e2.stops[0].size))
      return o2.minSize[t2] = e2.stops[0].size, o2.maxSize[t2] = e2.stops[0].size, o2.offset[t2] = o2.minSize[t2], o2.factor[t2] = 0, o2.type[t2] = S$6.DefinedSize, true;
    if (b$8(r2))
      return o2.minSize[t2] = r2, o2.maxSize[t2] = r2, o2.offset[t2] = r2, o2.factor[t2] = 0, o2.type[t2] = S$6.DefinedSize, true;
  }
  return M$6(n2, "Could not convert size info: unsupported variant of sizeInfo"), false;
}
function T$2(e2, o2, t2, i2, n2, r2) {
  const s2 = Math.abs(i2 - t2) > 0 ? (o2 - e2) / (i2 - t2) : 0;
  n2.minSize[r2] = s2 > 0 ? e2 : o2, n2.maxSize[r2] = s2 > 0 ? o2 : e2, n2.offset[r2] = e2 - t2 * s2, n2.factor[r2] = s2;
}
function U$2(e2, o2, t2, i2) {
  if (e2.normalizationField || e2.valueRepresentation)
    return M$6(i2, "Could not convert size info: unsupported property"), null;
  if (!g$6(e2.field))
    return M$6(i2, "Could not convert size info: field is not a string"), null;
  if (o2.size) {
    if (e2.field)
      if (o2.size.field) {
        if (e2.field !== o2.size.field)
          return M$6(i2, "Could not convert size info: multiple fields in use"), null;
      } else
        o2.size.field = e2.field;
  } else
    o2.size = { field: e2.field, minSize: [0, 0, 0], maxSize: [0, 0, 0], offset: [0, 0, 0], factor: [0, 0, 0], type: [S$6.Undefined, S$6.Undefined, S$6.Undefined] };
  let n2;
  switch (e2.axis) {
    case "width":
      return n2 = D$2(e2, o2.size, 0, t2, i2), n2 ? o2 : null;
    case "height":
      return n2 = D$2(e2, o2.size, 2, t2, i2), n2 ? o2 : null;
    case "depth":
      return n2 = D$2(e2, o2.size, 1, t2, i2), n2 ? o2 : null;
    case "width-and-depth":
      return n2 = D$2(e2, o2.size, 0, t2, i2), n2 && D$2(e2, o2.size, 1, t2, i2), n2 ? o2 : null;
    case null:
    case void 0:
    case "all":
      return n2 = D$2(e2, o2.size, 0, t2, i2), n2 = n2 && D$2(e2, o2.size, 1, t2, i2), n2 = n2 && D$2(e2, o2.size, 2, t2, i2), n2 ? o2 : null;
    default:
      return M$6(i2, `Could not convert size info: unknown axis "${e2.axis}""`), null;
  }
}
function E$6(e2, o2, t2) {
  for (let n2 = 0; n2 < 3; ++n2) {
    let t3 = o2.unitInMeters;
    e2.type[n2] === S$6.DefinedSize && (t3 *= o2.modelSize[n2], e2.type[n2] = S$6.DefinedScale), e2.minSize[n2] = e2.minSize[n2] / t3, e2.maxSize[n2] = e2.maxSize[n2] / t3, e2.offset[n2] = e2.offset[n2] / t3, e2.factor[n2] = e2.factor[n2] / t3;
  }
  let i2;
  if (e2.type[0] !== S$6.Undefined)
    i2 = 0;
  else if (e2.type[1] !== S$6.Undefined)
    i2 = 1;
  else {
    if (e2.type[2] === S$6.Undefined)
      return M$6(t2, "No size axis contains a valid size or scale"), false;
    i2 = 2;
  }
  for (let n2 = 0; n2 < 3; ++n2)
    e2.type[n2] === S$6.Undefined && (e2.minSize[n2] = e2.minSize[i2], e2.maxSize[n2] = e2.maxSize[i2], e2.offset[n2] = e2.offset[i2], e2.factor[n2] = e2.factor[i2], e2.type[n2] = e2.type[i2]);
  return true;
}
function O$4(e2, o2, t2) {
  e2[4 * o2 + 0] = t2.r / 255, e2[4 * o2 + 1] = t2.g / 255, e2[4 * o2 + 2] = t2.b / 255, e2[4 * o2 + 3] = t2.a;
}
function j$4(e2, o2, t2) {
  if (e2.normalizationField)
    return M$6(t2, "Could not convert color info: unsupported property"), null;
  if (C$7(e2.field)) {
    if (!e2.stops)
      return M$6(t2, "Could not convert color info: missing stops or colors"), null;
    {
      if (e2.stops.length > 8)
        return M$6(t2, "Could not convert color info: too many color stops"), null;
      o2.color = { field: e2.field, values: [0, 0, 0, 0, 0, 0, 0, 0], colors: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] };
      const i2 = e2.stops;
      for (let e3 = 0; e3 < 8; ++e3) {
        const t3 = i2[Math.min(e3, i2.length - 1)];
        o2.color.values[e3] = t3.value, O$4(o2.color.colors, e3, t3.color);
      }
    }
  } else {
    if (!(e2.stops && e2.stops.length >= 0))
      return M$6(t2, "Could not convert color info: no field and no colors/stops"), null;
    {
      const t3 = e2.stops && e2.stops.length >= 0 && e2.stops[0].color;
      o2.color = { field: null, values: [0, 0, 0, 0, 0, 0, 0, 0], colors: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] };
      for (let e3 = 0; e3 < 8; e3++)
        o2.color.values[e3] = 1 / 0, O$4(o2.color.colors, e3, t3);
    }
  }
  return o2;
}
function k$6(e2, o2, t2) {
  if (e2.normalizationField)
    return M$6(t2, "Could not convert opacity info: unsupported property"), null;
  if (C$7(e2.field)) {
    if (!e2.stops)
      return M$6(t2, "Could not convert opacity info: missing stops or opacities"), null;
    {
      if (e2.stops.length > 8)
        return M$6(t2, "Could not convert opacity info: too many opacity stops"), null;
      o2.opacity = { field: e2.field, values: [0, 0, 0, 0, 0, 0, 0, 0], opacityValues: [0, 0, 0, 0, 0, 0, 0, 0] };
      const i2 = e2.stops;
      for (let e3 = 0; e3 < 8; ++e3) {
        const t3 = i2[Math.min(e3, i2.length - 1)];
        o2.opacity.values[e3] = t3.value, o2.opacity.opacityValues[e3] = t3.opacity;
      }
    }
  } else {
    if (!(e2.stops && e2.stops.length >= 0))
      return M$6(t2, "Could not convert opacity info: no field and no opacities/stops"), null;
    {
      const t3 = e2.stops && e2.stops.length >= 0 && e2.stops[0].opacity;
      o2.opacity = { field: null, values: [0, 0, 0, 0, 0, 0, 0, 0], opacityValues: [0, 0, 0, 0, 0, 0, 0, 0] };
      for (let e3 = 0; e3 < 8; e3++)
        o2.opacity.values[e3] = 1 / 0, o2.opacity.opacityValues[e3] = t3;
    }
  }
  return o2;
}
function w$6(e2, o2, t2) {
  const i2 = t2 === 2 && e2.rotationType === "arithmetic";
  o2.offset[t2] = i2 ? 90 : 0, o2.factor[t2] = i2 ? -1 : 1, o2.type[t2] = 1;
}
function F$6(e2, o2, t2) {
  if (!C$7(e2.field))
    return M$6(t2, "Could not convert rotation info: field is not a string"), null;
  if (o2.rotation) {
    if (e2.field)
      if (o2.rotation.field) {
        if (e2.field !== o2.rotation.field)
          return M$6(t2, "Could not convert rotation info: multiple fields in use"), null;
      } else
        o2.rotation.field = e2.field;
  } else
    o2.rotation = { field: e2.field, offset: [0, 0, 0], factor: [1, 1, 1], type: [0, 0, 0] };
  switch (e2.axis) {
    case "tilt":
      return w$6(e2, o2.rotation, 0), o2;
    case "roll":
      return w$6(e2, o2.rotation, 1), o2;
    case null:
    case void 0:
    case "heading":
      return w$6(e2, o2.rotation, 2), o2;
    default:
      return M$6(t2, `Could not convert rotation info: unknown axis "${e2.axis}""`), null;
  }
}
function A$3(e2, o2, t2) {
  if (!e2)
    return null;
  const i2 = !o2.supportedTypes || !!o2.supportedTypes.size, n2 = !o2.supportedTypes || !!o2.supportedTypes.color, r2 = !o2.supportedTypes || !!o2.supportedTypes.rotation, s2 = !!o2.supportedTypes && !!o2.supportedTypes.opacity, l2 = e2.reduce((e3, l3) => {
    if (!e3)
      return e3;
    if (l3.valueExpression)
      return M$6(t2, "Could not convert visual variables: arcade expressions not supported"), null;
    switch (l3.type) {
      case "size":
        return i2 ? U$2(l3, e3, o2, t2) : e3;
      case "color":
        return n2 ? j$4(l3, e3, t2) : e3;
      case "opacity":
        return s2 ? k$6(l3, e3, t2) : null;
      case "rotation":
        return r2 ? F$6(l3, e3, t2) : e3;
      default:
        return null;
    }
  }, { size: null, color: null, opacity: null, rotation: null });
  return !(e2.length > 0 && l2) || l2.size || l2.color || l2.opacity || l2.rotation ? l2 && l2.size && !E$6(l2.size, o2, t2) ? null : l2 : null;
}
function I$4(e2) {
  return e2 && e2.size != null;
}
function P$4(e2, o2) {
  if (!e2)
    return { enabled: false };
  if (t$9.TESTS_DISABLE_FAST_UPDATES)
    return { enabled: false };
  const t2 = A$3(e2.visualVariables, o2);
  return t2 ? { enabled: true, visualVariables: t2, materialParameters: q$5(t2, o2), requiresShaderTransformation: I$4(t2) } : { enabled: false };
}
function R$6(e2, o2, t2) {
  if (!o2 || !e2.enabled)
    return false;
  const i2 = e2.visualVariables, n2 = A$3(o2.visualVariables, t2);
  return !!n2 && (!!(_$8(i2.size, n2.size, "size") && _$8(i2.color, n2.color, "color") && _$8(i2.rotation, n2.rotation, "rotation") && _$8(i2.opacity, n2.opacity, "opacity")) && (e2.visualVariables = n2, e2.materialParameters = q$5(n2, t2), e2.requiresShaderTransformation = I$4(n2), true));
}
function _$8(e2, o2, t2) {
  if (!!e2 != !!o2)
    return false;
  if (e2 && e2.field !== o2.field)
    return false;
  if (e2 && t2 === "rotation") {
    const t3 = e2, i2 = o2;
    for (let e3 = 0; e3 < 3; e3++)
      if (t3.type[e3] !== i2.type[e3] || t3.offset[e3] !== i2.offset[e3] || t3.factor[e3] !== i2.factor[e3])
        return false;
  }
  return true;
}
function q$5(e2, n2) {
  const r2 = { vvSizeEnabled: false, vvSizeMinSize: null, vvSizeMaxSize: null, vvSizeOffset: null, vvSizeFactor: null, vvSizeValue: null, vvColorEnabled: false, vvColorValues: null, vvColorColors: null, vvOpacityEnabled: false, vvOpacityValues: null, vvOpacityOpacities: null, vvSymbolAnchor: null, vvSymbolRotationMatrix: null }, s2 = I$4(e2);
  return e2 && e2.size ? (r2.vvSizeEnabled = true, r2.vvSizeMinSize = e2.size.minSize, r2.vvSizeMaxSize = e2.size.maxSize, r2.vvSizeOffset = e2.size.offset, r2.vvSizeFactor = e2.size.factor) : e2 && s2 && (r2.vvSizeValue = n2.transformation.scale), e2 && s2 && (r2.vvSymbolAnchor = n2.transformation.anchor, r2.vvSymbolRotationMatrix = e$o(), r$j($$1), V$2(n2.transformation.rotation[2], n2.transformation.rotation[0], n2.transformation.rotation[1], $$1), a$h(r2.vvSymbolRotationMatrix, $$1)), e2 && e2.color && (r2.vvColorEnabled = true, r2.vvColorValues = e2.color.values, r2.vvColorColors = e2.color.colors), e2 && e2.opacity && (r2.vvOpacityEnabled = true, r2.vvOpacityValues = e2.opacity.values, r2.vvOpacityOpacities = e2.opacity.opacityValues), r2;
}
!function(e2) {
  e2[e2.Undefined = 0] = "Undefined", e2[e2.DefinedSize = 1] = "DefinedSize", e2[e2.DefinedScale = 2] = "DefinedScale";
}(S$6 || (S$6 = {})), function(e2) {
  e2[e2.Undefined = 0] = "Undefined", e2[e2.DefinedAngle = 1] = "DefinedAngle";
}(y$8 || (y$8 = {})), function(o2) {
  const t2 = e$e(), i2 = n$h();
  function u2(o3, u3, f3) {
    if (!o3.vvSizeEnabled)
      return f3;
    n$g(t2, f3);
    const c2 = o3.vvSymbolRotationMatrix;
    s$e($$1, c2[0], c2[1], c2[2], 0, c2[3], c2[4], c2[5], 0, c2[6], c2[7], c2[8], 0, 0, 0, 0, 1), u$p(t2, t2, $$1);
    for (let t3 = 0; t3 < 3; ++t3) {
      const n2 = o3.vvSizeOffset[t3] + u3[0] * o3.vvSizeFactor[t3];
      i2[t3] = a$g(n2, o3.vvSizeMinSize[t3], o3.vvSizeMaxSize[t3]);
    }
    return i$d(t2, t2, i2), c$l(t2, t2, o3.vvSymbolAnchor), t2;
  }
  function f2(o3, t3, i3) {
    if (!t3.vvSizeEnabled)
      return o$7(o3, 1, 1, 1);
    for (let n2 = 0; n2 < 3; ++n2) {
      const r2 = t3.vvSizeOffset[n2] + i3[0] * t3.vvSizeFactor[n2];
      o3[n2] = a$g(r2, t3.vvSizeMinSize[n2], t3.vvSizeMaxSize[n2]);
    }
    return o3;
  }
  o2.evaluateModelTransform = u2, o2.evaluateModelTransformScale = f2;
}(h$4 || (h$4 = {}));
const $$1 = e$e(), B$3 = h$4.evaluateModelTransform, L$2 = h$4.evaluateModelTransformScale;
const se$1 = e$e(), ae$1 = r$k(0, 0, 1), oe$1 = 16, ne$1 = 1.5, le$1 = a$j, ce$1 = [le$1 / 2, le$1 / 2, 1 - le$1 / 2, 1 - le$1 / 2], he$2 = [e$p * le$1, e$p * le$1];
class me$3 extends y$9 {
  constructor(e2, t2, r2, i2) {
    super(e2, t2, r2, i2), this._cimLayers = null, this._cimSymbolMaterials = new Map(), this._cimSymbolTextures = new Map(), this._cimMaterialParametersInfo = null, this._cimRequiredFields = null, this._cimScaleFactorOrFunction = null, this._size = null, this._symbolTextureRatio = 1, this._outlineSize = 0, this._elevationOptions = { supportsOffsetAdjustment: true, supportsOnTheGround: true };
  }
  getCachedSize() {
    return { size: this._getIconSize() };
  }
  async doLoad(e2) {
    this._validateOrThrow();
    const t2 = this._prepareMaterialParameters(), r2 = this._getPrimitive();
    if (r$d(r2))
      this._prepareResourcesPrimitive(t2, r2);
    else {
      const r3 = g$f(this.symbol, this.symbolLayer), i2 = nt$2(r3);
      i2 && i2.mediaType === "application/json" ? await this._prepareResourcesCIM(t2, JSON.parse(i2.data), e2) : await this._prepareResourcesHref(t2, r3, e2);
    }
  }
  _validateOrThrow() {
    if (this._drivenProperties.size)
      return;
    const e2 = S$f(this._getIconSize());
    if (e2)
      throw new s$d("graphics3diconsymbollayer:invalid-size", e2);
  }
  _getIconSize() {
    const e2 = this.symbolLayer, t2 = Math.round(e2.size != null ? u$n(e2.size) : oe$1);
    return this._drivenProperties.size ? Math.max(t2, 64) : t2;
  }
  _generateTextureCIM(e2) {
    const t2 = this._getGraphicHash(e2);
    let r2 = t2 === "" ? null : this._cimSymbolTextures.get(t2);
    if (!r2) {
      const i2 = { scaleFactor: this._cimScaleFactorOrFunction }, s2 = this._context.sharedResources.cimSymbolRasterizer.rasterizeCIMSymbol3D(this._cimLayers, e2, "esriGeometryPoint", i2, null, null);
      this._cimMaterialParametersInfo.anchorPosition = this._getAnchorPos("relative", s2.anchorPosition);
      const a2 = { width: s2.imageData.width, height: s2.imageData.height, powerOfTwoResizeMode: c$m.PAD };
      r2 = new L$6(s2.imageData, a2), this._cimSymbolTextures.set(t2, r2), this._context.stage.add(r2);
    }
    return r2;
  }
  _computeSize(e2, t2) {
    const r2 = e2.width / e2.height;
    return r2 > 1 ? [t2, Math.round(t2 / r2)] : [Math.round(t2 * r2), t2];
  }
  _prepareMaterialParameters() {
    const e2 = { anchorPosition: this._getAnchorPos(this.symbolLayer.anchor, this.symbolLayer.anchorPosition) }, t2 = this.symbol;
    if (ue$2(t2)) {
      const { screenLength: r2, minWorldLength: s2, maxWorldLength: a2 } = t2.verticalOffset;
      e2.verticalOffset = { screenLength: u$n(r2), minWorldLength: s2 || 0, maxWorldLength: r$d(a2) ? a2 : 1 / 0 };
    }
    return this._context.screenSizePerspectiveEnabled && (e2.screenSizePerspective = this._context.sharedResources.screenSizePerspectiveSettings), e2.occlusionTest = true, e2.hasSlicePlane = this._context.slicePlaneEnabled, e2;
  }
  _prepareResourcesPrimitive(e2, t2) {
    const r2 = this._getOutlineSize();
    if (de$2(t2) && r2 === 0)
      throw new Error("Nothing to render");
    if (this._outlineSize = r2, e2.color = this._getFillColor(), e2.outlineColor = this._getOutlineColor(), e2.outlineSize = this._outlineSize, r$d(this._context.sharedResources.textures)) {
      const r3 = this._context.sharedResources.textures.fromData(`${t2}-icon`, () => o$d(t2));
      this._texture = r3.texture, this._releaseTexture = r3, e2.textureId = this._texture.id;
    }
    e2.textureIsSignedDistanceField = true, e2.distanceFieldBoundingBox = ce$1;
    const s2 = this._getIconSize();
    this._size = [s2, s2], this._symbolTextureRatio = 1 / le$1, this._createMaterialAndAddToStage(e2, this._context.stage);
  }
  async _prepareResourcesHref(e2, s2, a2) {
    if (!has("esri-canvas-svg-support") && It(s2)) {
      throw new s$d("graphics3diconsymbollayer:unsupported-image-format", "IconSymbol3DLayer failed to load (SVG symbols are not supported in IE11)");
    }
    this._outlineSize = this._getOutlineSize(), e2.color = this._getFillColor(), e2.outlineColor = this._getOutlineColor(), e2.outlineSize = this._outlineSize, e2.textureIsSignedDistanceField = false;
    const o2 = this._getIconSize(), n2 = o2 * this._context.graphicsCoreOwner.view.state.pixelRatio;
    if (r$d(this._context.sharedResources.textures)) {
      const i2 = await b$g(this._context.sharedResources.textures.fromUrl(s2, n2, { signal: a2 }));
      if (i2.ok === false) {
        w$a(i2.error);
        throw new s$d("graphics3diconsymbollayer:request-failed", `Failed to load (Request for icon resource failed: ${s2})`);
      }
      this._releaseTexture = i2.value;
      const l2 = i2.value.texture, h2 = l2.params;
      this._size = this._computeSize(h2, o2), e2.textureId = l2.id;
    }
    this._createMaterialAndAddToStage(e2, this._context.stage);
  }
  async _prepareResourcesCIM(e2, t2, r2) {
    const i2 = new d$j({ data: t2 });
    if (!this._context.sharedResources.cimSymbolRasterizer) {
      const e3 = (await import("./CIMSymbolRasterizer.js")).CIMSymbolRasterizer;
      f$a(r2), this._context.sharedResources.cimSymbolRasterizer || (this._context.sharedResources.cimSymbolRasterizer = new e3(this._context.renderCoordsHelper.spatialReference, true));
    }
    const s2 = this._context.layer.fields ? this._context.layer.fields.map((e3) => e3.toJSON()) : null;
    let a2, o2;
    if (this._cimLayers = await this._context.sharedResources.cimSymbolRasterizer.analyzeCIMSymbol(i2, s2, this._context.renderer && this._context.renderer.type === "dictionary" ? this._context.renderer.fieldMap : null, "esriGeometryPoint", { signal: r2 }), this._context.renderer && this._context.renderer.type === "dictionary" && this._context.renderer.scaleExpression) {
      const e3 = this._context.renderer;
      if (isNaN(e3.scaleExpression)) {
        const t3 = e3.scaleExpression, r3 = await o$e(t3, this._context.layer.spatialReference, s2);
        o2 = (e4, t4, i3) => {
          const s3 = i$e(r3, e4, { $view: i3 }, "esriGeometryPoint", t4);
          return s3 !== null ? s3 : 1;
        };
      } else
        a2 = Number(e3.scaleExpression);
    }
    this._cimScaleFactorOrFunction = a2 || o2 || 1;
    const n2 = this._context.renderer ? await this._context.renderer.getRequiredFields(this._context.layer.fieldsIndex) : [];
    f$a(r2);
    const l2 = this._context.layer.fieldsIndex;
    this._cimRequiredFields = n2.map((e3) => l2.get(e3).name), this._cimMaterialParametersInfo = e2, this._cimMaterialParametersInfo.color = this._getFillColor(), this._cimMaterialParametersInfo.outlineColor = [0, 0, 0, 0], this._cimMaterialParametersInfo.outlineSize = 0, this._cimMaterialParametersInfo.textureIsSignedDistanceField = false;
  }
  _getPrimitive() {
    return this.symbolLayer.resource && this.symbolLayer.resource.href ? null : this.symbolLayer.resource && this.symbolLayer.resource.primitive || j$8;
  }
  _getOutlineSize() {
    let e2 = 0;
    const t2 = this.symbolLayer;
    if (r$d(t2.outline) && t2.outline.size != null)
      return Math.max(u$n(t2.outline.size), 0);
    return e2 = de$2(this._getPrimitive()) ? ne$1 : 0, Math.max(e2, 0);
  }
  _getOutlineColor() {
    const t2 = this._getLayerOpacity(), r2 = this.symbolLayer, a2 = q$7(r2, "outline", "color");
    if (r$d(a2)) {
      const r3 = l$c.toUnitRGB(a2), i2 = a2.a * t2;
      return [r3[0], r3[1], r3[2], i2];
    }
    return [0, 0, 0, 0];
  }
  _getFillColor() {
    if (de$2(this._getPrimitive()))
      return c$b;
    const e2 = t$7(this._getPrimitive()), t2 = q$7(this.symbolLayer, "material", "color");
    return this._getCombinedOpacityAndColor(t2, { hasIntrinsicColor: e2 });
  }
  _getAnchorPos(e2, t2) {
    return e2 === "relative" ? r$i((t2.x || 0) + 0.5, 0.5 - (t2.y || 0)) : e2 in o$2 ? o$2[e2] : o$2.center;
  }
  _createMaterialAndAddToStage(e2, t2) {
    if (this._cimLayers ? this._fastUpdates = { enabled: false } : this._fastUpdates = P$4(this._context.renderer, this._fastVisualVariableConvertOptions()), this._fastUpdates.enabled && Object.assign(e2, this._fastUpdates.materialParameters), this._cimLayers) {
      let r2 = r$d(e2.textureId) ? this._cimSymbolMaterials.get(e2.textureId) : null;
      return r2 || (r2 = new Q$1(e2), this._cimSymbolMaterials.set(i$a(e2.textureId, 0), r2), t2.add(r2)), r2;
    }
    return this._material = new Q$1(e2), t2.add(this._material), this._material;
  }
  _setDrapingDependentMaterialParameters() {
    this.draped && (this._forEachMaterial((e2) => {
      e2.setParameters({ verticalOffset: null, screenSizePerspective: null, occlusionTest: false, hasSlicePlane: false, shaderPolygonOffset: 0, isDraped: this.draped });
    }), this.layerOpacityChanged());
  }
  destroy() {
    super.destroy(), this._forEachMaterial((e2) => this._context.stage.remove(e2)), this._material = null, this._cimSymbolMaterials.clear(), this._cimSymbolTextures.forEach((e2) => this._context.stage.remove(e2)), this._cimSymbolTextures.clear(), this._releaseTexture = w$b(this._releaseTexture);
  }
  _getScaleFactor(e2, t2) {
    if (this._drivenProperties.size && e2.size) {
      for (let t3 = 0; t3 < 3; t3++) {
        const r2 = e2.size[t3];
        r2 && r2 !== "symbol-value" && r2 !== "proportional" && (e2.size[t3] = u$n(r2));
      }
      if (e2.size[0] === "symbol-value")
        return 1;
      if (isFinite(+e2.size[0]))
        return +e2.size[0] / t2;
      if (isFinite(+e2.size[2]))
        return +e2.size[2] / t2;
    }
    return 1;
  }
  createGraphics3DGraphic(e2) {
    const t2 = e2.graphic;
    if (!this._validateGeometry(t2.geometry))
      return null;
    let r2, i2;
    if (this._cimLayers) {
      if (!this._cimLayers.length)
        return null;
      const e3 = this._generateTextureCIM(t2), s3 = __spreadValues({ textureId: e3.id }, this._cimMaterialParametersInfo);
      i2 = this._createMaterialAndAddToStage(s3, this._context.stage), r2 = [e3.params.width, e3.params.height];
    } else
      r2 = this._size, i2 = e$f(this._material);
    const s2 = d$9(t2.geometry);
    if (t$7(s2))
      return this.logger.warn(`unsupported geometry type for icon symbol: ${t2.geometry.type}`), null;
    const o2 = e2.renderingInfo, n2 = this._getVertexOpacityAndColor(o2);
    let c2 = 1;
    if (!this._fastUpdates.enabled || !this._fastUpdates.visualVariables.size) {
      const e3 = r2[0] > r2[1] ? r2[0] : r2[1];
      c2 = this._getScaleFactor(o2, e3);
    }
    c2 *= this._symbolTextureRatio;
    const h2 = [r2[0] * c2, r2[1] * c2], m2 = this.setGraphicElevationContext(t2, new h$8());
    return this.ensureDrapedStatus(m2.mode === "on-the-ground") && this._setDrapingDependentMaterialParameters(), this.draped ? this._createAsOverlay(t2, s2, i2, n2, h2, e2.layer.uid) : this._createAs3DShape(t2, s2, i2, n2, h2, m2, t2.uid);
  }
  layerOpacityChanged() {
    const e2 = this._getFillColor(), t2 = this._getOutlineColor();
    this._forEachMaterial((r2) => {
      r2.setParameters({ color: e2 }), r2.setParameters({ outlineColor: t2 });
    });
  }
  layerElevationInfoChanged(e2, t2, r2) {
    const i2 = this._elevationContext.mode, s2 = p$c(me$3.elevationModeChangeTypes, r2, i2);
    if (s2 !== x$b.UPDATE)
      return s2;
    const a2 = g$c(i2) || i2 === "absolute-height";
    return this.updateGraphics3DGraphicElevationInfo(e2, t2, () => a2);
  }
  slicePlaneEnabledChanged() {
    return this.draped || this._forEachMaterial((e2) => {
      e2.setParameters({ hasSlicePlane: this._context.slicePlaneEnabled });
    }), true;
  }
  physicalBasedRenderingChanged() {
    return true;
  }
  pixelRatioChanged() {
    return !!this._getPrimitive();
  }
  applyRendererDiff(e2, t2) {
    for (const r2 in e2.diff) {
      if (r2 !== "visualVariables")
        return e$a.Recreate_Symbol;
      if (!R$6(this._fastUpdates, t2, this._fastVisualVariableConvertOptions()))
        return e$a.Recreate_Symbol;
      r$d(this._material) && this._material.setParameters(this._fastUpdates.materialParameters);
    }
    return e$a.Fast_Update;
  }
  _defaultElevationInfoNoZ() {
    return _e$3;
  }
  _createAs3DShape(e2, t2, r2, i2, s2, a2, o2) {
    const n2 = this.getFastUpdateAttrValues(e2), l2 = n2 ? (e3) => B$3(this._fastUpdates.materialParameters, n2, e3) : null, c2 = this._context.stage.renderView._getObjectAndLayerIdColor({ graphicUid: o2, layerUid: this._context.layer.uid }), h2 = [b$h(ae$1, null, i2, s2, pe$2, null, n2, c2)], m2 = u$9(this._context, t2, h2, [r2], a2, this._context.layer.uid, o2, l2);
    if (m2 === null)
      return null;
    const u2 = new _$b(this, m2.object, h2, null, null, d$b, a2);
    return u2.alignedSampledElevation = m2.sampledElevation, u2.needsElevationUpdates = g$c(a2.mode) || a2.mode === "absolute-height", u2.getScreenSize = this._createScreenSizeGetter(s2, l2), u2.calculateRelativeScreenBounds = (e3) => r2.calculateRelativeScreenBounds(u2.getScreenSize(), 1, e3), f$7(u2, t2, this._context.elevationProvider), u2;
  }
  _createAsOverlay(e2, t2, r2, s2, a2, o2) {
    r2.renderPriority = this._renderPriority;
    const n2 = n$m();
    gn(t2, n2, this._context.overlaySR), n2[2] = ue$4;
    const l2 = this._context.clippingExtent;
    if (r$d(l2) && !E$c(l2, n2))
      return null;
    const c2 = this.getFastUpdateAttrValues(e2), h2 = c2 ? (e3) => B$3(this._fastUpdates.materialParameters, c2, e3) : null, m2 = this._context.stage.renderView._getObjectAndLayerIdColor({ graphicUid: e2.uid, layerUid: this._context.layer.uid }), u2 = b$h(ae$1, n2, s2, a2, null, null, c2, m2), d2 = new T$6(u2, r2, { layerUid: o2, graphicUid: e2.uid, calculateShaderTransformation: h2 });
    n2[3] = 0, a$i(d2.boundingSphere, n2);
    const _2 = new l$6(this, [d2], null, this._context.drapeSourceRenderer);
    return _2.getScreenSize = this._createScreenSizeGetter(a2, h2), _2.calculateRelativeScreenBounds = (e3) => r2.calculateRelativeScreenBounds(_2.getScreenSize(), 1, e3), _2;
  }
  _createScreenSizeGetter(e2, t2) {
    const r2 = this._outlineSize + 2;
    if (this._fastUpdates.enabled) {
      const i2 = e2[0] / this._symbolTextureRatio, s2 = e2[1] / this._symbolTextureRatio;
      return (e3 = n$k()) => {
        const a2 = t2(se$1);
        return e3[0] = a2[0] * i2 + r2, e3[1] = a2[5] * s2 + r2, e3;
      };
    }
    {
      const t3 = e2[0] / this._symbolTextureRatio + r2, i2 = e2[1] / this._symbolTextureRatio + r2;
      return (e3 = n$k()) => (e3[0] = t3, e3[1] = i2, e3);
    }
  }
  _fastVisualVariableConvertOptions() {
    const e2 = this._size[0] > this._size[1] ? this._size[0] : this._size[1], t2 = r$k(e2, e2, e2), r2 = e$q(1), i2 = e2 * r2;
    return { modelSize: t2, symbolSize: r$k(i2, i2, i2), unitInMeters: r2, transformation: { anchor: f$h, scale: l$e, rotation: f$h } };
  }
  _getGraphicHash(e2) {
    let t2 = "";
    for (const r2 of this._cimRequiredFields)
      t2 += r2 + e2.attributes[r2];
    return t2;
  }
  _forEachMaterial(e2) {
    r$d(this._material) && e2(this._material), this._cimSymbolMaterials.forEach(e2);
  }
  test() {
    return __spreadProps(__spreadValues({}, super.test()), { material: this._material });
  }
}
function ue$2(e2) {
  return e2 && e2.type === "point-3d" && e2.hasVisibleVerticalOffset();
}
function de$2(e2) {
  return !t$7(e2) && (e2 === "cross" || e2 === "x");
}
me$3.PRIMITIVE_SIZE = he$2, me$3.elevationModeChangeTypes = { definedChanged: x$b.UPDATE, staysOnTheGround: x$b.NONE, onTheGroundChanged: x$b.RECREATE };
const _e$3 = { mode: "relative-to-ground", offset: 0 }, pe$2 = r$f(0, 0, 0, 1);
function n$6(n2) {
  switch (n2) {
    case "butt":
      return r$l.BUTT;
    case "square":
      return r$l.SQUARE;
    case "round":
      return r$l.ROUND;
    default:
      return null;
  }
}
function r$6(e2) {
  return e2 === "diamond" ? "kite" : e2;
}
function C$6(C2) {
  const M2 = new o$9(), D2 = C2.hasMultipassTerrain && (C2.output === h$b.Color || C2.output === h$b.Alpha), k2 = C2.space === p$d.World;
  C2.hasTip && k2 && M2.extensions.add("GL_OES_standard_derivatives"), M2.include(s$f, C2), M2.include(i$f, C2), C2.output === h$b.Depth && M2.include(o$f, C2);
  const { vertex: N2, fragment: T2 } = M2;
  return T2.include(a$k), v$f(N2, C2), M2.attributes.add(O$8.POSITION, "vec3"), M2.attributes.add(O$8.UV0, "vec2"), M2.attributes.add(O$8.AUXPOS1, "vec3"), M2.varyings.add("vColor", "vec4"), M2.varyings.add("vpos", "vec3"), M2.varyings.add("vUV", "vec2"), M2.varyings.add("vSize", "float"), t$h(M2), D2 && M2.varyings.add("depth", "float"), C2.hasTip && M2.varyings.add("vLineWidth", "float"), N2.uniforms.add([new e$h("nearFar", (e2, r2) => r2.camera.nearFar), new e$g("viewport", (e2, r2) => r2.camera.fullViewport)]), N2.code.add(n$j`vec4 projectAndScale(vec4 pos) {
vec4 posNdc = proj * pos;
posNdc.xy *= viewport.zw / posNdc.w;
return posNdc;
}`), N2.code.add(n$j`void clip(vec4 pos, inout vec4 prev) {
float vnp = nearFar[0] * 0.99;
if (prev.z > -nearFar[0]) {
float interpolation = (-vnp - pos.z) / (prev.z - pos.z);
prev = mix(pos, prev, interpolation);
}
}`), k2 ? (M2.attributes.add(O$8.NORMAL, "vec3"), d$k(N2), N2.constants.add("tiltThreshold", "float", 0.7), N2.code.add(n$j`vec3 perpendicular(vec3 v) {
vec3 n = (viewNormal * vec4(normal.xyz, 1.0)).xyz;
vec3 n2 = cross(v, n);
vec3 forward = vec3(0.0, 0.0, 1.0);
float tiltDot = dot(forward, n);
return abs(tiltDot) < tiltThreshold ? n : n2;
}`)) : N2.code.add(n$j`vec2 perpendicular(vec2 v) {
return vec2(v.y, -v.x);
}`), N2.code.add(n$j`
      #define vecN ${k2 ? "vec3" : "vec2"}

      vecN normalizedSegment(vecN pos, vecN prev) {
        vecN segment = pos - prev;
        float segmentLen = length(segment);

        // normalize or zero if too short
        return (segmentLen > 0.001) ? segment / segmentLen : ${k2 ? "vec3(0.0, 0.0, 0.0)" : "vec2(0.0, 0.0)"};
      }

      vecN displace(vecN pos, vecN prev, float displacementLen) {
        vecN segment = normalizedSegment(pos, prev);

        vecN displacementDirU = perpendicular(segment);
        vecN displacementDirV = segment;

        ${C2.anchor === s$g.Tip ? "pos -= 0.5 * displacementLen * displacementDirV;" : ""}

        return pos + displacementLen * (uv0.x * displacementDirU + uv0.y * displacementDirV);
      }
    `), C2.space === p$d.Screen && (N2.uniforms.add(new e$r("inverseProjectionMatrix", (e2, r2) => r2.camera.inverseProjectionMatrix)), N2.code.add(n$j`vec3 inverseProject(vec4 posScreen) {
posScreen.xy = (posScreen.xy / viewport.zw) * posScreen.w;
return (inverseProjectionMatrix * posScreen).xyz;
}`), N2.code.add(n$j`bool rayIntersectPlane(vec3 rayDir, vec3 planeOrigin, vec3 planeNormal, out vec3 intersection) {
float cos = dot(rayDir, planeNormal);
float t = dot(planeOrigin, planeNormal) / cos;
intersection = t * rayDir;
return abs(cos) > 0.001 && t > 0.0;
}`), N2.uniforms.add(new o$a("perScreenPixelRatio", (e2, r2) => r2.camera.perScreenPixelRatio)), N2.code.add(n$j`
      vec4 toFront(vec4 displacedPosScreen, vec3 posLeft, vec3 posRight, vec3 prev, float lineWidth) {
        // Project displaced position back to camera space
        vec3 displacedPos = inverseProject(displacedPosScreen);

        // Calculate the plane that we want the marker to lie in. Note that this will always be an approximation since ribbon lines are generally
        // not planar and we do not know the actual position of the displaced prev vertices (they are offset in screen space, too).
        vec3 planeNormal = normalize(cross(posLeft - posRight, posLeft - prev));
        vec3 planeOrigin = posLeft;

        ${C2.hasCap ? "\n                if(prev.z > posLeft.z) {\n                  vec2 diff = posLeft.xy - posRight.xy;\n                  planeOrigin.xy += perpendicular(diff) / 2.0;\n                }\n              " : ""};

        // Move the plane towards the camera by a margin dependent on the line width (approximated in world space). This tolerance corrects for the
        // non-planarity in most cases, but sharp joins can place the prev vertices at arbitrary positions so markers can still clip.
        float offset = lineWidth * perScreenPixelRatio;
        planeOrigin *= (1.0 - offset);

        // Intersect camera ray with the plane and make sure it is within clip space
        vec3 rayDir = normalize(displacedPos);
        vec3 intersection;
        if (rayIntersectPlane(rayDir, planeOrigin, planeNormal, intersection) && intersection.z < -nearFar[0] && intersection.z > -nearFar[1]) {
          return vec4(intersection.xyz, 1.0);
        }

        // Fallback: use depth of pos or prev, whichever is closer to the camera
        float minDepth = planeOrigin.z > prev.z ? length(planeOrigin) : length(prev);
        displacedPos *= minDepth / length(displacedPos);
        return vec4(displacedPos.xyz, 1.0);
      }
  `)), N2.uniforms.add(new o$a("pixelRatio", (e2, r2) => r2.camera.pixelRatio)), n$n(M2), N2.code.add(n$j`void main(void) {
if (uv0.y == 0.0) {
gl_Position = vec4(1e038, 1e038, 1e038, 1.0);
}
else {
float lineWidth = getLineWidth();
float screenMarkerSize = getScreenMarkerSize();
vec4 pos  = view * vec4(position.xyz, 1.0);
vec4 prev = view * vec4(auxpos1.xyz, 1.0);
clip(pos, prev);`), k2 ? (C2.hideOnShortSegments && N2.code.add(n$j`if (areWorldMarkersHidden(pos, prev)) {
gl_Position = vec4(1e038, 1e038, 1e038, 1.0);
return;
}`), N2.code.add(n$j`pos.xyz = displace(pos.xyz, prev.xyz, getWorldMarkerSize(pos));
vec4 displacedPosScreen = projectAndScale(pos);`)) : (N2.code.add(n$j`vec4 posScreen = projectAndScale(pos);
vec4 prevScreen = projectAndScale(prev);
vec4 displacedPosScreen = posScreen;
displacedPosScreen.xy = displace(posScreen.xy, prevScreen.xy, screenMarkerSize);`), C2.space === p$d.Screen && N2.code.add(n$j`vec2 displacementDirU = perpendicular(normalizedSegment(posScreen.xy, prevScreen.xy));
vec3 lineRight = inverseProject(posScreen + lineWidth * vec4(displacementDirU.xy, 0.0, 0.0));
vec3 lineLeft = pos.xyz + (pos.xyz - lineRight);
pos = toFront(displacedPosScreen, lineLeft, lineRight, prev.xyz, lineWidth);
displacedPosScreen = projectAndScale(pos);`)), N2.code.add(n$j`
        ${D2 ? "depth = pos.z;" : ""}
        linearDepth = calculateLinearDepth(nearFar,pos.z);

        // Convert back into NDC
        displacedPosScreen.xy = (displacedPosScreen.xy / viewport.zw) * displacedPosScreen.w;

        // Convert texture coordinate into [0,1]
        vUV = (uv0 + 1.0) / 2.0;

        ${k2 ? "" : "vUV *= displacedPosScreen.w;"}

        ${C2.hasTip ? "vLineWidth = lineWidth;" : ""}

        vSize = screenMarkerSize;
        vColor = getColor();

        // Use camera space for slicing
        vpos = pos.xyz;

        gl_Position = displacedPosScreen;
      }
    }
  `), D2 && M2.include(n$o, C2), M2.include(u$l, C2), T2.uniforms.add([new e$g("intrinsicColor", (e2) => e2.color), new f$i("tex", (e2) => e2.texture)]), T2.include(e$s), M2.constants.add("texelSize", "float", 1 / t$i), T2.code.add(n$j`float markerAlpha(vec2 samplePos) {
samplePos += vec2(0.5, -0.5) * texelSize;
float sdf = rgba2float(texture2D(tex, samplePos)) - 0.5;
float distance = sdf * vSize;
distance -= 0.5;
return clamp(0.5 - distance, 0.0, 1.0);
}`), C2.hasTip && (M2.constants.add("relativeMarkerSize", "float", o$g / t$i), M2.constants.add("relativeTipLineWidth", "float", e$t), T2.code.add(n$j`
    float tipAlpha(vec2 samplePos) {
      // Convert coordinates s.t. they are in pixels and relative to the tip of an arrow marker
      samplePos -= vec2(0.5, 0.5 + 0.5 * relativeMarkerSize);
      samplePos *= vSize;

      float halfMarkerSize = 0.5 * relativeMarkerSize * vSize;
      float halfTipLineWidth = 0.5 * max(1.0, relativeTipLineWidth * vLineWidth);

      ${k2 ? "halfTipLineWidth *= fwidth(samplePos.y);" : ""}

      float distance = max(abs(samplePos.x) - halfMarkerSize, abs(samplePos.y) - halfTipLineWidth);
      return clamp(0.5 - distance, 0.0, 1.0);
    }
  `)), M2.constants.add("symbolAlphaCutoff", "float", t$j), T2.code.add(n$j`
  void main() {
    discardBySlice(vpos);
    ${D2 ? "terrainDepthTest(gl_FragCoord, depth);" : ""}

    vec4 finalColor = intrinsicColor * vColor;

    ${k2 ? "vec2 samplePos = vUV;" : "vec2 samplePos = vUV * gl_FragCoord.w;"}

    ${C2.hasTip ? "finalColor.a *= max(markerAlpha(samplePos), tipAlpha(samplePos));" : "finalColor.a *= markerAlpha(samplePos);"}

    if (finalColor.a < symbolAlphaCutoff) {
      discard;
    }

    ${C2.output === h$b.Alpha ? n$j`gl_FragColor = vec4(finalColor.a);` : ""}
    ${C2.output === h$b.Color ? n$j`gl_FragColor = highlightSlice(finalColor, vpos);` : ""}
    ${C2.output === h$b.Color && C2.transparencyPassType === o$h.Color ? "gl_FragColor = premultiplyAlpha(gl_FragColor);" : ""}
    ${C2.output === h$b.Highlight ? n$j`gl_FragColor = vec4(1.0);` : ""}
    ${C2.output === h$b.Depth ? n$j`outputDepth(linearDepth);` : ""}
  }
  `), M2;
}
const M$5 = Object.freeze(Object.defineProperty({ __proto__: null, build: C$6 }, Symbol.toStringTag, { value: "Module" }));
const R$5 = new Map([[O$8.POSITION, 0], [O$8.UV0, 2], [O$8.AUXPOS1, 3], [O$8.NORMAL, 4], [O$8.COLOR, 5], [O$8.COLORFEATUREATTRIBUTE, 5], [O$8.SIZE, 6], [O$8.SIZEFEATUREATTRIBUTE, 6], [O$8.OPACITYFEATUREATTRIBUTE, 7]]);
class b$7 extends e$i {
  initializeProgram(e2) {
    return new o$b(e2.rctx, b$7.shader.get().build(this.configuration), R$5);
  }
  _makePipelineState(t2, i2) {
    const o2 = this.configuration, a2 = t2 === o$h.NONE;
    return W$3({ blending: o2.output === h$b.Color || o2.output === h$b.Alpha ? a2 ? c$n : A$8(t2) : null, depthTest: { func: l$m(t2) }, depthWrite: a2 ? o2.writeDepth && a$e : E$h(t2), colorWrite: _$c, stencilWrite: o2.hasOccludees ? e$u : null, stencilTest: o2.hasOccludees ? i2 ? o$i : f$j : null, polygonOffset: { factor: 0, units: -10 } });
  }
  initializePipeline() {
    return this.configuration.occluder && (this._occluderPipelineTransparent = W$3({ blending: c$n, depthTest: s$h, depthWrite: null, colorWrite: _$c, stencilWrite: null, stencilTest: m$b }), this._occluderPipelineOpaque = W$3({ blending: c$n, depthTest: s$h, depthWrite: null, colorWrite: _$c, stencilWrite: l$n, stencilTest: P$8 }), this._occluderPipelineMaskWrite = W$3({ blending: null, depthTest: i$g, depthWrite: null, colorWrite: null, stencilWrite: e$u, stencilTest: o$i })), this._occludeePipelineState = this._makePipelineState(this.configuration.transparencyPassType, true), this._makePipelineState(this.configuration.transparencyPassType, false);
  }
  getPipelineState(e2, t2) {
    return t2 ? this._occludeePipelineState : this.configuration.occluder ? e2 === E$e.TRANSPARENT_OCCLUDER_MATERIAL ? this._occluderPipelineTransparent : e2 === E$e.OCCLUDER_MATERIAL ? this._occluderPipelineOpaque : this._occluderPipelineMaskWrite : super.getPipelineState(e2, t2);
  }
}
b$7.shader = new t$b(M$5, () => import("./LineMarker.glsl.js"));
class v$6 extends d$h {
  constructor(e2) {
    super(e2, new S$5()), this._vertexAttributeLocations = R$5, this._configuration = new a$l(), this._layout = this.createLayout();
  }
  dispose() {
  }
  getConfiguration(e2, t2) {
    return this._configuration.output = e2, this._configuration.space = t2.slot === E$e.DRAPED_MATERIAL ? p$d.Draped : this.parameters.worldSpace ? p$d.World : p$d.Screen, this._configuration.hideOnShortSegments = this.parameters.hideOnShortSegments, this._configuration.hasCap = this.parameters.cap !== r$l.BUTT, this._configuration.anchor = this.parameters.anchor, this._configuration.hasTip = this.parameters.hasTip, this._configuration.hasSlicePlane = this.parameters.hasSlicePlane, this._configuration.hasOccludees = this.parameters.hasOccludees, this._configuration.writeDepth = this.parameters.writeDepth, this._configuration.vvColor = this.parameters.vvColorEnabled, this._configuration.vvOpacity = this.parameters.vvOpacityEnabled, this._configuration.vvSize = this.parameters.vvSizeEnabled, this._configuration.occluder = this.parameters.renderOccluded === o$c.OccludeAndTransparentStencil, this._configuration.transparencyPassType = t2.transparencyPassType, this._configuration.hasMultipassTerrain = t2.multipassTerrain.enabled, this._configuration.cullAboveGround = t2.multipassTerrain.cullAboveGround, this._configuration;
  }
  intersect() {
  }
  createLayout() {
    const e2 = T$4().vec3f(O$8.POSITION).vec2f(O$8.UV0).vec3f(O$8.AUXPOS1);
    return this.parameters.worldSpace && e2.vec3f(O$8.NORMAL), this.parameters.vvSizeEnabled ? e2.f32(O$8.SIZEFEATUREATTRIBUTE) : e2.f32(O$8.SIZE), this.parameters.vvColorEnabled ? e2.f32(O$8.COLORFEATUREATTRIBUTE) : e2.vec4f(O$8.COLOR), this.parameters.vvOpacityEnabled && e2.f32(O$8.OPACITYFEATUREATTRIBUTE), e2;
  }
  createBufferWriter() {
    return new O$3(this._layout, this.parameters);
  }
  requiresSlot(e2, t2) {
    if (t2 === h$b.Color || t2 === h$b.Alpha || t2 === h$b.Highlight || t2 === h$b.Depth) {
      if (e2 === E$e.DRAPED_MATERIAL)
        return true;
      if (this.parameters.renderOccluded === o$c.OccludeAndTransparentStencil)
        return e2 === E$e.OPAQUE_MATERIAL || e2 === E$e.OCCLUDER_MATERIAL || e2 === E$e.TRANSPARENT_OCCLUDER_MATERIAL;
      if (t2 === h$b.Color || t2 === h$b.Alpha) {
        return e2 === (this.parameters.writeDepth ? E$e.TRANSPARENT_MATERIAL : E$e.TRANSPARENT_DEPTH_WRITE_DISABLED_MATERIAL);
      }
      return e2 === E$e.OPAQUE_MATERIAL;
    }
    return false;
  }
  createGLMaterial(e2) {
    return new _$7(e2);
  }
}
class _$7 extends h$f {
  _updateParameters(e2) {
    return this.updateTexture(this._material.parameters.textureId), this._material.setParameters(this.textureBindParameters), this.ensureTechnique(b$7, e2);
  }
  _updateOccludeeState(e2) {
    e2.hasOccludees !== this._material.parameters.hasOccludees && this._material.setParameters({ hasOccludees: e2.hasOccludees });
  }
  beginSlot(e2) {
    return this._output !== h$b.Color && this._output !== h$b.Alpha || this._updateOccludeeState(e2), this._updateParameters(e2);
  }
}
class S$5 extends v$g {
  constructor() {
    super(...arguments), this.width = 0, this.color = [1, 1, 1, 1], this.placement = "end", this.cap = r$l.BUTT, this.anchor = s$g.Center, this.hasTip = false, this.worldSpace = false, this.hideOnShortSegments = false, this.writeDepth = true, this.hasSlicePlane = false, this.vvFastUpdate = false, this.hasOccludees = false;
  }
}
class O$3 {
  constructor(e2, t2) {
    this.vertexBufferLayout = e2, this._parameters = t2;
  }
  allocate(e2) {
    return this.vertexBufferLayout.createBuffer(e2);
  }
  elementCount() {
    return this._parameters.placement === "begin-end" ? 12 : 6;
  }
  write(s2, i2, n2, o2, h2) {
    const c2 = n2.vertexAttributes.get(O$8.POSITION).data, u2 = c2.length / 3;
    let p2 = [1, 0, 0];
    const m2 = n2.vertexAttributes.get(O$8.NORMAL);
    this._parameters.worldSpace && r$d(m2) && (p2 = m2.data);
    let d2 = 1, A2 = 0;
    this._parameters.vvSizeEnabled ? A2 = n2.vertexAttributes.get(O$8.SIZEFEATUREATTRIBUTE).data[0] : n2.vertexAttributes.has(O$8.SIZE) && (d2 = n2.vertexAttributes.get(O$8.SIZE).data[0]);
    let f2 = [1, 1, 1, 1], E2 = 0;
    this._parameters.vvColorEnabled ? E2 = n2.vertexAttributes.get(O$8.COLORFEATUREATTRIBUTE).data[0] : n2.vertexAttributes.has(O$8.COLOR) && (f2 = n2.vertexAttributes.get(O$8.COLOR).data);
    let T2 = 0;
    this._parameters.vvOpacityEnabled && (T2 = n2.vertexAttributes.get(O$8.OPACITYFEATUREATTRIBUTE).data[0]);
    const v2 = new Float32Array(o2.buffer);
    let _2 = h2 * (this.vertexBufferLayout.stride / 4);
    const S2 = (e2, t2, r2, a2) => {
      if (v2[_2++] = e2[0], v2[_2++] = e2[1], v2[_2++] = e2[2], v2[_2++] = r2[0], v2[_2++] = r2[1], v2[_2++] = t2[0], v2[_2++] = t2[1], v2[_2++] = t2[2], this._parameters.worldSpace && (v2[_2++] = p2[0], v2[_2++] = p2[1], v2[_2++] = p2[2]), this._parameters.vvSizeEnabled ? v2[_2++] = A2 : v2[_2++] = d2, this._parameters.vvColorEnabled)
        v2[_2++] = E2;
      else {
        const e3 = Math.min(4 * a2, f2.length - 4);
        v2[_2++] = f2[e3 + 0], v2[_2++] = f2[e3 + 1], v2[_2++] = f2[e3 + 2], v2[_2++] = f2[e3 + 3];
      }
      this._parameters.vvOpacityEnabled && (v2[_2++] = T2);
    };
    let O2;
    !function(e2) {
      e2[e2.ASCENDING = 1] = "ASCENDING", e2[e2.DESCENDING = -1] = "DESCENDING";
    }(O2 || (O2 = {}));
    const R2 = (e2, i3) => {
      const n3 = o$7(b$6, c2[3 * e2], c2[3 * e2 + 1], c2[3 * e2 + 2]), o3 = g$5;
      let h3 = e2 + i3;
      do {
        o$7(o3, c2[3 * h3], c2[3 * h3 + 1], c2[3 * h3 + 2]), h3 += i3;
      } while (G$4(n3, o3) && h3 >= 0 && h3 < u2);
      s2 && (O$9(n3, n3, s2), O$9(o3, o3, s2)), S2(n3, o3, [-1, -1], e2), S2(n3, o3, [1, -1], e2), S2(n3, o3, [1, 1], e2), S2(n3, o3, [-1, -1], e2), S2(n3, o3, [1, 1], e2), S2(n3, o3, [-1, 1], e2);
    }, I2 = this._parameters.placement;
    I2 !== "begin" && I2 !== "begin-end" || R2(0, O2.ASCENDING), I2 !== "end" && I2 !== "begin-end" || R2(u2 - 1, O2.DESCENDING);
  }
}
const b$6 = n$h(), g$5 = n$h();
const q$4 = ["polyline", "polygon", "extent"];
class J$1 extends y$9 {
  constructor(e2, t2, r2, a2) {
    super(e2, t2, r2, a2);
  }
  async doLoad() {
    if (this._vvConvertOptions = { modelSize: [1, 1, 1], symbolSize: [1, 1, 1], unitInMeters: 1, transformation: { anchor: [0, 0, 0], scale: [1, 1, 1], rotation: [0, 0, 0] }, supportedTypes: { size: true, color: true, opacity: true, rotation: false } }, this._context.renderer && this._context.renderer.visualVariables && this._context.renderer.visualVariables.length > 0 ? this._fastUpdates = P$4(this._context.renderer, this._vvConvertOptions) : this._fastUpdates = { enabled: false }, !this._drivenProperties.size) {
      if ((this.symbolLayer.size != null ? this.symbolLayer.size : e$q(1)) < 0)
        throw new s$d("graphics3dlinesymbollayer:invalid-size", "Symbol sizes may not be negative values");
    }
    this._markerTexture = r$d(this.symbolLayer.marker) && r$d(this._context.sharedResources.textures) ? f$k(this._context.sharedResources.textures, r$6(this.symbolLayer.marker.style)) : null;
  }
  _getMaterialParameters(e2, t2 = false) {
    var _a;
    const r2 = this._getCombinedOpacityAndColor(t2 && this._markerColor || this._materialColor);
    this._patternHidesLine && !t2 && (r2[3] = 0);
    const a2 = { width: this._computeMaterialWidth((_a = this.symbolLayer) == null ? void 0 : _a.size), color: r2, hasPolygonOffset: true, join: this.symbolLayer.join || "miter", cap: n$6(this.symbolLayer.cap || "butt"), hasSlicePlane: this._context.slicePlaneEnabled, isClosed: e2, stipplePattern: a$m(this.symbolLayer.pattern), stippleScaleWithLineWidth: true };
    return this._fastUpdates && this._fastUpdates.visualVariables ? __spreadValues(__spreadValues({}, a2), this._fastUpdates.materialParameters) : a2;
  }
  get _materialColor() {
    return o$j(this.symbolLayer.material, (e2) => e2.color);
  }
  get _markerColor() {
    return o$j(this.symbolLayer.marker, (e2) => e2.color);
  }
  get _lineMaterial() {
    return t$7(this._lineMaterialCached) && (this._lineMaterialCached = new H$5(this._getMaterialParameters(false)), this._context.stage.add(this._lineMaterialCached)), this._lineMaterialCached;
  }
  get _ringMaterial() {
    return t$7(this._ringMaterialCached) && (this._ringMaterialCached = new H$5(this._getMaterialParameters(true)), this._context.stage.add(this._ringMaterialCached)), this._ringMaterialCached;
  }
  get _wireframeLineMaterial() {
    return t$7(this._wireframeLineMaterialCached) && (this._wireframeLineMaterialCached = new H$5(__spreadProps(__spreadValues({}, this._getMaterialParameters(false)), { wireframe: true })), this._context.stage.add(this._wireframeLineMaterialCached)), this._wireframeLineMaterialCached;
  }
  get _wireframeRingMaterial() {
    return t$7(this._wireframeRingMaterialCached) && (this._wireframeRingMaterialCached = new H$5(__spreadProps(__spreadValues({}, this._getMaterialParameters(true)), { wireframe: true })), this._context.stage.add(this._wireframeRingMaterialCached)), this._wireframeRingMaterialCached;
  }
  get _markerMaterial() {
    return t$7(this._markerMaterialCached) && r$d(this.symbolLayer.marker) && r$d(this._markerTexture) && (this._markerMaterialCached = new v$6(__spreadProps(__spreadValues({}, this._getMaterialParameters(false, true)), { placement: this.symbolLayer.marker.placement, textureId: this._markerTexture.texture.id })), this._context.stage.add(this._markerMaterialCached)), this._markerMaterialCached;
  }
  destroy() {
    super.destroy(), this._forEachMaterial((e2) => this._context.stage.remove(e2)), this._lineMaterialCached = null, this._ringMaterialCached = null, this._wireframeLineMaterialCached = null, this._wireframeRingMaterialCached = null, this._markerMaterialCached = null, this._markerTexture = w$b(this._markerTexture);
  }
  _getDrivenSize(e2) {
    return this._drivenProperties.size && e2.size ? u$n(c$c(e2.size)) : 1;
  }
  _getSizeFeatureAttributeData(e2) {
    return this._fastUpdates.enabled && this._fastUpdates.visualVariables.size ? v$8(this._fastUpdates.visualVariables.size.field, e2) : null;
  }
  _getDrivenColor(e2) {
    const t2 = r$f(1, 1, 1, 1);
    return this._drivenProperties.color && e2.color && (t2[0] = e2.color[0], t2[1] = e2.color[1], t2[2] = e2.color[2], e2.color.length > 0 && (t2[3] = e2.color[3])), this._drivenProperties.opacity && e2.opacity && (t2[3] = e2.opacity), t2;
  }
  _getColorFeatureAttributeData(e2) {
    return this._fastUpdates.enabled && this._fastUpdates.visualVariables.color ? v$8(this._fastUpdates.visualVariables.color.field, e2) : null;
  }
  _getOpacityFeatureAttributeData(e2) {
    return this._fastUpdates.enabled && this._fastUpdates.visualVariables.opacity ? v$8(this._fastUpdates.visualVariables.opacity.field, e2) : null;
  }
  createGraphics3DGraphic(e2) {
    const t2 = e2.graphic;
    if (!this._validateGeometry(t2.geometry, q$4, this.symbolLayer.type))
      return null;
    const r2 = this.setGraphicElevationContext(t2, new h$8());
    return this.ensureDrapedStatus(r2.mode === "on-the-ground"), this.draped ? this._createAsOverlay(e2, this._context.layer.uid) : this._createAs3DShape(e2, r2, t2.uid);
  }
  applyRendererDiff(e2, t2) {
    for (const r2 in e2.diff) {
      if (r2 !== "visualVariables")
        return e$a.Recreate_Symbol;
      if (!R$6(this._fastUpdates, t2, this._vvConvertOptions))
        return e$a.Recreate_Symbol;
      this._forEachMaterial((e3) => e3.setParameters(this._fastUpdates.materialParameters));
    }
    return e$a.Fast_Update;
  }
  prepareSymbolLayerPatch(e2) {
    var _a, _b;
    if (e2.diff.type !== "partial")
      return;
    const t2 = e2.diff.diff, r2 = {};
    ((_a = t2.size) == null ? void 0 : _a.type) === "complete" && (r2.width = this._computeMaterialWidth(t2.size.newValue), delete t2.size), ((_b = t2.cap) == null ? void 0 : _b.type) === "complete" && (r2.cap = n$6(i$a(t2.cap.newValue, "butt")), delete t2.cap);
    const a2 = this._prepareMarkerPatch(e2, t2);
    this._prepareMaterialPatch(e2, t2, a2), e2.symbolLayerStatePatches.push(() => this._forEachMaterial((e3) => e3.setParameters(r2)));
  }
  layerOpacityChanged() {
    this._forEachMaterial((e2, t2) => this._updateMaterialLayerOpacity(e2, t2));
  }
  _forEachMaterial(e2) {
    r$d(this._lineMaterialCached) && e2(this._lineMaterialCached), r$d(this._ringMaterialCached) && e2(this._ringMaterialCached), r$d(this._wireframeLineMaterialCached) && e2(this._wireframeLineMaterialCached), r$d(this._wireframeRingMaterialCached) && e2(this._wireframeRingMaterialCached), r$d(this._markerMaterialCached) && e2(this._markerMaterialCached, true);
  }
  _updateMaterialLayerOpacity(e2, t2 = false) {
    const r2 = e2.parameters.color, a2 = q$7(this.symbolLayer, "material", "color"), i2 = this._patternHidesLine && !t2 ? 0 : this._getCombinedOpacity(a2), s2 = r$f(r2[0], r2[1], r2[2], i2);
    e2.setParameters({ color: s2 });
  }
  layerElevationInfoChanged(e2, t2, r2) {
    const a2 = this._elevationContext.mode, i2 = p$c(J$1.elevationModeChangeTypes, r2, a2);
    if (i2 !== x$b.UPDATE)
      return i2;
    const s2 = g$c(a2);
    return this.updateGraphics3DGraphicElevationInfo(e2, t2, () => s2);
  }
  slicePlaneEnabledChanged() {
    const e2 = { hasSlicePlane: this._context.slicePlaneEnabled };
    return this._forEachMaterial((t2) => t2.setParameters(e2)), true;
  }
  physicalBasedRenderingChanged() {
    return true;
  }
  pixelRatioChanged() {
    return true;
  }
  _getGeometryAsPolygonOrPolyline(e2) {
    switch (e2.type) {
      case "extent":
        if (e2 instanceof w$9)
          return v$d.fromExtent(e2);
        break;
      case "polygon":
      case "polyline":
        return e2;
    }
    return null;
  }
  _createAs3DShape(e2, r2, a2) {
    const i2 = e2.graphic, s2 = this._getGeometryAsPolygonOrPolyline(i2.geometry), o2 = s2.type === "polygon" ? s2.rings : s2.paths, n2 = new Array(), l2 = new Array(), h2 = new Array(), c2 = a$b(), d2 = i$h(s2, this._context.elevationProvider, this._context.renderCoordsHelper, r2), m2 = s2.type === "polygon" ? "rings" : "paths";
    this._logGeometryCreationWarnings(d2, o2, m2, "LineSymbol3DLayer");
    for (let _2 = 0; _2 < d2.lines.length; _2++) {
      const { position: r3, mapPosition: i3 } = d2.lines[_2];
      if (r$d(this._context.clippingExtent) && (A$6(c2), M$9(c2, i3), !R$9(c2, this._context.clippingExtent)))
        continue;
      const o3 = this._createGeometry(e2, r3, i3, s2.type, K$1.ELEVATED, a2);
      n2.push(o3), l2.push(s2.type === "polygon" ? this._ringMaterial : this._lineMaterial), h2.push(o$8), t$9.LINE_WIREFRAMES && (n2.push(o3.cloneShallow()), l2.push(s2.type === "polygon" ? this._wireframeRingMaterial : this._wireframeLineMaterial), h2.push(o$8));
      const m3 = this._markerMaterial;
      r$d(m3) && (n2.push(o3.cloneShallow()), l2.push(m3), h2.push(o$8));
    }
    if (n2.length === 0)
      return null;
    const f2 = new x$c({ geometries: n2, materials: l2, transformations: h2, castShadow: false, metadata: { layerUid: this._context.layer.uid, graphicUid: a2 } }), C2 = new _$b(this, f2, n2, null, null, b$c, r2);
    return C2.alignedSampledElevation = d2.sampledElevation, C2.needsElevationUpdates = g$c(r2.mode), C2;
  }
  _createGeometry(e2, t2, r2, a2, i2, s2) {
    const o2 = a2 === "polygon", n2 = this._fastUpdates.enabled && this._fastUpdates.visualVariables.color, l2 = this._fastUpdates.enabled && this._fastUpdates.visualVariables.size, h2 = this._context.stage.renderView._getObjectAndLayerIdColor({ graphicUid: s2, layerUid: this._context.layer.uid });
    return m$c({ overlayInfo: i2 === K$1.DRAPED ? { spatialReference: this._context.overlaySR, renderCoordsHelper: this._context.renderCoordsHelper } : null, removeDuplicateStartEnd: o2, attributeData: { position: t2, mapPosition: r2, size: l2 ? null : this._getDrivenSize(e2.renderingInfo), color: n2 ? null : this._getDrivenColor(e2.renderingInfo), sizeFeature: this._getSizeFeatureAttributeData(e2.graphic), colorFeature: this._getColorFeatureAttributeData(e2.graphic), opacityFeature: this._getOpacityFeatureAttributeData(e2.graphic) } }, h2);
  }
  _createAsOverlay(e2, r2) {
    const a2 = e2.graphic, i2 = this._getGeometryAsPolygonOrPolyline(a2.geometry), s2 = i2.type === "polygon" ? i2.rings : i2.paths, o2 = i2.type === "polygon" ? this._ringMaterial : this._lineMaterial;
    o2.renderPriority = this._renderPriority;
    const l2 = t$9.LINE_WIREFRAMES ? i2.type === "polygon" ? this._wireframeRingMaterial : this._wireframeLineMaterial : null, h2 = this._markerMaterial;
    r$d(l2) && (l2.renderPriority = this._renderPriority - 1e-3), r$d(h2) && (h2.renderPriority = this._renderPriority - 2e-3);
    const p2 = new Array(), c2 = a$b(), d2 = A$6(), m2 = s$i(i2, this._context.overlaySR), C2 = i2.type === "polygon" ? "rings" : "paths";
    this._logGeometryCreationWarnings(m2, s2, C2, "LineSymbol3DLayer");
    for (const _2 of m2.lines) {
      if (A$6(c2), M$9(c2, _2.position), !R$9(c2, this._context.clippingExtent))
        continue;
      f$e(d2, c2);
      const s3 = this._createGeometry(e2, _2.position, null, i2.type, K$1.DRAPED, a2.uid), m3 = (e3) => {
        const t2 = new T$6(s3, e3, { layerUid: r2, graphicUid: a2.uid });
        return p2.push(t2), t2;
      };
      if (r$d(h2)) {
        const e3 = m3(h2), t2 = e$f(this.symbolLayer.marker).placement;
        t2 !== "begin" && t2 !== "begin-end" || M$9(c2, _2.position, 0, 1), t2 !== "end" && t2 !== "begin-end" || M$9(c2, _2.position, _2.position.length - 3, 1), this._updateBoundingSphere(e3, c2);
      }
      const C3 = m3(o2);
      if (this._updateBoundingSphere(C3, c2), t$9.LINE_WIREFRAMES) {
        const e3 = m3(l2);
        this._updateBoundingSphere(e3, c2);
      }
    }
    return new l$6(this, p2, d2, this._context.drapeSourceRenderer);
  }
  _updateBoundingSphere(e2, t2) {
    r$m(e2.boundingSphere, 0.5 * (t2[0] + t2[3]), 0.5 * (t2[1] + t2[4]), 0, 0.5 * Math.sqrt((t2[3] - t2[0]) * (t2[3] - t2[0]) + (t2[4] - t2[1]) * (t2[4] - t2[1])));
  }
  get _patternHidesLine() {
    const e2 = this.symbolLayer.pattern;
    return r$d(e2) && e2.type === "style" && e2.style === "none";
  }
  _computeMaterialWidth(e2) {
    return e2 = i$a(e2, e$q(1)), this._drivenProperties.size ? this._fastUpdates.enabled && this._fastUpdates.visualVariables.size ? u$n(1) : 1 : u$n(e2);
  }
  _prepareMaterialPatch(e2, t2, i2) {
    const s2 = t2.material;
    if (t$7(s2))
      return void (i2.changed && i2.useMaterialColor && this._patchMaterialColor(this._getCombinedOpacityAndColor(this._materialColor), this._markerMaterialCached, e2));
    if (s2.type === "collection")
      return;
    const o2 = s2.type === "complete" ? o$j(s2.newValue, (e3) => e3.color) : s2.diff.color.type === "complete" ? s2.diff.color.newValue : null, n2 = this._getCombinedOpacityAndColor(o2);
    i2.useMaterialColor && this._patchMaterialColor(t$k(n2), this._markerMaterialCached, e2), this._patternHidesLine && (n2[3] = 0), this._patchMaterialColor(n2, this._lineMaterialCached, e2), delete t2.material;
  }
  _prepareMarkerPatch(e2, r2) {
    const i2 = r2.marker;
    if (t$7(i2) || i2.type !== "partial" || r$d(i2.diff.style) || r$d(i2.diff.placement) || r$d(i2.diff.color) && i2.diff.color.type !== "complete")
      return { changed: false, useMaterialColor: t$7(this._markerColor) };
    const s2 = i2.diff.color;
    if (t$7(s2))
      return delete r2.marker, { changed: false, useMaterialColor: t$7(this._markerColor) };
    const o2 = e$f(s2.newValue);
    return t$7(o2) ? (delete r2.marker, { changed: true, useMaterialColor: true }) : (this._patchMaterialColor(this._getCombinedOpacityAndColor(o2), this._markerMaterialCached, e2), delete r2.marker, { changed: true, useMaterialColor: false });
  }
  _patchMaterialColor(e2, t2, r2) {
    t$7(t2) || r2.symbolLayerStatePatches.push(() => t2.setParameters({ color: e2 }));
  }
}
var K$1;
J$1.elevationModeChangeTypes = { definedChanged: x$b.RECREATE, staysOnTheGround: x$b.NONE, onTheGroundChanged: x$b.RECREATE }, function(e2) {
  e2[e2.DRAPED = 0] = "DRAPED", e2[e2.ELEVATED = 1] = "ELEVATED";
}(K$1 || (K$1 = {}));
const me$2 = ["mesh"];
class he$1 extends y$9 {
  constructor(e2, t2, r2, a2) {
    super(e2, t2, r2, a2), this._materials = new Map(), this._textures = new Map(), this.ensureDrapedStatus(false);
  }
  async doLoad() {
    t$9.DRAW_MESH_GEOMETRY_NORMALS && (this._debugVertexNormalMaterial = new F$8({ color: [1, 0, 1, 1] }), this._debugFaceNormalMaterial = new F$8({ color: [0, 1, 1, 1] }));
  }
  destroy() {
    super.destroy(), this._context.stage.removeMany(Array.from(this._materials.values(), (e2) => e2.material)), this._context.stage.removeMany(Array.from(this._textures.values())), this._materials.clear(), this._textures.clear();
  }
  createGraphics3DGraphic(e2) {
    const t2 = e2.graphic;
    if (!this._validateGeometry(t2.geometry, me$2, "fill on mesh-3d"))
      return null;
    const r2 = this.setGraphicElevationContext(t2, new h$8()), a2 = e2.renderingInfo;
    return this._createAs3DShape(t2, a2, r2, t2.uid);
  }
  layerOpacityChanged(e2, r2) {
    const a2 = this._getLayerOpacity();
    this._materials.forEach((e3) => {
      e3.material.setParameters({ layerOpacity: a2 });
      const t2 = e3.material.parameters;
      this._setMaterialTransparentParameter(t2, e3), e3.material.setParameters({ transparent: t2.transparent });
    }), e2.forEach((e3) => {
      const o2 = r2(e3);
      r$d(o2) && o2.layerOpacityChanged(a2, this._context.isAsync);
    });
  }
  layerElevationInfoChanged(e2, t2) {
    return this.updateGraphics3DGraphicElevationInfo(e2, t2, v$e);
  }
  slicePlaneEnabledChanged(e2, r2) {
    return this._materials.forEach((e3) => {
      e3.material.setParameters({ hasSlicePlane: this._context.slicePlaneEnabled });
    }), e2.forEach((e3) => {
      const a2 = r2(e3);
      r$d(a2) && a2.slicePlaneEnabledChanged(this._context.slicePlaneEnabled, this._context.isAsync);
    }), true;
  }
  physicalBasedRenderingChanged() {
    const e2 = this._usePBR();
    return this._materials.forEach((t2) => t2.material.setParameters({ usePBR: e2 })), true;
  }
  pixelRatioChanged() {
    return true;
  }
  _requiresSymbolVertexColors() {
    return this._drivenProperties.color || this._drivenProperties.opacity;
  }
  _colorOrTextureUid(t2) {
    return t$7(t2) ? "-" : t2 instanceof l$c ? t2.toHex() : t2.contentHash;
  }
  _materialPropertiesDefault(e2, t2) {
    const r2 = this._requiresSymbolVertexColors(), a2 = !!e2.vertexAttributes.color, o2 = !!e2.vertexAttributes.tangent;
    return { hasSymbolVertexColors: r2, hasVertexColors: a2, hasVertexTangents: o2, uid: `vc:${a2},vt:${o2},vct${t2},svc:${r2}` };
  }
  _materialProperties(e2, t2, r2) {
    const a2 = this._materialPropertiesDefault(e2, r2);
    if (!t2.material)
      return a2;
    const { color: o2, colorTexture: s2, normalTexture: n2, doubleSided: i2, alphaCutoff: l2, alphaMode: u2 } = t2.material, c2 = this._colorOrTextureUid(o2), m2 = this._colorOrTextureUid(s2), h2 = this._colorOrTextureUid(n2);
    if (a2.color = o2, a2.colorTexture = s2, a2.normalTexture = n2, a2.uid = `${a2.uid},cmuid:${c2},ctmuid:${m2},ntmuid:${h2},ds:${i2},ac:${l2},am:${u2}`, t2.material instanceof c$o) {
      const { metallic: e3, roughness: r3, metallicRoughnessTexture: o3, emissiveColor: s3, emissiveTexture: n3, occlusionTexture: i3 } = t2.material, l3 = this._colorOrTextureUid(o3), u3 = this._colorOrTextureUid(s3), c3 = this._colorOrTextureUid(n3), m3 = this._colorOrTextureUid(i3);
      a2.metallic = e3, a2.roughness = r3, a2.metallicRoughnessTexture = o3, a2.emissiveColor = s3, a2.emissiveTexture = n3, a2.occlusionTexture = i3, a2.colorTextureTransform = t2.material.colorTextureTransform, a2.normalTextureTransform = t2.material.normalTextureTransform, a2.emissiveTextureTransform = t2.material.emissiveTextureTransform, a2.occlusionTextureTransform = t2.material.occlusionTextureTransform, a2.metallicRoughnessTextureTransform = t2.material.metallicRoughnessTextureTransform, a2.uid = `${a2.uid},mrm:${e3},mrr:${r3},mrt:${l3},emuid:${u3},etmuid:${c3},otmuid:${m3}`;
    }
    return a2;
  }
  _setInternalColorValueParameters(t2, r2) {
    r2.diffuse = l$c.toUnitRGB(t2), r2.opacity = t2.a;
  }
  _getLoadableTextureResource(e2) {
    return e2.data ? e2.data : e2.url;
  }
  _getInternalTextureId(e2) {
    const r2 = this._getInternalTexture(e2, C$c.Opaque);
    return r$d(r2) ? r2.id : null;
  }
  _getInternalTexture(e2, t2) {
    const r2 = this._getLoadableTextureResource(e2);
    if (!r2)
      return null;
    const a2 = `${e2.contentHash}/${t2}`;
    let o2 = this._textures.get(a2);
    return o2 || (o2 = new L$6(r2, { mipmap: true, wrap: this._castTextureWrap(e2.wrap), noUnpackFlip: true, preMultiplyAlpha: t2 !== C$c.Opaque }), this._textures.set(a2, o2), this._context.stage.add(o2), this._context.stage.loadImmediate(o2)), o2;
  }
  _castTextureWrap(e2 = "repeat") {
    if (typeof e2 == "string") {
      const t2 = this._castTextureWrapIndividual(e2);
      return { s: t2, t: t2 };
    }
    return { s: this._castTextureWrapIndividual(e2.horizontal), t: this._castTextureWrapIndividual(e2.vertical) };
  }
  _castTextureWrapIndividual(e2) {
    switch (e2) {
      case "clamp":
        return D$5.CLAMP_TO_EDGE;
      case "mirror":
        return D$5.MIRRORED_REPEAT;
      default:
        return D$5.REPEAT;
    }
  }
  _setInternalMaterialParameters(r2, a2) {
    if (r$d(r2.color) && this._setInternalColorValueParameters(r2.color, a2), r$d(r2.colorTexture)) {
      const e2 = this._getInternalTexture(r2.colorTexture, a2.textureAlphaMode);
      r$d(e2) ? (a2.textureId = e2.id, a2.textureAlphaPremultiplied = !!e2.params.preMultiplyAlpha) : a2.textureId = void 0;
    }
    r$d(r2.normalTexture) && (a2.normalTextureId = this._getInternalTextureId(r2.normalTexture)), r$d(r2.emissiveColor) && (a2.emissiveFactor = l$c.toUnitRGB(r2.emissiveColor)), r$d(r2.emissiveTexture) && (a2.emissiveTextureId = this._getInternalTextureId(r2.emissiveTexture)), r$d(r2.occlusionTexture) && (a2.occlusionTextureId = this._getInternalTextureId(r2.occlusionTexture)), r$d(r2.metallicRoughnessTexture) && (a2.metallicRoughnessTextureId = this._getInternalTextureId(r2.metallicRoughnessTexture)), a2.colorTextureTransformMatrix = c$p(r2.colorTextureTransform), a2.normalTextureTransformMatrix = c$p(r2.normalTextureTransform), a2.occlusionTextureTransformMatrix = c$p(r2.occlusionTextureTransform), a2.emissiveTextureTransformMatrix = c$p(r2.emissiveTextureTransform), a2.metallicRoughnessTextureTransformMatrix = c$p(r2.metallicRoughnessTextureTransform);
  }
  _setExternalMaterialParameters(r2) {
    const a2 = this._drivenProperties.color;
    let o2 = r$d(this.symbolLayer.material) ? this.symbolLayer.material.colorMixMode : null;
    if (a2)
      r2.externalColor = _$e;
    else {
      const a3 = r$d(this.symbolLayer.material) ? this.symbolLayer.material.color : null;
      r$d(a3) ? r2.externalColor = l$c.toUnitRGBA(a3) : (o2 = null, r2.externalColor = _$e);
    }
    o2 && (r2.colorMixMode = o2), r2.castShadows = !!this.symbolLayer.castShadows;
  }
  _hasTransparentVertexColors(e2) {
    const t2 = e2.vertexAttributes.color;
    if (t$7(t2))
      return false;
    for (let r2 = 3; r2 < t2.length; r2 += 4)
      if (t2[r2] !== 255)
        return true;
    return false;
  }
  _getOrCreateMaterial(e2, r2) {
    var _a, _b, _c;
    const a2 = (_a = r2.material) == null ? void 0 : _a.color, o2 = (_b = r2.material) == null ? void 0 : _b.colorTexture, s2 = (_c = r2.material) == null ? void 0 : _c.alphaMode, n2 = s2 === "blend", i2 = !(s2 === "opaque") && (this._hasTransparentVertexColors(e2) || r$d(a2) && a2.a < 1 || r$d(o2) && o2.transparent || n2), l2 = this._materialProperties(e2, r2, i2), u2 = this._materials.get(l2.uid);
    if (u2)
      return u2.material;
    const c2 = { material: null, isComponentTransparent: i2, alphaMode: r2.material ? r2.material.alphaMode : "opaque" }, m2 = l2.metallicRoughnessTexture == null && l2.metallic == null && l2.roughness == null, h2 = { usePBR: this._usePBR(), isSchematic: m2, hasVertexColors: l2.hasVertexColors, hasSymbolColors: l2.hasSymbolVertexColors, hasVertexTangents: l2.hasVertexTangents, ambient: f$h, diffuse: l$e, opacity: 1, doubleSided: true, doubleSidedType: "winding-order", cullFace: n$l.None, layerOpacity: this._getLayerOpacity(), hasSlicePlane: this._context.slicePlaneEnabled, initTextureTransparent: true };
    m2 || (h2.mrrFactors = [l2.metallic != null ? l2.metallic : 1, l2.roughness != null ? l2.roughness : 1, 0.5]), r2.material && (h2.doubleSided = r2.material.doubleSided, h2.cullFace = r2.material.doubleSided ? n$l.None : n$l.Back, h2.textureAlphaCutoff = r2.material.alphaCutoff), this._setExternalMaterialParameters(h2), this._setMaterialTransparentParameter(h2, c2), this._setInternalMaterialParameters(l2, h2);
    const f2 = new C$b(h2);
    return c2.material = f2, this._materials.set(l2.uid, c2), this._context.stage.add(f2), f2;
  }
  _usePBR() {
    return this._context.physicalBasedRenderingEnabled;
  }
  _setMaterialTransparentParameter(e2, t2) {
    e2.transparent = this.needsDrivenTransparentPass || t2.isComponentTransparent || e2.layerOpacity < 1 || e2.opacity < 1 || e2.externalColor && e2.externalColor[3] < 1, t2.alphaMode === "auto" ? e2.textureAlphaMode = e2.transparent ? C$c.MaskBlend : C$c.Opaque : e2.textureAlphaMode = t2.alphaMode === "opaque" ? C$c.Opaque : t2.alphaMode === "mask" ? C$c.Mask : C$c.Blend;
  }
  _addDebugNormals(e2, t2, r2, a2) {
    const o2 = t2.length, s2 = e2.spatialReference.isGeographic ? 20015077 / 180 : 1, n2 = 0.1 * Math.max(e2.extent.width * s2, e2.extent.height * s2, e2.extent.zmax - e2.extent.zmin), i2 = [], l2 = [], u2 = [], c2 = [];
    for (let m2 = 0; m2 < o2; m2++) {
      const e3 = t2[m2], r3 = e3.vertexAttributes.get(O$8.POSITION), a3 = e3.vertexAttributes.get(O$8.NORMAL), o3 = e3.indices.get(O$8.POSITION), s3 = e3.indices.get(O$8.NORMAL), h3 = r3.data, d3 = a3.data;
      for (let t3 = 0; t3 < o3.length; t3++) {
        const e4 = 3 * o3[t3], r4 = 3 * s3[t3];
        for (let t4 = 0; t4 < 3; t4++)
          i2.push(h3[e4 + t4]);
        for (let t4 = 0; t4 < 3; t4++)
          i2.push(h3[e4 + t4] + d3[r4 + t4] * n2);
        if (l2.push(l2.length), l2.push(l2.length), t3 % 3 == 0) {
          this._calculateFaceNormal(h3, o3, t3, xe), this._getFaceVertices(h3, o3, t3, pe$1, de$1, ge$1), u$g(pe$1, pe$1, de$1), u$g(pe$1, pe$1, ge$1), g$d(pe$1, pe$1, 1 / 3);
          for (let e5 = 0; e5 < 3; e5++)
            u2.push(pe$1[e5]);
          for (let e5 = 0; e5 < 3; e5++)
            u2.push(pe$1[e5] + xe[e5] * n2);
          c2.push(c2.length), c2.push(c2.length);
        }
      }
    }
    const h2 = new d$i([[O$8.POSITION, { data: i2, size: 3, exclusive: true }]], [[O$8.POSITION, l2]], a$f.Line);
    t2.push(h2), r2.push(this._debugVertexNormalMaterial), a2.push(r$n(a2[0]));
    const d2 = new d$i([[O$8.POSITION, { data: u2, size: 3, exclusive: true }]], [[O$8.POSITION, c2]], a$f.Line);
    t2.push(d2), r2.push(this._debugFaceNormalMaterial), a2.push(r$n(a2[0]));
  }
  _createAs3DShape(e2, r2, a2, o2) {
    const s2 = e2.geometry;
    if (s2.type !== "mesh")
      return null;
    const n2 = this._createGeometryInfo(s2, r2, o2);
    if (!n2)
      return null;
    const { geometries: i2, materials: l2, transformations: u2, objectTransformation: c2 } = n2;
    t$9.DRAW_MESH_GEOMETRY_NORMALS && this._addDebugNormals(s2, i2, l2, u2);
    const m2 = new x$c({ geometries: i2, materials: l2, transformations: u2, metadata: { layerUid: this._context.layer.uid, graphicUid: o2 } });
    m2.transformation = c2;
    const h2 = this._createEdgeMaterial(), f2 = r$d(h2) ? { baseMaterial: l2[0], edgeMaterials: [h2], properties: { mergeGeometries: true, hasSlicePlane: this._context.slicePlaneEnabled } } : null, p2 = new _$b(this, m2, i2, null, null, d$b, a2, f2);
    return p2.needsElevationUpdates = v$e(a2.mode), p2.useObjectOriginAsAttachmentOrigin = true, p2.elevationContext.centerPointInElevationSR = this._getCenterPointInElevationSR(m2), p2.alignedSampledElevation = d$b(p2, p2.elevationContext, this._context.elevationProvider, this._context.renderCoordsHelper), p2;
  }
  _getCenterPointInElevationSR(e2) {
    const r2 = v$b(0, 0, 0, r$d(this._context.elevationProvider.spatialReference) ? this._context.elevationProvider.spatialReference : null);
    return Hn([e2.transformation[12], e2.transformation[13], e2.transformation[14]], this._context.renderCoordsHelper.spatialReference, r2), r2;
  }
  _createComponentNormals(e2, t2, r2, a2) {
    switch (r2.shading || "flat") {
      case "source":
        return this._createComponentNormalsSource(e2, t2, r2, a2);
      case "flat":
        return this._createComponentNormalsFlat(e2, a2);
      case "smooth":
        return this._createComponentNormalsSmooth(e2, a2);
      default:
        return;
    }
  }
  _createComponentNormalsSource(e2, t2, a2, o2) {
    if (t$7(t2))
      return this._createComponentNormalsFlat(e2, o2);
    let s2 = false;
    if (!a2.trustSourceNormals)
      for (let r2 = 0; r2 < o2.length; r2 += 3) {
        this._calculateFaceNormal(e2, o2, r2, xe);
        for (let e3 = 0; e3 < 3; e3++) {
          const a3 = 3 * o2[r2 + e3];
          pe$1[0] = t2[a3 + 0], pe$1[1] = t2[a3 + 1], pe$1[2] = t2[a3 + 2], P$9(xe, pe$1) < 0 && (t2[a3 + 0] = -t2[a3 + 0], t2[a3 + 1] = -t2[a3 + 1], t2[a3 + 2] = -t2[a3 + 2], s2 = true);
        }
      }
    return { normals: t2, indices: o2, didFlipNormals: s2 };
  }
  _createComponentNormalsFlat(e2, t2) {
    const r2 = new Float32Array(t2.length), a2 = new Array(3 * t2.length);
    for (let o2 = 0; o2 < t2.length; o2 += 3) {
      const s2 = this._calculateFaceNormal(e2, t2, o2, xe);
      for (let e3 = 0; e3 < 3; e3++)
        r2[o2 + e3] = s2[e3], a2[o2 + e3] = o2 / 3;
    }
    return { normals: r2, indices: a2, didFlipNormals: false };
  }
  _createComponentNormalsSmooth(e2, t2) {
    const r2 = {};
    for (let s2 = 0; s2 < t2.length; s2 += 3) {
      const a3 = this._calculateFaceNormal(e2, t2, s2, xe);
      for (let e3 = 0; e3 < 3; e3++) {
        const o3 = t2[s2 + e3];
        let n2 = r2[o3];
        n2 || (n2 = { normal: n$h(), count: 0 }, r2[o3] = n2), u$g(n2.normal, n2.normal, a3), n2.count++;
      }
    }
    const a2 = new Float32Array(3 * t2.length), o2 = new Array(3 * t2.length);
    for (let s2 = 0; s2 < t2.length; s2++) {
      const e3 = r2[t2[s2]];
      e3.count !== 1 && (z$5(e3.normal, e3.normal), e3.count = 1);
      for (let t3 = 0; t3 < 3; t3++)
        a2[3 * s2 + t3] = e3.normal[t3];
      o2[s2] = s2;
    }
    return { normals: a2, indices: o2, didFlipNormals: false };
  }
  _getFaceVertices(e2, t2, r2, a2, o2, s2) {
    const n2 = 3 * t2[r2 + 0], i2 = 3 * t2[r2 + 1], l2 = 3 * t2[r2 + 2];
    a2[0] = e2[n2 + 0], a2[1] = e2[n2 + 1], a2[2] = e2[n2 + 2], o2[0] = e2[i2 + 0], o2[1] = e2[i2 + 1], o2[2] = e2[i2 + 2], s2[0] = e2[l2 + 0], s2[1] = e2[l2 + 1], s2[2] = e2[l2 + 2];
  }
  _calculateFaceNormal(e2, t2, r2, a2) {
    return this._getFaceVertices(e2, t2, r2, pe$1, de$1, ge$1), e$n(de$1, de$1, pe$1), e$n(ge$1, ge$1, pe$1), _$d(pe$1, de$1, ge$1), z$5(a2, pe$1), a2;
  }
  _getOrCreateComponents(e2) {
    return i$a(e2.components, be$1);
  }
  _createPositionBuffer(e2, r2) {
    let a2 = e2.vertexAttributes.position;
    const o2 = r2.reprojection === ve.ECEF ? r2.transformBeforeProject : null;
    if (r$d(o2) && (a2 = R$a(a2, new Float64Array(a2.length), o2)), r2.reprojection === ve.NONE)
      return r2.needsBufferCopy ? new Float64Array(a2) : a2;
    const s2 = r$d(o2) ? a2 : new Float64Array(a2.length);
    return xn(a2, e2.spatialReference, 0, s2, this._context.renderCoordsHelper.spatialReference, 0, a2.length / 3), s2;
  }
  _createNormalBuffer(e2, a2, o2) {
    let s2 = e2.vertexAttributes.normal;
    if (t$7(s2))
      return null;
    const n2 = o2.reprojection === ve.ECEF ? o2.transformBeforeProject : null;
    r$d(n2) && (s2 = v$h(s2, new Float32Array(s2.length), n2));
    if (this._context.graphicsCoreOwner.view.viewingMode === "local" || o2.reprojection === ve.NONE)
      return o2.needsBufferCopy && e2.vertexAttributes.normal === s2 ? new Float32Array(s2) : s2;
    const i2 = e2.vertexAttributes.position, l2 = r$d(n2) ? s2 : new Float32Array(s2.length);
    return j$9(s2, i2, a2, e2.spatialReference, l2);
  }
  _createTangentBuffer(e2, a2, o2) {
    let s2 = e2.vertexAttributes.tangent;
    if (t$7(s2))
      return null;
    const n2 = o2.reprojection === ve.ECEF ? o2.transformBeforeProject : null;
    r$d(n2) && (s2 = V$5(s2, new Float32Array(s2.length), n2));
    if (this._context.graphicsCoreOwner.view.viewingMode === "local" || o2.reprojection === ve.NONE)
      return o2.needsBufferCopy && e2.vertexAttributes.normal === s2 ? new Float32Array(s2) : s2;
    const i2 = e2.vertexAttributes.position, l2 = r$d(n2) ? s2 : new Float32Array(s2.length);
    return k$9(s2, i2, a2, e2.spatialReference, l2);
  }
  _createColorBuffer(e2) {
    return e2.vertexAttributes.color;
  }
  _createSymbolColorBuffer(e2) {
    if (this._requiresSymbolVertexColors()) {
      const t2 = this._getVertexOpacityAndColor(e2), r2 = n$p(q$7(this.symbolLayer, "material", "colorMixMode")), a2 = new Uint8Array(4);
      return o$k(t2, r2, a2), a2;
    }
    return null;
  }
  _createBuffers(e2, r2) {
    const a2 = e2.vertexAttributes && e2.vertexAttributes.position;
    if (!a2)
      return this.logger.warn("Mesh geometry must contain position vertex attributes"), null;
    const o2 = e2.vertexAttributes.normal, s2 = e2.vertexAttributes.uv, n2 = e2.vertexAttributes.tangent;
    if (r$d(o2) && o2.length !== a2.length)
      return this.logger.warn("Mesh normal vertex buffer must contain the same number of elements as the position buffer"), null;
    if (r$d(n2) && n2.length / 4 != a2.length / 3)
      return this.logger.warn("Mesh tangent vertex buffer must contain the same number of elements as the position buffer"), null;
    if (r$d(s2) && s2.length / 2 != a2.length / 3)
      return this.logger.warn("Mesh uv vertex buffer must contain the same number of elements as the position buffer"), null;
    const i2 = this._computeReprojectionInfo(e2), l2 = this._createPositionBuffer(e2, i2), u2 = this._createColorBuffer(e2), c2 = this._createSymbolColorBuffer(r2), m2 = this._createNormalBuffer(e2, l2, i2), f2 = this._createTangentBuffer(e2, l2, i2);
    return { positionBuffer: l2, normalBuffer: m2, tangentBuffer: f2, uvBuffer: s2, colorBuffer: u2, symbolColorBuffer: c2, objectTransformation: i2.reprojection === ve.NONE && r$d(i2.objectTransformation) ? i2.objectTransformation : this._transformOriginLocal(e2, l2, m2, f2), geometryTransformation: i2.reprojection === ve.NONE && r$d(i2.geometryTransformation) ? i2.geometryTransformation : e$e() };
  }
  _computeReprojectionInfo(e2) {
    const r2 = r$d(e2.transform), a2 = r2 && e2.transform.geographic || this._context.renderCoordsHelper.viewingMode === l$f.Local ? ve.NONE : ve.ECEF;
    if (r2) {
      if (a2 === ve.NONE) {
        const t3 = e$e();
        Zn(e2.spatialReference, e2.transform.origin, t3, this._context.renderCoordsHelper.spatialReference);
        return { reprojection: a2, objectTransformation: t3, geometryTransformation: r$n(e2.transform.localMatrix), needsBufferCopy: false };
      }
      const t2 = x$e(e$e(), e2.transform.origin);
      return u$p(t2, t2, e2.transform.localMatrix), { reprojection: a2, transformBeforeProject: t2, needsBufferCopy: true };
    }
    return { reprojection: a2, needsBufferCopy: true };
  }
  _transformOriginLocal(e2, r2, a2, o2) {
    const i2 = this._context.renderCoordsHelper.spatialReference, l2 = e2.anchor;
    fe$2[0] = l2.x, fe$2[1] = l2.y, fe$2[2] = l2.z;
    const u2 = e$e();
    Zn(e2.spatialReference, fe$2, u2, i2);
    const m2 = T$5.fromTypedArray(r2);
    if (h$d(_e$2, u2), t$g(m2, m2, _e$2), r$d(a2) || r$d(o2)) {
      if (a$h(Te$1, u2), o$l(Te$1, Te$1), r$d(a2)) {
        const e3 = i$i.fromTypedArray(a2);
        r$h(e3, e3, Te$1);
      }
      if (r$d(o2)) {
        const e3 = i$i.fromTypedArray(o2, 4 * o2.BYTES_PER_ELEMENT);
        r$h(e3, e3, Te$1);
      }
    }
    return u2;
  }
  _validateFaces(e2, t2) {
    const r2 = e2.vertexAttributes.position.length / 3, a2 = t2.faces;
    if (a2) {
      let e3 = -1;
      for (let t3 = 0; t3 < a2.length; t3++) {
        const r3 = a2[t3];
        r3 > e3 && (e3 = r3);
      }
      if (r2 <= e3)
        return this.logger.warn(`Vertex index ${e3} is out of bounds of the mesh position buffer`), false;
    } else if (r2 % 3 != 0)
      return this.logger.warn("Mesh position buffer length must be a multiple of 9 if no component faces are defined (3 values per vertex * 3 vertices per triangle)"), false;
    return true;
  }
  _getOrCreateFaces(e2, t2) {
    return t2.faces ? t2.faces : u$q(e2.vertexAttributes.position.length / 3);
  }
  _isOutsideClippingArea(e2) {
    if (!this._context.clippingExtent)
      return false;
    const r2 = e2.vertexAttributes && e2.vertexAttributes.position;
    if (!r2)
      return false;
    const a2 = this._context.elevationProvider.spatialReference;
    let o2;
    const s2 = r2.length / 3;
    return r$d(a2) && !e2.spatialReference.equals(a2) ? (o2 = new Float64Array(r2.length), xn(e2.vertexAttributes.position, e2.spatialReference, 0, o2, a2, 0, s2)) : o2 = r2, A$6(ye$2), M$9(ye$2, o2, 0, s2), !R$9(ye$2, this._context.clippingExtent);
  }
  _createGeometryInfo(e2, a2, o2) {
    if (!An(e2.spatialReference, this._context.graphicsCoreOwner.view.spatialReference))
      return this.logger.warn("Geometry spatial reference is not compatible with the view"), null;
    if (this._isOutsideClippingArea(e2))
      return null;
    const s2 = this._createBuffers(e2, a2);
    if (t$7(s2))
      return null;
    const { positionBuffer: n2, uvBuffer: i2, colorBuffer: l2, symbolColorBuffer: u2, normalBuffer: c2, tangentBuffer: m2, objectTransformation: h2, geometryTransformation: f2 } = s2, p2 = this._getOrCreateComponents(e2), d2 = [], g2 = [], x2 = [];
    let _2 = false;
    for (const r2 of p2) {
      if (!this._validateFaces(e2, r2))
        return null;
      const a3 = this._getOrCreateFaces(e2, r2);
      if (a3.length === 0)
        continue;
      const s3 = this._createComponentNormals(n2, c2, r2, a3);
      s3.didFlipNormals && (_2 = true);
      const h3 = [[O$8.POSITION, { size: 3, data: n2, exclusive: true }], [O$8.NORMAL, { size: 3, data: s3.normals, exclusive: true }]], p3 = [[O$8.POSITION, a3], [O$8.NORMAL, s3.indices]];
      r$d(l2) && (h3.push([O$8.COLOR, { size: 4, data: l2, exclusive: true }]), p3.push([O$8.COLOR, a3])), r$d(u2) && (h3.push([O$8.SYMBOLCOLOR, { size: 4, data: u2, exclusive: true }]), p3.push([O$8.SYMBOLCOLOR, new Array(a3.length).fill(0)])), r$d(i2) && (h3.push([O$8.UV0, { size: 2, data: i2, exclusive: true }]), p3.push([O$8.UV0, a3])), r$d(m2) && (h3.push([O$8.TANGENT, { size: 4, data: m2, exclusive: true }]), p3.push([O$8.TANGENT, a3]));
      const T2 = this._context.stage.renderView._getObjectAndLayerIdColor({ graphicUid: o2, layerUid: this._context.layer.uid }), y2 = new d$i(h3, p3, a$f.Triangle, T2);
      d2.push(y2), g2.push(f2), x2.push(this._getOrCreateMaterial(e2, r2));
    }
    return _2 && this.logger.warn("Normals have been automatically flipped to be consistent with the counter clock wise face winding order. It is better to generate mesh geometries that have consistent normals."), { geometries: d2, transformations: g2, materials: x2, objectTransformation: h2 };
  }
  _createEdgeMaterial() {
    const e2 = { opacity: this._getLayerOpacity() };
    return f$g(this.symbolLayer, e2);
  }
}
const fe$2 = n$h(), pe$1 = n$h(), de$1 = n$h(), ge$1 = n$h(), xe = n$h(), _e$2 = e$e(), Te$1 = e$o(), ye$2 = a$b(), be$1 = [new g$g()];
var ve;
!function(e2) {
  e2[e2.NONE = 0] = "NONE", e2[e2.ECEF = 1] = "ECEF";
}(ve || (ve = {}));
class f$4 {
  constructor(e2, t2, i2, n2) {
    this.graphics3DSymbolLayer = e2, this.instanceIndex = t2, this.elevationAligner = i2, this.elevationContext = n2, this.type = "lod-instance", this._highlights = new Set(), this.alignedSampledElevation = 0, this.isElevationSource = false, this.needsElevationUpdates = false;
  }
  initialize() {
  }
  setVisibility(e2) {
    const t2 = this._lodRenderer.instanceData;
    e2 !== t2.getVisible(this.instanceIndex) && t2.setVisible(this.instanceIndex, e2);
  }
  destroy() {
    this.instanceIndex != null && (this._lodRenderer.instanceData.removeInstance(this.instanceIndex), this.graphics3DSymbolLayer.notifyDestroyGraphicLayer(this));
  }
  alignWithElevation(t2, i2, n2) {
    if (this.elevationAligner) {
      i$9(this.elevationContext.featureExpressionInfoContext, n2);
      const s2 = this.elevationAligner(this, this.elevationContext, t2, i2);
      r$d(s2) && (this.alignedSampledElevation = s2);
    }
  }
  getCenterObjectSpace(e2 = n$h()) {
    return this._lodRenderer.instanceData.getCombinedLocalTransform(this.instanceIndex, I$3), O$9(e2, this._lodRenderer.baseBoundingSphere.center, I$3);
  }
  getBoundingBoxObjectSpace(e2 = a$b()) {
    this._lodRenderer.instanceData.getCombinedLocalTransform(this.instanceIndex, I$3);
    const t2 = this._lodRenderer.baseBoundingBox;
    A$6(e2);
    for (let s2 = 0; s2 < 8; ++s2)
      o$7(x$7, (1 & s2) == 0 ? t2[0] : t2[3], (2 & s2) == 0 ? t2[1] : t2[4], (4 & s2) == 0 ? t2[2] : t2[5]), O$9(x$7, x$7, I$3), c$q(e2, x$7);
    return e2;
  }
  computeAttachmentOrigin(e2) {
    this._lodRenderer.instanceData.getGlobalTransform(this.instanceIndex, I$3), e2.render.origin[0] += I$3[12], e2.render.origin[1] += I$3[13], e2.render.origin[2] += I$3[14], e2.render.num++;
  }
  async getProjectedBoundingBox(t2, n2, s2, r2, o2) {
    const d2 = this.getBoundingBoxObjectSpace(o2), m2 = v$5, u2 = P$7(d2) ? 1 : m2.length;
    this._lodRenderer.instanceData.getGlobalTransform(this.instanceIndex, I$3);
    for (let e2 = 0; e2 < u2; e2++) {
      const t3 = m2[e2];
      x$7[0] = d2[t3[0]], x$7[1] = d2[t3[1]], x$7[2] = d2[t3[2]], O$9(x$7, x$7, I$3), p$5[3 * e2 + 0] = x$7[0], p$5[3 * e2 + 1] = x$7[1], p$5[3 * e2 + 2] = x$7[2];
    }
    if (!t2(p$5, 0, u2))
      return null;
    A$6(d2);
    let f2 = null;
    this.calculateRelativeScreenBounds && (f2 = this.calculateRelativeScreenBounds());
    for (let e2 = 0; e2 < 3 * u2; e2 += 3) {
      for (let t3 = 0; t3 < 3; t3++)
        d2[t3] = Math.min(d2[t3], p$5[e2 + t3]), d2[t3 + 3] = Math.max(d2[t3 + 3], p$5[e2 + t3]);
      f2 && s2.push({ location: p$5.slice(e2, e2 + 3), screenSpaceBoundingRect: f2 });
    }
    if (n2 && (p$9(d2, b$5), this.elevationContext.mode !== "absolute-height")) {
      let t3;
      const i2 = X$2(d2, n2.service.spatialReference, n2);
      try {
        t3 = await n2.service.queryElevation(b$5[0], b$5[1], r2, i2, "ground");
      } catch (_2) {
      }
      r$d(t3) && V$4(d2, 0, 0, -this.alignedSampledElevation + t3);
    }
    return d2;
  }
  addObjectState(e2, t2) {
    if (e2 === u$h.Highlight) {
      const i2 = new r$o(e2);
      this._addHighlightId(i2), t2.addExternal((e3) => {
        this._removeHighlightId(e3);
      }, i2);
    }
  }
  removeObjectState(e2) {
    this._highlights.forEach((t2) => e2.remove(t2));
  }
  _addHighlightId(e2) {
    this._highlights.add(e2), this._lodRenderer.instanceData.setHighlight(this.instanceIndex, true);
  }
  _removeHighlightId(e2) {
    this._highlights.delete(e2), this._lodRenderer.instanceData.setHighlight(this.instanceIndex, this._highlights.size > 0);
  }
  get _lodRenderer() {
    return this.graphics3DSymbolLayer.lodRenderer;
  }
}
const p$5 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], x$7 = n$h(), b$5 = n$h(), v$5 = [[0, 1, 2], [3, 1, 2], [0, 4, 2], [3, 4, 2], [0, 1, 5], [3, 1, 5], [0, 4, 5], [3, 4, 5]], I$3 = e$e();
function t$4(s2) {
  const t2 = [];
  return s2.stageResources.geometries.forEach((e2, o2) => {
    const r2 = s2.stageResources.materials[o2], n2 = s2.stageResources.textures;
    t2.push({ material: r2, geometry: e2, textures: n2 });
  }), { components: t2, minScreenSpaceRadius: r$d(s2.lodThreshold) ? s2.lodThreshold : 0, pivotOffset: s2.pivotOffset };
}
function o$1(e2) {
  return { levels: e2.map((e3) => t$4(e3)) };
}
function r$5(e2, t2 = c$4) {
  const o2 = c$9(e2);
  return Math.sqrt(o2 / (t2 * Math.PI));
}
function n$5(e2) {
  e2.levels.forEach((e3) => {
    e3.minScreenSpaceRadius || (e3.minScreenSpaceRadius = r$5(e3));
  });
}
const c$4 = 0.05;
var O$2;
function F$5(t2) {
  let e2 = T$4().mat4f64(O$8.LOCALTRANSFORM).mat4f64(O$8.GLOBALTRANSFORM).vec4f64(O$8.BOUNDINGSPHERE).vec3f64(O$8.MODELORIGIN).mat3f(O$8.MODEL).mat3f(O$8.MODELNORMAL).vec2f(O$8.MODELSCALEFACTORS);
  return t2.includes("color") && (e2 = e2.vec4f(O$8.COLOR)), t2.includes("featureAttribute") && (e2 = e2.vec4f(O$8.FEATUREATTRIBUTE)), e2 = e2.u8(O$8.STATE).u8(O$8.LODLEVEL), t2.includes(O$8.OBJECTANDLAYERIDCOLOR) && (e2 = e2.vec4u8(O$8.OBJECTANDLAYERIDCOLOR)), e2.alignTo(8), e2;
}
!function(t2) {
  t2[t2.ALLOCATED = 1] = "ALLOCATED", t2[t2.DEFAULT_ACTIVE = 2] = "DEFAULT_ACTIVE", t2[t2.VISIBLE = 4] = "VISIBLE", t2[t2.HIGHLIGHT = 8] = "HIGHLIGHT", t2[t2.HIGHLIGHT_ACTIVE = 16] = "HIGHLIGHT_ACTIVE", t2[t2.REMOVE = 32] = "REMOVE", t2[t2.TRANSFORM_CHANGED = 64] = "TRANSFORM_CHANGED", t2[t2.ACTIVE = 18] = "ACTIVE";
}(O$2 || (O$2 = {}));
class v$4 {
  constructor(t2) {
    this.localTransform = t2.getField(O$8.LOCALTRANSFORM, b$i), this.globalTransform = t2.getField(O$8.GLOBALTRANSFORM, b$i), this.modelOrigin = t2.getField(O$8.MODELORIGIN, T$5), this.model = t2.getField(O$8.MODEL, l$o), this.modelNormal = t2.getField(O$8.MODELNORMAL, l$o), this.modelScaleFactors = t2.getField(O$8.MODELSCALEFACTORS, u$s), this.boundingSphere = t2.getField(O$8.BOUNDINGSPHERE, h$g), this.color = t2.getField(O$8.COLOR, c$r), this.featureAttribute = t2.getField(O$8.FEATUREATTRIBUTE, c$r), this.state = t2.getField(O$8.STATE, d$l), this.lodLevel = t2.getField(O$8.LODLEVEL, d$l), this.objectAndLayerIdColor = t2.getField(O$8.OBJECTANDLAYERIDCOLOR, x$f);
  }
}
class M$4 extends n$f {
  constructor(t2, e2) {
    super(), this._capacity = 0, this._size = 0, this._next = 0, this._buffer = null, this._view = null, this._layout = F$5(t2), this._shaderTransformation = e2;
  }
  get capacity() {
    return this._capacity;
  }
  get size() {
    return this._size;
  }
  get buffer() {
    return this._buffer.buffer;
  }
  get view() {
    return this._view;
  }
  addInstance() {
    this._size + 1 > this._capacity && this._grow();
    const t2 = this._findSlot();
    return this._view.state.set(t2, O$2.ALLOCATED), this._size++, this.emit("instance-added", { index: t2 }), t2;
  }
  removeInstance(t2) {
    const e2 = this._view.state;
    e$v(t2 >= 0 && t2 < this._capacity && e2.get(t2) & O$2.ALLOCATED, "invalid instance handle"), this._getStateFlag(t2, O$2.ACTIVE) ? this._setStateFlags(t2, O$2.REMOVE) : this.freeInstance(t2), this.emit("instance-removed", { index: t2 });
  }
  freeInstance(t2) {
    const e2 = this._view.state;
    e$v(t2 >= 0 && t2 < this._capacity && e2.get(t2) & O$2.ALLOCATED, "invalid instance handle"), e2.set(t2, 0), this._size--;
  }
  setLocalTransform(t2, e2, s2 = true) {
    this._view.localTransform.setMat(t2, e2), s2 && this.updateModelTransform(t2);
  }
  getLocalTransform(t2, e2) {
    this._view.localTransform.getMat(t2, e2);
  }
  setGlobalTransform(t2, e2, s2 = true) {
    this._view.globalTransform.setMat(t2, e2), s2 && this.updateModelTransform(t2);
  }
  getGlobalTransform(t2, e2) {
    this._view.globalTransform.getMat(t2, e2);
  }
  updateModelTransform(t2) {
    const a2 = this._view, o2 = C$5, h2 = b$4;
    a2.localTransform.getMat(t2, R$4), a2.globalTransform.getMat(t2, w$5);
    const l2 = u$p(w$5, w$5, R$4);
    o$7(o2, l2[12], l2[13], l2[14]), a2.modelOrigin.setVec(t2, o2), a$h(h2, l2), a2.model.setMat(t2, h2);
    const c2 = p$e(C$5, l2);
    c2.sort(), a2.modelScaleFactors.set(t2, 0, c2[1]), a2.modelScaleFactors.set(t2, 1, c2[2]), u$r(h2, h2), o$l(h2, h2), a2.modelNormal.setMat(t2, h2), this._setStateFlags(t2, O$2.TRANSFORM_CHANGED), this.emit("instance-transform-changed", { index: t2 });
  }
  getModelTransform(t2, e2) {
    const s2 = this._view;
    s2.model.getMat(t2, b$4), s2.modelOrigin.getVec(t2, C$5), e2[0] = b$4[0], e2[1] = b$4[1], e2[2] = b$4[2], e2[3] = 0, e2[4] = b$4[3], e2[5] = b$4[4], e2[6] = b$4[5], e2[7] = 0, e2[8] = b$4[6], e2[9] = b$4[7], e2[10] = b$4[8], e2[11] = 0, e2[12] = C$5[0], e2[13] = C$5[1], e2[14] = C$5[2], e2[15] = 1;
  }
  applyShaderTransformation(t2, e2) {
    this._shaderTransformation && this._shaderTransformation.applyTransform(this, t2, e2);
  }
  getCombinedModelTransform(t2, e2) {
    return this.getModelTransform(t2, e2), this._shaderTransformation && this._shaderTransformation.applyTransform(this, t2, e2), e2;
  }
  getCombinedLocalTransform(t2, e2) {
    return this._view.localTransform.getMat(t2, e2), this._shaderTransformation && this._shaderTransformation.applyTransform(this, t2, e2), e2;
  }
  getCombinedMaxScaleFactor(t2) {
    let e2 = this._view.modelScaleFactors.get(t2, 1);
    if (this._shaderTransformation) {
      const s2 = this._shaderTransformation.scaleFactor(C$5, this, t2);
      e2 *= Math.max(s2[0], s2[1], s2[2]);
    }
    return e2;
  }
  getCombinedMedianScaleFactor(t2) {
    let e2 = this._view.modelScaleFactors.get(t2, 0);
    if (this._shaderTransformation) {
      const s2 = this._shaderTransformation.scaleFactor(C$5, this, t2);
      e2 *= I$2(s2[0], s2[1], s2[2]);
    }
    return e2;
  }
  getModel(t2, e2) {
    this._view.model.getMat(t2, e2);
  }
  setFeatureAttribute(t2, e2) {
    this._view.featureAttribute.setVec(t2, e2);
  }
  getFeatureAttribute(t2, e2) {
    this._view.featureAttribute.getVec(t2, e2);
  }
  setColor(t2, e2) {
    this._view.color.setVec(t2, e2);
  }
  setObjectAndLayerIdColor(t2, e2) {
    this._view.objectAndLayerIdColor.setVec(t2, e2);
  }
  getColor(t2, e2) {
    this._view.color.getVec(t2, e2);
  }
  setVisible(t2, e2) {
    e2 !== this.getVisible(t2) && (this._setStateFlag(t2, O$2.VISIBLE, e2), this.emit("instance-visibility-changed", { index: t2 }));
  }
  getVisible(t2) {
    return this._getStateFlag(t2, O$2.VISIBLE);
  }
  setHighlight(t2, e2) {
    e2 !== this.getHighlight(t2) && (this._setStateFlag(t2, O$2.HIGHLIGHT, e2), this.emit("instance-highlight-changed", { index: t2 }));
  }
  getHighlight(t2) {
    return this._getStateFlag(t2, O$2.HIGHLIGHT);
  }
  getState(t2) {
    return this._view.state.get(t2);
  }
  getLodLevel(t2) {
    return this._view.lodLevel.get(t2);
  }
  countFlags(t2) {
    let e2 = 0;
    for (let s2 = 0; s2 < this._capacity; ++s2) {
      this.getState(s2) & t2 && ++e2;
    }
    return e2;
  }
  _setStateFlags(t2, e2) {
    const s2 = this._view.state;
    e2 = s2.get(t2) | e2, s2.set(t2, e2);
  }
  _clearStateFlags(t2, e2) {
    const s2 = this._view.state;
    e2 = s2.get(t2) & ~e2, s2.set(t2, e2);
  }
  _setStateFlag(t2, e2, s2) {
    s2 ? this._setStateFlags(t2, e2) : this._clearStateFlags(t2, e2);
  }
  _getStateFlag(t2, e2) {
    return !!(this._view.state.get(t2) & e2);
  }
  _grow() {
    const t2 = Math.max(S$4, Math.floor(this._capacity * p$4)), e2 = this._layout.createBuffer(t2);
    if (this._buffer) {
      const t3 = new Uint8Array(this._buffer.buffer);
      new Uint8Array(e2.buffer).set(t3);
    }
    this._capacity = t2, this._buffer = e2, this._view = new v$4(this._buffer);
  }
  _findSlot() {
    const t2 = this._view.state;
    let e2 = this._next;
    for (; t2.get(e2) & O$2.ALLOCATED; )
      e2 = e2 + 1 === this._capacity ? 0 : e2 + 1;
    return this._next = e2 + 1 === this._capacity ? 0 : e2 + 1, e2;
  }
}
function I$2(t2, e2, s2) {
  return Math.max(Math.min(t2, e2), Math.min(Math.max(t2, e2), s2));
}
const S$4 = 1024, p$4 = 2, C$5 = n$h(), b$4 = e$o(), R$4 = e$e(), w$5 = e$e();
class n$4 extends G$5 {
  constructor(e2, r2) {
    super((t2) => w$c(this._instanceData.view.boundingSphere.getVec(t2, this._tmpSphere)), { maximumDepth: 25 }), this._tmpSphere = R$b(), this._tmpMat4 = e$e(), this._instanceData = e2, this._boundingSphere = r2;
  }
  addInstance(t2) {
    const s2 = this._instanceData.view.boundingSphere, i2 = this._instanceData.getCombinedModelTransform(t2, this._tmpMat4);
    O$9(this._tmpSphere, this._boundingSphere.center, i2), this._tmpSphere[3] = this._boundingSphere.radius * l$p(i2), s2.setVec(t2, this._tmpSphere), this.add([t2]);
  }
  removeInstance(t2) {
    this.remove([t2]);
  }
}
class t$3 {
  constructor(t2, s2) {
    this.thresholdScale = 1, this._camera = new J$3(), this._worldSpaceRadius = t2, this._thresholds = s2.map((e2) => e2);
  }
  updateCamera(e2) {
    this._camera.copyFrom(e2);
  }
  selectLevel(e2, t2) {
    const s2 = this._camera.computeScreenPixelSizeAt(e2), r2 = this._worldSpaceRadius * t2 / s2, a2 = this._thresholds;
    let h2 = -1;
    for (let o2 = 0; o2 < a2.length; ++o2)
      r2 >= a2[o2] * this.thresholdScale && (h2 = o2);
    return h2;
  }
}
class m$2 {
  constructor(s2, o2) {
    const i2 = s2.renderContext.rctx, { geometry: m2, material: u2 } = o2;
    this._materialRepository = s2.materialRep, u2.setParameters({ instancedDoublePrecision: true });
    const f2 = u2.createBufferWriter(), d2 = f2.vertexBufferLayout, p2 = f2.elementCount(m2), c2 = f2.allocate(p2);
    f2.write(null, null, m2, c2, 0), this.geometry = m2, this.material = u2, this.glMaterials = new e$w(u2, this._materialRepository), this.vertexBufferLayout = d2, this.vbo = E$i.createVertex(i2, F$9.STATIC_DRAW, c2.buffer), this.vao = new r$p(i2, E$d, { geometry: o$m(d2) }, { geometry: this.vbo }), this.vertexCount = p2;
  }
  destroy() {
    this.glMaterials.destroy(), this.vbo.dispose(), this.vao.dispose();
  }
  get boundingInfo() {
    return this.geometry.boundingInfo;
  }
  get triangleCount() {
    return this.vertexCount / 3;
  }
  intersect(r2, t2, e2, a2, n2, l2, m2, u2) {
    const f2 = this.geometry.id;
    this.material.intersect(this.geometry, null, r2.transform.transform, r2, e2, a2, (e3, a3, d2, p2, c2) => {
      if (e3 >= 0) {
        if (t2 != null && !t2(r2.rayBegin, r2.rayEnd, e3))
          return;
        const p3 = { layerUid: l2.layerUid, graphicUid: l2.graphicUid(n2), geometryId: f2, triangleNr: d2, baseBoundingSphere: m2, numLodLevels: u2 };
        if ((r2.results.min.drapedLayerOrder == null || c2 >= r2.results.min.drapedLayerOrder) && (r2.results.min.dist == null || e3 < r2.results.min.dist) && r2.results.min.set(i$j.LOD, p3, e3, a3, r2.transform.transform, c2), r2.options.store !== t$l.MIN && (r2.results.max.drapedLayerOrder == null || c2 >= r2.results.max.drapedLayerOrder) && (r2.results.max.dist == null || e3 > r2.results.max.dist) && r2.results.max.set(i$j.LOD, p3, e3, a3, r2.transform.transform, c2), r2.options.store === t$l.ALL) {
          const t3 = U$5(r2.results.min.ray);
          t3.set(i$j.LOD, p3, e3, a3, r2.transform.transform, c2), r2.results.all.push(t3);
        }
      }
    });
  }
}
class h$3 {
  constructor(n2, o2) {
    this.minScreenSpaceRadius = n2, this.components = o2;
  }
  static async create(n2, o2, i2) {
    const r2 = await Promise.allSettled(o2.components.map((o3) => n2.schedule(() => new m$2(n2, o3), i2))), s2 = r2.map((n3) => n3.status === "fulfilled" ? n3.value : null).filter((n3) => n3);
    if (p$f(i2) || s2.length !== r2.length) {
      s2.forEach((n3) => n3.destroy()), f$a(i2);
      for (const n3 of r2)
        if (n3.status === "rejected")
          throw n3.reason;
    }
    return new h$3(o2.minScreenSpaceRadius, s2);
  }
  destroy() {
    this.components.forEach((n2) => n2.destroy());
  }
  intersect(n2, o2, t2, e2, i2, r2, s2) {
    this.components.forEach((c2) => c2.intersect(n2, o2, t2, e2, i2, r2, this.boundingSphere, s2));
  }
  get boundingBox() {
    if (t$7(this._boundingBox)) {
      const n2 = A$6();
      this.components.forEach((t2) => {
        r$d(t2.boundingInfo) && (c$q(n2, t2.boundingInfo.bbMin), c$q(n2, t2.boundingInfo.bbMax));
      }), this._boundingBox = n2;
    }
    return this._boundingBox;
  }
  get boundingSphere() {
    if (t$7(this._boundingSphere)) {
      const n2 = this.boundingBox, o2 = n$h();
      p$9(n2, o2), this._boundingSphere = { center: o2, radius: 0.5 * g$h(n2) };
    }
    return this._boundingSphere;
  }
  get triangleCount() {
    return this.components.reduce((n2, o2) => n2 + o2.triangleCount, 0);
  }
}
class r$4 {
  constructor(r2, i2, s2) {
    this._elementSize = i2, this._buffer = E$i.createVertex(r2, F$9.STATIC_DRAW), this.resize(s2);
  }
  destroy() {
    this._buffer.dispose();
  }
  get elementSize() {
    return this._elementSize;
  }
  get capacity() {
    return this._capacity;
  }
  get array() {
    return this._array;
  }
  get buffer() {
    return this._buffer;
  }
  get memoryUsage() {
    return { cpu: this._capacity * this._elementSize, gpu: this._capacity * this._elementSize };
  }
  copyRange(e2, t2, r2, i2 = 0) {
    const s2 = new Uint8Array(this.array, e2 * this.elementSize, (t2 - e2) * this.elementSize);
    new Uint8Array(r2.array, i2 * this.elementSize).set(s2);
  }
  transferAll() {
    this._buffer.setData(this._array);
  }
  transferRange(e2, t2) {
    const r2 = e2 * this._elementSize, i2 = t2 * this._elementSize;
    this._buffer.setSubData(new Uint8Array(this._array), r2, r2, i2);
  }
  resize(e2) {
    const t2 = e2 * this._elementSize, r2 = new ArrayBuffer(t2);
    this._array && (e2 >= this._capacity ? new Uint8Array(r2).set(new Uint8Array(this._array)) : new Uint8Array(r2).set(new Uint8Array(this._array).subarray(0, e2 * this._elementSize))), this._array = r2, this._buffer.setSize(t2), this._capacity = e2;
  }
}
class n$3 {
  constructor(a2) {
    this.modelOriginHi = a2.getField(O$8.MODELORIGINHI, i$i), this.modelOriginLo = a2.getField(O$8.MODELORIGINLO, i$i), this.model = a2.getField(O$8.MODEL, l$o), this.modelNormal = a2.getField(O$8.MODELNORMAL, l$o), this.color = a2.getField(O$8.INSTANCECOLOR, c$r), this.featureAttribute = a2.getField(O$8.INSTANCEFEATUREATTRIBUTE, c$r), this.objectAndLayerIdColor = a2.getField(O$8.OBJECTANDLAYERIDCOLOR_INSTANCED, x$f);
  }
}
class d$7 {
  constructor(t2, i2) {
    this._headIndex = 0, this._tailIndex = 0, this._firstIndex = null, this._captureFirstIndex = true, this._updating = false, this._prevHeadIndex = 0, this._resized = false, this._rctx = t2, this._instanceBufferLayout = i2, this._elementSize = i2.stride, this._capacity = 1;
  }
  destroy() {
    this._buffer && this._buffer.destroy();
  }
  get buffer() {
    return this._buffer.buffer;
  }
  get view() {
    return this._view;
  }
  get capacity() {
    return this._capacity;
  }
  get size() {
    const t2 = this._headIndex, i2 = this._tailIndex;
    return t2 >= i2 ? t2 - i2 : t2 + this._capacity - i2;
  }
  get isEmpty() {
    return this._headIndex === this._tailIndex;
  }
  get isFull() {
    return this._tailIndex === (this._headIndex + 1) % this._capacity;
  }
  get headIndex() {
    return this._headIndex;
  }
  get tailIndex() {
    return this._tailIndex;
  }
  get firstIndex() {
    return this._firstIndex;
  }
  get memoryUsage() {
    return this._buffer ? this._buffer.memoryUsage : { cpu: 0, gpu: 0 };
  }
  reset() {
    this._headIndex = 0, this._tailIndex = 0, this._firstIndex = null;
  }
  startUpdateCylce() {
    this._captureFirstIndex = true;
  }
  beginUpdate() {
    e$v(!this._updating, "already updating"), this._updating = true, this._prevHeadIndex = this._headIndex;
  }
  endUpdate() {
    e$v(this._updating, "not updating"), this.size < f$3 * this.capacity && this._shrink(), this._resized ? (this._buffer.transferAll(), this._resized = false) : this._transferRange(this._prevHeadIndex, this._headIndex), this._updating = false;
  }
  allocateHead() {
    e$v(this._updating, "not updating"), this.isFull && this._grow();
    const t2 = this.headIndex;
    return this._captureFirstIndex && (this._firstIndex = t2, this._captureFirstIndex = false), this._incrementHead(), e$v(this._headIndex !== this._tailIndex, "invalid pointers"), t2;
  }
  freeTail() {
    e$v(this._updating, "not updating"), e$v(this.size > 0, "invalid size");
    const t2 = this._tailIndex === this._firstIndex;
    this._incrementTail(), t2 && (this._firstIndex = this._tailIndex);
  }
  _grow() {
    const t2 = Math.max(_$6, Math.floor(this._capacity * c$3));
    this._resize(t2);
  }
  _shrink() {
    const t2 = Math.max(_$6, Math.floor(this._capacity * u$5));
    this._resize(t2);
  }
  _resize(t2) {
    if (e$v(this._updating, "not updating"), t2 === this._capacity)
      return;
    const i2 = new r$4(this._rctx, this._elementSize, t2);
    if (this._buffer) {
      this._firstIndex && (this._firstIndex = (this._firstIndex + this._capacity - this._tailIndex) % this._capacity);
      const t3 = this.size, e2 = this._compactInstances(i2);
      e$v(e2 === t3, "invalid compaction"), this._buffer.destroy(), this._tailIndex = 0, this._headIndex = e2, this._prevHeadIndex = 0;
    }
    this._resized = true, this._capacity = t2, this._buffer = i2, this._view = new n$3(this._instanceBufferLayout.createView(this._buffer.array));
  }
  _compactInstances(t2) {
    const i2 = this._headIndex, e2 = this._tailIndex;
    return e2 < i2 ? (this._buffer.copyRange(e2, i2, t2), i2 - e2) : e2 > i2 ? (this._buffer.copyRange(e2, this._capacity, t2), i2 > 0 && this._buffer.copyRange(0, i2, t2, this._capacity - e2), i2 + (this._capacity - e2)) : 0;
  }
  _incrementHead(t2 = 1) {
    this._headIndex = (this._headIndex + t2) % this._capacity;
  }
  _incrementTail(t2 = 1) {
    this._tailIndex = (this._tailIndex + t2) % this._capacity;
  }
  _transferRange(t2, i2) {
    t2 < i2 ? this._buffer.transferRange(t2, i2) : t2 > i2 && (i2 > 0 && this._buffer.transferRange(0, i2), this._buffer.transferRange(t2, this._capacity));
  }
}
const _$6 = 1024, c$3 = 2, f$3 = 0.3, u$5 = 0.5;
const x$6 = (e2) => {
  const t2 = e2.baseBoundingSphere.radius, a2 = e2.levels.map((e3) => e3.minScreenSpaceRadius);
  return new t$3(t2, a2);
};
class M$3 {
  constructor(e2, t2, a2, s2) {
    this.type = i$j.LOD, this.isGround = false, this._levels = [], this._defaultRenderInstanceData = [], this._highlightRenderInstanceData = [], this._instanceIndex = 0, this._slicePlane = false, this._lastCamera = new J$3(), this._updateCyclesWithStaticCamera = -1, this._needFullCycle = false, this.slots = [E$e.OPAQUE_MATERIAL, E$e.TRANSPARENT_MATERIAL], this.canRender = true, this._symbol = e2, this._optionalFields = t2, this._metadata = a2, this._instanceBufferLayout = B$8({ instancedDoublePrecision: true, instanced: t2 }), this._glInstanceBufferLayout = o$m(this._instanceBufferLayout, 1), this._instanceData = new M$4(this._optionalFields, s2), this._instanceData.on("instance-added", () => this._requestUpdateCycle()), this._instanceData.on("instance-removed", () => this._requestUpdateCycle()), this._instanceData.on("instance-transform-changed", (e3) => {
      this._requestUpdateCycle(), this._metadata.notifyGraphicGeometryChanged(e3.index);
    }), this._instanceData.on("instance-visibility-changed", (e3) => {
      this._requestUpdateCycle(true), this._metadata.notifyGraphicVisibilityChanged(e3.index);
    }), this._instanceData.on("instance-highlight-changed", () => this._requestUpdateCycle(true)), this._enableLevelSelection = this._symbol.levels.length > 1;
  }
  get levels() {
    return this._levels;
  }
  get baseBoundingBox() {
    return this._levels[this._levels.length - 1].boundingBox;
  }
  get baseBoundingSphere() {
    return this._levels[this._levels.length - 1].boundingSphere;
  }
  get baseMaterial() {
    return this._levels[this._levels.length - 1].components[0].material;
  }
  get slicePlaneEnabled() {
    return this._slicePlane;
  }
  set slicePlaneEnabled(e2) {
    this._slicePlane = e2;
  }
  get layerUid() {
    return this._metadata.layerUid;
  }
  get instanceData() {
    return this._instanceData;
  }
  get memoryUsage() {
    const e2 = { cpu: 0, gpu: 0 };
    return this._defaultRenderInstanceData.forEach((t2) => {
      const a2 = t2.memoryUsage;
      e2.cpu += a2.cpu, e2.gpu += a2.gpu;
    }), this._highlightRenderInstanceData.forEach((t2) => {
      const a2 = t2.memoryUsage;
      e2.cpu += a2.cpu, e2.gpu += a2.gpu;
    }), e2;
  }
  get renderStats() {
    const e2 = this._instanceData.size, t2 = [];
    return this._levels.forEach((e3, a2) => {
      const s2 = this._defaultRenderInstanceData[a2], n2 = this._highlightRenderInstanceData[a2], i2 = s2.size + n2.size, r2 = e3.triangleCount;
      t2.push({ renderedInstances: i2, renderedTriangles: i2 * r2, trianglesPerInstance: r2 });
    }), { totalInstances: e2, renderedInstances: t2.reduce((e3, t3) => e3 + t3.renderedInstances, 0), renderedTriangles: t2.reduce((e3, t3) => e3 + t3.renderedTriangles, 0), levels: t2 };
  }
  async initializeRenderContext(e2, t2) {
    this._context = e2;
    const a2 = e2.renderContext.rctx, i2 = await Promise.allSettled(this._symbol.levels.map((s2) => (this._defaultRenderInstanceData.push(new d$7(a2, this._instanceBufferLayout)), this._highlightRenderInstanceData.push(new d$7(a2, this._instanceBufferLayout)), h$3.create(e2, s2, t2)))), r2 = i2.map((e3) => e3.status === "fulfilled" ? e3.value : null).filter((e3) => e3);
    if (p$f(t2) || r2.length !== i2.length) {
      r2.forEach((e3) => e3.destroy()), f$a(t2);
      for (const e3 of i2)
        if (e3.status === "rejected")
          throw e3.reason;
    }
    this._levels = r2, this._levelSelector = x$6(this);
  }
  uninitializeRenderContext() {
    this._invalidateOctree(), this._levels.forEach((e2) => e2.destroy()), this._defaultRenderInstanceData.forEach((e2) => e2.destroy()), this._highlightRenderInstanceData.forEach((e2) => e2.destroy());
  }
  get needsTransparentPass() {
    return this._levels.some((e2) => e2.components.some((e3) => e3.material.requiresSlot(E$e.TRANSPARENT_MATERIAL, h$b.Color)));
  }
  get needsHighlight() {
    return this._highlightRenderInstanceData.some((e2) => e2.size > 0);
  }
  prepareRender(e2) {
    if (t$9.LOD_INSTANCE_RENDERER_DISABLE_UPDATES)
      return;
    if (this._enableLevelSelection) {
      const t3 = e2.bindParameters.contentCamera.equals(this._lastCamera);
      this._lastCamera.copyFrom(e2.bindParameters.contentCamera), t3 || this._requestUpdateCycle();
    }
    const t2 = this._needFullCycle ? this._instanceData.size : 2e3;
    this._needFullCycle = false, this._updateInstances(e2.bindParameters.contentCamera, t2), this._needsUpdates && this._context.requestRender();
  }
  render(e2) {
    if (!this.baseMaterial.isVisible() || !this.baseMaterial.isVisibleForOutput(e2.output))
      return;
    e2.rctx.bindVAO();
    e2.output !== h$b.Highlight && e2.output !== h$b.ShadowHighlight && this._renderComponents(e2, this._defaultRenderInstanceData);
    e2.output !== h$b.ShadowExludeHighlight && this._renderComponents(e2, this._highlightRenderInstanceData);
  }
  intersect(e2, t2, a2, s2) {
    if (!this.baseMaterial.isVisible())
      return;
    const n2 = n$h();
    e$n(n2, s2, a2);
    const i2 = (n3) => {
      this._instanceData.getCombinedModelTransform(n3, q$3), e2.transform.set(q$3), O$9(H$4, a2, e2.transform.inverse), O$9(B$2, s2, e2.transform.inverse);
      const i3 = this._instanceData.getState(n3), r2 = this._instanceData.getLodLevel(n3), o2 = this._levels.length;
      e$v(i3 & O$2.ACTIVE, "invalid instance state"), e$v(r2 >= 0 && r2 < o2, "invaid lod level"), this._levels[r2].intersect(e2, t2, H$4, B$2, n3, this._metadata, o2);
    };
    this.baseMaterial.parameters.verticalOffset ? this._octree.forEach(i2) : this._octree.forEachAlongRay(a2, n2, i2);
  }
  queryDepthRange(e2) {
    return this._queryDepthRangeOctree(e2);
  }
  notifyShaderTransformationChanged() {
    this._invalidateOctree();
  }
  _requestUpdateCycle(e2 = false) {
    this._updateCyclesWithStaticCamera = -1, e2 && (this._needFullCycle = true), this._needsUpdates && this._context.requestRender();
  }
  get _needsUpdates() {
    return this._instanceData.size > 0 && this._updateCyclesWithStaticCamera < 1;
  }
  get _octree() {
    return t$7(this._octreeCached) && (this._octreeCached = this._buildOctree()), this._octreeCached;
  }
  _invalidateOctree() {
    this._octreeCached = s$j(this._octreeCached);
  }
  _buildOctree() {
    const e2 = new n$4(this._instanceData, this.baseBoundingSphere), t2 = this._instanceData, a2 = t2.view ? t2.view.state : null;
    for (let s2 = 0; s2 < this._instanceData.capacity; ++s2) {
      a2.get(s2) & O$2.ACTIVE && e2.addInstance(s2);
    }
    return e2;
  }
  _queryDepthRangeOctree(e2) {
    const t2 = e2.eye, a2 = e2.viewForward, s2 = this._octree.findClosest(a2, G$5.DepthOrder.FRONT_TO_BACK, e2.frustum), n2 = this._octree.findClosest(a2, G$5.DepthOrder.BACK_TO_FRONT, e2.frustum);
    if (s2 != null && n2 != null) {
      this._instanceData.view.boundingSphere.getVec(s2, N$3), e$n(N$3, N$3, t2);
      const i2 = P$9(N$3, a2) - N$3[3];
      this._instanceData.view.boundingSphere.getVec(n2, N$3), e$n(N$3, N$3, t2);
      const l2 = P$9(N$3, a2) + N$3[3];
      return { near: Math.max(e2.near, i2), far: Math.min(e2.far, l2) };
    }
    return { near: 1 / 0, far: -1 / 0 };
  }
  _startUpdateCycle() {
    this._updateCyclesWithStaticCamera++, this._defaultRenderInstanceData.forEach((e2) => {
      e2.startUpdateCylce();
    }), this._highlightRenderInstanceData.forEach((e2) => {
      e2.startUpdateCylce();
    }), this._needsUpdates && this._context.requestRender();
  }
  _updateInstances(e2, t2) {
    const s2 = this._enableLevelSelection, n2 = this._levelSelector;
    n2.updateCamera(e2), this._defaultRenderInstanceData.forEach((e3) => e3.beginUpdate()), this._highlightRenderInstanceData.forEach((e3) => e3.beginUpdate());
    const i2 = this._instanceData, r2 = this._instanceData.view, o2 = i2.size, l2 = i2.capacity;
    let c2 = this._instanceIndex;
    t2 = Math.min(o2, t2);
    for (let h2 = 0; h2 < t2; ++h2) {
      c2 === 0 && this._startUpdateCycle();
      const e3 = r2.state.get(c2);
      let o3 = 0;
      if (!(e3 & O$2.ALLOCATED)) {
        c2 = c2 + 1 === l2 ? 0 : c2 + 1, t2++;
        continue;
      }
      const h3 = r2.lodLevel.get(c2);
      if (e3 & O$2.DEFAULT_ACTIVE && this._defaultRenderInstanceData[h3].freeTail(), e3 & O$2.HIGHLIGHT_ACTIVE && this._highlightRenderInstanceData[h3].freeTail(), e3 & O$2.REMOVE)
        i2.freeInstance(c2);
      else if (e3 & O$2.VISIBLE) {
        let t3 = 0;
        s2 && (r2.modelOrigin.getVec(c2, w$4), t3 = n2.selectLevel(w$4, i2.getCombinedMedianScaleFactor(c2))), o3 = e3 & ~(O$2.ACTIVE | O$2.TRANSFORM_CHANGED), t3 >= 0 && (e3 & O$2.HIGHLIGHT ? (V$1(this._highlightRenderInstanceData[t3], r2, c2), o3 |= O$2.HIGHLIGHT_ACTIVE) : (V$1(this._defaultRenderInstanceData[t3], r2, c2), o3 |= O$2.DEFAULT_ACTIVE)), r2.state.set(c2, o3), r2.lodLevel.set(c2, t3);
      } else
        o3 = e3 & ~(O$2.ACTIVE | O$2.TRANSFORM_CHANGED), r2.state.set(c2, o3);
      if (r$d(this._octreeCached)) {
        const t3 = !!(e3 & O$2.ACTIVE), a2 = !!(o3 & O$2.ACTIVE);
        !t3 && a2 ? this._octreeCached.addInstance(c2) : t3 && !a2 ? this._octreeCached.removeInstance(c2) : t3 && a2 && e3 & O$2.TRANSFORM_CHANGED && (this._octreeCached.removeInstance(c2), this._octreeCached.addInstance(c2));
      }
      c2 = c2 + 1 === l2 ? 0 : c2 + 1;
    }
    this._instanceIndex = c2, this._defaultRenderInstanceData.forEach((e3) => e3.endUpdate()), this._highlightRenderInstanceData.forEach((e3) => e3.endUpdate());
  }
  _renderComponents(e2, t2) {
    this.levels.forEach((a2, s2) => {
      a2.components.forEach((a3) => {
        this._renderComponent(e2, t2[s2], a3, s2);
      });
    });
  }
  _renderComponent(t2, a2, s2, n2) {
    const { bindParameters: i2, rctx: r2, output: o2 } = t2;
    if (a2.size === 0 || !s2.material.requiresSlot(i2.slot, t2.output))
      return;
    const l2 = s2.glMaterials.load(r2, i2.slot, o2);
    if (t$7(l2))
      return;
    const c2 = l2.beginSlot(i2), h2 = r2.bindTechnique(c2, s2.material.parameters, i2);
    r2.bindVAO(s2.vao), c2.ensureAttributeLocations(s2.vao), h2.bindDraw(G$3, i2, s2.material.parameters), t$9.LOD_INSTANCE_RENDERER_COLORIZE_BY_LEVEL && t2.output === h$b.Color && (h2.setUniform4fv("externalColor", P$3[Math.min(n2, P$3.length - 1)]), h2.setUniform1i("colorMixMode", U$6.replace));
    const d2 = r2.capabilities.instancing, _2 = a2.capacity, f2 = a2.headIndex, g2 = a2.tailIndex, C2 = a2.firstIndex, I2 = this._glInstanceBufferLayout, y2 = (e2, t3) => {
      R$c(r2, E$d, a2.buffer, I2, e2), d2.drawArraysInstanced(c2.primitiveType, 0, s2.vertexCount, t3 - e2), E$k(r2, E$d, a2.buffer, I2);
    };
    s2.material.parameters.transparent && C2 != null ? f2 > g2 ? (e$v(C2 >= g2 && C2 <= f2, "invalid firstIndex"), y2(C2, f2), y2(g2, C2)) : f2 < g2 && (C2 <= f2 ? (e$v(C2 >= 0 && C2 <= f2, "invalid firstIndex"), y2(C2, f2), y2(g2, _2), y2(0, C2)) : (e$v(C2 >= g2 && C2 <= _2, "invalid firstIndex"), y2(C2, _2), y2(0, f2), y2(g2, C2))) : f2 > g2 ? y2(g2, f2) : f2 < g2 && (y2(0, f2), y2(g2, _2)), r2.bindVAO(null);
  }
}
function V$1(e2, t2, a2) {
  const s2 = e2.allocateHead();
  F$4(t2, a2, e2.view, s2);
}
function F$4(e2, t2, a2, s2) {
  p$g(e2.modelOrigin, t2, a2.modelOriginHi, a2.modelOriginLo, s2), a2.model.copyFrom(s2, e2.model, t2), a2.modelNormal.copyFrom(s2, e2.modelNormal, t2), e2.color && a2.color && a2.color.copyFrom(s2, e2.color, t2), e2.objectAndLayerIdColor && a2.objectAndLayerIdColor && a2.objectAndLayerIdColor.copyFrom(s2, e2.objectAndLayerIdColor, t2), e2.featureAttribute && a2.featureAttribute && a2.featureAttribute.copyFrom(s2, e2.featureAttribute, t2);
}
const w$4 = n$h(), N$3 = n$m(), q$3 = e$e(), H$4 = n$h(), B$2 = n$h(), P$3 = [r$f(1, 0, 1, 1), r$f(0, 0, 1, 1), r$f(0, 1, 0, 1), r$f(1, 1, 0, 1), r$f(1, 0, 0, 1)], G$3 = new E$j();
class me$1 extends y$9 {
  constructor(e2, t2, s2, r2) {
    super(e2, t2, s2, r2), this._resources = null, this._optionalFields = new Array(), this._instanceIndexToGraphicUid = new Map(), this._hasLoadedPBRTextures = false, this._disposeResourceHandles = new Array(), this.ensureDrapedStatus(false), this._hasLoadedPBRTextures = s2.physicalBasedRenderingEnabled;
  }
  getCachedSize() {
    const [e2, s2, r2] = r$d(this._resources) ? this._resources.symbolSize : [1, 1, 1];
    return { width: e2, depth: s2, height: r2 };
  }
  async doLoad(e2) {
    if (!this._drivenProperties.size) {
      if (S$f(this.symbolLayer))
        throw new Error();
    }
    const t2 = this.symbolLayer;
    if (this._isPrimitive) {
      const s2 = t2.resource ? t2.resource.primitive : d$g;
      this._resources = await this._createResourcesForPrimitive(s2, e2);
    } else
      this._resources = await this._createResourcesForUrl(t2.resource.href, e2);
    this.layerOpacityChanged(), this.slicePlaneEnabledChanged(), this.physicalBasedRenderingChanged(), this.complexity = this.computeComplexity();
  }
  get extentPadding() {
    return r$d(this._resources) ? this._resources.extentPadding : 0;
  }
  get _isPrimitive() {
    return !(this.symbolLayer.resource && this.symbolLayer.resource.href);
  }
  get lodRenderer() {
    return q$7(this._resources, "lodRenderer");
  }
  _setMaterialTransparencyParams(e2, t2 = q$7(this.symbolLayer, "material", "color")) {
    const r2 = this._getCombinedOpacity(t2), a2 = r2 < 1 || this.needsDrivenTransparentPass;
    return e2.transparent = a2, e2.opacity = r2, e2.cullFace = a2 ? n$l.None : n$l.Back, e2;
  }
  async _createResourcesForPrimitive(s2, a2) {
    if (!r$b(s2))
      throw new Error(`Unknown object symbol primitive: ${s2}`);
    const i2 = this.symbolLayer, n2 = a$b(c$s(s2)), c2 = e$l(F$a(n2)), l2 = e$l(t$m(c2, i2)), h2 = s$k(l2), d2 = false, m2 = false, u2 = { usePBR: this._context.physicalBasedRenderingEnabled, isSchematic: true, ambient: l$e, diffuse: l$e, hasSlicePlane: this._context.slicePlaneEnabled, hasSliceHighlight: false, castShadows: this.symbolLayer.castShadows, offsetTransparentBackfaces: !this.symbolLayer.isPrimitive }, y2 = u2.usePBR;
    this._setMaterialTransparencyParams(u2);
    const f2 = this.symbol;
    if (f2.type === "point-3d" && f2.verticalOffset) {
      const { screenLength: e2, minWorldLength: s3, maxWorldLength: r2 } = f2.verticalOffset;
      u2.verticalOffset = { screenLength: u$n(e2), minWorldLength: s3 || 0, maxWorldLength: r$d(r2) ? r2 : 1 / 0 }, u2.castShadows = false;
    }
    if (this._context.screenSizePerspectiveEnabled && (u2.screenSizePerspective = this._context.sharedResources.screenSizePerspectiveSettings), this._drivenProperties.color)
      u2.externalColor = _$e;
    else {
      const s3 = r$d(i2.material) && i2.material.color, r2 = r$d(s3) ? l$c.toUnitRGBA(s3) : _$e;
      u2.externalColor = r2;
    }
    this._fastUpdates = P$4(this._context.renderer, this._fastVisualVariableConvertOptions(n2, l2, c2, n$q)), u2.instanced = ["transformation"], this._fastUpdates.enabled ? (Object.assign(u2, this._fastUpdates.materialParameters), u2.instanced.push("featureAttribute"), this._optionalFields.push("featureAttribute")) : this._hasPerInstanceColor() && (u2.instanced.push("color"), this._optionalFields.push("color")), has("enable-feature:objectAndLayerId-rendering") && (u2.instanced.push("objectAndLayerIdColor"), this._optionalFields.push("objectAndLayerIdColor"));
    const _2 = new C$b(u2), P2 = o$5(s2, _2);
    if (!P2)
      throw new Error(`Unknown object symbol primitive: ${s2}`);
    const R2 = r$a(P2).map((e2) => ({ opacity: 1, transparent: e2.parameters.transparent })), v2 = await this._createStageResources(P2, y2);
    return { lodResources: P2, lodRenderer: await this._createLodRenderer(P2, a2), stageResources: v2, symbolSize: l2, extentPadding: h2, isEsriSymbolResource: d2, isWosr: m2, originalMaterialParameters: R2, physicalBasedRenderingEnabled: y2, resourceBoundingBox: n2, resourceSize: c2, pivotOffset: n$q };
  }
  async _createResourcesForUrl(e2, a2) {
    const i2 = ["transformation"], n2 = { materialParamsMixin: { instanced: i2, hasSlicePlane: this._context.slicePlaneEnabled, castShadows: this.symbolLayer.castShadows }, streamDataRequester: this._context.streamDataRequester, cache: this._context.sharedResources.objectResourceCache };
    this._fastUpdates = P$4(this._context.renderer, this._fastVisualVariableConvertOptions(n$q, n$q, n$q, n$q)), this._fastUpdates.enabled ? (Object.assign(n2.materialParamsMixin, this._fastUpdates.materialParameters), i2.push("featureAttribute"), this._optionalFields.push("featureAttribute")) : this._hasPerInstanceColor() && (i2.push("color"), this._optionalFields.push("color")), has("enable-feature:objectAndLayerId-rendering") && (i2.push("objectAndLayerIdColor"), this._optionalFields.push("objectAndLayerIdColor"));
    const c2 = this.symbol;
    if (c2.type === "point-3d" && c2.verticalOffset) {
      const { screenLength: e3, minWorldLength: s2, maxWorldLength: r2 } = c2.verticalOffset;
      n2.materialParamsMixin.verticalOffset = { screenLength: u$n(e3), minWorldLength: s2 || 0, maxWorldLength: r$d(r2) ? r2 : 1 / 0 }, n2.materialParamsMixin.castShadows = false;
    }
    n2.signal = a2, n2.usePBR = this._context.physicalBasedRenderingEnabled, n2.skipHighLods = this._context.skipHighSymbolLods;
    const l2 = n2.usePBR, h2 = await Y$4(e2, n2), d2 = h2.isEsriSymbolResource, m2 = h2.isWosr, u2 = o$1(h2.lods);
    n$5(u2), u2.levels.sort((e3, t2) => e3.minScreenSpaceRadius - t2.minScreenSpaceRadius), u2.levels[0].minScreenSpaceRadius = Math.min(2, u2.levels[0].minScreenSpaceRadius);
    const y2 = this._context, f2 = this.symbolLayer.material, _2 = this._getExternalColorParameters(f2), g2 = q$7(this.symbolLayer, "material", "color"), P2 = this._getCombinedOpacity(g2, { hasIntrinsicColor: true }), R2 = this.needsDrivenTransparentPass, v2 = r$a(u2), x2 = r$a(u2).map((e3) => ({ opacity: e3.parameters.opacity || 1, transparent: e3.parameters.transparent }));
    v2.forEach((e3) => {
      const t2 = e3.parameters;
      e3.setParameters(_2);
      const s2 = t2.opacity * P2, r2 = s2 < 1 || R2 || t2.transparent;
      e3.setParameters({ opacity: s2, transparent: r2 }), y2.screenSizePerspectiveEnabled && e3.setParameters({ screenSizePerspective: y2.sharedResources.screenSizePerspectiveSettings });
    });
    const L2 = h2.referenceBoundingBox, S2 = e$l(F$a(L2)), C2 = e$l(u2.levels[0].pivotOffset), j2 = e$l(t$m(S2, this.symbolLayer)), U2 = s$k(j2);
    R$6(this._fastUpdates, this._context.renderer, this._fastVisualVariableConvertOptions(L2, j2, S2, C2)) && v2.forEach((e3) => e3.setParameters(this._fastUpdates.materialParameters));
    const E2 = await this._createStageResources(u2, l2);
    return { lodResources: u2, lodRenderer: await this._createLodRenderer(u2, a2), stageResources: E2, symbolSize: j2, extentPadding: U2, isEsriSymbolResource: d2, isWosr: m2, originalMaterialParameters: x2, physicalBasedRenderingEnabled: l2, resourceBoundingBox: L2, resourceSize: S2, pivotOffset: C2 };
  }
  _addDisposeResource(e2) {
    this._disposeResourceHandles.push(e2);
  }
  async _createStageResources(e2, t2) {
    const s2 = this._context.stage, r2 = r$a(e2);
    t2 !== this._context.physicalBasedRenderingEnabled && this.physicalBasedRenderingChanged(), s2.addMany(r2), this._addDisposeResource(() => s2.removeMany(r2));
    const a2 = e$8(e2);
    s2.addMany(a2), this._addDisposeResource(() => s2.removeMany(a2)), await s2.load(a2);
    const i2 = t$6(e2);
    return s2.addMany(i2), this._addDisposeResource(() => s2.removeMany(i2)), { materials: r2, textures: a2, geometries: i2 };
  }
  async _createLodRenderer(e2, t2) {
    const s2 = this._context.stage, r2 = { layerUid: this._context.layer.uid, graphicUid: (e3) => this._instanceIndexToGraphicUid.get(e3), notifyGraphicGeometryChanged: (e3) => this._context.notifyGraphicGeometryChanged(this._instanceIndexToGraphicUid.get(e3)), notifyGraphicVisibilityChanged: (e3) => this._context.notifyGraphicVisibilityChanged(this._instanceIndexToGraphicUid.get(e3)) }, a2 = this._fastUpdates.enabled ? { applyTransform: (e3, t3, s3) => {
      e3.getFeatureAttribute(t3, _e$1), n$g(s3, B$3(this._fastUpdates.materialParameters, _e$1, s3));
    }, scaleFactor: (e3, t3, s3) => (t3.getFeatureAttribute(s3, _e$1), L$2(e3, this._fastUpdates.materialParameters, _e$1)) } : null, i2 = new M$3(e2, this._optionalFields, r2, a2);
    return i2.slicePlaneEnabled = this._context.slicePlaneEnabled, this._addDisposeResource(() => {
      s2.removeRenderPlugin(i2);
    }), await s2.addRenderPlugin(i2.slots, i2, t2), i2;
  }
  _getExternalColorParameters(s2) {
    const r2 = {};
    return this._drivenProperties.color ? r2.externalColor = _$e : r$d(s2) && r$d(s2.color) ? r2.externalColor = l$c.toUnitRGBA(s2.color) : (r2.externalColor = _$e, r2.colorMixMode = "ignore"), r2;
  }
  destroy() {
    super.destroy(), this._cleanupResources();
  }
  _cleanupResources() {
    this._disposeResourceHandles.forEach((e2) => e2()), this._disposeResourceHandles.length = 0, this._resources = null;
  }
  createGraphics3DGraphic(e2) {
    const t2 = e2.graphic;
    if (!this._validateGeometry(t2.geometry))
      return null;
    const s2 = d$9(t2.geometry);
    if (t$7(s2))
      return this.logger.warn(`unsupported geometry type for icon symbol: ${t2.geometry.type}`), null;
    const r2 = this.setGraphicElevationContext(t2, new h$8()), i2 = e2.renderingInfo;
    return this._createAs3DShape(t2, s2, i2, r2, t2.uid, e2.layer.uid);
  }
  notifyDestroyGraphicLayer(e2) {
    this._instanceIndexToGraphicUid.delete(e2.instanceIndex);
  }
  graphicLayerToGraphicId() {
    return 0;
  }
  layerOpacityChanged() {
    if (t$7(this._resources))
      return;
    const e2 = this._drivenProperties.opacity, t2 = !this._isPrimitive, r2 = this._resources.stageResources.materials, i2 = this._resources.originalMaterialParameters;
    for (let a2 = 0; a2 < r2.length; a2++) {
      const o2 = r2[a2], n2 = q$7(this.symbolLayer, "material", "color"), c2 = i2[a2], l2 = this._getCombinedOpacity(n2, { hasIntrinsicColor: t2 }) * c2.opacity, h2 = l2 < 1 || e2 || c2.transparent;
      o2.setParameters({ opacity: l2, transparent: h2 }), this._isPrimitive && o2.setParameters({ cullFace: h2 ? n$l.None : n$l.Back });
    }
  }
  layerElevationInfoChanged(e2, t2) {
    return this.updateGraphics3DGraphicElevationInfo(e2, t2, v$e);
  }
  slicePlaneEnabledChanged() {
    if (t$7(this._resources))
      return true;
    this._resources.lodRenderer.slicePlaneEnabled = this._context.slicePlaneEnabled;
    for (const e2 of this._resources.stageResources.materials)
      e2.setParameters({ hasSlicePlane: this._context.slicePlaneEnabled });
    return true;
  }
  physicalBasedRenderingChanged() {
    if (t$7(this._resources))
      return true;
    const { stageResources: e2, isWosr: t2 } = this._resources;
    for (const s2 of e2.materials)
      this._isPrimitive ? s2.setParameters({ usePBR: this._context.physicalBasedRenderingEnabled, isSchematic: true }) : t2 || s2.setParameters({ usePBR: this._context.physicalBasedRenderingEnabled, isSchematic: false });
    return this._hasLoadedPBRTextures !== false || this._context.physicalBasedRenderingEnabled !== true || (this._hasLoadedPBRTextures = true, false);
  }
  pixelRatioChanged() {
    return true;
  }
  applyRendererDiff(e2, t2) {
    if (t$7(this._resources))
      return e$a.Recreate_Symbol;
    const { stageResources: { materials: s2 }, lodRenderer: r2, resourceBoundingBox: i2, symbolSize: o2, resourceSize: n2, pivotOffset: c2 } = this._resources;
    for (const a2 in e2.diff) {
      if (a2 !== "visualVariables")
        return e$a.Recreate_Symbol;
      if (!R$6(this._fastUpdates, t2, this._fastVisualVariableConvertOptions(i2, o2, n2, c2)))
        return e$a.Recreate_Symbol;
      for (const e3 of s2)
        e3.setParameters(this._fastUpdates.materialParameters);
      r2.notifyShaderTransformationChanged();
    }
    return e$a.Fast_Update;
  }
  computeComplexity() {
    if (t$7(this._resources))
      return super.computeComplexity();
    const e2 = this._resources.lodResources, t2 = n$9(e2.levels[0]).reduce((e3, t3) => e3 + t3.indices.get(O$8.POSITION).length, 0) / 3, s2 = (e3) => Array.from(e3.vertexAttributes.values()).reduce((e4, t3) => {
      var _a, _b;
      return e4 + ((_b = (_a = t3.data.buffer) == null ? void 0 : _a.byteLength) != null ? _b : 0);
    }, 0) + Array.from(e3.indices.values()).reduce((e4, t3) => e4 + (Array.isArray(t3) ? 12 * t3.length : t3.buffer.byteLength), 0), r2 = e$8(e2).reduce((e3, t3) => e3 + t3.estimatedTexMemRequired, 0) / 4 + t$6(e2).reduce((e3, t3) => e3 + s2(t3), 0);
    return { primitivesPerFeature: t2, primitivesPerCoordinate: 0, drawCallsPerFeature: 0, estimated: false, memory: __spreadProps(__spreadValues({}, l$8(this.symbol, this.symbolLayer)), { resourceBytes: r2 }) };
  }
  _hasLodRenderer() {
    return r$d(this._resources);
  }
  _createAs3DShape(e2, s2, r2, i2, o2, n2) {
    if (!this._hasLodRenderer() || t$7(this._resources))
      return null;
    const c2 = this.getFastUpdateAttrValues(e2), l2 = !this._fastUpdates.enabled && this._hasPerInstanceColor() ? B$5(r2.color, r2.opacity) : null, h2 = this._context.clippingExtent;
    if (gn(s2, ue$1, this._context.elevationProvider.spatialReference), r$d(h2) && !E$c(h2, ue$1))
      return null;
    const d2 = this._requiresTerrainElevation(i2), p2 = this._computeGlobalTransform(s2, i2, fe$1, be), m2 = this._computeLocalTransform(this._resources, this.symbolLayer, r2, ye$1), u2 = this._resources.lodRenderer.instanceData, y2 = u2.addInstance();
    this._instanceIndexToGraphicUid.set(y2, o2), u2.setLocalTransform(y2, m2, false), u2.setGlobalTransform(y2, p2), c2 && u2.setFeatureAttribute(y2, c2), l2 && u2.setColor(y2, l2), has("enable-feature:objectAndLayerId-rendering") && u2.setObjectAndLayerIdColor(y2, this._context.stage.renderView._objectAndLayerIdRenderHelper.getObjectAndLayerIdColor({ graphicUid: o2, layerUid: n2 }));
    const f2 = new f$4(this, y2, I$6, i2);
    return d2 && (f2.alignedSampledElevation = be.sampledElevation), f2.needsElevationUpdates = v$e(i2.mode), f$7(f2, s2, this._context.elevationProvider), f2;
  }
  _computeGlobalTransform(e2, t2, s2, r2) {
    return d$e(e2, this._context.elevationProvider, t2, this._context.renderCoordsHelper, r2), ue$1[0] = e2.x, ue$1[1] = e2.y, ue$1[2] = r2.z, Zn(e2.spatialReference, ue$1, s2, this._context.renderCoordsHelper.spatialReference), s2;
  }
  _computeLocalTransform(e2, t2, s2, r2) {
    return r$j(r2), this._applyObjectRotation(s2, false, r2), this._applyObjectRotation(t2, true, r2), this._applyObjectScale(e2, s2, r2), this._applyAnchor(e2, t2, r2), r2;
  }
  _applyObjectScale(e2, t2, s2) {
    if (this._fastUpdates.enabled && this._fastUpdates.requiresShaderTransformation)
      return;
    const r2 = this._drivenProperties.size && t2.size ? t2.size : e2.symbolSize, a2 = I$9(r2, e2.symbolSize, e2.resourceSize, this._context.renderCoordsHelper.unitInMeters);
    a2[0] === 1 && a2[1] === 1 && a2[2] === 1 || i$d(s2, s2, a2);
  }
  prepareSymbolLayerPatch(e2) {
    if (e2.diff.type !== "partial")
      return;
    const t2 = e2.diff.diff;
    this._preparePatchTransform(e2, t2), this._preparePatchColor(e2, t2);
  }
  updateGeometry(e2, t2) {
    if (t$7(this._resources))
      return true;
    const s2 = t2 && d$9(t2);
    if (t$7(s2))
      return false;
    const r2 = this.getGeometryElevationMode(t2);
    return e2.elevationContext.mode === r2 && (this._computeGlobalTransform(s2, e2.elevationContext, fe$1, be), this._requiresTerrainElevation(e2.elevationContext) && (e2.alignedSampledElevation = be.sampledElevation), this._resources.lodRenderer.instanceData.setGlobalTransform(e2.instanceIndex, fe$1, true), f$7(e2, s2, this._context.elevationProvider), true);
  }
  _preparePatchTransform(e2, t2) {
    if (!(t2.heading || t2.tilt || t2.roll || t2.width || t2.height || t2.depth || t2.anchor || t2.anchorPosition))
      return;
    if (t$7(this._resources))
      return;
    const s2 = (e3, t3, s3) => i$a(e3 != null && e3.type === "complete" ? e3.newValue : t3, s3), r2 = s2(t2.heading, this.symbolLayer.heading, 0), o2 = s2(t2.tilt, this.symbolLayer.tilt, 0), n2 = s2(t2.roll, this.symbolLayer.roll, 0), c2 = s2(t2.width, this.symbolLayer.width, void 0), l2 = s2(t2.height, this.symbolLayer.height, void 0), h2 = s2(t2.depth, this.symbolLayer.depth, void 0), d2 = s2(t2.anchor, this.symbolLayer.anchor, void 0), p2 = s2(t2.anchorPosition, this.symbolLayer.anchorPosition, void 0);
    delete t2.heading, delete t2.tilt, delete t2.roll, delete t2.width, delete t2.height, delete t2.depth, delete t2.anchor, delete t2.anchorPosition;
    const m2 = { heading: r2, tilt: o2, roll: n2, anchor: d2, anchorPosition: p2 }, u2 = this._resources;
    this.loadStatus === e$9.LOADED && e2.symbolLayerStatePatches.push(() => {
      u2.symbolSize = e$l(t$m(u2.resourceSize, { width: c2, height: l2, depth: h2, isPrimitive: this.symbolLayer.isPrimitive }));
    }), e2.graphics3DGraphicPatches.push((e3, t3) => {
      const s3 = this._computeLocalTransform(u2, m2, t3, ye$1), r3 = e3.instanceIndex;
      u2.lodRenderer.instanceData.setLocalTransform(r3, s3, true);
    });
  }
  _preparePatchColor(s2, r2) {
    if (!r2.material || r2.material.type !== "partial")
      return;
    const i2 = r2.material.diff;
    if (!i2.color || i2.color.type !== "complete" || i2.color.newValue == null || i2.color.oldValue == null)
      return;
    const o2 = i2.color.newValue, n2 = r$d(o2) ? l$c.toUnitRGBA(o2) : _$e;
    delete i2.color;
    const c2 = this._resources;
    t$7(c2) || s2.graphics3DGraphicPatches.push((e2) => {
      let t2;
      this._hasPerInstanceColor() ? (c2.lodRenderer.instanceData.setColor(e2.instanceIndex, n2), t2 = this._setMaterialTransparencyParams({}, o2)) : t2 = this._setMaterialTransparencyParams({ externalColor: n2 }, o2);
      for (const s3 of c2.stageResources.materials)
        s3.setParameters(t2);
    });
  }
  _requiresTerrainElevation(e2) {
    return e2.mode !== "absolute-height";
  }
  _applyObjectRotation(e2, t2, s2) {
    if (!(this._fastUpdates.enabled && this._fastUpdates.requiresShaderTransformation && t2))
      return G$6(e2.heading, e2.tilt, e2.roll, s2);
  }
  _computeAnchor(e2, s2, r2) {
    const a2 = n$h();
    switch (r2.anchor) {
      case "center":
        r$e(a2, p$9(e2)), j$a(a2, a2);
        break;
      case "top": {
        const t2 = p$9(e2);
        o$7(a2, -t2[0], -t2[1], -e2[5]);
        break;
      }
      case "bottom": {
        const t2 = p$9(e2);
        o$7(a2, -t2[0], -t2[1], -e2[2]);
        break;
      }
      case "relative": {
        const t2 = p$9(e2), s3 = F$a(e2), i2 = r2.anchorPosition, o2 = i2 ? r$k(i2.x, i2.y, i2.z) : f$h;
        c$t(a2, s3, o2), u$g(a2, a2, t2), j$a(a2, a2);
        break;
      }
      default:
        r$d(s2) ? j$a(a2, s2) : r$e(a2, f$h);
    }
    return a2;
  }
  _applyAnchor(e2, t2, s2) {
    if (this._fastUpdates.enabled && this._fastUpdates.requiresShaderTransformation)
      return;
    const r2 = this._computeAnchor(e2.resourceBoundingBox, e2.pivotOffset, t2);
    r2 && c$l(s2, s2, r2);
  }
  _hasPerInstanceColor() {
    return this._drivenProperties.color || this._drivenProperties.opacity;
  }
  _fastVisualVariableConvertOptions(e2, s2, r2, a2) {
    const i2 = r$d(e2) ? e$l(F$a(e2)) : l$e, o2 = r$d(e2) ? this._computeAnchor(e2, a2, this.symbolLayer) : f$h, n2 = this._context.renderCoordsHelper.unitInMeters, c2 = I$9(r$d(s2) ? s2 : void 0, s2, r2, n2), l2 = r$k(this.symbolLayer.tilt || 0, this.symbolLayer.roll || 0, this.symbolLayer.heading || 0);
    return { modelSize: i2, symbolSize: r$d(s2) ? s2 : l$e, unitInMeters: n2, transformation: { anchor: o2, scale: c2, rotation: l2 } };
  }
}
const ue$1 = n$h(), ye$1 = e$e(), fe$1 = e$e(), _e$1 = n$m(), be = new j$6();
function n$2(t2, n2) {
  return t2[0] = n2[0], t2[1] = n2[1], t2[2] = n2[2], t2[3] = n2[3], t2;
}
function a$2(t2) {
  return t2[0] = 1, t2[1] = 0, t2[2] = 0, t2[3] = 1, t2;
}
function r$3(t2, n2, a2, r2, s2) {
  return t2[0] = n2, t2[1] = a2, t2[2] = r2, t2[3] = s2, t2;
}
function s$5(t2, n2) {
  if (t2 === n2) {
    const a2 = n2[1];
    t2[1] = n2[2], t2[2] = a2;
  } else
    t2[0] = n2[0], t2[1] = n2[2], t2[2] = n2[1], t2[3] = n2[3];
  return t2;
}
function u$4(t2, n2) {
  const a2 = n2[0], r2 = n2[1], s2 = n2[2], u2 = n2[3];
  let o2 = a2 * u2 - s2 * r2;
  return o2 ? (o2 = 1 / o2, t2[0] = u2 * o2, t2[1] = -r2 * o2, t2[2] = -s2 * o2, t2[3] = a2 * o2, t2) : null;
}
function o(t2, n2) {
  const a2 = n2[0];
  return t2[0] = n2[3], t2[1] = -n2[1], t2[2] = -n2[2], t2[3] = a2, t2;
}
function e$5(t2) {
  return t2[0] * t2[3] - t2[2] * t2[1];
}
function c$2(t2, n2, a2) {
  const r2 = n2[0], s2 = n2[1], u2 = n2[2], o2 = n2[3], e2 = a2[0], c2 = a2[1], i2 = a2[2], f2 = a2[3];
  return t2[0] = r2 * e2 + u2 * c2, t2[1] = s2 * e2 + o2 * c2, t2[2] = r2 * i2 + u2 * f2, t2[3] = s2 * i2 + o2 * f2, t2;
}
function i$3(t2, n2, a2) {
  const r2 = n2[0], s2 = n2[1], u2 = n2[2], o2 = n2[3], e2 = Math.sin(a2), c2 = Math.cos(a2);
  return t2[0] = r2 * c2 + u2 * e2, t2[1] = s2 * c2 + o2 * e2, t2[2] = r2 * -e2 + u2 * c2, t2[3] = s2 * -e2 + o2 * c2, t2;
}
function f$2(t2, n2, a2) {
  const r2 = n2[0], s2 = n2[1], u2 = n2[2], o2 = n2[3], e2 = a2[0], c2 = a2[1];
  return t2[0] = r2 * e2, t2[1] = s2 * e2, t2[2] = u2 * c2, t2[3] = o2 * c2, t2;
}
function l$4(t2, n2) {
  const a2 = Math.sin(n2), r2 = Math.cos(n2);
  return t2[0] = r2, t2[1] = a2, t2[2] = -a2, t2[3] = r2, t2;
}
function h$2(t2, n2) {
  return t2[0] = n2[0], t2[1] = 0, t2[2] = 0, t2[3] = n2[1], t2;
}
function M$2(t2) {
  return "mat2(" + t2[0] + ", " + t2[1] + ", " + t2[2] + ", " + t2[3] + ")";
}
function b$3(t2) {
  return Math.sqrt(t2[0] ** 2 + t2[1] ** 2 + t2[2] ** 2 + t2[3] ** 2);
}
function m$1(t2, n2, a2, r2) {
  return t2[2] = r2[2] / r2[0], a2[0] = r2[0], a2[1] = r2[1], a2[3] = r2[3] - t2[2] * a2[1], [t2, n2, a2];
}
function d$6(t2, n2, a2) {
  return t2[0] = n2[0] + a2[0], t2[1] = n2[1] + a2[1], t2[2] = n2[2] + a2[2], t2[3] = n2[3] + a2[3], t2;
}
function p$3(t2, n2, a2) {
  return t2[0] = n2[0] - a2[0], t2[1] = n2[1] - a2[1], t2[2] = n2[2] - a2[2], t2[3] = n2[3] - a2[3], t2;
}
function y$7(t2, n2) {
  return t2[0] === n2[0] && t2[1] === n2[1] && t2[2] === n2[2] && t2[3] === n2[3];
}
function x$5(n2, a2) {
  const r2 = n2[0], s2 = n2[1], u2 = n2[2], o2 = n2[3], e2 = a2[0], c2 = a2[1], i2 = a2[2], f2 = a2[3], l2 = a$n();
  return Math.abs(r2 - e2) <= l2 * Math.max(1, Math.abs(r2), Math.abs(e2)) && Math.abs(s2 - c2) <= l2 * Math.max(1, Math.abs(s2), Math.abs(c2)) && Math.abs(u2 - i2) <= l2 * Math.max(1, Math.abs(u2), Math.abs(i2)) && Math.abs(o2 - f2) <= l2 * Math.max(1, Math.abs(o2), Math.abs(f2));
}
function g$4(t2, n2, a2) {
  return t2[0] = n2[0] * a2, t2[1] = n2[1] * a2, t2[2] = n2[2] * a2, t2[3] = n2[3] * a2, t2;
}
function j$3(t2, n2, a2, r2) {
  return t2[0] = n2[0] + a2[0] * r2, t2[1] = n2[1] + a2[1] * r2, t2[2] = n2[2] + a2[2] * r2, t2[3] = n2[3] + a2[3] * r2, t2;
}
const S$3 = c$2, q$2 = p$3;
Object.freeze(Object.defineProperty({ __proto__: null, copy: n$2, identity: a$2, set: r$3, transpose: s$5, invert: u$4, adjoint: o, determinant: e$5, multiply: c$2, rotate: i$3, scale: f$2, fromRotation: l$4, fromScaling: h$2, str: M$2, frob: b$3, LDU: m$1, add: d$6, subtract: p$3, exactEquals: y$7, equals: x$5, multiplyScalar: g$4, multiplyScalarAndAdd: j$3, mul: S$3, sub: q$2 }, Symbol.toStringTag, { value: "Module" }));
class r$2 extends d$i {
  constructor(e2, r2, i2, s2, n2, o2, c2) {
    super(e2, r2, a$f.Triangle, c2), this.path = i2, this.geometrySR = s2, this.upVectorAlignment = n2, this.stencilWidth = o2;
  }
}
function i$2(t2) {
  return "upVectorAlignment" in t2;
}
function e$4() {
  return [1, 0, 0, 1];
}
function r$1(e2) {
  return [e2[0], e2[1], e2[2], e2[3]];
}
function t$2(e2, r2, t2, n2) {
  return [e2, r2, t2, n2];
}
function n$1(e2, r2) {
  return new Float64Array(e2, r2, 4);
}
Object.freeze(Object.defineProperty({ __proto__: null, create: e$4, clone: r$1, fromValues: t$2, createView: n$1 }, Symbol.toStringTag, { value: "Module" }));
function E$5() {
  return { up: n$h(), right: n$h() };
}
function k$5(t2, e2, i2) {
  O$9(t2.up, e2.up, i2), O$9(t2.right, e2.right, i2);
}
function G$2(t2, e2, i2) {
  r$g(t2, P$9(i2, e2.right), P$9(i2, e2.up));
}
class B$1 {
  constructor() {
    this.pos = n$h(), this.posES = n$h(), this.posGS = n$h(), this.vRight = n$h(), this.vLeft = n$h(), this.frame = E$5(), this.rotationFrame = E$5(), this.rotationRight = n$k(), this.rotationAngle = 0, this.miterStretch = e$4();
  }
  setFrameFromUpVector(t2) {
    r$e(this.frame.up, t2), u$g(at, this.vLeft, this.vRight), z$5(at, at), g$d(nt, this.frame.up, P$9(at, this.frame.up)), e$n(pt, at, nt), z$5(pt, pt), _$d(this.frame.right, pt, this.frame.up);
  }
  computeRotationAxisAndAngleFromUpVector() {
    r$e(this.rotationFrame.up, this.frame.up), r$e(this.rotationFrame.right, this.frame.right), r$g(this.rotationRight, 1, 0), g$d(nt, this.frame.up, P$9(this.frame.up, this.vLeft)), e$n(nt, this.vLeft, nt), j$a(nt, nt), z$5(nt, nt), g$d(at, this.frame.up, P$9(this.frame.up, this.vRight)), e$n(at, this.vRight, at), z$5(at, at), _$d(lt, this.rotationFrame.up, this.vLeft);
    const s2 = Math.sign(P$9(lt, this.vRight));
    if (this.rotationAngle = s2 * (Math.PI - l$q(P$9(nt, at))), Math.abs(this.rotationAngle) > 0) {
      const t2 = F$b(Math.cos(0.5 * this.rotationAngle));
      r$3(this.miterStretch, t2 - 1 + 1, 0, 0, 1);
    }
    const r2 = Math.PI - this.rotationAngle;
    this.maxStretchDistance = Math.abs(Math.min(this.vLeftLength, this.vRightLength) / Math.cos(0.5 * r2));
  }
}
class j$2 {
  constructor() {
    this.vertices = [], this.vertexIndices = [], this.vertexNormals = [], this.poles = [], this.poleIndices = [], this.uvs = null, this.uvIndices = null;
  }
  addVertex(t2, e2) {
    return this.vertices.push(t$n(t2)), this.vertexNormals.push(t$n(e2)), this.vertices.length - 1;
  }
  addUV(t2) {
    return this.uvs || (this.uvs = [], this.uvIndices = []), this.uvs.push(t2), this.uvs.length - 1;
  }
  addPole(t2, e2 = null) {
    return this.poles.push({ position: t$n(t2), normal: e2 ? t$n(e2) : null }), this.poles.length - 1;
  }
  addSegment(t2, e2 = null, i2 = null) {
    this.vertexIndices.push(t2.v0), this.vertexIndices.push(t2.v1), e2 && (this.uvIndices.push(e2.v0), this.uvIndices.push(e2.v1)), i2 && (this.poleIndices.push(i2.v0), this.poleIndices.push(i2.v1));
  }
  get numSegments() {
    return this.vertexIndices.length / 2;
  }
  hasUV() {
    return this.uvs != null;
  }
  translate(t2, e2) {
    for (const i2 of this.vertices)
      i2[0] += t2, i2[1] += e2;
    for (const i2 of this.poles)
      i2.position[0] += t2, i2.position[1] += e2;
  }
  static circle(t2 = 20) {
    const e2 = 0.5, i2 = new j$2(), s2 = { v0: 0, v1: 0 };
    i2.addPole(r$i(0, 0));
    for (let h2 = 0; h2 < t2; ++h2) {
      const s3 = 2 * h2 * Math.PI / t2, r3 = Math.cos(s3), o3 = Math.sin(s3), n2 = r$i(r3 * e2, o3 * e2), a2 = r$i(r3, o3);
      i2.addVertex(n2, a2), i2.addUV(h2 / t2);
    }
    i2.addUV(1);
    for (let h2 = 0; h2 < t2 - 1; ++h2) {
      const t3 = { v0: h2, v1: h2 + 1 }, e3 = t3;
      i2.addSegment(t3, e3, s2);
    }
    const r2 = { v0: t2 - 1, v1: 0 }, o2 = { v0: t2 - 1, v1: t2 };
    return i2.addSegment(r2, o2, s2), i2;
  }
  static rect() {
    const t2 = 1, e2 = 1, i2 = new j$2(), s2 = r$i(0.5 * -t2, 0.5 * -e2), r2 = r$i(0.5 * t2, 0.5 * -e2), o2 = r$i(0.5 * t2, 0.5 * e2), h2 = r$i(0.5 * -t2, 0.5 * e2), n2 = r$i(0, -1), a2 = r$i(1, 0), l2 = r$i(0, 1), u2 = r$i(-1, 0);
    i2.addUV(0), i2.addUV(1), i2.addPole(r$i(0, 0.5 * e2), l2), i2.addPole(r$i(0, 0.5 * e2)), i2.addPole(r$i(0, 0.5 * -e2)), i2.addPole(r$i(0, 0.5 * -e2), n2);
    const p2 = { v0: 0, v1: 1 };
    return i2.addVertex(s2, n2), i2.addVertex(r2, n2), i2.addSegment({ v0: 0, v1: 1 }, p2, { v0: 3, v1: 3 }), i2.addVertex(r2, a2), i2.addVertex(o2, a2), i2.addSegment({ v0: 2, v1: 3 }, p2, { v0: 2, v1: 1 }), i2.addVertex(o2, l2), i2.addVertex(h2, l2), i2.addSegment({ v0: 4, v1: 5 }, p2, { v0: 0, v1: 0 }), i2.addVertex(h2, u2), i2.addVertex(s2, u2), i2.addSegment({ v0: 6, v1: 7 }, p2, { v0: 1, v1: 2 }), i2;
  }
}
class z$3 {
  constructor(t2) {
    this.vertices = [], this.offset = n$h(), this.xform = e$e(), this.vertices = t2;
    const e2 = Math.floor((t2.length - 1) / 2);
    r$e(this.offset, this.vertices[e2].pos);
    for (const i2 of this.vertices)
      e$n(i2.pos, i2.pos, this.offset);
    c$l(this.xform, this.xform, this.offset), this.updatePathVertexInformation();
  }
  updatePathVertexInformation() {
    const t2 = this.vertices.length;
    let e2 = this.vertices[0];
    e2.index = 0, o$7(e2.vLeft, 0, 0, 0), e2.vLeftLength = 0, e$n(e2.vRight, this.vertices[1].pos, e2.pos), e2.vRightLength = s$k(e2.vRight), z$5(e2.vRight, e2.vRight);
    let i2 = e2;
    for (let s2 = 1; s2 < t2; ++s2)
      e2 = this.vertices[s2], e2.index = s2, r$e(e2.vLeft, i2.vRight), e2.vLeftLength = i2.vRightLength, s2 < t2 - 1 ? (e$n(e2.vRight, this.vertices[s2 + 1].pos, e2.pos), e2.vRightLength = s$k(e2.vRight), z$5(e2.vRight, e2.vRight)) : (r$e(e2.vRight, e2.vLeft), e2.vRightLength = e2.vLeftLength), i2 = e2;
  }
}
function J(t2, e2) {
  let i2 = null;
  const s2 = t2.vertices.length, r2 = 0.99619469809, o2 = n$h(), h2 = n$h(), n2 = n$h(), a2 = n$h(), l2 = n$h(), u2 = n$h(), p2 = p$h();
  let f2 = t2.vertices[0];
  r$e(h2, e2), o$7(o2, 0, 1, 0), J$4(f2.vRight, h2, o2, o2, n2, h2, r2), r$e(f2.frame.up, h2), r$e(f2.frame.right, n2), i2 = f2;
  for (let c2 = 1; c2 < s2; ++c2) {
    f2 = t2.vertices[c2], u$g(l2, f2.vLeft, f2.vRight);
    let e3 = s$k(l2);
    e3 > 0 ? (e3 = 1 / Math.sqrt(e3), l2[0] = l2[0] * e3, l2[1] = l2[1] * e3, l2[2] = l2[2] * e3) : (l2[0] = f2.vRight[0], l2[1] = f2.vRight[1], l2[2] = f2.vRight[2]), u$g(u2, i2.pos, i2.frame.up), _$f(f2.pos, l2, p2);
    q$8(p2, p$i(u2, f2.vLeft), a2) ? (e$n(a2, a2, f2.pos), z$5(h2, a2), _$d(n2, l2, h2), z$5(n2, n2)) : J$4(l2, i2.frame.up, i2.frame.right, o2, n2, h2, r2), r$e(f2.frame.up, h2), r$e(f2.frame.right, n2), i2 = f2;
  }
}
class H$3 {
  numProfilesPerJoin() {
    return 1;
  }
  extrude(t2, e2, i2) {
    for (let s2 = 0; s2 < e2.vertices.length; ++s2)
      i2(t2.index, t2.frame, e2.vertices[s2], e2.vertexNormals[s2], false);
  }
}
class X {
  constructor(t2 = 0.8 * Math.PI, e2 = 1) {
    this.cutoffAngle = t2, this.numBendSubdivisions = e2;
  }
  numProfilesPerJoin() {
    return this.numBendSubdivisions + 1;
  }
  extrude(t2, e2, i2) {
    const s2 = ft;
    if (Math.abs(t2.rotationAngle) >= this.cutoffAngle)
      for (let r2 = 0; r2 < this.numBendSubdivisions + 1; ++r2) {
        g$i(ct, 0.5 * -t2.rotationAngle + r2 * t2.rotationAngle / this.numBendSubdivisions, t2.rotationFrame.up), k$5(s2, t2.frame, ct);
        for (let r3 = 0; r3 < e2.vertices.length; ++r3) {
          j$b(e2.vertices[r3], t2.rotationRight) * t2.rotationAngle >= 0 ? i2(t2.index, s2, e2.vertices[r3], e2.vertexNormals[r3], false) : (_$g(rt, e2.vertices[r3], t2.miterStretch), i2(t2.index, t2.frame, rt, e2.vertexNormals[r3], true));
        }
      }
    else
      for (let r2 = 0; r2 < this.numBendSubdivisions + 1; ++r2)
        for (let s3 = 0; s3 < e2.vertices.length; ++s3) {
          const r3 = j$b(e2.vertices[s3], t2.rotationRight) * t2.rotationAngle >= 0;
          _$g(rt, e2.vertices[s3], t2.miterStretch), i2(t2.index, t2.frame, rt, e2.vertexNormals[s3], !r3);
        }
  }
}
const K = { generateUV: false };
class Q {
  rebuildConnectingProfileGeometry(t2, e2, i2) {
    for (let s2 = 0; s2 < e2.vertices.length; ++s2)
      i2(t2.index, t2.frame, e2.vertices[s2], e2.vertexNormals[s2], 0, 0);
  }
}
class W$2 extends Q {
  constructor() {
    super();
  }
  getNumVertices() {
    return 0;
  }
  getNumIndices() {
    return 0;
  }
  rebuildCapGeometry() {
  }
  buildTopology() {
  }
}
class Y$3 extends Q {
  constructor(t2, e2 = 0, i2 = false) {
    super(), this.profile = t2, this.profilePlaneOffset = e2, this.flip = i2;
  }
  getNumVertices() {
    return this.profile.vertices.length;
  }
  getNumIndices() {
    return 3 * this.profile.numSegments;
  }
  rebuildConnectingProfileGeometry(t2, e2, i2) {
    for (let s2 = 0; s2 < e2.vertices.length; ++s2)
      i2(t2.index, t2.frame, e2.vertices[s2], e2.vertexNormals[s2], this.profilePlaneOffset, 0);
  }
  rebuildCapGeometry(t2, e2) {
    const i2 = ot;
    r$g(i2, 0, 0);
    const s2 = this.flip ? 1 : -1;
    for (let r2 = 0; r2 < this.profile.vertices.length; ++r2)
      e2(t2.index, t2.frame, this.profile.vertices[r2], i2, this.profilePlaneOffset, s2);
  }
  buildTopology(t2, e2) {
    const i2 = this.vertexBufferStart + this.profile.vertexIndices[0];
    for (let s2 = 1; s2 < this.profile.numSegments; ++s2) {
      const t3 = this.profile.vertexIndices[2 * s2 + 0], r2 = this.profile.vertexIndices[2 * s2 + 1], o2 = this.vertexBufferStart + t3, h2 = this.vertexBufferStart + r2;
      this.flip ? e2(h2, o2, i2) : e2(i2, o2, h2);
    }
  }
}
class Z extends Q {
  constructor(t2) {
    super(), this.flip = false, this.sign = 0, this.breakNormals = false, this.numSegments = 3, this.profile = t2.profile, this.flip = t2.flip, this.sign = this.flip ? 1 : -1, this.breakNormals = t2.breakNormals, this.numSegments = t2.subdivisions;
  }
  getNumVertices() {
    let t2 = 0;
    return t2 = this.profile.vertices.length * (this.numSegments - 1), this.breakNormals && (t2 += this.profile.vertices.length), t2 += this.profile.poles.length, t2;
  }
  getNumIndices() {
    let t2 = 0;
    t2 += 2 * this.profile.numSegments * (this.numSegments - 1);
    for (let e2 = 0; e2 < this.profile.numSegments; ++e2) {
      const i2 = this.profile.vertexIndices[2 * e2 + 0], s2 = this.profile.vertexIndices[2 * e2 + 1];
      this.profile.poleIndices[i2] === this.profile.poleIndices[s2] ? t2 += 1 : t2 += 2;
    }
    return 3 * t2;
  }
  rebuildCapGeometry(t2, e2) {
    const i2 = t2.frame, s2 = 0.5 * this.sign, r2 = rt, o2 = ot;
    r$g(o2, 0, 0);
    for (let h2 = 0; h2 < this.profile.poles.length; ++h2) {
      const r3 = this.profile.poles[h2];
      r3.normal ? e2(t2.index, i2, r3.position, r3.normal, s2, 0) : e2(t2.index, i2, r3.position, o2, s2, this.sign);
    }
    if (this.breakNormals)
      for (let h2 = 0; h2 < this.profile.vertices.length; ++h2)
        e2(t2.index, i2, this.profile.vertices[h2], this.profile.vertexNormals[h2], 0, 0);
    for (let h2 = 0; h2 < this.numSegments - 1; ++h2) {
      const n2 = (1 - (h2 + 1) / this.numSegments) * Math.PI * 0.5, a2 = Math.sin(n2), l2 = Math.cos(n2);
      for (let h3 = 0; h3 < this.profile.vertices.length; ++h3) {
        const n3 = this.profile.poles[this.profile.poleIndices[h3]];
        o$n(r2, this.profile.vertices[h3], n3.position), l$i(r2, r2, a2), n3.normal ? (s$l(r2, r2, n3.position), e2(t2.index, i2, r2, n3.normal, s2 * l2, 0)) : (v$i(o2, r2), l$i(o2, o2, a2), s$l(r2, r2, n3.position), e2(t2.index, i2, r2, o2, s2 * l2, this.sign * l2));
      }
    }
  }
  buildTopology(t2, e2) {
    const i2 = this.breakNormals ? this.vertexBufferStart + this.profile.poles.length : this.firstProfileVertexIndex, s2 = this.breakNormals ? this.vertexBufferStart + this.profile.poles.length + this.profile.vertices.length : this.vertexBufferStart + this.profile.poles.length;
    for (let r2 = 0; r2 < this.profile.numSegments; ++r2) {
      const t3 = this.profile.vertexIndices[2 * r2 + 0], o2 = this.profile.vertexIndices[2 * r2 + 1], h2 = this.vertexBufferStart + this.profile.poleIndices[t3], n2 = this.vertexBufferStart + this.profile.poleIndices[o2];
      let a2 = i2 + t3, l2 = i2 + o2;
      for (let i3 = 0; i3 < this.numSegments - 1; ++i3) {
        const r3 = s2 + i3 * this.profile.vertices.length + t3, h3 = s2 + i3 * this.profile.vertices.length + o2;
        this.flip ? (e2(r3, l2, a2), e2(l2, r3, h3)) : (e2(a2, l2, r3), e2(h3, r3, l2)), a2 = r3, l2 = h3;
      }
      this.flip ? (e2(h2, l2, a2), h2 !== n2 && e2(h2, n2, l2)) : (e2(a2, l2, h2), h2 !== n2 && e2(l2, n2, h2));
    }
  }
}
class $ {
  constructor(t2, e2, i2, s2, r2, o2 = K) {
    this.options = o2, this._extrusionVertexCount = 0, this.numExtrusionProfiles = 0, this.numVerticesTotal = 0, this.numNormalsTotal = 0, this.numUVTotal = 0, this.profile = e2, this.path = t2, this.extruder = i2, this.startCap = s2, this.endCap = r2;
    const h2 = this.path.vertices.length - 2;
    this.numExtrusionProfiles = i2.numProfilesPerJoin() * h2 + 2, this.numVerticesTotal = e2.vertices.length * this.numExtrusionProfiles, this.numNormalsTotal = this.numVerticesTotal, this.startCap.vertexBufferStart = this.numVerticesTotal;
    const n2 = this.startCap.getNumVertices();
    this.numVerticesTotal += n2, this.numNormalsTotal += n2, this.endCap.vertexBufferStart = this.numVerticesTotal;
    const a2 = this.endCap.getNumVertices();
    this.numVerticesTotal += a2, this.numNormalsTotal += a2, this.pathVertexData = new Float32Array(1 * this.numVerticesTotal), this.profileRightAxisData = new Float32Array(4 * this.numVerticesTotal), this.profileUpAxisData = new Float32Array(4 * this.numVerticesTotal), this.profileVertexAndNormalData = new Float32Array(4 * this.numVerticesTotal), this.profile.hasUV() && this.options.generateUV && (this.numUVTotal = this.profile.uvs.length, this.uvData = new Float32Array(2 * this.numUVTotal)), this.originData = new Float32Array(3 * this.path.vertices.length), this._rebuildGeometry(), this.buildTopology();
  }
  emitVertex(t2, e2, i2, s2, r2) {
    if (this.profileRightAxisData[4 * this._extrusionVertexCount + 0] = e2.right[0], this.profileRightAxisData[4 * this._extrusionVertexCount + 1] = e2.right[1], this.profileRightAxisData[4 * this._extrusionVertexCount + 2] = e2.right[2], this.profileUpAxisData[4 * this._extrusionVertexCount + 0] = e2.up[0], this.profileUpAxisData[4 * this._extrusionVertexCount + 1] = e2.up[1], this.profileUpAxisData[4 * this._extrusionVertexCount + 2] = e2.up[2], this.profileVertexAndNormalData[4 * this._extrusionVertexCount + 0] = i2[0], this.profileVertexAndNormalData[4 * this._extrusionVertexCount + 1] = i2[1], this.profileVertexAndNormalData[4 * this._extrusionVertexCount + 2] = s2[0], this.profileVertexAndNormalData[4 * this._extrusionVertexCount + 3] = s2[1], this.pathVertexData[this._extrusionVertexCount] = t2, r2) {
      const e3 = this.path.vertices[t2];
      this.profileRightAxisData[4 * this._extrusionVertexCount + 3] = e3.rotationRight[0] * e3.maxStretchDistance, this.profileUpAxisData[4 * this._extrusionVertexCount + 3] = e3.rotationRight[1] * e3.maxStretchDistance;
    } else
      this.profileRightAxisData[4 * this._extrusionVertexCount + 3] = 0, this.profileUpAxisData[4 * this._extrusionVertexCount + 3] = 0;
    ++this._extrusionVertexCount;
  }
  emitCapVertex(t2, e2, i2, s2, r2, o2) {
    this.profileRightAxisData[4 * this._extrusionVertexCount + 0] = e2.right[0], this.profileRightAxisData[4 * this._extrusionVertexCount + 1] = e2.right[1], this.profileRightAxisData[4 * this._extrusionVertexCount + 2] = e2.right[2], this.profileUpAxisData[4 * this._extrusionVertexCount + 0] = e2.up[0], this.profileUpAxisData[4 * this._extrusionVertexCount + 1] = e2.up[1], this.profileUpAxisData[4 * this._extrusionVertexCount + 2] = e2.up[2], this.profileVertexAndNormalData[4 * this._extrusionVertexCount + 0] = i2[0], this.profileVertexAndNormalData[4 * this._extrusionVertexCount + 1] = i2[1], this.profileVertexAndNormalData[4 * this._extrusionVertexCount + 2] = s2[0], this.profileVertexAndNormalData[4 * this._extrusionVertexCount + 3] = s2[1], this.pathVertexData[this._extrusionVertexCount] = t2, this.profileRightAxisData[4 * this._extrusionVertexCount + 3] = r2, this.profileUpAxisData[4 * this._extrusionVertexCount + 3] = o2, ++this._extrusionVertexCount;
  }
  emitTriangle(t2, e2, i2) {
    this.vertexIndices.push(t2), this.vertexIndices.push(e2), this.vertexIndices.push(i2), this.pathVertexIndices.push(this.pathVertexData[t2]), this.pathVertexIndices.push(this.pathVertexData[e2]), this.pathVertexIndices.push(this.pathVertexData[i2]), this.normalIndices.push(t2), this.normalIndices.push(e2), this.normalIndices.push(i2);
  }
  _rebuildGeometry() {
    const t2 = (t3, e3, i2, s2, r2) => this.emitVertex(t3, e3, i2, s2, r2), e2 = (t3, e3, i2, s2, r2, o2) => this.emitCapVertex(t3, e3, i2, s2, r2, o2);
    this._extrusionVertexCount = 0;
    for (const i2 of this.path.vertices)
      this.originData[3 * i2.index + 0] = i2.pos[0], this.originData[3 * i2.index + 1] = i2.pos[1], this.originData[3 * i2.index + 2] = i2.pos[2];
    this.startCap.rebuildConnectingProfileGeometry(this.path.vertices[0], this.profile, e2);
    for (let i2 = 1; i2 < this.path.vertices.length - 1; ++i2)
      this.extruder.extrude(this.path.vertices[i2], this.profile, t2);
    if (this.endCap.rebuildConnectingProfileGeometry(this.path.vertices[this.path.vertices.length - 1], this.profile, e2), this.startCap.rebuildCapGeometry(this.path.vertices[0], e2), this.endCap.rebuildCapGeometry(this.path.vertices[this.path.vertices.length - 1], e2), this.profile.hasUV() && this.options.generateUV)
      for (let i2 = 0; i2 < this.profile.uvs.length; ++i2)
        this.uvData[2 * i2 + 0] = this.profile.uvs[i2], this.uvData[2 * i2 + 1] = 0;
  }
  buildTopology() {
    const t2 = this.profile.vertices.length, e2 = this.profile.numSegments, i2 = this.numExtrusionProfiles - 1;
    let s2 = 3 * (2 * (e2 * i2));
    this.startCap.indexBufferStart = s2, this.startCap.firstProfileVertexIndex = 0, s2 += this.startCap.getNumIndices(), this.endCap.indexBufferStart = s2, this.endCap.firstProfileVertexIndex = t2 * (this.numExtrusionProfiles - 1), this.vertexIndices = new Array(), this.normalIndices = new Array(), this.pathVertexIndices = new Array(), this.profile.hasUV() && this.options.generateUV && (this.uvIndices = new Array());
    for (let o2 = 0; o2 < e2; ++o2) {
      const e3 = this.profile.vertexIndices[2 * o2], s3 = this.profile.vertexIndices[2 * o2 + 1];
      for (let r3 = 0; r3 < i2; ++r3) {
        const i3 = r3 * t2 + e3, o3 = (r3 + 1) * t2 + e3, h2 = (r3 + 1) * t2 + s3, n2 = r3 * t2 + s3;
        this.emitTriangle(i3, o3, h2), this.emitTriangle(i3, h2, n2);
      }
    }
    const r2 = (t3, e3, i3) => this.emitTriangle(t3, e3, i3);
    this.startCap.buildTopology(this.path.vertices[0], r2), this.endCap.buildTopology(this.path.vertices[this.path.vertices.length - 1], r2);
  }
  onPathChanged() {
    this._rebuildGeometry();
  }
}
class tt {
  constructor(t2) {
    this.builder = t2;
  }
  get xform() {
    return this.builder.path.xform;
  }
  onPathChanged() {
    this.builder.onPathChanged();
  }
}
class et extends tt {
  constructor(t2) {
    super(t2), this.vertexAttributePosition = null, this.vertexAttributeNormal = null, this.vertexAttributeColor = null, this.vertexAttributePosition = new Float32Array(3 * this.builder.numVerticesTotal), this.vertexAttributeNormal = new Float32Array(3 * this.builder.numNormalsTotal), this.vertexAttributeColor = new Uint8Array(4), this.vertexAttributeColor[0] = 255, this.vertexAttributeColor[1] = 255, this.vertexAttributeColor[2] = 255, this.vertexAttributeColor[3] = 255;
  }
  bakeVertexColors(t2) {
    this.vertexAttributeColor[0] = 255 * t2[0], this.vertexAttributeColor[1] = 255 * t2[1], this.vertexAttributeColor[2] = 255 * t2[2], this.vertexAttributeColor[3] = 255 * (t2.length > 3 ? t2[3] : 1);
  }
  bake(t2) {
    this.size = t2;
    for (let e2 = 0; e2 < this.builder.numVerticesTotal; ++e2) {
      let i2 = this.builder.pathVertexData[e2];
      const s2 = i2 === 0 || i2 === this.builder.path.vertices.length - 1;
      i2 *= 3;
      const r2 = st;
      o$7(r2, this.builder.originData[i2++], this.builder.originData[i2++], this.builder.originData[i2]);
      const o2 = 4 * e2, h2 = nt, l2 = rt, u2 = at, d2 = lt, v2 = ut;
      let m2 = 0, g2 = 0;
      if (o$7(d2, this.builder.profileRightAxisData[o2], this.builder.profileRightAxisData[o2 + 1], this.builder.profileRightAxisData[o2 + 2]), o$7(v2, this.builder.profileUpAxisData[o2], this.builder.profileUpAxisData[o2 + 1], this.builder.profileUpAxisData[o2 + 2]), r$g(l2, this.builder.profileVertexAndNormalData[o2] * t2[0], this.builder.profileVertexAndNormalData[o2 + 1] * t2[1]), s2)
        _$d(u2, v2, d2), m2 = this.builder.profileRightAxisData[o2 + 3] * t2[0], g2 = this.builder.profileUpAxisData[o2 + 3];
      else {
        const t3 = ot, e3 = ht;
        r$g(t3, this.builder.profileRightAxisData[o2 + 3], this.builder.profileUpAxisData[o2 + 3]);
        const i3 = q$9(t3);
        v$i(t3, t3);
        const s3 = j$b(l2, t3);
        if (Math.abs(s3) > i3) {
          r$g(e3, -t3[1], t3[0]);
          const r3 = j$b(l2, e3);
          l$i(t3, t3, i3 * Math.sign(s3)), l$i(e3, e3, r3), s$l(l2, t3, e3);
        }
        o$7(u2, 0, 0, 0);
      }
      o$7(h2, d2[0] * l2[0] + v2[0] * l2[1], d2[1] * l2[0] + v2[1] * l2[1], d2[2] * l2[0] + v2[2] * l2[1]), this.vertexAttributePosition[3 * e2 + 0] = r2[0] + h2[0] + u2[0] * m2, this.vertexAttributePosition[3 * e2 + 1] = r2[1] + h2[1] + u2[1] * m2, this.vertexAttributePosition[3 * e2 + 2] = r2[2] + h2[2] + u2[2] * m2;
      const V2 = rt;
      r$g(V2, this.builder.profileVertexAndNormalData[o2 + 2], this.builder.profileVertexAndNormalData[o2 + 3]), this.vertexAttributeNormal[3 * e2 + 0] = d2[0] * V2[0] + v2[0] * V2[1] + u2[0] * g2, this.vertexAttributeNormal[3 * e2 + 1] = d2[1] * V2[0] + v2[1] * V2[1] + u2[1] * g2, this.vertexAttributeNormal[3 * e2 + 2] = d2[2] * V2[0] + v2[2] * V2[1] + u2[2] * g2;
    }
  }
  createGeometryData() {
    const t2 = [[O$8.POSITION, this.builder.vertexIndices], [O$8.NORMAL, this.builder.normalIndices]], e2 = [[O$8.POSITION, { size: 3, data: this.vertexAttributePosition, exclusive: true }], [O$8.NORMAL, { size: 3, data: this.vertexAttributeNormal, exclusive: true }]];
    if (this.vertexAttributeColor) {
      const i2 = this.builder.vertexIndices.length;
      t2.push([O$8.COLOR, new Array(i2).fill(0)]), e2.push([O$8.COLOR, { size: 4, data: this.vertexAttributeColor }]);
    }
    return { vertexAttributes: e2, indices: t2 };
  }
  onPathChanged() {
    super.onPathChanged(), this.bake(this.size);
  }
  intersect(t2, e2, i2) {
    const s2 = this.builder.vertexIndices, r2 = { size: 3, data: this.vertexAttributePosition }, o2 = s2.length / 3;
    v$j(t2, e2, 0, o2, s2, r2, void 0, void 0, i2);
  }
}
class it extends tt {
  constructor(t2, e2, i2, s2) {
    super(t2), this.sizeAttributeValue = e2, this.colorAttributeValue = i2, this.opacityAttributeValue = s2, this.vvData = null, this.baked = new et(t2), this.vvData = new Float32Array(4 * this.builder.path.vertices.length);
    for (let r2 = 0; r2 < this.builder.path.vertices.length; ++r2) {
      this.vvData[4 * r2 + 0] = e2, this.vvData[4 * r2 + 1] = i2, this.vvData[4 * r2 + 2] = s2;
      const t3 = r2 === 0 || r2 === this.builder.path.vertices.length - 1;
      this.vvData[4 * r2 + 3] = t3 ? 1 : 0;
    }
  }
  createGeometryData() {
    return { vertexAttributes: [[O$8.POSITION, { size: 3, data: this.builder.originData, exclusive: true }], [O$8.PROFILERIGHT, { size: 4, data: this.builder.profileRightAxisData, exclusive: true }], [O$8.PROFILEUP, { size: 4, data: this.builder.profileUpAxisData, exclusive: true }], [O$8.PROFILEVERTEXANDNORMAL, { size: 4, data: this.builder.profileVertexAndNormalData, exclusive: true }], [O$8.FEATUREVALUE, { size: 4, data: this.vvData, exclusive: true }]], indices: [[O$8.POSITION, this.builder.pathVertexIndices], [O$8.PROFILERIGHT, this.builder.vertexIndices], [O$8.PROFILEUP, this.builder.vertexIndices], [O$8.PROFILEVERTEXANDNORMAL, this.builder.vertexIndices], [O$8.FEATUREVALUE, this.builder.pathVertexIndices]] };
  }
}
const st = n$h(), rt = n$k(), ot = n$k(), ht = n$k(), nt = n$h(), at = n$h(), lt = n$h(), ut = n$h(), pt = n$h(), ft = E$5(), ct = e$e();
const f$1 = 8;
function n(e2, c2) {
  e2.attributes.add(O$8.FEATUREVALUE, "vec4");
  const n2 = e2.vertex;
  n2.code.add(n$j`bool isCapVertex() {
return featureValue.w == 1.0;
}`), n2.uniforms.add(new e$h("size", (e3) => e3.size)), c2.vvSize ? (n2.uniforms.add(new e$x("vvSizeMinSize", (e3) => e3.vvSizeMinSize)), n2.uniforms.add(new e$x("vvSizeMaxSize", (e3) => e3.vvSizeMaxSize)), n2.uniforms.add(new e$x("vvSizeOffset", (e3) => e3.vvSizeOffset)), n2.uniforms.add(new e$x("vvSizeFactor", (e3) => e3.vvSizeFactor)), n2.code.add(n$j`vec2 getSize() {
return size * clamp(vvSizeOffset + featureValue.x * vvSizeFactor, vvSizeMinSize, vvSizeMaxSize).xz;
}`)) : n2.code.add(n$j`vec2 getSize(){
return size;
}`), c2.vvOpacity ? (n2.constants.add("vvOpacityNumber", "int", f$1), n2.uniforms.add([new o$o("vvOpacityValues", (e3) => e3.vvOpacityValues, f$1), new o$o("vvOpacityOpacities", (e3) => e3.vvOpacityOpacities, f$1)]), n2.code.add(n$j`vec4 applyOpacity(vec4 color) {
float value = featureValue.z;
if (value <= vvOpacityValues[0]) {
return vec4( color.xyz, vvOpacityOpacities[0]);
}
for (int i = 1; i < vvOpacityNumber; ++i) {
if (vvOpacityValues[i] >= value) {
float f = (value - vvOpacityValues[i-1]) / (vvOpacityValues[i] - vvOpacityValues[i-1]);
return vec4( color.xyz, mix(vvOpacityOpacities[i-1], vvOpacityOpacities[i], f));
}
}
return vec4( color.xyz, vvOpacityOpacities[vvOpacityNumber - 1]);
}`)) : n2.code.add(n$j`vec4 applyOpacity(vec4 color){
return color;
}`), c2.vvColor ? (n2.constants.add("vvColorNumber", "int", o$p), n2.uniforms.add([new o$o("vvColorValues", (e3) => e3.vvColorValues, o$p), new e$y("vvColorColors", (e3) => e3.vvColorColors, o$p)]), n2.code.add(n$j`vec4 getColor() {
float value = featureValue.y;
if (value <= vvColorValues[0]) {
return applyOpacity(vvColorColors[0]);
}
for (int i = 1; i < vvColorNumber; ++i) {
if (vvColorValues[i] >= value) {
float f = (value - vvColorValues[i-1]) / (vvColorValues[i] - vvColorValues[i-1]);
return applyOpacity(mix(vvColorColors[i-1], vvColorColors[i], f));
}
}
return applyOpacity(vvColorColors[vvColorNumber - 1]);
}`)) : n2.code.add(n$j`vec4 getColor(){
return applyOpacity(vec4(1, 1, 1, 1));
}`), e2.include(o$q), e2.attributes.add(O$8.PROFILERIGHT, "vec4"), e2.attributes.add(O$8.PROFILEUP, "vec4"), e2.attributes.add(O$8.PROFILEVERTEXANDNORMAL, "vec4"), n2.code.add(n$j`vec3 calculateVPos() {
vec2 size = getSize();
vec3 origin = position;
vec3 right = profileRight.xyz;
vec3 up = profileUp.xyz;
vec3 forward = cross(up, right);
vec2 profileVertex = profileVertexAndNormal.xy * size;
vec2 profileNormal = profileVertexAndNormal.zw;
float positionOffsetAlongProfilePlaneNormal = 0.0;
float normalOffsetAlongProfilePlaneNormal = 0.0;`), n2.code.add(n$j`if(!isCapVertex()) {
vec2 rotationRight = vec2(profileRight.w, profileUp.w);
float maxDistance = length(rotationRight);`), n2.code.add(n$j`rotationRight = maxDistance > 0.0 ? normalize(rotationRight) : vec2(0, 0);
float rx = dot(profileVertex, rotationRight);
if (abs(rx) > maxDistance) {
vec2 rotationUp = vec2(-rotationRight.y, rotationRight.x);
float ry = dot(profileVertex, rotationUp);
profileVertex = rotationRight * maxDistance * sign(rx) + rotationUp * ry;
}
}else{
positionOffsetAlongProfilePlaneNormal = profileRight.w * size[0];
normalOffsetAlongProfilePlaneNormal = profileUp.w;
}
vec3 offset = right * profileVertex.x + up * profileVertex.y + forward * positionOffsetAlongProfilePlaneNormal;
return origin + offset;
}`), n2.code.add(n$j`vec3 localNormal() {
vec3 right = profileRight.xyz;
vec3 up = profileUp.xyz;
vec3 forward = cross(up, right);
vec2 profileNormal = profileVertexAndNormal.zw;
vec3 normal = right * profileNormal.x + up * profileNormal.y;
if(isCapVertex()) {
normal += forward * profileUp.w;
}
return normal;
}`);
}
class p$2 extends v$g {
  constructor() {
    super(...arguments), this.size = r$i(1, 1);
  }
}
function F$3(F2) {
  const _2 = new o$9(), { vertex: M2, fragment: O2 } = _2;
  switch (v$f(M2, F2), _2.varyings.add("vpos", "vec3"), _2.include(n, F2), F2.output !== h$b.Color && F2.output !== h$b.Alpha || (_2.include(r$q, F2), _2.include(v$k, F2), _2.include(d$m, F2), _2.varyings.add("vnormal", "vec3"), _2.varyings.add("vcolor", "vec4"), F2.hasMultipassTerrain && _2.varyings.add("depth", "float"), M2.code.add(n$j`
      void main() {
        vpos = calculateVPos();
        vnormal = normalize(localNormal());

        ${F2.hasMultipassTerrain ? "depth = (view * vec4(vpos, 1.0)).z;" : ""}
        gl_Position = transformPosition(proj, view, vpos);

        ${F2.output === h$b.Color ? "forwardLinearDepth();" : ""}

        vcolor = getColor();
      }
    `)), _2.include(n$o, F2), F2.output) {
    case h$b.Alpha:
      _2.include(u$l, F2), O2.uniforms.add(new o$a("opacity", (e2) => e2.opacity)), O2.code.add(n$j`
      void main() {
        discardBySlice(vpos);
        ${F2.hasMultipassTerrain ? "terrainDepthTest(gl_FragCoord, depth);" : ""}
        float combinedOpacity = vcolor.a * opacity;
        gl_FragColor = vec4(combinedOpacity);
      }
    `);
      break;
    case h$b.Color:
      _2.include(u$l, F2), _2.include(p$j, F2), _2.include(n$r, F2), _2.include(v$k, F2), _2.include(e$z, F2), c$u(O2, F2), h$h(O2), u$t(O2), O2.uniforms.add([M2.uniforms.get("localOrigin"), new e$x("ambient", (e2) => e2.ambient), new e$x("diffuse", (e2) => e2.diffuse), new e$x("specular", (e2) => e2.specular), new o$a("opacity", (e2) => e2.opacity)]), O2.include(e$s), a$p(O2), O2.code.add(n$j`
        void main() {
          discardBySlice(vpos);
          ${F2.hasMultipassTerrain ? "terrainDepthTest(gl_FragCoord, depth);" : ""}

          shadingParams.viewDirection = normalize(vpos - cameraPosition);
          shadingParams.normalView = vnormal;
          vec3 normal = shadingNormal(shadingParams);
          float ssao = evaluateAmbientOcclusionInverse();

          float additionalAmbientScale = additionalDirectedAmbientLight(vpos + localOrigin);
          vec3 additionalLight = ssao * mainLightIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;
          ${F2.receiveShadows ? "float shadow = readShadowMap(vpos, linearDepth);" : F2.spherical ? "float shadow = lightingGlobalFactor * (1.0 - additionalAmbientScale);" : "float shadow = 0.0;"}
          vec3 albedo = vcolor.rgb * max(ambient, diffuse); // combine the old material parameters into a single one
          float combinedOpacity = vcolor.a * opacity;
          albedo += 0.25 * specular; // don't completely ignore specular for now

          vec3 shadedColor = evaluateSceneLighting(normal, albedo, shadow, 1.0 - ssao, additionalLight);
          gl_FragColor = vec4(shadedColor, combinedOpacity);
          gl_FragColor = highlightSlice(gl_FragColor, vpos);
          ${F2.transparencyPassType === o$h.Color ? "gl_FragColor = premultiplyAlpha(gl_FragColor);" : ""}
        }
      `);
      break;
    case h$b.Depth:
    case h$b.Shadow:
    case h$b.ShadowHighlight:
    case h$b.ShadowExludeHighlight:
      _2.include(r$q, F2), i$k(_2), _2.varyings.add("depth", "float"), M2.code.add(n$j`void main() {
vpos = calculateVPos();
gl_Position = transformPositionWithDepth(proj, view, vpos, nearFar, depth);
}`), _2.include(u$l, F2), _2.include(o$f, F2), O2.code.add(n$j`void main() {
discardBySlice(vpos);
outputDepth(depth);
}`);
      break;
    case h$b.Normal:
      _2.include(r$q, F2), _2.include(r$r, F2), d$k(M2), _2.varyings.add("vnormal", "vec3"), M2.code.add(n$j`void main(void) {
vpos = calculateVPos();
vnormal = normalize((viewNormal * vec4(localNormal(), 1.0)).xyz);
gl_Position = transformPosition(proj, view, vpos);
}`), _2.include(u$l, F2), O2.code.add(n$j`void main() {
discardBySlice(vpos);
vec3 normal = normalize(vnormal);
if (gl_FrontFacing == false) normal = -normal;
gl_FragColor = vec4(vec3(0.5) + 0.5 * normal, 1.0);
}`);
      break;
    case h$b.Highlight:
      _2.include(r$q, F2), _2.include(r$r, F2), _2.varyings.add("vnormal", "vec3"), M2.code.add(n$j`void main(void) {
vpos = calculateVPos();
gl_Position = transformPosition(proj, view, vpos);
}`), _2.include(u$l, F2), _2.include(a$o, F2), O2.code.add(n$j`void main() {
discardBySlice(vpos);
outputHighlight();
}`);
  }
  return _2;
}
const _$5 = Object.freeze(Object.defineProperty({ __proto__: null, build: F$3 }, Symbol.toStringTag, { value: "Module" }));
const R$3 = new Map([[O$8.POSITION, 0], [O$8.PROFILERIGHT, 1], [O$8.PROFILEUP, 2], [O$8.PROFILEVERTEXANDNORMAL, 3], [O$8.FEATUREVALUE, 4]]);
class x$4 extends p$2 {
  constructor() {
    super(...arguments), this.ambient = r$k(0.2, 0.2, 0.2), this.diffuse = r$k(0.8, 0.8, 0.8), this.specular = r$k(0, 0, 0), this.opacity = 1;
  }
}
class C$4 extends e$i {
  initializeConfiguration(e2, o2) {
    o2.hasWebGL2Context = e2.rctx.type === r$s.WEBGL2, o2.spherical = e2.viewingMode === l$f.Global, o2.doublePrecisionRequiresObfuscation = i$m(e2.rctx);
  }
  initializeProgram(e2) {
    return new o$b(e2.rctx, C$4.shader.get().build(this.configuration), R$3);
  }
  initializePipeline() {
    const e2 = this.configuration.transparencyPassType, o2 = this.configuration, t2 = e2 === o$h.NONE, i2 = e2 === o$h.FrontFace;
    return W$3({ blending: o2.output !== h$b.Color && o2.output !== h$b.Alpha || !o2.transparent ? null : t2 ? c$n : A$8(e2), culling: o2.hasSlicePlane && !o2.transparent && !(o2.doubleSidedMode === i$l.None) && o$r, depthTest: { func: l$m(e2) }, depthWrite: t2 || i2 ? a$e : null, colorWrite: _$c, stencilWrite: o2.hasOccludees ? e$u : null, stencilTest: o2.hasOccludees ? f$j : null, polygonOffset: t2 || i2 ? null : _$h });
  }
}
C$4.shader = new t$b(_$5, () => import("./Path.glsl.js"));
class E$4 extends s$b {
  constructor() {
    super(...arguments), this.output = h$b.Color, this.doubleSidedMode = i$l.None, this.transparencyPassType = o$h.NONE, this.spherical = false, this.receiveShadows = false, this.receiveAmbientOcclusion = false, this.vvSize = false, this.vvColor = false, this.vvOpacity = false, this.hasSlicePlane = false, this.transparent = false, this.hasOccludees = false, this.hasMultipassTerrain = false, this.cullAboveGround = false, this.doublePrecisionRequiresObfuscation = false;
  }
}
e$c([e$j({ count: h$b.COUNT })], E$4.prototype, "output", void 0), e$c([e$j({ count: i$l.COUNT })], E$4.prototype, "doubleSidedMode", void 0), e$c([e$j({ count: o$h.COUNT })], E$4.prototype, "transparencyPassType", void 0), e$c([e$j()], E$4.prototype, "spherical", void 0), e$c([e$j()], E$4.prototype, "receiveShadows", void 0), e$c([e$j()], E$4.prototype, "receiveAmbientOcclusion", void 0), e$c([e$j()], E$4.prototype, "vvSize", void 0), e$c([e$j()], E$4.prototype, "vvColor", void 0), e$c([e$j()], E$4.prototype, "vvOpacity", void 0), e$c([e$j()], E$4.prototype, "hasSlicePlane", void 0), e$c([e$j()], E$4.prototype, "transparent", void 0), e$c([e$j()], E$4.prototype, "hasOccludees", void 0), e$c([e$j()], E$4.prototype, "hasMultipassTerrain", void 0), e$c([e$j()], E$4.prototype, "cullAboveGround", void 0), e$c([e$j()], E$4.prototype, "doublePrecisionRequiresObfuscation", void 0), e$c([e$j({ constValue: d$n.Disabled })], E$4.prototype, "pbrMode", void 0), e$c([e$j({ constValue: true })], E$4.prototype, "hasVvInstancing", void 0), e$c([e$j({ constValue: false })], E$4.prototype, "useCustomDTRExponentForWater", void 0), e$c([e$j({ constValue: false })], E$4.prototype, "useFillLights", void 0);
class E$3 extends d$h {
  constructor(e2) {
    super(e2, new _$4()), this.supportsEdges = true, this._vertexAttributeLocations = R$3, this._configuration = new E$4(), this._vertexBufferLayout = E$3.getVertexBufferLayout(this.parameters);
  }
  getConfiguration(e2, t2) {
    return this._configuration.output = e2, this._configuration.vvSize = this.parameters.vvSizeEnabled, this._configuration.vvColor = this.parameters.vvColorEnabled, this._configuration.vvOpacity = this.parameters.vvOpacityEnabled, this._configuration.hasSlicePlane = this.parameters.hasSlicePlane, this._configuration.transparent = this.parameters.transparent, this._configuration.hasOccludees = this.parameters.hasOccludees, e2 !== h$b.Color && e2 !== h$b.Alpha || (this._configuration.doubleSidedMode = this.parameters.doubleSided && this.parameters.doubleSidedType === "normal" ? i$l.View : this.parameters.doubleSided && this.parameters.doubleSidedType === "winding-order" ? i$l.WindingOrder : i$l.None, this._configuration.receiveShadows = this.parameters.receiveShadows, this._configuration.receiveAmbientOcclusion = !!t2.ssaoHelper.ready && this.parameters.receiveSSAO), this._configuration.transparencyPassType = t2.transparencyPassType, this._configuration.hasMultipassTerrain = t2.multipassTerrain.enabled, this._configuration.cullAboveGround = t2.multipassTerrain.cullAboveGround, this._configuration;
  }
  isVisibleForOutput(e2) {
    return e2 !== h$b.Shadow && e2 !== h$b.ShadowExludeHighlight && e2 !== h$b.ShadowHighlight || this.parameters.castShadows;
  }
  isVisible() {
    return super.isVisible() && this.parameters.opacity > 0;
  }
  intersect(i2, a2, s2, o2, n2, h2, u2) {
    const l2 = i2;
    if (!i$2(l2))
      return;
    const d2 = l2.path, p2 = [this.parameters.size[0], this.parameters.size[1]];
    if (this.parameters.vvSizeEnabled) {
      const t2 = this.parameters.vvSizeOffset, r2 = this.parameters.vvSizeFactor, i3 = this.parameters.vvSizeMinSize, a3 = this.parameters.vvSizeMaxSize, s3 = d2.sizeAttributeValue;
      p2[0] *= a$g(t2[0] + s3 * r2[0], i3[0], a3[0]), p2[1] *= a$g(t2[2] + s3 * r2[2], i3[2], a3[2]);
    }
    const m2 = Math.max(p2[0], p2[1]), f2 = i2.boundingInfo;
    if (t$7(f2))
      return void this._intersectTriangles(d2, p2, n2, h2, u2);
    const b2 = u$u(f2.bbMin[0] - m2, f2.bbMin[1] - m2, f2.bbMin[2] - m2, f2.bbMax[0] + m2, f2.bbMax[1] + m2, f2.bbMax[2] + m2), v2 = [h2[0] - n2[0], h2[1] - n2[1], h2[2] - n2[2]], S2 = Math.sqrt(v2[0] * v2[0] + v2[1] * v2[1] + v2[2] * v2[2]), g2 = [S2 / v2[0], S2 / v2[1], S2 / v2[2]];
    O$a(b2, n2, g2, o2.tolerance) && this._intersectTriangles(d2, p2, n2, h2, u2);
  }
  _intersectTriangles(e2, t2, r2, i2, a2) {
    e2.baked.size && e2.baked.size[0] === t2[0] && e2.baked.size[1] === t2[1] || e2.baked.bake(t2), e2.baked.intersect(r2, i2, a2);
  }
  computeAttachmentOrigin(e2, t2) {
    const r2 = e2.vertexAttributes;
    if (!r2)
      return null;
    const i2 = r2.get(O$8.POSITION);
    return f$l(i2, null, false, t2);
  }
  createBufferWriter() {
    return new w$3(this._vertexBufferLayout);
  }
  requiresSlot(e2, t2) {
    switch (t2) {
      case h$b.Shadow:
      case h$b.ShadowHighlight:
      case h$b.ShadowExludeHighlight:
        if (!this.parameters.castShadows)
          return false;
      case h$b.Color:
      case h$b.Alpha:
      case h$b.Depth:
      case h$b.Normal:
      case h$b.Highlight:
      case h$b.ObjectAndLayerIdColor:
        return e2 === (this.parameters.transparent ? E$e.TRANSPARENT_MATERIAL : E$e.OPAQUE_MATERIAL) || e2 === E$e.DRAPED_MATERIAL;
      default:
        return false;
    }
  }
  createGLMaterial(e2) {
    return new O$1(e2);
  }
  static getVertexBufferLayout(e2) {
    const t2 = T$4().vec3f(O$8.POSITION).vec4f(O$8.PROFILERIGHT).vec4f(O$8.PROFILEUP).vec4f(O$8.PROFILEVERTEXANDNORMAL);
    return (e2.vvColorEnabled || e2.vvSizeEnabled || e2.vvOpacityEnabled) && t2.vec4f(O$8.FEATUREVALUE), t2;
  }
}
class O$1 extends t$d {
  _updateOccludeeState(e2) {
    e2.hasOccludees !== this._material.parameters.hasOccludees && this._material.setParameters({ hasOccludees: e2.hasOccludees });
  }
  _updateShadowState(e2) {
    (t$7(this.technique) || e2.shadowMap.enabled !== this.technique.configuration.receiveShadows) && this._material.setParameters({ receiveShadows: e2.shadowMap.enabled });
  }
  beginSlot(e2) {
    return this._output !== h$b.Color && this._output !== h$b.Alpha || (this._updateShadowState(e2), this._updateOccludeeState(e2)), this.ensureTechnique(C$4, e2);
  }
}
class _$4 extends x$4 {
  constructor() {
    super(...arguments), this.doubleSided = false, this.doubleSidedType = "normal", this.receiveSSAO = true, this.receiveShadows = false, this.castShadows = true, this.hasSlicePlane = false, this.transparent = false, this.hasOccludees = false;
  }
}
class w$3 {
  constructor(e2) {
    this.vertexBufferLayout = e2;
  }
  allocate(e2) {
    return this.vertexBufferLayout.createBuffer(e2);
  }
  elementCount(e2) {
    return e2.indices.get(O$8.POSITION).length;
  }
  write(e2, t2, r2, i2, a2) {
    y$6(O$8.PROFILERIGHT, r2, i2, a2), y$6(O$8.PROFILEUP, r2, i2, a2), y$6(O$8.PROFILEVERTEXANDNORMAL, r2, i2, a2), this.vertexBufferLayout.hasField(O$8.FEATUREVALUE) && y$6(O$8.FEATUREVALUE, r2, i2, a2), m$d(r2, this.vertexBufferLayout, e2, t2, i2, a2);
  }
}
function y$6(e2, t2, r2, a2) {
  if (t2.vertexAttributes.has(e2)) {
    const s2 = t2.vertexAttributes.get(e2), o2 = t2.indices.get(e2);
    e$v(s2.size === 4);
    const n2 = r2.getField(e2, c$r);
    if (!n2)
      throw new Error("unable to acquire view for " + e2);
    u$m(o2, s2.data, n2, a2);
  }
}
const se = ["polyline"];
class ae extends y$9 {
  constructor(e2, t2, r2, i2) {
    super(e2, t2, r2, i2), this._intrinsicSize = r$i(1, 1), this._upVectorAlignment = "path", this._stencilWidth = 0.1, this.ensureDrapedStatus(false);
  }
  async doLoad() {
    const t2 = r$d(this.symbolLayer.width) ? this.symbolLayer.width : this.symbolLayer.height, r2 = r$d(this.symbolLayer.height) ? this.symbolLayer.height : t2;
    this._vvConvertOptions = { modelSize: [1, 1, 1], symbolSize: [t2, 1, r2], unitInMeters: this._context.renderCoordsHelper.unitInMeters, transformation: { anchor: [0, 0, 0], scale: [1, 1, 1], rotation: [0, 0, 0] }, supportedTypes: { size: true, color: true, opacity: true, rotation: false } }, this._context.renderer && this._context.renderer.visualVariables && this._context.renderer.visualVariables.length > 0 ? this._fastUpdates = P$4(this._context.renderer, this._vvConvertOptions) : this._fastUpdates = { enabled: false };
    const a2 = this.symbolLayer.anchor || "center";
    this._upVectorAlignment = "path", this.symbolLayer.profileRotation === "heading" && (this._upVectorAlignment = "world");
    const l2 = this.symbolLayer.profile || "circle";
    switch (l2) {
      case "circle":
      default:
        this._profile = j$2.circle(_e);
        break;
      case "quad":
        this._profile = j$2.rect();
    }
    let c2 = [0, 0];
    a2 !== "center" && (c2 = { left: [0.5, 0], right: [-0.5, 0], top: [0, -0.5], bottom: [0, 0.5] }[a2], this._profile.translate(c2[0], c2[1]));
    switch (this.symbolLayer.join || "simple") {
      case "round":
        this._extruder = new X(0, ge);
        break;
      case "bevel":
        this._extruder = new X(0, 1);
        break;
      case "miter":
        this._extruder = new X(0.8 * Math.PI, 1);
        break;
      default:
        this._extruder = new H$3();
    }
    const p2 = this.symbolLayer.cap || "butt";
    switch (p2) {
      case "none":
        this._startCap = new W$2(), this._endCap = new W$2();
        break;
      case "butt":
      default:
        this._startCap = new Y$3(this._profile, 0), this._endCap = new Y$3(this._profile, 0, true);
        break;
      case "square":
        this._startCap = new Y$3(this._profile, -0.5), this._endCap = new Y$3(this._profile, 0.5, true);
        break;
      case "round": {
        const e2 = l2 === "quad";
        this._startCap = new Z({ profile: this._profile, flip: false, breakNormals: e2, subdivisions: ye }), this._endCap = new Z({ profile: this._profile, flip: true, breakNormals: e2, subdivisions: ye });
        break;
      }
    }
    const m2 = q$7(this.symbolLayer, "material", "color"), d2 = this._getCombinedOpacityAndColor(m2), f2 = e$l(d2), u2 = d2[3], g2 = u2 < 1 || this.needsDrivenTransparentPass, y2 = { diffuse: f2, ambient: f2, opacity: u2, transparent: g2, hasVertexColors: false, hasSlicePlane: this._context.slicePlaneEnabled, castShadows: this.symbolLayer.castShadows, cullFace: g2 || p2 === "none" ? n$l.None : n$l.Back, offsetTransparentBackfaces: true };
    if (!this._drivenProperties.size && (r$g(this._intrinsicSize, t2, r2), !V$6(this._intrinsicSize[0]) || !V$6(this._intrinsicSize[1])))
      throw new s$d("graphics3dpathsymbollayer:invalid-size", "Symbol sizes may not be negative values");
    if (this._fastUpdates.enabled && this._fastUpdates.visualVariables.size || l$i(this._intrinsicSize, this._intrinsicSize, 1 / this._context.renderCoordsHelper.unitInMeters), this._fastUpdates.enabled) {
      const e2 = __spreadProps(__spreadValues(__spreadValues({}, y2), this._fastUpdates.materialParameters), { size: e$A(this._intrinsicSize) });
      this._material = new E$3(e2);
    } else
      y2.hasVertexColors = this._drivenProperties.color || this._drivenProperties.opacity, this._material = new C$b(y2);
    this._material.setParameters({ usePBR: this._context.physicalBasedRenderingEnabled, isSchematic: true }), this._context.stage.add(this._material);
  }
  destroy() {
    super.destroy(), this._context.stage.remove(this._material), this._material = null;
  }
  createGraphics3DGraphic(e2) {
    const t2 = e2.graphic;
    if (!this._validateGeometry(t2.geometry, se, this.symbolLayer.type))
      return null;
    const r2 = this.setGraphicElevationContext(t2, new h$8()), i2 = e2.renderingInfo;
    return this._createAs3DShape(t2, i2, r2, t2.uid);
  }
  layerOpacityChanged() {
    const e2 = q$7(this.symbolLayer, "material", "color"), t2 = this._getCombinedOpacity(e2), r2 = t2 < 1 || this.needsDrivenTransparentPass;
    this._material.setParameters({ opacity: t2, transparent: r2 });
  }
  layerElevationInfoChanged(e2, t2) {
    return this.updateGraphics3DGraphicElevationInfo(e2, t2, v$e);
  }
  slicePlaneEnabledChanged() {
    return this._material.setParameters({ hasSlicePlane: this._context.slicePlaneEnabled }), true;
  }
  physicalBasedRenderingChanged() {
    return this._material.setParameters({ usePBR: this._context.physicalBasedRenderingEnabled, isSchematic: true }), true;
  }
  pixelRatioChanged() {
    return true;
  }
  applyRendererDiff(e2, t2) {
    for (const r2 in e2.diff) {
      if (r2 !== "visualVariables")
        return e$a.Recreate_Symbol;
      if (!R$6(this._fastUpdates, t2, this._vvConvertOptions))
        return e$a.Recreate_Symbol;
      this._material.setParameters(this._fastUpdates.materialParameters);
    }
    return e$a.Fast_Update;
  }
  getVertexData(e2) {
    let t2 = 0;
    const r2 = e2.paths, s2 = [], a2 = e2.spatialReference, o2 = this._context.elevationProvider.spatialReference, n2 = this._context.renderCoordsHelper.spatialReference;
    for (const i2 of r2)
      t2 += i2.length;
    const l2 = new Float64Array(3 * t2), h2 = new Float64Array(3 * t2), c2 = new Float64Array(3 * t2);
    let p2 = 0;
    for (const i2 of r2) {
      s2.push({ index: p2, numVertices: i2.length });
      for (const t3 of i2)
        l2[p2++] = t3[0], l2[p2++] = t3[1], l2[p2++] = e2.hasZ ? t3[2] : 0;
    }
    let m2 = true;
    return r$d(o2) && !a2.equals(o2) ? m2 = xn(l2, a2, 0, h2, o2, 0, t2) : this._copyVertices(l2, 0, h2, 0, t2), r$d(o2) && !o2.equals(n2) ? xn(h2, o2, 0, c2, n2, 0, t2) : this._copyVertices(h2, 0, c2, 0, t2), { pathVertexDataInfos: s2, vertexDataGS: l2, vertexDataES: h2, vertexDataRS: c2, projectionSuccess: m2, terrainElevation: 0 };
  }
  _copyVertices(e2, t2, r2, i2, s2) {
    t2 *= 3, i2 *= 3;
    for (let a2 = 0; a2 < s2; ++a2)
      r2[i2++] = e2[t2++], r2[i2++] = e2[t2++], r2[i2++] = e2[t2++];
  }
  _createAs3DShape(e2, t2, r2, s2) {
    const a2 = e2.geometry, o2 = new Array(), n2 = new Array(), l2 = new Array(), h2 = a2.spatialReference, p2 = a$b(), m2 = this._context.renderCoordsHelper;
    pe.spatialReference = h2;
    const d2 = this.getVertexData(a2);
    if (!d2.projectionSuccess)
      return this.logger.warn("PathSymbol3DLayer geometry failed to be created (failed to project geometry to view spatial reference)"), null;
    if (d2.pathVertexDataInfos.length > 0) {
      for (let a3 = 0; a3 < d2.pathVertexDataInfos.length; ++a3) {
        const f2 = d2.pathVertexDataInfos[a3], u2 = f2.index, g2 = f2.numVertices;
        if (g2 < 2)
          continue;
        if (r$d(this._context.clippingExtent) && (A$6(p2), M$9(p2, d2.vertexDataES, 3 * u2, g2), !R$9(p2, this._context.clippingExtent)))
          continue;
        const y2 = [];
        for (let e3 = u2; e3 < u2 + 3 * g2; ) {
          const t3 = e3++, i2 = e3++, s3 = e3++, a4 = new B$1();
          o$7(a4.posGS, d2.vertexDataGS[t3], d2.vertexDataGS[i2], d2.vertexDataGS[s3]), o$7(a4.posES, d2.vertexDataES[t3], d2.vertexDataES[i2], d2.vertexDataES[s3]);
          const o3 = m$e(a4.posES, this._context.elevationProvider, r2, m2);
          o$7(me, d2.vertexDataRS[t3], d2.vertexDataRS[i2], d2.vertexDataRS[s3]), m2.setAltitude(me, o3), o$7(a4.pos, me[0], me[1], me[2]), y2.push(a4);
        }
        const _2 = new z$3(y2);
        oe(_2, this._upVectorAlignment, this._context.renderCoordsHelper);
        const b2 = new $(_2, this._profile, this._extruder, this._startCap, this._endCap);
        let v2 = null;
        if (this._fastUpdates.enabled) {
          const t3 = this._fastUpdates.visualVariables, r3 = t3.size ? v$8(t3.size.field, e2) : 0, i2 = t3.color ? v$8(t3.color.field, e2) : 0, s3 = t3.opacity ? v$8(t3.opacity.field, e2) : 0;
          v2 = new it(b2, r3, i2, s3);
        } else {
          const e3 = [this._intrinsicSize[0], this._intrinsicSize[1]];
          this._drivenProperties.size && (e3[0] *= ne(t2.size[0], t2.size[2] === "symbol-value" ? this.symbolLayer.height || 0 : t2.size[2], this.symbolLayer.width || 0), e3[1] *= ne(t2.size[2], t2.size[0] === "symbol-value" ? this.symbolLayer.width || 0 : t2.size[0], this.symbolLayer.height || 0));
          let r3 = null;
          this._drivenProperties.color && (r3 = t2.color), this._drivenProperties.opacity && t2.opacity != null && (r3 = r3 ? [r3[0], r3[1], r3[2], t2.opacity] : [1, 1, 1, t2.opacity]);
          const i2 = new et(b2);
          i2.bake(e3), r3 && i2.bakeVertexColors(r3), v2 = i2;
        }
        const { vertexAttributes: x2, indices: w2 } = v2.createGeometryData(), P2 = this._context.stage.renderView._getObjectAndLayerIdColor({ graphicUid: s2, layerUid: this._context.layer.uid }), j2 = new r$2(x2, w2, v2, h2, this._upVectorAlignment, this._stencilWidth, P2);
        o2.push(j2), n2.push(this._material), l2.push(v2.xform);
      }
      if (o2.length > 0) {
        const e3 = { layerUid: this._context.layer.uid, graphicUid: s2 }, t3 = new x$c({ geometries: o2, materials: n2, transformations: l2, metadata: e3 }), i2 = new _$b(this, t3, o2, null, null, he, r2);
        return i2.alignedSampledElevation = d2.terrainElevation, i2.needsElevationUpdates = v$e(r2.mode), i2;
      }
    } else
      a2.paths.length !== 0 && a2.paths.some((e3) => e3.length > 0) || this.logger.warn("PathSymbol3DLayer geometry failed to be created (no paths were defined)");
    return null;
  }
}
function oe(e2, i2, s2) {
  switch (i2) {
    case "world":
      for (const t2 of e2.vertices)
        u$g(de, t2.pos, e2.offset), s2.worldUpAtPosition(de, me), t2.setFrameFromUpVector(me), t2.computeRotationAxisAndAngleFromUpVector();
      break;
    case "path":
      u$g(de, e2.vertices[0].pos, e2.offset), s2.worldUpAtPosition(de, me), J(e2, me);
      for (const i3 of e2.vertices) {
        const e3 = Math.sign(P$9(i3.frame.right, i3.vRight));
        _$d(i3.rotationFrame.up, i3.vRight, i3.vLeft), g$d(i3.rotationFrame.up, i3.rotationFrame.up, e3), z$5(i3.rotationFrame.up, i3.rotationFrame.up);
        const s3 = P$9(i3.rotationFrame.up, i3.frame.up), o2 = P$9(i3.rotationFrame.up, i3.frame.right);
        if (g$d(de, i3.frame.up, -o2), g$d(fe, i3.frame.right, s3), u$g(de, de, fe), z$5(i3.rotationFrame.right, de), G$2(i3.rotationRight, i3.frame, i3.rotationFrame.right), j$a(de, i3.vLeft), i3.rotationAngle = -e3 * (Math.PI - l$q(P$9(de, i3.vRight))), Math.abs(i3.rotationAngle) > 0) {
          const e4 = F$b(Math.cos(0.5 * i3.rotationAngle));
          r$3(i3.miterStretch, 1 + (e4 - 1) * i3.rotationRight[0] * i3.rotationRight[0], (e4 - 1) * i3.rotationRight[0] * i3.rotationRight[1], (e4 - 1) * i3.rotationRight[0] * i3.rotationRight[1], 1 + (e4 - 1) * i3.rotationRight[1] * i3.rotationRight[1]);
        }
        const n2 = Math.PI - i3.rotationAngle;
        i3.maxStretchDistance = Math.abs(Math.min(i3.vLeftLength, i3.vRightLength) * F$b(Math.cos(0.5 * n2)));
      }
  }
}
function ne(e2, t2, r2) {
  switch (e2) {
    case "symbol-value":
      return r2;
    case "proportional":
      return t2;
    default:
      return e2;
  }
}
function le(e2, t2, r2, i2) {
  let s2 = 0;
  for (const a2 of e2.vertices)
    d$e(a2.posES, r2, t2, i2, ue), s2 += ue.sampledElevation, u$g(me, a2.pos, e2.offset), i2.setAltitude(me, ue.z), e$n(a2.pos, me, e2.offset);
  return e2.updatePathVertexInformation(), s2 / e2.vertices.length;
}
function he(e2, t2, r2, i2) {
  const s2 = e2.stageObject, a2 = s2.geometryRecords;
  let o2 = 0;
  ce.spatialReference = i2.spatialReference;
  for (const n2 of a2) {
    const e3 = n2.geometry;
    if (!i$2(e3))
      continue;
    const a3 = e3.path, l2 = a3.builder.path, h2 = e3.geometrySR;
    pe.spatialReference = h2, o2 += le(l2, t2, r2, i2), e3.upVectorAlignment !== "world" && oe(l2, e3.upVectorAlignment, i2), a3.onPathChanged(), e3.invalidateBoundingInfo(), s2.geometryVertexAttrsUpdated(n2);
  }
  return o2 / a2.length;
}
const ce = v$b(0, 0, 0, null), pe = v$b(0, 0, 0, null), me = n$h(), de = n$s(), fe = n$s(), ue = new j$6(), ge = 3, ye = 3, _e = 10;
function T$1(t2, o2, r2, s2, n2 = 1) {
  if (r2.isGeographic && s2 === l$f.Global) {
    const t3 = new Float64Array(o2.typedBuffer.length), e2 = 3 * o2.count, s3 = u$v(r2);
    for (let r3 = 0; r3 < e2; r3 += 3)
      ee$1(o2.typedBuffer, r3, t3, r3, s3);
    o2 = T$5.fromTypedArray(t3);
  }
  r$g(k$4, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);
  for (let e2 = 0; e2 < o2.count; e2++)
    o2.getVec(e2, E$2), k$4[0] = Math.min(k$4[0], E$2[0]), k$4[1] = Math.min(k$4[1], E$2[1]);
  const c2 = k$4[0] % n2, a2 = k$4[1] % n2;
  P$2[0] = k$4[0] - c2, P$2[1] = k$4[1] - a2;
  for (let e2 = 0; e2 < o2.count; e2++)
    o2.getVec(e2, E$2), t2.setValues(e2, (E$2[0] - P$2[0]) / n2, (E$2[1] - P$2[1]) / n2, P$2[0] / n2, P$2[1] / n2);
}
function M$1(t2, o2, r2, f2, i2 = 1) {
  o$7(Y$2, 1, 0, 0), o$7(_$3, 0, 1, 0), o$7(d$5, 0, 0, 1), C$3(y$5, o2), O(o2, F$2) && S$2(F$2, Y$2, _$3, d$5, r2, y$5), r$g(k$4, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY), r$g(A$2, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY);
  for (let e2 = 0; e2 < o2.count; e2++) {
    o2.getVec(e2, E$2);
    const t3 = P$9(Y$2, E$2), r3 = P$9(_$3, E$2);
    k$4[0] = Math.min(k$4[0], t3), k$4[1] = Math.min(k$4[1], r3), A$2[0] = Math.max(A$2[0], t3), A$2[1] = Math.max(A$2[1], r3);
  }
  const u2 = P$9(d$5, y$5);
  H$2(v$3, k$4[0], k$4[1], u2, Y$2, _$3, d$5), H$2(x$3, A$2[0], k$4[1], u2, Y$2, _$3, d$5), H$2(G$1, k$4[0], A$2[1], u2, Y$2, _$3, d$5), e$n(x$3, x$3, v$3), g$d(x$3, x$3, 0.5), e$n(G$1, G$1, v$3), g$d(G$1, G$1, 0.5), u$g(v$3, v$3, x$3), u$g(v$3, v$3, G$1);
  const I2 = k$4[0] % i2, p2 = k$4[1] % i2;
  P$2[0] = k$4[0] - I2, P$2[1] = k$4[1] - p2;
  for (let e2 = 0; e2 < o2.count; e2++) {
    o2.getVec(e2, E$2), t2.setValues(e2, (P$9(Y$2, E$2) - P$2[0]) / i2, (P$9(_$3, E$2) - P$2[1]) / i2, P$2[0] / i2, P$2[1] / i2);
    for (let t3 = 0; t3 < 3; t3++)
      f2.set(e2, t3, v$3[t3]), f2.set(e2, t3 + 3, x$3[t3]), f2.set(e2, t3 + 6, G$1[t3]);
  }
}
const y$5 = n$h(), E$2 = n$h(), F$2 = p$h(), Y$2 = n$h(), _$3 = n$h(), d$5 = n$h(), k$4 = n$k(), A$2 = n$k(), P$2 = n$k(), v$3 = n$h(), x$3 = n$h(), G$1 = n$h();
function O(t2, o2) {
  const e2 = t2.count - 1;
  return b$j(t2, o2, 0, Math.floor(e2 / 3), Math.floor(e2 * (2 / 3)));
}
function S$2(o2, e2, r2, c2, m2, p2) {
  r$d(m2) ? (m2.basisMatrixAtPosition(p2, w$2), o$7(B, w$2[0], w$2[1], w$2[2]), o$7(z$2, w$2[4], w$2[5], w$2[6]), o$7(q$1, w$2[8], w$2[9], w$2[10])) : (o$7(B, 1, 0, 0), o$7(z$2, 0, 1, 0), o$7(q$1, 0, 0, 1));
  const N2 = Y$5(o2);
  P$9(N2, q$1) < 0 && g$d(N2, N2, -1), r$e(c2, N2);
  const l2 = P$9(N2, z$2), h2 = P$9(N2, B);
  Math.abs(l2) < Math.abs(h2) ? (q$a(e2, B, N2, -h2), z$5(e2, e2), _$d(r2, e2, N2), z$5(r2, r2), g$d(r2, r2, -1)) : (q$a(r2, z$2, N2, -l2), z$5(r2, r2), _$d(e2, r2, N2), z$5(e2, e2));
}
const w$2 = e$e(), B = n$h(), z$2 = n$h(), q$1 = n$h();
function C$3(t2, o2) {
  o$7(D$1, 0, 0, 0);
  for (let e2 = 0; e2 < o2.count - 1; e2++)
    o2.getVec(e2, E$2), u$g(D$1, D$1, E$2);
  g$d(t2, D$1, 1 / (o2.count - 1));
}
const D$1 = n$h();
function H$2(t2, o2, e2, r2, n2, c2, a2) {
  o$7(t2, o2 * n2[0] + e2 * c2[0] + r2 * a2[0], o2 * n2[1] + e2 * c2[1] + r2 * a2[1], o2 * n2[2] + e2 * c2[2] + r2 * a2[2]);
}
var a$1;
!function(a2) {
  a2[a2.Horizontal = 0] = "Horizontal", a2[a2.Vertical = 1] = "Vertical", a2[a2.Cross = 2] = "Cross", a2[a2.ForwardDiagonal = 3] = "ForwardDiagonal", a2[a2.BackwardDiagonal = 4] = "BackwardDiagonal", a2[a2.DiagonalCross = 5] = "DiagonalCross", a2[a2.COUNT = 6] = "COUNT";
}(a$1 || (a$1 = {}));
const y$4 = 0.70710678118, S$1 = y$4, j$1 = 0.08715574274;
function x$2(x2) {
  const T2 = new o$9(), C2 = x2.hasMultipassTerrain && (x2.output === h$b.Color || x2.output === h$b.Alpha);
  x2.draped || T2.extensions.add("GL_OES_standard_derivatives");
  const { vertex: R2, fragment: D2 } = T2;
  v$f(R2, x2), T2.include(r$q, x2), T2.include(e$B, x2), x2.draped ? R2.uniforms.add(new o$a("worldToScreenRatio", (e2, o2) => 1 / o2.screenToPCSRatio)) : T2.attributes.add(O$8.BOUNDINGRECT, "mat3"), T2.attributes.add(O$8.POSITION, "vec3"), T2.attributes.add(O$8.UVMAPSPACE, "vec4"), T2.varyings.add("vpos", "vec3"), T2.varyings.add("vuv", "vec2"), C2 && T2.varyings.add("depth", "float");
  const $2 = x2.style === a$1.ForwardDiagonal || x2.style === a$1.BackwardDiagonal || x2.style === a$1.DiagonalCross;
  $2 && R2.code.add(n$j`
      const mat2 rotate45 = mat2(${n$j.float(y$4)}, ${n$j.float(-S$1)},
                                 ${n$j.float(S$1)}, ${n$j.float(y$4)});
    `), x2.draped || (c$u(R2, x2), R2.uniforms.add(new o$a("worldToScreenPerDistanceRatio", (e2, o2) => 1 / o2.camera.perScreenPixelRatio)), R2.code.add(n$j`vec3 projectPointToLineSegment(vec3 center, vec3 halfVector, vec3 point) {
float projectedLength = dot(halfVector, point - center) / dot(halfVector, halfVector);
return center + halfVector * clamp(projectedLength, -1.0, 1.0);
}`), R2.code.add(n$j`vec3 intersectRayPlane(vec3 rayDir, vec3 rayOrigin, vec3 planeNormal, vec3 planePoint) {
float d = dot(planeNormal, planePoint);
float t = (d - dot(planeNormal, rayOrigin)) / dot(planeNormal, rayDir);
return rayOrigin + t * rayDir;
}`), R2.code.add(n$j`
      float boundingRectDistanceToCamera() {
        vec3 center = vec3(boundingRect[0][0], boundingRect[0][1], boundingRect[0][2]);
        vec3 halfU = vec3(boundingRect[1][0], boundingRect[1][1], boundingRect[1][2]);
        vec3 halfV = vec3(boundingRect[2][0], boundingRect[2][1], boundingRect[2][2]);
        vec3 n = normalize(cross(halfU, halfV));

        vec3 viewDir = - vec3(view[0][2], view[1][2], view[2][2]);

        float viewAngle = dot(viewDir, n);
        float minViewAngle = ${n$j.float(j$1)};

        if (abs(viewAngle) < minViewAngle) {
          // view direction is (almost) parallel to plane -> clamp it to min angle
          float normalComponent = sign(viewAngle) * minViewAngle - viewAngle;
          viewDir = normalize(viewDir + normalComponent * n);
        }

        // intersect view direction with infinite plane that contains bounding rect
        vec3 planeProjected = intersectRayPlane(viewDir, cameraPosition, n, center);

        // clip to bounds by projecting to u and v line segments individually
        vec3 uProjected = projectPointToLineSegment(center, halfU, planeProjected);
        vec3 vProjected = projectPointToLineSegment(center, halfV, planeProjected);

        // use to calculate the closest point to camera on bounding rect
        vec3 closestPoint = uProjected + vProjected - center;

        return length(closestPoint - cameraPosition);
      }
    `)), R2.code.add(n$j`
    vec2 scaledUV() {
      vec2 uv = uvMapSpace.xy ${$2 ? " * rotate45" : ""};
      vec2 uvCellOrigin = uvMapSpace.zw ${$2 ? " * rotate45" : ""};

      ${x2.draped ? "" : n$j`
            float distanceToCamera = boundingRectDistanceToCamera();
            float worldToScreenRatio = worldToScreenPerDistanceRatio / distanceToCamera;
          `}

      // Logarithmically discretize ratio to avoid jittering
      float step = 0.1;
      float discreteWorldToScreenRatio = log(worldToScreenRatio);
      discreteWorldToScreenRatio = ceil(discreteWorldToScreenRatio / step) * step;
      discreteWorldToScreenRatio = exp(discreteWorldToScreenRatio);

      vec2 uvOffset = mod(uvCellOrigin * discreteWorldToScreenRatio, ${n$j.float(x2.patternSpacing)});
      return uvOffset + (uv * discreteWorldToScreenRatio);
    }
  `);
  const V2 = x2.output === h$b.Depth;
  return V2 && (T2.include(o$f, x2), i$k(T2), t$h(T2)), R2.code.add(n$j`
    void main(void) {
      vuv = scaledUV();
      vpos = position;
      ${C2 ? "depth = (view * vec4(vpos, 1.0)).z;" : ""}
      forwardNormalizedVertexColor();
      gl_Position = ${V2 ? n$j`transformPositionWithDepth(proj, view, vpos, nearFar, linearDepth);` : n$j`transformPosition(proj, view, vpos);`}
    }
  `), T2.include(u$l, x2), D2.include(e$s), x2.draped && D2.uniforms.add(new o$a("texelSize", (e2, o2) => 1 / o2.camera.pixelRatio)), x2.output === h$b.Highlight && T2.include(a$o, x2), C2 && T2.include(n$o, x2), x2.output !== h$b.Highlight && (D2.code.add(n$j`
      const float lineWidth = ${n$j.float(x2.lineWidth)};
      const float spacing = ${n$j.float(x2.patternSpacing)};
      const float spacingINV = ${n$j.float(1 / x2.patternSpacing)};

      float coverage(float p, float txlSize) {
        p = mod(p, spacing);

        float halfTxlSize = txlSize / 2.0;

        float start = p - halfTxlSize;
        float end = p + halfTxlSize;

        float coverage = (ceil(end * spacingINV) - floor(start * spacingINV)) * lineWidth;
        coverage -= min(lineWidth, mod(start, spacing));
        coverage -= max(lineWidth - mod(end, spacing), 0.0);

        return coverage / txlSize;
      }
    `), x2.draped || D2.code.add(n$j`const int maxSamples = 5;
float sample(float p) {
vec2 dxdy = abs(vec2(dFdx(p), dFdy(p)));
float fwidth = dxdy.x + dxdy.y;
ivec2 samples = 1 + ivec2(clamp(dxdy, 0.0, float(maxSamples - 1)));
vec2 invSamples = 1.0 / vec2(samples);
float accumulator = 0.0;
for (int j = 0; j < maxSamples; j++) {
if(j >= samples.y) {
break;
}
for (int i = 0; i < maxSamples; i++) {
if(i >= samples.x) {
break;
}
vec2 step = vec2(i,j) * invSamples - 0.5;
accumulator += coverage(p + step.x * dxdy.x + step.y * dxdy.y, fwidth);
}
}
accumulator /= float(samples.x * samples.y);
return accumulator;
}`)), D2.uniforms.add(new e$g("uColor", (e2) => e2.color)), D2.code.add(n$j`
    void main() {
      discardBySlice(vpos);
      ${C2 ? "terrainDepthTest(gl_FragCoord, depth);" : ""}
      vec4 color = ${x2.hasVertexColors ? "vColor * uColor;" : "uColor;"}
      color = highlightSlice(color, vpos);

      ${x2.output !== h$b.Highlight ? n$j`color.a *= ${P$1(x2)};` : ""}

      if (color.a < ${n$j.float(t$j)}) {
        discard;
      }

      ${x2.output === h$b.Alpha ? n$j`gl_FragColor = vec4(color.a);` : ""}

      ${x2.output === h$b.Color ? n$j`gl_FragColor = color; ${x2.transparencyPassType === o$h.Color ? "gl_FragColor = premultiplyAlpha(gl_FragColor);" : ""}` : ""}
      ${x2.output === h$b.Highlight ? n$j`outputHighlight();` : ""}
      ${x2.output === h$b.Depth ? n$j`outputDepth(linearDepth);` : ""};
    }
  `), T2;
}
function P$1(e2) {
  function o2(o3) {
    return e2.draped ? n$j`coverage(vuv.${o3}, texelSize)` : n$j`sample(vuv.${o3})`;
  }
  switch (e2.style) {
    case a$1.ForwardDiagonal:
    case a$1.Horizontal:
      return o2("y");
    case a$1.BackwardDiagonal:
    case a$1.Vertical:
      return o2("x");
    case a$1.DiagonalCross:
    case a$1.Cross:
      return n$j`
        1.0 - (1.0 - ${o2("x")}) * (1.0 - ${o2("y")})
      `;
    default:
      return "0.0";
  }
}
const T = Object.freeze(Object.defineProperty({ __proto__: null, build: x$2 }, Symbol.toStringTag, { value: "Module" }));
class C$2 extends e$i {
  initializeConfiguration(e2, t2) {
    t2.hasWebGL2Context = e2.rctx.type === r$s.WEBGL2;
  }
  initializeProgram(e2) {
    return new o$b(e2.rctx, C$2.shader.get().build(this.configuration), w$1);
  }
  _setPipelineState(e2, o2) {
    const r2 = this.configuration, i2 = e2 === o$h.NONE, s2 = e2 === o$h.FrontFace;
    return W$3({ blending: r2.output === h$b.Color || r2.output === h$b.Alpha ? i2 ? c$n : A$8(e2) : null, culling: h$i(r2.cullFace), depthTest: { func: l$m(e2) }, depthWrite: i2 ? r2.writeDepth && a$e : E$h(e2), colorWrite: _$c, stencilWrite: r2.hasOccludees ? e$u : null, stencilTest: r2.hasOccludees ? o2 ? o$i : f$j : null, polygonOffset: i2 || s2 ? r2.polygonOffset && N$2 : a$q(r2.enableOffset) });
  }
  initializePipeline() {
    return this._occludeePipelineState = this._setPipelineState(this.configuration.transparencyPassType, true), this._setPipelineState(this.configuration.transparencyPassType, false);
  }
  getPipelineState(e2, t2) {
    return t2 ? this._occludeePipelineState : super.getPipelineState(e2, t2);
  }
}
C$2.shader = new t$b(T, () => import("./Pattern.glsl.js"));
const N$2 = { factor: 1, units: 1 };
class x$1 extends s$b {
  constructor() {
    super(...arguments), this.output = h$b.Color, this.cullFace = n$l.None, this.transparencyPassType = o$h.NONE, this.hasSlicePlane = false, this.hasVertexColors = false, this.polygonOffset = false, this.writeDepth = true, this.hasOccludees = false, this.enableOffset = true, this.hasMultipassTerrain = false, this.cullAboveGround = false;
  }
}
e$c([e$j({ count: h$b.COUNT })], x$1.prototype, "output", void 0), e$c([e$j({ count: n$l.COUNT })], x$1.prototype, "cullFace", void 0), e$c([e$j({ count: a$1.COUNT })], x$1.prototype, "style", void 0), e$c([e$j({ count: o$h.COUNT })], x$1.prototype, "transparencyPassType", void 0), e$c([e$j()], x$1.prototype, "hasSlicePlane", void 0), e$c([e$j()], x$1.prototype, "hasVertexColors", void 0), e$c([e$j()], x$1.prototype, "polygonOffset", void 0), e$c([e$j()], x$1.prototype, "writeDepth", void 0), e$c([e$j()], x$1.prototype, "hasOccludees", void 0), e$c([e$j()], x$1.prototype, "patternSpacing", void 0), e$c([e$j()], x$1.prototype, "lineWidth", void 0), e$c([e$j()], x$1.prototype, "enableOffset", void 0), e$c([e$j()], x$1.prototype, "draped", void 0), e$c([e$j()], x$1.prototype, "hasMultipassTerrain", void 0), e$c([e$j()], x$1.prototype, "cullAboveGround", void 0);
const w$1 = new Map([[O$8.POSITION, 0], [O$8.COLOR, 3], [O$8.UVMAPSPACE, 4], [O$8.BOUNDINGRECT, 5]]);
class y$3 extends d$h {
  constructor(t2) {
    super(t2, new j()), this.supportsEdges = true, this._vertexAttributeLocations = w$1, this._configuration = new x$1();
  }
  getConfiguration(t2, e2) {
    return this._configuration.output = t2, this._configuration.cullFace = this.parameters.cullFace, this._configuration.hasVertexColors = this.parameters.hasVertexColors, this._configuration.hasSlicePlane = this.parameters.hasSlicePlane, this._configuration.polygonOffset = this.parameters.polygonOffset, this._configuration.writeDepth = this.parameters.writeDepth, this._configuration.style = this.parameters.style, this._configuration.patternSpacing = this.parameters.patternSpacing, this._configuration.lineWidth = this.parameters.lineWidth, this._configuration.draped = this.parameters.draped, this._configuration.transparencyPassType = e2.transparencyPassType, this._configuration.enableOffset = e2.camera.relativeElevation < S$g, this._configuration.hasMultipassTerrain = e2.multipassTerrain.enabled, this._configuration.cullAboveGround = e2.multipassTerrain.cullAboveGround, this._configuration;
  }
  intersect(t2, e2, r2, i2, s2, a2, o2) {
    x$g(t2, e2, i2, s2, a2, void 0, o2);
  }
  requiresSlot(t2, e2) {
    if (e2 === h$b.Color || e2 === h$b.Alpha || e2 === h$b.Highlight || e2 === h$b.Depth && this.parameters.writeLinearDepth) {
      if (t2 === E$e.DRAPED_MATERIAL)
        return true;
      if (e2 === h$b.Highlight)
        return t2 === E$e.OPAQUE_MATERIAL;
      return t2 === (this.parameters.writeDepth ? E$e.TRANSPARENT_MATERIAL : E$e.TRANSPARENT_DEPTH_WRITE_DISABLED_MATERIAL);
    }
    return false;
  }
  createGLMaterial(t2) {
    return new E$1(t2);
  }
  createBufferWriter() {
    const t2 = T$4().vec3f(O$8.POSITION).vec4u8(O$8.COLOR).vec4f(O$8.UVMAPSPACE);
    return this.parameters.draped || t2.mat3f(O$8.BOUNDINGRECT), new R$2(t2);
  }
}
class E$1 extends t$d {
  _updateParameters(t2) {
    return this.ensureTechnique(C$2, t2);
  }
  _updateOccludeeState(t2) {
    t2.hasOccludees !== this._material.parameters.hasOccludees && this._material.setParameters({ hasOccludees: t2.hasOccludees });
  }
  beginSlot(t2) {
    return this._output !== h$b.Color && this._output !== h$b.Alpha || this._updateOccludeeState(t2), this._updateParameters(t2);
  }
}
class R$2 extends v$l {
  write(t2, a2, o2, n2, c2) {
    for (const h2 of this.vertexBufferLayout.fieldNames) {
      const a3 = o2.vertexAttributes.get(h2), l2 = o2.indices.get(h2);
      if (a3 && l2)
        switch (h2) {
          case O$8.POSITION: {
            e$v(a3.size === 3);
            const e2 = n2.getField(h2, i$i);
            e2 && y$d(l2, a3.data, t2, e2, c2);
            break;
          }
          case O$8.COLOR: {
            e$v(a3.size === 3 || a3.size === 4);
            const t3 = n2.getField(h2, x$f);
            t3 && h$j(l2, a3.data, a3.size, t3, c2);
            break;
          }
          case O$8.UVMAPSPACE: {
            e$v(a3.size === 4);
            const t3 = n2.getField(h2, c$r);
            t3 && u$m(l2, a3.data, t3, c2);
            break;
          }
          case O$8.BOUNDINGRECT: {
            e$v(a3.size === 9);
            const r2 = n2.getField(h2, l$o);
            r2 && this.writeBoundingRect(l2, a3.data, t2, r2, c2);
            break;
          }
        }
    }
  }
  writeBoundingRect(t2, e2, r2, i2, s2) {
    const a2 = r2, o2 = i2.typedBuffer, n2 = i2.typedBufferStride, c2 = t2.length;
    s2 *= n2;
    for (let h2 = 0; h2 < c2; ++h2) {
      const r3 = 9 * t2[h2], i3 = e2[r3], c3 = e2[r3 + 1], l2 = e2[r3 + 2];
      o2[s2] = a2[0] * i3 + a2[4] * c3 + a2[8] * l2 + a2[12], o2[s2 + 1] = a2[1] * i3 + a2[5] * c3 + a2[9] * l2 + a2[13], o2[s2 + 2] = a2[2] * i3 + a2[6] * c3 + a2[10] * l2 + a2[14];
      for (let t3 = 3; t3 < 9; ++t3)
        o2[s2 + t3] = e2[r3 + t3];
      s2 += n2;
    }
  }
}
class j extends h$c {
  constructor() {
    super(...arguments), this.color = r$f(1, 1, 1, 1), this.writeDepth = true, this.writeLinearDepth = false, this.hasVertexColors = false, this.polygonOffset = false, this.hasSlicePlane = false, this.cullFace = n$l.None, this.hasOccludees = false, this.style = a$1.Cross, this.patternSpacing = 10, this.lineWidth = 1, this.draped = true;
  }
}
function f(r2, e2, t2) {
  return g$3(u$3(r2), e2, t2);
}
function u$3(r2) {
  return r2 && r2.pattern || null;
}
function g$3(t2, a2, o2) {
  return r$d(t2) ? t2.style === "none" || t2.style === "solid" ? (t2.style === "none" && (a2.color = r$f(0, 0, 0, 0), a2.transparent = true), new m$f(a2)) : (a2.style = p$1(t2.style), a2.draped = o2.isDraped, new y$3(a2)) : new m$f(a2);
}
function p$1(r2) {
  switch (r2) {
    case "horizontal":
      return a$1.Horizontal;
    case "vertical":
      return a$1.Vertical;
    case "cross":
      return a$1.Cross;
    case "forward-diagonal":
      return a$1.ForwardDiagonal;
    case "backward-diagonal":
      return a$1.BackwardDiagonal;
    case "diagonal-cross":
      return a$1.DiagonalCross;
    default:
      return;
  }
}
function d$4(r2) {
  return r2.material instanceof y$3 && !r2.material.parameters.draped;
}
function y$2(r2, e2) {
  if (d$4(r2)) {
    const n2 = r2.geometry.vertexAttributes, l2 = n2.get(O$8.POSITION).data, m2 = n2.get(O$8.UVMAPSPACE).data, c2 = n2.get(O$8.BOUNDINGRECT).data;
    M$1(c$r.fromTypedArray(m2), T$5.fromTypedArray(l2), e2, a$r.fromTypedArray(c2));
  }
}
function w(r2, e2, t2, a2) {
  const o2 = p$8(r2, e2, t2, a2), i2 = r2.stageObject.geometryRecords;
  for (let n2 = 0; n2 < i2.length; n2++)
    y$2(i2[n2], a2);
  return o2;
}
const H$1 = ["polyline", "polygon", "extent"];
class W$1 extends y$9 {
  constructor(e2, t2, r2, i2) {
    super(e2, t2, r2, i2), this._needsUV = false, this._hasOutline = false;
  }
  async doLoad() {
  }
  _ensureMaterials() {
    this._ensureFillMaterial(), this._ensureOutlineMaterial();
  }
  _ensureFillMaterial() {
    if (r$d(this._material))
      return;
    const e2 = q$7(this.symbolLayer, "material", "color"), i2 = this._getCombinedOpacityAndColor(e2);
    this._material = f(this.symbolLayer, { color: i2, transparent: i2[3] < 1 || this.needsDrivenTransparentPass, polygonOffset: false, hasVertexColors: true, writeLinearDepth: true, hasSlicePlane: this._context.slicePlaneEnabled }, { isDraped: this.draped }), this._needsUV = this._material instanceof y$3, this._context.stage.add(this._material);
  }
  _ensureOutlineMaterial() {
    const e2 = this.symbolLayer.outline;
    if (r$d(this._outlineMaterial) || !this._isValidOutline(e2))
      return;
    this._hasOutline = true;
    const r2 = (t2) => {
      const r3 = a$m(e2.pattern);
      return new H$5({ width: t2, color: this._getOutlineColor(), hasPolygonOffset: true, hasSlicePlane: this._context.slicePlaneEnabled, isClosed: true, stipplePattern: r3, stippleScaleWithLineWidth: true, cap: n$6(e2.patternCap || "butt") });
    };
    this._outlineMaterial = r2(u$n(e2.size)), this._context.stage.add(this._outlineMaterial);
  }
  _isValidOutline(e2) {
    return r$d(e2) && e2.size && e2.size > 0 && r$d(e2.color) && (t$7(e2.pattern) || e2.pattern.type !== "style" || e2.pattern.style !== "none");
  }
  destroy() {
    super.destroy(), this._context.stage.remove(this._material), this._material = null, this._context.stage.remove(this._outlineMaterial), this._outlineMaterial = null;
  }
  createGraphics3DGraphic(e2) {
    const t2 = e2.graphic;
    if (!this._validateGeometry(t2.geometry, H$1, this.symbolLayer.type))
      return null;
    const r2 = this._getVertexOpacityAndColor(e2.renderingInfo, 255), i2 = this.setGraphicElevationContext(t2, new h$8());
    return this.ensureDrapedStatus(i2.mode === "on-the-ground"), this._ensureMaterials(), this.draped ? this._createAsOverlay(t2, r2) : this._createAs3DShape(t2, r2, i2);
  }
  layerOpacityChanged() {
    if (r$d(this._material)) {
      const e2 = this._material.parameters.color, t2 = q$7(this.symbolLayer, "material", "color"), i2 = this._getCombinedOpacity(t2);
      this._material.setParameters({ color: [e2[0], e2[1], e2[2], i2], transparent: i2 < 1 || this.needsDrivenTransparentPass });
    }
    if (r$d(this._outlineMaterial)) {
      const e2 = this._outlineMaterial.parameters.color;
      this._outlineMaterial.setParameters({ color: [e2[0], e2[1], e2[2], this._getOutlineOpacity()] });
    }
  }
  layerElevationInfoChanged(e2, t2, r2) {
    const i2 = this._elevationContext.mode, o2 = p$c(W$1.elevationModeChangeTypes, r2, i2);
    if (o2 !== x$b.UPDATE)
      return o2;
    const n2 = g$c(i2);
    return this.updateGraphics3DGraphicElevationInfo(e2, t2, () => n2);
  }
  slicePlaneEnabledChanged() {
    if (r$d(this._material) && this._material.setParameters({ hasSlicePlane: this._context.slicePlaneEnabled }), r$d(this._outlineMaterial)) {
      const e2 = { hasSlicePlane: this._context.slicePlaneEnabled };
      this._outlineMaterial.setParameters(e2);
    }
    return true;
  }
  physicalBasedRenderingChanged() {
    return true;
  }
  pixelRatioChanged() {
    return true;
  }
  _createAs3DShape(e2, t2, r2) {
    var _a;
    const o2 = u$7(e2.geometry);
    if (t$7(o2))
      return null;
    const n2 = e$6(o2, this._context.elevationProvider, this._context.renderCoordsHelper, r2), a2 = new z$1(n2, t2, this._context.layer.uid, e2.uid), s2 = a2.renderData.position.length / 3;
    if (this._needsUV && (a2.uvMapSpace = new Float32Array(4 * s2), a2.boundingRect = new Float64Array(9 * s2)), a2.objectAndLayerIdColor = (_a = this._context.stage.renderView) == null ? void 0 : _a._getObjectAndLayerIdColor({ graphicUid: a2.graphicsUid, layerUid: a2.layerUid }), this._createAs3DShapeFill(a2), this._hasOutline && this._createAs3DShapeOutline(a2), this._logGeometryCreationWarnings(a2.renderData, o2.rings, "rings", "FillSymbol3DLayer"), a2.outGeometries.length === 0)
      return null;
    this._needsUV && M$1(c$r.fromTypedArray(a2.uvMapSpace), T$5.fromTypedArray(a2.renderData.position), this._context.renderCoordsHelper, a$r.fromTypedArray(a2.boundingRect));
    const l2 = new x$c({ geometries: a2.outGeometries, materials: a2.outMaterials, transformations: a2.outTransforms, castShadow: false, metadata: { layerUid: this._context.layer.uid, graphicUid: e2.uid } }), c2 = new _$b(this, l2, a2.outGeometries, null, null, w, r2);
    return c2.alignedSampledElevation = a2.renderData.sampledElevation, c2.needsElevationUpdates = g$c(r2.mode), c2;
  }
  _createAs3DShapeFill(e2) {
    const r2 = e2.renderData.polygons;
    for (const { position: i2, mapPosition: n2, holeIndices: l2, index: c2, count: d2 } of r2) {
      if (r$d(this._context.clippingExtent) && (A$6(k$3), M$9(k$3, n2), !R$9(k$3, this._context.clippingExtent)))
        continue;
      const r3 = x$d(n2, l2, 3);
      if (r3.length === 0)
        continue;
      const m2 = n$7({ indices: r3, attributeData: { position: i2, color: e2.color, mapPosition: n2, uvMapSpace: this._needsUV ? new Float32Array(e2.uvMapSpace.buffer, 4 * c2 * e2.uvMapSpace.BYTES_PER_ELEMENT, 4 * d2) : null, boundingRect: this._needsUV ? new Float64Array(e2.boundingRect.buffer, 9 * c2 * e2.boundingRect.BYTES_PER_ELEMENT, 9 * d2) : null, objectAndLayerIdColor: e2.objectAndLayerIdColor } });
      e2.outGeometries.push(m2), e2.outMaterials.push(e$f(this._material)), e2.outTransforms.push(o$8);
    }
  }
  _createAs3DShapeOutline(e2) {
    if (!this._hasOutline)
      return;
    const r2 = e2.renderData.outlines;
    for (let i2 = 0; i2 < r2.length; ++i2) {
      const { mapPosition: n2, position: a2 } = r2[i2];
      if (r$d(this._context.clippingExtent) && (A$6(k$3), M$9(k$3, n2), !R$9(k$3, this._context.clippingExtent)))
        continue;
      const l2 = m$c({ overlayInfo: null, removeDuplicateStartEnd: true, attributeData: { position: a2, mapPosition: n2 } }, e2.objectAndLayerIdColor), c2 = l2.vertexAttributes.get(O$8.POSITION);
      c2.data === a2 && (c2.data = new Float64Array(a2)), e2.outGeometries.push(l2), e2.outMaterials.push(e$f(this._outlineMaterial)), e2.outTransforms.push(o$8);
    }
  }
  _createAsOverlay(e2, r2) {
    var _a;
    const n2 = u$7(e2.geometry);
    if (t$7(n2))
      return null;
    e$f(this._material).renderPriority = this._renderPriority + this._renderPriorityStep / 2, r$d(this._outlineMaterial) && (this._outlineMaterial.renderPriority = this._renderPriority);
    const a2 = r$9(n2, this._context.overlaySR), s2 = new Y$1(a2, r2, this._context.layer.uid, e2.uid), l2 = s2.renderData.position.length / 3;
    return this._needsUV && (s2.uvMapSpace = new Float32Array(4 * l2)), s2.outBoundingBox = A$6(), s2.objectAndLayerIdColor = (_a = this._context.stage.renderView) == null ? void 0 : _a._getObjectAndLayerIdColor({ graphicUid: s2.graphicsUid, layerUid: s2.layerUid }), this._createAsOverlayFill(s2), this._hasOutline && this._createAsOverlayOutline(s2), this._logGeometryCreationWarnings(s2.renderData, n2.rings, "rings", "FillSymbol3DLayer"), s2.outGeometries.length === 0 ? null : (this._needsUV && T$1(c$r.fromTypedArray(s2.uvMapSpace), T$5.fromTypedArray(s2.renderData.position), this._context.overlaySR, this._context.graphicsCoreOwner.view.state.viewingMode), new l$6(this, s2.outGeometries, s2.outBoundingBox, this._context.drapeSourceRenderer));
  }
  _createAsOverlayFill(e2) {
    const t2 = e2.renderData.polygons;
    for (const { position: r2, holeIndices: i2, index: n2, count: s2 } of t2) {
      if (A$6(k$3), M$9(k$3, r2), !R$9(k$3, this._context.clippingExtent))
        continue;
      const t3 = x$d(r2, i2, 3);
      if (t3.length === 0)
        continue;
      f$e(e2.outBoundingBox, k$3);
      const c2 = n$7({ indices: t3, attributeData: { position: r2, color: e2.color, uvMapSpace: this._needsUV ? new Float32Array(e2.uvMapSpace.buffer, 4 * n2 * e2.uvMapSpace.BYTES_PER_ELEMENT, 4 * s2) : null, objectAndLayerIdColor: e2.objectAndLayerIdColor } }), m2 = new T$6(c2, e$f(this._material), { layerUid: e2.layerUid, graphicUid: e2.graphicsUid }), y2 = k$3;
      r$m(m2.boundingSphere, 0.5 * (y2[0] + y2[3]), 0.5 * (y2[1] + y2[4]), 0, 0.5 * Math.sqrt((y2[3] - y2[0]) * (y2[3] - y2[0]) + (y2[4] - y2[1]) * (y2[4] - y2[1]))), e2.outGeometries.push(m2);
    }
  }
  _createAsOverlayOutline(e2) {
    if (!this._hasOutline)
      return;
    const t2 = e2.renderData.outlines;
    for (let r2 = 0; r2 < t2.length; ++r2) {
      const { position: i2 } = t2[r2];
      if (A$6(k$3), M$9(k$3, i2), !R$9(k$3, this._context.clippingExtent))
        continue;
      f$e(e2.outBoundingBox, k$3);
      const n2 = m$c({ overlayInfo: { spatialReference: this._context.overlaySR, renderCoordsHelper: this._context.renderCoordsHelper }, removeDuplicateStartEnd: true, attributeData: { position: i2 } }, e2.objectAndLayerIdColor), a2 = new T$6(n2, e$f(this._outlineMaterial), { layerUid: e2.layerUid, graphicUid: e2.graphicsUid }), s2 = k$3;
      r$m(a2.boundingSphere, 0.5 * (s2[0] + s2[3]), 0.5 * (s2[1] + s2[4]), 0, 0.5 * Math.sqrt((s2[3] - s2[0]) * (s2[3] - s2[0]) + (s2[4] - s2[1]) * (s2[4] - s2[1]))), e2.outGeometries.push(a2);
    }
  }
  _getOutlineOpacity() {
    const e2 = q$7(this.symbolLayer, "outline", "color");
    return (this.draped ? 1 : this._getLayerOpacity()) * (r$d(e2) ? e2.a : 0);
  }
  _getOutlineColor() {
    const i2 = q$7(this.symbolLayer, "outline", "color"), o2 = this._getOutlineOpacity();
    return B$5(r$d(i2) ? l$c.toUnitRGB(i2) : null, o2);
  }
  test() {
    return __spreadProps(__spreadValues({}, super.test()), { createAsOverlay: (e2, t2) => this._createAsOverlay(e2, t2), createAs3DShape: (e2, t2, r2) => this._createAs3DShape(e2, t2, r2) });
  }
}
W$1.elevationModeChangeTypes = { definedChanged: x$b.RECREATE, staysOnTheGround: x$b.NONE, onTheGroundChanged: x$b.RECREATE };
const k$3 = a$b();
class z$1 extends c$7 {
  constructor(e2, t2, r2, i2) {
    super(e2, r2, i2), this.color = t2;
  }
}
class Y$1 extends c$7 {
  constructor(e2, t2, r2, i2) {
    super(e2, r2, i2), this.color = t2;
  }
}
class s$4 {
  constructor(o2) {
    this.definition = o2, this.key = JSON.stringify(o2), this.haloSize = Math.round(o2.halo.size), this.textStyle = this._colorToRGBA(o2.color), this.haloStyle = this._colorToRGB(o2.halo.color), this.backgroundStyle = o2.background.color[3] !== 0 ? this._colorToRGBA(o2.background.color) : null;
  }
  fontString(o2) {
    const r2 = this.definition.font;
    return `${r2.style} ${r2.weight} ${o2}px ${r2.family}, sans-serif`;
  }
  _colorToRGB(o2) {
    return `rgb(${o2.slice(0, 3).map((o3) => Math.floor(255 * o3)).toString()})`;
  }
  _colorToRGBA(o2) {
    return `rgba(${o2.slice(0, 3).map((o3) => Math.floor(255 * o3)).toString()},${o2[3]})`;
  }
  static async fromSymbol(a2, c2 = 1) {
    const g2 = q$7(a2, "material", "color"), f2 = b$k(g2, l$d, l$c.toUnitRGBA), d2 = b$k(a2.size, 12, u$n), h2 = a2.lineHeight, m2 = r$d(a2.background) ? l$c.toUnitRGBA(a2.background.color) : l$d, u2 = { family: b$k(a2.font, "sans-serif", (o2) => o2.family), decoration: b$k(a2.font, "none", (o2) => o2.decoration), weight: b$k(a2.font, "normal", (o2) => o2.weight), style: b$k(a2.font, "normal", (o2) => o2.style) }, b2 = a2.halo, y2 = r$d(b2) && r$d(b2.color) && b2.size > 0 ? { size: u$n(b2.size), color: l$c.toUnitRGBA(b2.color) } : { size: 0, color: l$d }, p2 = new s$4({ color: f2, size: d2, background: { color: m2, padding: r$d(a2.background) ? [0.65 * d2, 0.5 * d2] : [0, 0], borderRadius: r$d(a2.background) ? d2 * (6 / 16) : 0 }, lineSpacingFactor: h2, font: u2, halo: y2, pixelRatio: c2 }), S2 = p2.fontString(d2);
    try {
      await document.fonts.load(S2);
    } catch (R2) {
      s$a.getLogger("esri.views.3d.webgl-engine.lib.TextRenderParameters").warnOnce(`Failed to preload font '${S2}'. Some text symbology may be rendered using the default browser font.`);
    }
    return p2;
  }
}
class i$1 {
  constructor(e2, t2, n2) {
    this._renderer = new s$6(e2, t2, n2);
  }
  get key() {
    return this._renderer.key;
  }
  get baselineAnchorY() {
    return 1 - this._renderer.firstRenderedBaselinePosition / this._renderer.renderedHeight;
  }
  get displayWidth() {
    return this._renderer.displayWidth;
  }
  get displayHeight() {
    return this._renderer.displayHeight;
  }
  create() {
    const r2 = o$3(d$3, this._renderer.renderedWidth, this._renderer.renderedHeight), i2 = r2.getContext("2d");
    return i2.save(), this._renderer.render(i2, 0, 0), i2.restore(), new L$6(r2, { wrap: { s: D$5.CLAMP_TO_EDGE, t: D$5.CLAMP_TO_EDGE }, noUnpackFlip: false, mipmap: true, preMultiplyAlpha: true, powerOfTwoResizeMode: c$m.PAD });
  }
}
const d$3 = { canvas: null };
const C$1 = [0, 0, 1];
class R$1 extends y$9 {
  constructor(e2, t2, r2, n2) {
    super(e2, t2, r2, n2), this._elevationOptions = { supportsOffsetAdjustment: true, supportsOnTheGround: false }, this.ensureDrapedStatus(false);
  }
  async doLoad() {
    if (!this._drivenProperties.size) {
      const t2 = S$f(this.symbolLayer.size);
      if (t2)
        throw new s$d("graphics3dtextsymbollayer:invalid-size", t2);
    }
    await this._createTextRenderParameters();
  }
  async _createTextRenderParameters() {
    const e2 = this._context.graphicsCoreOwner.view.state.pixelRatio;
    this._textRenderParameters = await s$4.fromSymbol(this.symbolLayer, e2);
  }
  destroy() {
    super.destroy();
  }
  createGraphics3DGraphic(e2) {
    const n2 = e2.graphic, s2 = d$9(n2.geometry);
    if (t$7(s2))
      return this.logger.warn(`unsupported geometry type for text symbol: ${n2.geometry.type}`), null;
    const i2 = this.symbolLayer.text;
    if (t$7(i2) || i2 === "")
      return null;
    const o2 = i$c(this.symbol) && this.symbol.hasVisibleVerticalOffset() ? this.symbol.verticalOffset : null;
    if (r$d(o2) && !l$h(this.symbolLayer))
      return this.logger.errorOncePerTick(`Callouts and vertical offset on text symbols are currently only supported with 'center' horizontal alignment (not with '${this.symbolLayer.horizontalAlignment}' alignment)`), null;
    const a2 = __spreadProps(__spreadValues({}, A$1), { verticalOffset: o2, horizontalPlacement: this.symbolLayer.horizontalAlignment, verticalPlacement: f$5(this.symbolLayer.verticalAlignment) });
    return this._createAs3DShape(n2, s2, i2, a2);
  }
  createLabel(e2, r2, n2, s2) {
    const i2 = e2.graphic, o2 = d$9(i2.geometry);
    if (t$7(o2))
      return this.logger.warn(`unsupported geometry type for label: ${i2.geometry.type}`), null;
    const a2 = r2.text;
    return !a2 || /^\s+$/.test(a2) ? null : this._createAs3DShape(i2, o2, a2, r2, n2, s2);
  }
  setGraphicElevationContext(e2, t2, r2 = 0) {
    const n2 = super.setGraphicElevationContext(e2, t2);
    return n2.addOffsetRenderUnits(r2), n2;
  }
  layerOpacityChanged() {
    return this.logger.warn("layer opacity change not yet implemented in Graphics3DTextSymbolLayer"), false;
  }
  layerElevationInfoChanged(e2, t2) {
    return U$1(e2, t2, (e3, t3) => {
      this.updateGraphicElevationContext(t3, e3);
    }), x$b.UPDATE;
  }
  slicePlaneEnabledChanged(e2, t2) {
    return U$1(e2, t2, (e3) => {
      for (const t3 of e3.stageObject.geometryRecords)
        t3.material.setParameters({ hasSlicePlane: this._context.slicePlaneEnabled });
    }), true;
  }
  physicalBasedRenderingChanged() {
    return true;
  }
  pixelRatioChanged() {
    return false;
  }
  updateGraphicElevationContext(e2, t2) {
    this.setGraphicElevationContext(e2, t2.elevationContext, t2.metadata.elevationOffset), t2.needsElevationUpdates = g$c(t2.elevationContext.mode) || t2.elevationContext.mode === "absolute-height";
  }
  _defaultElevationInfoNoZ() {
    return G;
  }
  _createAs3DShape(e2, l2, c2, m2, f2, g2) {
    const y2 = this.setGraphicElevationContext(e2, new h$8(), m2.elevationOffset), x2 = q$7(e2.geometry, "type") === "polyline", b2 = e2.uid;
    let P2 = null, O2 = null;
    if (t$7(g2)) {
      const e3 = c$5(m2.horizontalPlacement);
      P2 = new i$1(c2, e3, this._textRenderParameters);
      let n2 = null;
      if (r$d(this._context.sharedResources.textures)) {
        O2 = this._context.sharedResources.textures.fromData(P2.key, () => e$f(P2).create(), () => {
          r$d(n2) && n2.release();
        });
        const e4 = this._context.stage.renderView.textureRepository.acquire(O2.texture.id);
        if (t$7(e4) || C$d(e4))
          return O2.release(), null;
        n2 = e4;
      }
    }
    const w2 = D(P2, m2), L2 = { occlusionTest: true, screenOffset: m2.screenOffset, anchorPosition: w2, polygonOffset: true, color: [1, 1, 1, 1], centerOffsetUnits: m2.centerOffsetUnits, debugDrawLabelBorder: m2.debugDrawLabelBorder, drawInSecondSlot: true };
    if (r$d(O2) && (L2.textureId = O2.texture.id), r$d(g2) && (L2.textureId = g2.id), r$d(m2.verticalOffset)) {
      const { screenLength: e3, minWorldLength: t2, maxWorldLength: n2 } = m2.verticalOffset;
      L2.verticalOffset = { screenLength: u$n(e3), minWorldLength: t2 || 0, maxWorldLength: r$d(n2) ? n2 : 1 / 0 };
    }
    if (this._context.screenSizePerspectiveEnabled) {
      const { screenSizePerspectiveSettings: e3, screenSizePerspectiveSettingsLabels: t2 } = this._context.sharedResources;
      L2.screenSizePerspective = t2.overridePadding(this._textRenderParameters.haloSize + this._textRenderParameters.definition.background.padding[0]), L2.screenSizePerspectiveAlignment = e3;
    }
    let R2;
    if (x2 && (L2.shaderPolygonOffset = 1e-4), L2.hasSlicePlane = this._context.slicePlaneEnabled, r$d(f2)) {
      const e3 = JSON.stringify(L2);
      R2 = f2.get(e3), t$7(R2) && (R2 = new Q$1(L2), f2.add(e3, R2));
    } else
      R2 = new Q$1(L2);
    const U2 = [R2], G2 = m2.translation, A2 = r$d(P2) ? [P2.displayWidth, P2.displayHeight] : [0, 0], T2 = m2.centerOffset, W2 = [b$h(C$1, G2, null, A2, T2, [0, 0], null)], I2 = this._context.layer.uid, k2 = u$9(this._context, l2, W2, U2, y2, I2, b2);
    if (k2 === null)
      return null;
    const B2 = new _$b(this, k2.object, W2, t$7(f2) ? U2 : null, O2, d$b, y2);
    B2.alignedSampledElevation = k2.sampledElevation, B2.needsElevationUpdates = g$c(y2.mode) || y2.mode === "absolute-height";
    const { displayWidth: H2, displayHeight: $2 } = r$d(P2) ? P2 : m2;
    B2.getScreenSize = (e3 = n$k()) => (e3[0] = H2, e3[1] = $2, e3);
    const V2 = { labelText: c2, elevationOffset: m2.elevationOffset };
    return B2.metadata = V2, f$7(B2, l2, this._context.elevationProvider), B2;
  }
}
function U$1(e2, t2, n2) {
  e2 && e2.forEach((e3) => {
    const s2 = t2(e3);
    r$d(s2) && n2(s2, e3.graphic);
  });
}
function D(e2, t2) {
  if (t2.verticalPlacement === "baseline") {
    const n3 = r$7[t2.horizontalPlacement], s2 = r$d(e2) ? e2.baselineAnchorY : 0;
    return r$i(n3, s2);
  }
  const n2 = i$4(t2.horizontalPlacement, t2.verticalPlacement);
  return o$2[n2];
}
const G = { mode: "relative-to-ground", offset: 0 }, A$1 = { text: null, translation: [0, 0, 0], elevationOffset: 0, centerOffset: [0, 0, 0, 1], screenOffset: [0, 0], horizontalPlacement: "center", verticalPlacement: "center", verticalOffset: null, centerOffsetUnits: null, debugDrawLabelBorder: false, displayWidth: 0, displayHeight: 0 };
const e$3 = { "calm-small": { waveStrength: 5e-3, perturbationStrength: 0.02, textureRepeat: 12, waveVelocity: 0.01 }, "rippled-small": { waveStrength: 0.02, perturbationStrength: 0.09, textureRepeat: 32, waveVelocity: 0.07 }, "slight-small": { waveStrength: 0.05, perturbationStrength: 0.07, textureRepeat: 28, waveVelocity: 0.1 }, "moderate-small": { waveStrength: 0.075, perturbationStrength: 0.07, textureRepeat: 24, waveVelocity: 0.1 }, "calm-medium": { waveStrength: 3125e-6, perturbationStrength: 0.01, textureRepeat: 8, waveVelocity: 0.02 }, "rippled-medium": { waveStrength: 0.035, perturbationStrength: 0.015, textureRepeat: 12, waveVelocity: 0.07 }, "slight-medium": { waveStrength: 0.06, perturbationStrength: 0.015, textureRepeat: 8, waveVelocity: 0.12 }, "moderate-medium": { waveStrength: 0.09, perturbationStrength: 0.03, textureRepeat: 4, waveVelocity: 0.12 }, "calm-large": { waveStrength: 0.01, perturbationStrength: 0, textureRepeat: 4, waveVelocity: 0.05 }, "rippled-large": { waveStrength: 0.025, perturbationStrength: 0.01, textureRepeat: 8, waveVelocity: 0.11 }, "slight-large": { waveStrength: 0.06, perturbationStrength: 0.02, textureRepeat: 3, waveVelocity: 0.13 }, "moderate-large": { waveStrength: 0.14, perturbationStrength: 0.03, textureRepeat: 2, waveVelocity: 0.15 } };
const F$1 = ["polyline", "polygon", "extent"];
class I$1 extends y$9 {
  constructor(e2, t2, r2, o2) {
    super(e2, t2, r2, o2);
  }
  async doLoad() {
  }
  destroy() {
    super.destroy(), this._context.stage.remove(this._material), this._material = null;
  }
  createGraphics3DGraphic(e2) {
    const t2 = e2.graphic;
    if (!this._validateGeometry(t2.geometry, F$1, this.symbolLayer.type))
      return null;
    const r2 = this.setGraphicElevationContext(t2, new h$8());
    return this.ensureDrapedStatus(r2.mode === "on-the-ground"), this.ensureMaterial(), this.draped ? this._createAsOverlay(t2) : this._createAs3DShape(t2, r2, t2.uid);
  }
  ensureMaterial() {
    if (r$d(this._material))
      return;
    const r2 = new d$o(), o2 = this.symbolLayer.color;
    r$d(o2) && (r2.color = l$c.toUnitRGBA(o2));
    const i2 = this._getCombinedOpacity(o2, { hasIntrinsicColor: true });
    r2.color = [r2.color[0], r2.color[1], r2.color[2], i2], r2.transparent = i2 < 1 || this.needsDrivenTransparentPass, r2.waveDirection = r$d(this.symbolLayer.waveDirection) ? I$1.headingVectorFromAngle(this.symbolLayer.waveDirection) : r$i(0, 0);
    const s2 = this.symbolLayer.waveStrength + "-" + this.symbolLayer.waterbodySize, n2 = e$3[s2];
    r2.waveStrength = n2.waveStrength, r2.waveTextureRepeat = n2.textureRepeat, r2.waveVelocity = n2.waveVelocity, r2.flowStrength = n2.perturbationStrength, r2.hasSlicePlane = this._context.slicePlaneEnabled, r2.isDraped = this.draped, this._material = new f$m(r2), this._context.stage.add(this._material);
  }
  layerOpacityChanged() {
    if (t$7(this._material))
      return;
    const e2 = this._material.parameters.color, t2 = this._getCombinedOpacity(this.symbolLayer.color, { hasIntrinsicColor: true }), o2 = t2 < 1 || this.needsDrivenTransparentPass;
    this._material.setParameters({ color: [e2[0], e2[1], e2[2], t2], transparent: o2 });
  }
  layerElevationInfoChanged(e2, t2, r2) {
    const o2 = this._elevationContext.mode, i2 = p$c(I$1.elevationModeChangeTypes, r2, o2);
    if (i2 !== x$b.UPDATE)
      return i2;
    const s2 = g$c(o2);
    return this.updateGraphics3DGraphicElevationInfo(e2, t2, () => s2);
  }
  slicePlaneEnabledChanged() {
    return r$d(this._material) && this._material.setParameters({ hasSlicePlane: this._context.slicePlaneEnabled }), true;
  }
  physicalBasedRenderingChanged() {
    return true;
  }
  pixelRatioChanged() {
    return true;
  }
  _createAs3DShape(e2, t2, o2) {
    const i2 = u$7(e2.geometry);
    if (t$7(i2))
      return null;
    const s2 = e$6(i2, this._context.elevationProvider, this._context.renderCoordsHelper, t2), n2 = s2.position.length / 3, a2 = new Float64Array(2 * n2), l2 = new Y(s2, a2);
    if (this._create3DShapeGeometries(l2), this._logGeometryCreationWarnings(l2.renderData, i2.rings, "rings", "WaterSymbol3DLayer"), l2.outGeometries.length === 0)
      return null;
    this._createUVCoordsFromVertices(l2.uvCoords, l2.renderData.mapPosition, n2, this._context.elevationProvider.spatialReference);
    const c2 = new x$c({ geometries: l2.outGeometries, materials: l2.outMaterials, transformations: l2.outTransforms, castShadow: false, metadata: { layerUid: this._context.layer.uid, graphicUid: o2 } }), h2 = new _$b(this, c2, l2.outGeometries, null, null, p$8, t2);
    return h2.alignedSampledElevation = l2.renderData.sampledElevation, h2.needsElevationUpdates = g$c(t2.mode), h2;
  }
  _createUVCoordsFromVertices(e2, t2, r2, o2) {
    const s2 = $$3(o2);
    D$6(k$2);
    for (let i2 = 0; i2 < r2; i2++)
      r$g(z, t2[3 * i2 + 0], t2[3 * i2 + 1]), m$g(k$2, z);
    l$r(k$2, k$2, s2);
    const n2 = k$2[0] % I$1.unitSizeOfTexture, l2 = k$2[1] % I$1.unitSizeOfTexture;
    W[0] = k$2[0] - n2, W[1] = k$2[1] - l2;
    for (let i2 = 0; i2 < r2; i2++)
      e2[2 * i2 + 0] = (t2[3 * i2 + 0] * s2 - W[0]) / I$1.unitSizeOfTexture, e2[2 * i2 + 1] = (t2[3 * i2 + 1] * s2 - W[1]) / I$1.unitSizeOfTexture;
  }
  _create3DShapeGeometries(e2) {
    const r2 = e2.renderData.polygons, i2 = e2.uvCoords;
    for (const { count: a2, index: l2, position: c2, mapPosition: h2, holeIndices: m2 } of r2) {
      if (r$d(this._context.clippingExtent) && (A$6(N$1), M$9(N$1, h2), !R$9(N$1, this._context.clippingExtent)))
        continue;
      const r3 = x$d(h2, m2, 3);
      if (r3.length === 0)
        continue;
      const u2 = new Float64Array(i2.buffer, 2 * l2 * i2.BYTES_PER_ELEMENT, 2 * a2), p2 = o$4({ indices: r3, attributeData: { position: c2, uv0: u2, mapPosition: h2 } });
      e2.outGeometries.push(p2), e2.outMaterials.push(e$f(this._material)), e2.outTransforms.push(o$8);
    }
  }
  _createAsOverlay(e2) {
    const t2 = u$7(e2.geometry);
    if (t$7(t2))
      return null;
    e$f(this._material).renderPriority = this._renderPriority;
    const i2 = r$9(t2, this._context.overlaySR), s2 = i2.position.length / 3, n2 = new Float64Array(2 * s2), a2 = new q(i2, n2, this._context.layer.uid, e2.uid);
    return a2.outBoundingBox = A$6(), this._createAsOverlayWater(a2), this._logGeometryCreationWarnings(a2.renderData, t2.rings, "rings", "WaterSymbol3DLayer"), a2.outGeometries.length === 0 ? null : (this._createUVCoordsFromVertices(a2.uvCoords, a2.renderData.position, s2, this._context.overlaySR), new l$6(this, a2.outGeometries, a2.outBoundingBox, this._context.drapeSourceRenderer));
  }
  _createAsOverlayWater(e2) {
    const t2 = e2.uvCoords, r2 = e2.renderData.polygons;
    for (const { position: i2, holeIndices: n2, index: a2, count: l2 } of r2) {
      if (A$6(N$1), M$9(N$1, i2), !R$9(N$1, this._context.clippingExtent))
        continue;
      f$e(e2.outBoundingBox, N$1);
      const r3 = x$d(i2, n2, 3);
      if (r3.length === 0)
        continue;
      const c2 = new Float64Array(t2.buffer, 2 * a2 * t2.BYTES_PER_ELEMENT, 2 * l2), h2 = o$4({ indices: r3, attributeData: { position: i2, uv0: c2 } }), u2 = new T$6(h2, e$f(this._material), { layerUid: e2.layerUid, graphicUid: e2.graphicsUid }), p2 = N$1;
      r$m(u2.boundingSphere, 0.5 * (p2[0] + p2[3]), 0.5 * (p2[1] + p2[4]), 0, 0.5 * Math.sqrt((p2[3] - p2[0]) * (p2[3] - p2[0]) + (p2[4] - p2[1]) * (p2[4] - p2[1]))), e2.outGeometries.push(u2);
    }
  }
  static headingVectorFromAngle(e2) {
    const t2 = n$k(), r2 = r$t(e2);
    return t2[0] = Math.sin(r2), t2[1] = Math.cos(r2), t2;
  }
  test() {
    return __spreadProps(__spreadValues({}, super.test()), { create3DShape: (e2) => this._createAs3DShape(e2.graphic, e2.elevationContext, e2.graphicUid), ensureMaterial: () => this.ensureMaterial() });
  }
}
I$1.unitSizeOfTexture = 100, I$1.elevationModeChangeTypes = { definedChanged: x$b.RECREATE, staysOnTheGround: x$b.NONE, onTheGroundChanged: x$b.RECREATE };
const W = n$k(), k$2 = u$o(), z = n$k(), N$1 = a$b();
class Y extends c$7 {
  constructor(e2, t2) {
    super(e2, null, null), this.uvCoords = t2;
  }
}
class q extends c$7 {
  constructor(e2, t2, r2, o2) {
    super(e2, r2, o2), this.uvCoords = t2;
  }
}
function c$1(o2, e2, t2, i2) {
  const m2 = h$1[o2.type] && h$1[o2.type][e2.type] || l$3[e2.type];
  return m2 ? new m2(o2, e2, t2, i2) : (s$a.getLogger("esri.views.3d.layers.graphics.Graphics3DSymbolLayerFactory").error("GraphicsLayerFactory#make", `unknown symbol type ${e2.type}`), null);
}
const l$3 = { icon: me$3, object: me$1, line: J$1, path: ae, fill: W$1, extrude: $$2, text: R$1, water: I$1 };
const h$1 = { "mesh-3d": { fill: he$1 } };
class p extends a$6 {
  constructor(e2, t2, s2) {
    super(t2.schedule), this._symbol = e2, this._context = t2, this._backgroundLayers = s2, this._destroyed = false, this.symbolLayers = new Array(), this.referenced = 0, this._extentPadding = 0;
  }
  set symbol(e2) {
    this._symbol = e2;
    for (let s2 = 0; s2 < e2.symbolLayers.length; s2++) {
      const r2 = this.symbolLayers[s2];
      t$7(r2) || (r2.symbol = e2, r2.symbolLayer = e2.symbolLayers.items[s2]);
    }
  }
  get symbol() {
    return this._symbol;
  }
  async doLoad(t2) {
    let r2 = this._symbol.symbolLayers;
    this._extentPadding = 0, this._backgroundLayers && (r2 = this._backgroundLayers.concat(r2));
    const i2 = r2.length;
    for (; this.symbolLayers.length < r2.length; )
      this.symbolLayers.push(null);
    this.symbolLayers.length = r2.length;
    const n2 = [];
    for (let e2 = 0; e2 < i2; e2++) {
      const s2 = r2.getItemAt(e2);
      if (s2.enabled === false)
        continue;
      d$2.renderPriority = 1 - (1 + e2) / i2, d$2.renderPriorityStep = 1 / i2, d$2.ignoreDrivers = s2._ignoreDrivers;
      const a2 = c$1(this.symbol, s2, this._context, d$2);
      n2.push(d$p(t2, () => {
        this.symbolLayers[e2] = null, a2.destroy();
      })), this.symbolLayers[e2] = a2;
    }
    await c$j(this.symbolLayers, async (e2, t3) => {
      if (r$d(e2))
        try {
          await e2.load(), this._extentPadding += Math.max(this._extentPadding, e2.extentPadding);
        } catch {
          this.symbolLayers[t3] = null;
        }
    });
    for (const e2 of n2)
      e2 == null ? void 0 : e2.remove();
    if (n2.length = 0, f$a(t2), this.symbolLayers.length && !this.symbolLayers.some((e2) => !!e2))
      throw new Error();
  }
  getSymbolLayerSize(e2) {
    const t2 = this.symbolLayers[e2];
    return r$d(t2) ? t2.getCachedSize() : null;
  }
  get extentPadding() {
    return this._extentPadding;
  }
  get symbologySnappingSupported() {
    return this.symbolLayers.some((e2) => r$d(e2) && e2.queryForSnapping);
  }
  createGraphics3DGraphic(e2, t2) {
    const r2 = e2.graphic, o2 = new Array(this.symbolLayers.length);
    for (let i2 = 0; i2 < this.symbolLayers.length; i2++) {
      const t3 = this.symbolLayers[i2];
      o2[i2] = r$d(t3) ? t3.createGraphics3DGraphic(e2) : null;
    }
    const a2 = this._context.arcade || this._context.featureExpressionInfoContext && this._context.featureExpressionInfoContext.arcade && this._context.featureExpressionInfoContext.arcade.modules || null;
    return new V$3(r2, t2 || this, o2, e2.layer, a2);
  }
  get complexity() {
    return P$6(this.symbolLayers.map((e2) => q$7(e2, "complexity")));
  }
  globalPropertyChanged(e2, t2) {
    const r2 = this.symbolLayers.length;
    for (let o2 = 0; o2 < r2; o2++) {
      const r3 = this.symbolLayers[o2], a2 = (e3) => {
        const t3 = e3.graphics[o2];
        return t3 instanceof _$b ? t3 : null;
      };
      if (r$d(r3) && !r3.globalPropertyChanged(e2, t2, a2))
        return false;
    }
    return true;
  }
  applyRendererDiff(e2, t2) {
    return this.loadStatus !== e$9.LOADED ? e$a.Recreate_Symbol : this.symbolLayers.reduce((r2, o2) => r2 !== e$a.Recreate_Symbol && r$d(o2) ? Math.min(r2, o2.applyRendererDiff(e2, t2)) : r2, e$a.Fast_Update);
  }
  prepareSymbolPatch(e2) {
    if (this.loadStatus === e$9.FAILED)
      return;
    if (e2.diff.type !== "partial")
      return;
    const r2 = e2.diff.diff;
    if (!r2.symbolLayers || r2.symbolLayers.type !== "partial")
      return;
    const o2 = r2.symbolLayers.diff;
    this.symbolLayers.forEach((r3, a2) => {
      if (t$7(r3))
        return;
      const i2 = o2[a2];
      if (i2) {
        const t2 = { diff: i2, graphics3DGraphicPatches: [], symbolLayerStatePatches: [] };
        r3.prepareSymbolLayerPatch(t2), e2.symbolStatePatches.push(...t2.symbolLayerStatePatches), t2.graphics3DGraphicPatches.length && e2.graphics3DGraphicPatches.push((e3, r4) => {
          const o3 = e3.graphics[a2];
          r$d(o3) && t2.graphics3DGraphicPatches.forEach((e4) => e4(o3, r4));
        });
      }
    });
  }
  updateGeometry(e2, s2) {
    for (let r2 = 0; r2 < this.symbolLayers.length; r2++) {
      const o2 = this.symbolLayers[r2];
      if (t$7(o2))
        continue;
      const a2 = e2.graphics[r2];
      if (t$7(a2) || !o2.updateGeometry(a2, s2))
        return false;
    }
    return true;
  }
  onRemoveGraphic(e2) {
    for (let r2 = 0; r2 < this.symbolLayers.length; r2++) {
      const o2 = this.symbolLayers[r2];
      if (t$7(o2))
        continue;
      const a2 = e2.graphics[r2];
      r$d(a2) && o2.onRemoveGraphic(a2);
    }
  }
  getFastUpdateStatus() {
    let e2 = 0, s2 = 0, r2 = 0;
    return this.symbolLayers.forEach((o2) => {
      t$7(o2) || (o2.loadStatus === e$9.LOADING ? e2++ : o2.isFastUpdatesEnabled() ? r2++ : s2++);
    }), { loading: e2, slow: s2, fast: r2 };
  }
  async queryForSnapping(e2, t2, r2, o2) {
    const i2 = this.symbolLayers.filter(r$d).filter((e3) => r$d(e3.queryForSnapping)).map((s2) => s2.queryForSnapping(e2, t2, r2, o2)), n2 = await Promise.all(i2);
    return f$a(o2), n2.flat();
  }
  destroy() {
    if (this.destroyed)
      console.error("Graphics3DSymbol.destroy called when already destroyed!");
    else {
      super.destroy();
      for (const e2 of this.symbolLayers)
        r$d(e2) && e2.destroy();
      this.symbolLayers.length = 0, this._destroyed = true;
    }
  }
  get destroyed() {
    return this._destroyed;
  }
}
const d$2 = { renderPriority: 0, renderPriorityStep: 1, ignoreDrivers: false };
class s$3 extends p {
  constructor(r2, t2, a2) {
    super(r2, t2, a2), this._calloutSymbolLayer = null, this.symbol.hasVisibleCallout() && (this._calloutSymbolLayer = e$7(this.symbol, t2));
  }
  async doLoad(t2) {
    var _a;
    const a2 = this._calloutSymbolLayer ? b$g(this._calloutSymbolLayer.load()) : null;
    try {
      await super.doLoad(t2), f$a(t2);
    } catch (o2) {
      throw (_a = this._calloutSymbolLayer) == null ? void 0 : _a.abortLoad(), o2;
    }
    a2 && await a2;
  }
  destroy() {
    super.destroy(), this._calloutSymbolLayer = s$j(this._calloutSymbolLayer);
  }
  createGraphics3DGraphic(r2, t2) {
    const e2 = super.createGraphics3DGraphic(r2, t2);
    if (r$d(this._calloutSymbolLayer) && r$d(e2)) {
      const t3 = this._createCalloutGraphic(r2);
      r$d(t3) && e2.addAuxiliaryGraphic(t3);
    }
    return e2;
  }
  globalPropertyChanged(r2, t2) {
    return !!super.globalPropertyChanged(r2, t2) && (!this._calloutSymbolLayer || this._calloutSymbolLayer.globalPropertyChanged(r2, t2, (r3) => this._getCalloutGraphicLayer(r3)));
  }
  updateGeometry(r2, t2) {
    const a2 = super.updateGeometry(r2, t2);
    if (a2 && this._calloutSymbolLayer) {
      const a3 = this._getCalloutGraphicLayer(r2);
      if (a3)
        return this._calloutSymbolLayer.updateGeometry(a3, t2);
    }
    return a2;
  }
  _createCalloutGraphic(r2) {
    const t2 = r2.renderingInfo, a2 = { renderer: t2.renderer, symbol: t2.symbol, translation: [0, 0, 0], centerOffset: [0, 0, 0, 0], screenOffset: [0, 0], centerOffsetUnits: "world", elevationOffset: 0, materialCollection: null };
    return r2.renderingInfo = a2, this._calloutSymbolLayer.createGraphics3DGraphic(r2);
  }
  _getCalloutGraphicLayer(r2) {
    for (const t2 of r2._auxiliaryGraphics)
      if (t2.graphics3DSymbolLayer === this._calloutSymbolLayer)
        return t2;
  }
}
function t$1(t2, i2, e2) {
  let p$12;
  if (t2.type === "point-3d")
    p$12 = s$3;
  else
    p$12 = p;
  return new p$12(t2, i2, e2);
}
class e$2 extends a$6 {
  constructor(t2, s2, r2) {
    super(s2), this.symbol = t2, this._convert = r2, this.symbologySnappingSupported = false, this.graphics3DSymbol = null, this.referenced = 0;
  }
  getSymbolLayerSize(s2) {
    return r$d(this.graphics3DSymbol) ? this.graphics3DSymbol.getSymbolLayerSize(s2) : null;
  }
  get symbolLayers() {
    return r$d(this.graphics3DSymbol) ? this.graphics3DSymbol.symbolLayers : [];
  }
  get extentPadding() {
    return r$d(this.graphics3DSymbol) ? this.graphics3DSymbol.extentPadding : 0;
  }
  async doLoad(s2) {
    const r2 = await this.symbol.fetchSymbol({ signal: s2 });
    r2.id = this.symbol.id, this.graphics3DSymbol = this._convert(r2), r$d(this.graphics3DSymbol) && await this.graphics3DSymbol.load();
  }
  createGraphics3DGraphic(s2) {
    return r$d(this.graphics3DSymbol) ? this.graphics3DSymbol.createGraphics3DGraphic(s2, this) : null;
  }
  get complexity() {
    return r$d(this.graphics3DSymbol) ? this.graphics3DSymbol.complexity : b$b;
  }
  globalPropertyChanged(s2, r2) {
    return !!r$d(this.graphics3DSymbol) && this.graphics3DSymbol.globalPropertyChanged(s2, r2);
  }
  applyRendererDiff(r2, i2) {
    return r$d(this.graphics3DSymbol) ? this.graphics3DSymbol.applyRendererDiff(r2, i2) : e$a.Recreate_Symbol;
  }
  prepareSymbolPatch(s2) {
    r$d(this.graphics3DSymbol) && this.graphics3DSymbol.prepareSymbolPatch(s2);
  }
  updateGeometry(s2, r2) {
    return !!r$d(this.graphics3DSymbol) && this.graphics3DSymbol.updateGeometry(s2, r2);
  }
  onRemoveGraphic() {
  }
  getFastUpdateStatus() {
    return r$d(this.graphics3DSymbol) ? this.graphics3DSymbol.getFastUpdateStatus() : { loading: 1, fast: 0, slow: 0 };
  }
  destroy() {
    r$d(this.graphics3DSymbol) && this.graphics3DSymbol.destroy(), this.graphics3DSymbol = void 0, super.destroy();
  }
  get destroyed() {
    return this.graphics3DSymbol === void 0;
  }
}
class s$2 {
  constructor(t2) {
    this._graphicsCore = t2, this._idToState = new Map(), this._states = new Set();
    const i2 = t2.owner.layer && t2.owner.layer.objectIdField;
    i2 ? (this._getGraphicId = (t3) => O$7(t3, i2), this._getGraphics3DGraphicById = (t3) => this._graphicsCore.getGraphics3DGraphicByObjectId(t3)) : (this._getGraphicId = (t3) => t3.uid, this._getGraphics3DGraphicById = (t3) => this._graphicsCore.getGraphics3DGraphicById(t3));
  }
  destroy() {
    this._idToState.clear(), this._states.forEach((t2, i2) => this.remove(i2));
  }
  add(t2) {
    const e2 = { remove: () => this.remove(t2) };
    if (this._states.has(t2))
      return e2;
    const s2 = this._getGraphicId(t2.graphic), a2 = this._getGraphics3DGraphicById(s2);
    this._states.has(t2) || this._states.add(t2);
    return this._ensureStateList(s2).push(t2), t2.displaying = !!r$d(a2) && a2.isVisible(), t2.isDraped = !!r$d(a2) && a2.isDraped, t2.tracking = true, r$d(a2) && t2.emit("changed", {}), e2;
  }
  remove(i2) {
    if (this._states.has(i2)) {
      if (this._idToState.size) {
        const e2 = this._getGraphicId(i2.graphic), s2 = this._idToState.get(e2);
        s2 && (C$e(s2, i2), s2.length === 0 && this._idToState.delete(e2));
      }
      this._states.delete(i2), i2.tracking = false, i2.displaying = false;
    }
  }
  addGraphic(t2) {
    this._forEachState(t2, (i2) => {
      i2.displaying = t2.isVisible(), i2.isDraped = t2.isDraped, i2.emit("changed", {});
    });
  }
  removeGraphic(t2) {
    this._forEachState(t2, (t3) => {
      t3.displaying = false, t3.isDraped = false;
    });
  }
  updateGraphicGeometry(t2) {
    this._forEachState(t2, (t3) => {
      t3.emit("changed", {});
    });
  }
  updateGraphicVisibility(t2) {
    this._forEachState(t2, (i2) => {
      i2.displaying = t2.isVisible();
    });
  }
  allGraphicsDeleted() {
    this._states.forEach((t2) => {
      t2.displaying = false;
    });
  }
  _ensureStateList(t2) {
    const i2 = this._idToState.get(t2);
    if (i2)
      return i2;
    const e2 = new Array();
    return this._idToState.set(t2, e2), e2;
  }
  _forEachState(t2, i2) {
    if (this._states.size === 0 || this._idToState.size === 0)
      return;
    const e2 = this._getGraphicId(t2.graphic), s2 = this._idToState.get(e2);
    s2 != null && s2.forEach(i2);
  }
}
let d$1 = class extends m$8 {
  constructor(t2) {
    super(t2), this._index = new h$k(9, has("esri-csp-restrictions") ? (t3) => ({ minX: t3.extent[0], minY: t3.extent[1], maxX: t3.extent[2], maxY: t3.extent[3] }) : [".extent[0]", ".extent[1]", ".extent[2]", ".extent[3]"]), this._missing = new Set(), this._boundsByFeature = new Map(), this.spatialReference = null, this.hasZ = null, this.hasM = null, this.objectIdField = null, this.updating = false;
  }
  setup(t2) {
    this._addMany(t2);
  }
  destroy() {
    this._missing.clear(), this._index.destroy(), this._index = null, this._boundsByFeature.clear(), this._boundsByFeature = null;
  }
  update() {
    this._missing.size > 0 && (this._addMany(Array.from(this._missing.values())), this.updating = false, this._missing.clear());
  }
  get updatingRemaining() {
    return this._missing.size;
  }
  queryGraphicUIDsInExtent(t2, e2, i2) {
    !t$7(e2) && e2.equals(this.spatialReference) && (u$2.minX = t2[0], u$2.minY = t2[1], u$2.maxX = t2[2], u$2.maxY = t2[3], this.update(), this._index.search(u$2, (t3) => i2(t3.graphic.uid)));
  }
  add(t2) {
    this._missing.add(t2), this.updating = true;
  }
  remove(t2) {
    if (this._missing.delete(t2))
      return void (this.updating = this._missing.size > 0);
    this._index.remove(t2);
    const e2 = O$7(t2.graphic, this._get("objectIdField"));
    e2 != null && this._boundsByFeature.delete(e2);
  }
  _addMany(t2) {
    if (t2.length === 0)
      return;
    const e2 = this._get("objectIdField");
    for (const s2 of t2) {
      s2.computeExtent(this.spatialReference);
      const t3 = O$7(s2.graphic, e2);
      t3 != null && this._boundsByFeature.set(t3, s2.extent);
    }
    this._index.load(t2);
  }
  clear() {
    this._index.clear(), this._missing.clear(), this._boundsByFeature.clear(), this.updating = false;
  }
  forEachInBounds(t2, e2) {
    u$2.minX = t2[0], u$2.minY = t2[1], u$2.maxX = t2[2], u$2.maxY = t2[3], this.update(), this._index.search(u$2, (t3) => {
      e2(t3);
    });
  }
  getBounds(t2, e2) {
    this.update();
    const s2 = this._boundsByFeature.get(t2);
    return s2 ? G$7(e2, s2) : null;
  }
};
e$c([y$c({ constructOnly: true })], d$1.prototype, "spatialReference", void 0), e$c([y$c({ constructOnly: true })], d$1.prototype, "hasZ", void 0), e$c([y$c({ constructOnly: true })], d$1.prototype, "hasM", void 0), e$c([y$c({ constructOnly: true })], d$1.prototype, "objectIdField", void 0), e$c([y$c()], d$1.prototype, "updating", void 0), e$c([y$c({ readOnly: true })], d$1.prototype, "updatingRemaining", null), d$1 = e$c([n$d("esri.views.3d.layers.graphics.SpatialIndex2D")], d$1);
const u$2 = { minX: 0, minY: 0, maxX: 0, maxY: 0 };
const v$2 = 1;
let b$2 = class extends n$f.EventedMixin(m$8) {
  constructor(e2) {
    super(e2), this._elevationOffset = 0, this._layerHandes = new t$o();
  }
  get spatialReference() {
    var _a;
    return (_a = this.view) == null ? void 0 : _a.spatialReference;
  }
  initialize() {
    this._renderCoordsHelper = this.view.renderCoordsHelper, this._intersectLayers = [this.stageLayer], this._intersector = x$h(this.view.state.viewingMode), this._intersector.options.store = t$l.MIN;
    const e2 = this._computeLayerExtent(this.spatialReference, this.stageLayer);
    this._zmin = e2[2], this._zmax = e2[5];
    const t2 = this.stageLayer.events;
    this._layerHandes.add([t2.on("layerObjectAdded", (e3) => this._objectChanged(e3.object)), t2.on("layerObjectRemoved", (e3) => this._objectChanged(e3.object)), t2.on("objectGeometryAdded", (e3) => this._objectChanged(e3.object)), t2.on("objectGeometryRemoved", (e3) => this._objectChanged(e3.object)), t2.on("vertexAttrsUpdated", (e3) => this._objectChanged(e3.object)), t2.on("objectTransformation", (e3) => this._objectChanged(e3))]);
  }
  dispose() {
    this._layerHandes.destroy();
  }
  elevationInfoChanged() {
    const e2 = this.layer != null ? this.layer.elevationInfo : null;
    if (e2 != null && e2.mode !== "on-the-ground") {
      const t2 = L$5(this.layer.spatialReference), o2 = r$u(e2.unit);
      this._elevationOffset = i$a(e2.offset, 0) * o2 / t2;
    } else
      this._elevationOffset = 0;
  }
  getElevation(e2, t2, o2, r2) {
    if (R[0] = e2, R[1] = t2, R[2] = o2, !this._renderCoordsHelper.toRenderCoords(R, r2, R))
      return s$a.getLogger(this.declaredClass).error("could not project point for elevation alignment"), null;
    const n2 = this._elevationOffset, i2 = this._zmin + n2, a2 = this._zmax + n2;
    this._renderCoordsHelper.setAltitude(H, a2, R), this._renderCoordsHelper.setAltitude(L$1, i2, R);
    const c2 = (e3) => e3.metadata && e3.metadata.isElevationSource;
    return this._intersector.reset(H, L$1, null), this._intersector.intersect(this._intersectLayers, null, v$2, null, c2), this._intersector.results.min.getIntersectionPoint(R) ? this._renderCoordsHelper.getAltitude(R) : null;
  }
  _objectChanged(e2) {
    var _a;
    const t2 = this.spatialReference;
    if (!((_a = e2.metadata) == null ? void 0 : _a.isElevationSource) || t$7(t2))
      return;
    A$6(x);
    const { lastValidElevationBB: o2 } = e2.metadata;
    o2.isEmpty() || this._expandExtent(t2, o2.min, o2.max, x);
    const { min: r2, max: s2 } = e2.boundingVolumeWorldSpace;
    this._expandExtent(t2, r2, s2, x), B$7(x, C), this._zmin = Math.min(this._zmin, x[2]), this._zmax = Math.max(this._zmax, x[5]), E.extent = C, E.spatialReference = t2, this.emit("elevation-change", E), r$e(o2.min, r2), r$e(o2.max, s2);
  }
  _computeLayerExtent(e2, t2) {
    return A$6(x), r$d(e2) && t2.objects.forAll((t3) => this._expandExtent(e2, t3.boundingVolumeWorldSpace.min, t3.boundingVolumeWorldSpace.max, x)), x;
  }
  _expandExtent(e2, t2, o2, r2) {
    for (let s2 = 0; s2 < 8; ++s2)
      R[0] = 1 & s2 ? t2[0] : o2[0], R[1] = 2 & s2 ? t2[1] : o2[1], R[2] = 4 & s2 ? t2[2] : o2[2], this._renderCoordsHelper.fromRenderCoords(R, R, e2), c$q(r2, R);
    return r2;
  }
};
e$c([y$c({ constructOnly: true })], b$2.prototype, "layer", void 0), e$c([y$c({ constructOnly: true })], b$2.prototype, "stageLayer", void 0), e$c([y$c({ constructOnly: true })], b$2.prototype, "view", void 0), e$c([y$c()], b$2.prototype, "spatialReference", null), b$2 = e$c([n$d("esri.views.3d.layers.support.StageLayerElevationProvider")], b$2);
const x = A$6(), C = D$6(), E = { spatialReference: null, extent: C, context: "scene" }, R = n$h(), H = n$h(), L$1 = n$h();
function e$1(l2, x2, e2) {
  if (t$7(l2) || t$7(e2))
    return false;
  let u2 = true;
  return i[0] = l2.xmin != null ? l2.xmin : 0, i[1] = l2.ymin != null ? l2.ymin : 0, i[2] = l2.zmin != null ? l2.zmin : 0, u2 = u2 && xn(i, l2.spatialReference, 0, i, e2, 0, 1), x2[0] = i[0], x2[1] = i[1], i[0] = l2.xmax != null ? l2.xmax : 0, i[1] = l2.ymax != null ? l2.ymax : 0, i[2] = l2.zmax != null ? l2.zmax : 0, u2 = u2 && xn(i, l2.spatialReference, 0, i, e2, 0, 1), x2[2] = i[0], x2[3] = i[1], l2.xmin == null && (x2[0] = -1 / 0), l2.ymin == null && (x2[1] = -1 / 0), l2.xmax == null && (x2[2] = 1 / 0), l2.ymax == null && (x2[3] = 1 / 0), u2;
}
const i = n$h();
var Ue;
const Oe = n$h(), je = a$b(), Le = "esri.views.3d.layers.graphics.Graphics3DCore", Ve = s$a.getLogger(Le);
let Fe = Ue = class extends m$8 {
  constructor(e2) {
    super(e2), this._propertiesPool = new o$s({ computedExtent: w$9 }, this), this.computedExtent = null, this.currentRenderer = null, this.rendererHasGeometryOperations = false, this._graphicStateTracking = null, this.symbolCreationContext = new e$b((e3, i2) => this._frameTask.schedule(e3, i2)), this.graphics3DGraphics = new Map(), this.stageLayer = null, this.stage = null, this._graphicsDrapedUids = new Set(), this._graphicsBySymbol = new Map(), this._symbolConversionCache = new Map(), this._symbols = new Map(), this._graphicsWithoutSymbol = new Map(), this._graphicsWaitingForSymbol = new Map(), this._graphicsUpdateId = 0, this._handles = new t$o(), this._frameTask = y$f, this._suspendSymbolCleanup = false, this._viewSpatialReference = null, this._arcadeOnDemand = null, this._rendererChangeAbortController = null, this._elevationInfoChangeAbortController = null, this._initializeAbortController = null, this._scaleVisibility = null, this._filterVisibility = null, this._spatialIndex = null, this.extentPadding = 0, this._updatingPendingLoadedGraphicsChange = null, this._featureStore = null, this._deconflictor = null, this._labeler = null, this._objectStates = null, this._viewElevationProvider = null, this._stageLayerElevationProvider = null, this._sharedSymbolResourcesOwnerHandle = null, this._whenGraphics3DGraphicRequests = {}, this._pendingUpdates = new Map(), this._numberOfGraphics = 0, this._numberOfGraphicsProvidingElevation = 0, this._pendingAdds = 0, this._pendingRemoves = 0, this._loadingSymbols = 0, this._pendingUpdatesPool = new l$s({ allocator: (e3) => e3 || new ke(), deallocator: (e3) => (e3.clear(), e3) }), this._symbolWarningLogged = false, this._geometryWarningLogged = false, this._objectIdInvisibleSet = new Set(), this._whenSymbolRemoved = new l$s(), this.preferredUpdatePolicy = i$n.SYNC, this.forcedUpdatePolicy = null, this.elevationFeatureExpressionEnabled = true, this.owner = null, this.layer = null, this.graphicSymbolSupported = true, this.getRenderingInfoWithoutRenderer = false, this.setUidToIdOnAdd = true, this.hasZ = null, this.hasM = null, this._usedMemory = 0, this._visible = void 0, this._startCreateGraphics = false;
  }
  get spatialIndex() {
    var _a;
    return this._spatialIndex || (this._spatialIndex = new d$1({ objectIdField: (_a = this.owner.layer) == null ? void 0 : _a.objectIdField, spatialReference: this._viewSpatialReference, hasZ: this.hasZ, hasM: this.hasM }), this._spatialIndex.setup(Array.from(this.graphics3DGraphics.values()))), this._spatialIndex.update(), this._spatialIndex;
  }
  get numberOfGraphics() {
    return this._numberOfGraphics;
  }
  get effectiveUpdatePolicy() {
    return r$d(this.currentRenderer) && this.currentRenderer.type === "dictionary" ? i$n.ASYNC : i$a(this.forcedUpdatePolicy, this.preferredUpdatePolicy);
  }
  get featureStore() {
    return this._featureStore;
  }
  get initializePromise() {
    return this._initializePromise;
  }
  get scaleVisibility() {
    return this._scaleVisibility;
  }
  get elevationAlignment() {
    return this._elevationAlignment;
  }
  get objectStates() {
    return this._objectStates;
  }
  get filterVisibility() {
    return this._filterVisibility;
  }
  get updating() {
    var _a;
    return !!(this._graphicsWaitingForSymbol.size > 0 || this.running || ((_a = this._elevationAlignment) == null ? void 0 : _a.updating) || r$d(this._scaleVisibility) && this._scaleVisibility.updating || r$d(this._filterVisibility) && this._filterVisibility.updating || this._rendererChangeAbortController || this._elevationInfoChangeAbortController || this._updatingPendingLoadedGraphicsChange || this._frameTask.updating || this._loadingSymbols > 0);
  }
  get running() {
    var _a;
    return this._pendingUpdates.size > 0 || !!((_a = this._spatialIndex) == null ? void 0 : _a.updating);
  }
  get suspendedOrOutsideOfView() {
    var _a;
    return this.owner.suspended || ((_a = this.owner.suspendInfo) == null ? void 0 : _a.outsideOfView);
  }
  get updatingRemaining() {
    var _a, _b;
    return this.updating ? this._pendingUpdates.size + 0.1 * (((_a = this._spatialIndex) == null ? void 0 : _a.updatingRemaining) || 0) + 0.1 * (((_b = this._elevationAlignment) == null ? void 0 : _b.updatingRemaining) || 0) : 0;
  }
  get displayFeatureLimit() {
    const e2 = this.owner && this.owner.view && this.owner.view.qualitySettings, i2 = e2 ? e2.graphics3D.minTotalNumberOfFeatures : 0, t2 = e2 ? e2.graphics3D.maxTotalNumberOfFeatures : 0, r2 = e2 ? e2.graphics3D.maxTotalNumberOfPrimitives : 0, s2 = this.averageSymbolComplexity, a2 = Math.max(1, r$d(s2) ? s2.primitivesPerFeature : 1), n2 = r$d(s2) && s2.drawCallsPerFeature > 0 ? t2 / s2.drawCallsPerFeature * 0.3 : t2, o2 = Math.ceil(r2 / a2), l2 = Math.max(i2, Math.min(t2, o2, n2)), d2 = this._get("displayFeatureLimit");
    return d2 && d2.minimumTotalNumberOfFeatures === i2 && d2.maximumTotalNumberOfFeatures === t2 && d2.maximumTotalNumberOfPrimitives === r2 && d2.averageSymbolComplexity === s2 && d2.maximumNumberOfFeatures === l2 ? d2 : { minimumTotalNumberOfFeatures: i2, maximumTotalNumberOfFeatures: t2, maximumTotalNumberOfPrimitives: r2, averageSymbolComplexity: s2, maximumNumberOfFeatures: l2 };
  }
  get averageSymbolComplexity() {
    const e2 = d$a(this._symbolComplexities), i2 = this._get("averageSymbolComplexity");
    return e2.numComplexities === 0 || r$d(i2) && (e2.estimated && (i2.primitivesPerFeature >= e2.primitivesPerFeature || i2.primitivesPerCoordinate >= e2.primitivesPerCoordinate || i2.drawCallsPerFeature >= e2.drawCallsPerFeature) || i2.primitivesPerFeature === e2.primitivesPerFeature && i2.primitivesPerCoordinate === e2.primitivesPerCoordinate && i2.drawCallsPerFeature === e2.drawCallsPerFeature) ? i2 : e2;
  }
  get usedMemory() {
    const e2 = r$d(this.averageSymbolComplexity) && this.labelsEnabled ? this.averageSymbolComplexity.memory.bytesPerFeatureLabel * this._numberOfGraphics : 0, i2 = this._getSymbolComplexitiesUsed().reduce((e3, i3) => e3 + i3.memory.resourceBytes, 0);
    return this._usedMemory + e2 + i2;
  }
  get usedMemoryPerGraphic() {
    if (this._usedMemory && this._numberOfGraphics)
      return (this._pendingAdds + this._pendingRemoves) / this._numberOfGraphics > 20 ? 0 : this._usedMemory / this._numberOfGraphics;
    if (r$d(this.averageSymbolComplexity)) {
      const e2 = this.labelsEnabled ? this.averageSymbolComplexity.memory.bytesPerFeatureLabel : 0;
      return this.averageSymbolComplexity.memory.bytesPerFeature + e2;
    }
    return 0;
  }
  get unprocessedMemoryEstimate() {
    return Math.max(0, (this._pendingAdds - this._pendingRemoves) * this.usedMemoryPerGraphic);
  }
  get _symbolComplexities() {
    return this.currentRenderer ? this._getSymbolComplexitiesUsedOrRenderer(this.currentRenderer) : this._getSymbolComplexitiesUsed();
  }
  _getConvertedSymbol(e2) {
    var _a;
    if (e2.type === "web-style")
      return e2.clone();
    const i2 = this._symbolConversionCache.get(e2.id);
    if (r$d(i2))
      return i2;
    const t2 = S$h(e2, { geometryType: (_a = this.layer) == null ? void 0 : _a.geometryType, retainId: true, hasLabelingContext: this._hasLabelingContext(e2) }), r2 = t2.symbol || null;
    return t$7(r2) && t2.error && Ve.error(t2.error.message), this._symbolConversionCache.set(e2.id, r2), r2;
  }
  _getSymbolComplexitiesUsedOrRenderer(e2) {
    if (t$7(e2))
      return [];
    const i2 = e2.getSymbols(), t2 = "backgroundFillSymbol" in e2 && e2.backgroundFillSymbol;
    if (!(t2 || i2 && i2.length))
      return [];
    const r2 = [], s2 = this._getSymbolComplexityUsedOrRenderer(t2);
    r$d(s2) && r2.push(s2);
    for (const a2 of i2) {
      const e3 = this._getSymbolComplexityUsedOrRenderer(a2);
      r$d(e3) && r2.push(e3);
    }
    return r2;
  }
  _getSymbolComplexityUsedOrRenderer(e2) {
    if (t$7(e2))
      return null;
    const i2 = this._symbols.get(e2.id);
    if (r$d(i2))
      return i2.complexity;
    const t2 = this._getConvertedSymbol(e2);
    return r$d(t2) ? y$a(t2) : null;
  }
  _getSymbolComplexitiesUsed() {
    const e2 = [];
    return this._symbols.forEach((i2) => {
      r$d(i2) && e2.push(i2.complexity);
    }), e2;
  }
  get _objectIdField() {
    return this.layer.objectIdField;
  }
  initialize() {
    this._viewSpatialReference = this.owner.view.spatialReference, this._featureStore = new l$9({ objectIdField: this.owner.layer && this.owner.layer.objectIdField, hasZ: this.hasZ, hasM: this.hasM, viewSpatialReference: this._viewSpatialReference, featureSpatialReference: this.owner.featureSpatialReference, getSpatialIndex: () => this.spatialIndex, forEach: (e3) => this.graphics3DGraphics.forEach(e3), toArray: () => Array.from(this.graphics3DGraphics.values()) });
    const e2 = (e3, i3, t2) => this.spatialIndex.queryGraphicUIDsInExtent(e3, i3, t2), { componentFactories: i2 } = this;
    if (r$d(i2.elevationAlignment)) {
      const t2 = i2.elevationAlignment(this, e2);
      this._elevationAlignment = t2;
    }
    if (r$d(i2.scaleVisibility)) {
      const t2 = i2.scaleVisibility(this, e2);
      this._scaleVisibility = t2;
    }
    if (r$d(i2.filterVisibility)) {
      const e3 = i2.filterVisibility({ featureStore: this._featureStore, getFeatureCount: () => this.graphics3DGraphics.size, updateFeatureVisibilities: (e4) => this.modifyGraphics3DGraphicVisibilities((i3) => i3.setVisibilityFlag(C$9.FILTER, e4(O$7(i3.graphic, this._objectIdField)), E$a.GRAPHIC)), setAllFeaturesVisibility: (e4) => this.modifyGraphics3DGraphicVisibilities((i3) => i3.setVisibilityFlag(C$9.FILTER, e4, E$a.GRAPHIC)), clearFeaturesVisibility: () => this.modifyGraphics3DGraphicVisibilities((e4) => e4.clearVisibilityFlag(C$9.FILTER)) });
      this._filterVisibility = e3;
    }
    if (r$d(i2.deconflictor)) {
      const e3 = i2.deconflictor(this);
      this._deconflictor = e3;
    }
    if (r$d(i2.labeler) && r$d(this._scaleVisibility)) {
      const e3 = i2.labeler(this, this._scaleVisibility);
      this._labeler = e3;
    }
    if (r$d(i2.objectStates)) {
      const e3 = i2.objectStates(this);
      this._objectStates = e3;
    }
    this._initializeAbortController = new AbortController(), this._initializePromise = this._initializeAsync();
  }
  async _initializeAsync() {
    var _a, _b, _c;
    const e2 = this._initializeAbortController.signal, i2 = this.owner.view;
    this._viewElevationProvider = new n$a(this._viewSpatialReference, i2), this._initializeStage(i2, this.layer.uid), this.symbolCreationContext.sharedResources = i2.sharedSymbolResources, this._sharedSymbolResourcesOwnerHandle = i2.sharedSymbolResources.addGraphicsOwner(this.owner), r$d(this.currentRenderer) && (this.symbolCreationContext.renderer = this.currentRenderer), this.symbolCreationContext.stage = this.stage, this.symbolCreationContext.streamDataRequester = i2.sharedSymbolResources.streamDataRequester, this.symbolCreationContext.renderCoordsHelper = i2.renderCoordsHelper, this.symbolCreationContext.layer = this.layer, this.symbolCreationContext.graphicsCoreOwner = this.owner, this.symbolCreationContext.localOriginFactory = new j$c(i2.renderSpatialReference), this.symbolCreationContext.elevationProvider = i2.elevationProvider, this.symbolCreationContext.notifyGraphicGeometryChanged = (e3) => this.notifyGraphicGeometryChanged(e3), this.symbolCreationContext.notifyGraphicVisibilityChanged = (e3) => this.notifyGraphicVisibilityChanged(e3);
    const t2 = d$d(this.layer.elevationInfo, this.elevationFeatureExpressionEnabled);
    if (this.symbolCreationContext.featureExpressionInfoContext = await u$e(t2, this._viewSpatialReference, e2, Ve), f$a(e2), this.symbolCreationContext.screenSizePerspectiveEnabled = i2.screenSizePerspectiveEnabled && this.layer.screenSizePerspectiveEnabled, this.symbolCreationContext.slicePlaneEnabled = !!this.owner.slicePlaneEnabled, this.symbolCreationContext.physicalBasedRenderingEnabled = !!((_a = this.owner.view.qualitySettings) == null ? void 0 : _a.physicallyBasedRenderingEnabled), this.symbolCreationContext.skipHighSymbolLods = !!((_c = (_b = this.owner.view.qualitySettings) == null ? void 0 : _b.graphics3D) == null ? void 0 : _c.skipHighSymbolLods), "drapeSourceType" in this.owner) {
      const { owner: e3 } = this;
      this.symbolCreationContext.drapeSourceRenderer = i2.basemapTerrain.overlayManager.registerGeometryDrapeSource(e3), this._handles.add(n$e(() => i2.basemapTerrain.overlayManager.unregisterDrapeSource(e3)));
    }
    this._handles.add([l$t(() => this.suspendedOrOutsideOfView, () => this._frameTask.reschedule(() => this._updateLayerVisibility())), l$t(() => {
      var _a2;
      return [(_a2 = this.layer) == null ? void 0 : _a2.screenSizePerspectiveEnabled, this.owner.view.screenSizePerspectiveEnabled];
    }, () => {
      var _a2;
      const e3 = i2.screenSizePerspectiveEnabled && this.layer.screenSizePerspectiveEnabled;
      e3 !== this.symbolCreationContext.screenSizePerspectiveEnabled && (this.symbolCreationContext.screenSizePerspectiveEnabled = e3, (_a2 = this._labeler) == null ? void 0 : _a2.reset(), this.recreateAllGraphicsAndSymbols());
    }), l$t(() => this.owner.slicePlaneEnabled, (e3) => this._slicePlaneEnabledChange(!!e3)), l$t(() => {
      var _a2;
      return (_a2 = this.owner.view.state) == null ? void 0 : _a2.pixelRatio;
    }, () => this._pixelRatioChange()), l$t(() => {
      var _a2;
      return !!((_a2 = this.owner.view.qualitySettings) == null ? void 0 : _a2.physicallyBasedRenderingEnabled);
    }, (e3) => this._physicalBasedRenderingChange(e3)), l$t(() => {
      var _a2, _b2;
      return !!((_b2 = (_a2 = this.owner.view.qualitySettings) == null ? void 0 : _a2.graphics3D) == null ? void 0 : _b2.skipHighSymbolLods);
    }, (e3) => this._skipHighSymbolLoDsChange(e3)), f$n(() => {
      var _a2;
      return (_a2 = i2.basemapTerrain) == null ? void 0 : _a2.tilingScheme;
    }, (e3) => {
      if (!e3.spatialReference.equals(this.symbolCreationContext.overlaySR) && r$d(i2.basemapTerrain.spatialReference) && (this.symbolCreationContext.overlaySR = i2.basemapTerrain.spatialReference), this._handles.has("loaded-graphics"))
        this.recreateAllGraphics();
      else {
        const e4 = () => {
          var _a2;
          return (_a2 = this.owner) == null ? void 0 : _a2.loadedGraphics;
        };
        this._handles.add([a$s(e4, "change", (e5) => {
          this._graphicsCollectionChanged(e5), this._signalUpdatingDuringAsyncLoadedGraphicsChange();
        }, { onListenerAdd: () => {
          this.recreateAllGraphics(), this._signalUpdatingDuringAsyncLoadedGraphicsChange();
        } })], "loaded-graphics");
      }
    }, { initial: true }), l$t(() => this.effectiveUpdatePolicy, (e3) => {
      r$d(this.stageLayer) && (this.stageLayer.updatePolicy = e3), this.symbolCreationContext.isAsync = this.effectiveUpdatePolicy === i$n.ASYNC, e3 === i$n.SYNC && this.runTask(F$c);
    }, w$d)]), this._frameTask = i2.resourceController.scheduler.registerTask(I$a.GRAPHICS_CORE, this), this.layer && "featureReduction" in this.layer && this._handles.add(l$t(() => this.layer.featureReduction, () => this._deconflictor.featureReductionChange())), this.notifyChange("averageSymbolComplexity"), this.rendererChange(this.owner.renderer).catch(() => {
    }), this._initializeAbortController = null;
  }
  _abortInitialize() {
    this._initializeAbortController && (this._initializeAbortController.abort(), this._initializeAbortController = null);
  }
  destroy() {
    this._abortInitialize(), this._abortRendererChange(), this._abortElevationInfoChange(), this.owner.view.deconflictor.removeGraphicsOwner(this), this.owner.view.labeler.removeGraphicsOwner(this), this._elevationAlignment = s$j(this._elevationAlignment), this._scaleVisibility = s$j(this._scaleVisibility), this._filterVisibility = s$j(this._filterVisibility), this._deconflictor = null, this._labeler = null, this._objectStates = s$j(this._objectStates), this.clear(), this._featureStore = s$j(this._featureStore), this._updatingPendingLoadedGraphicsChange = h$l(this._updatingPendingLoadedGraphicsChange), this._graphicStateTracking = s$j(this._graphicStateTracking), this.stage && (this.stage.remove(this.stageLayer), this.stageLayer = null, this.stage = null), this._handles = s$j(this._handles), this._frameTask.remove(), this._frameTask = y$f, this._viewSpatialReference = null, this._set("owner", null);
    for (const e2 in this._whenGraphics3DGraphicRequests)
      this._whenGraphics3DGraphicRequests[e2].reject(new s$d("graphic:layer-destroyed", "Layer has been destroyed"));
    this._whenGraphics3DGraphicRequests = null, this._sharedSymbolResourcesOwnerHandle = h$l(this._sharedSymbolResourcesOwnerHandle), this._propertiesPool = s$j(this._propertiesPool), this._pendingUpdatesPool = null, this._symbolConversionCache.clear(), this._objectIdInvisibleSet.clear(), this._spatialIndex = s$j(this._spatialIndex);
  }
  clear() {
    var _a, _b;
    (_a = this._objectStates) == null ? void 0 : _a.allGraphicsDeleted(), r$d(this._graphicStateTracking) && this._graphicStateTracking.allGraphicsDeleted(), this.graphics3DGraphics.forEach((e2) => e2.destroy()), (_b = this._spatialIndex) == null ? void 0 : _b.clear(), this.graphics3DGraphics.clear(), this._numberOfGraphics = 0, this._usedMemory = 0, this._updateLayerVisibility(), this._symbols.forEach(s$j), this._symbols.clear(), this._graphicsBySymbol.clear(), this._graphicsWithoutSymbol.clear(), this._graphicsWaitingForSymbol.clear(), this._pendingUpdates.clear(), this._pendingUpdatesPool.clear(), this._pendingAdds = 0, this._pendingRemoves = 0, this.notifyChange("updating"), this.notifyChange("running"), this.notifyChange("updatingRemaining"), this._featureStore.events.emit("changed");
  }
  _initializeStage(e2, i2) {
    this.stage = e2._stage, this.stageLayer = new l$u({ isPickable: !this.suspendedOrOutsideOfView, updatePolicy: this.effectiveUpdatePolicy }, i2), this.stage.add(this.stageLayer);
    const t2 = this.stageLayer.events;
    t2.on("objectTransformation", (e3) => this.notifyGraphicGeometryChanged(e3.metadata.graphicUid)), t2.on("visibilityChanged", (e3) => this.notifyGraphicVisibilityChanged(e3.metadata.graphicUid)), t2.on("objectGeometryAdded", (e3) => this.notifyGraphicGeometryChanged(e3.object.metadata.graphicUid)), t2.on("objectGeometryRemoved", (e3) => this.notifyGraphicGeometryChanged(e3.object.metadata.graphicUid)), t2.on("vertexAttrsUpdated", (e3) => this.notifyGraphicGeometryChanged(e3.object.metadata.graphicUid));
  }
  notifyGraphicGeometryChanged(e2) {
    if (t$7(this._graphicStateTracking) || t$7(e2))
      return;
    const i2 = this.graphics3DGraphics.get(e2);
    i2 && this._graphicStateTracking.updateGraphicGeometry(i2);
  }
  notifyGraphicVisibilityChanged(e2) {
    if (t$7(this._graphicStateTracking) || t$7(e2))
      return;
    const i2 = this.graphics3DGraphics.get(e2);
    i2 && this._graphicStateTracking.updateGraphicVisibility(i2);
  }
  _updateLayerVisibility() {
    const e2 = this.displayFeatureLimit.maximumNumberOfFeatures, i2 = this._numberOfGraphics > e2 * ze, t2 = !this.suspendedOrOutsideOfView && !i2;
    t2 !== this._visible && (this._visible = t2, t2 ? (this.stageLayer.isPickable = true, this.updateAllGraphicsVisibility()) : (this.stageLayer.isPickable = false, this._hideAllGraphics()), this._updateStageLayerVisibility());
  }
  _updateStageLayerVisibility() {
    this.stageLayer.isVisible = this._visible && (this.layer.opacity == null || this.layer.opacity > 0);
  }
  getGraphics3DGraphicById(e2) {
    return this.graphics3DGraphics.get(e2);
  }
  getGraphics3DGraphicByObjectId(e2) {
    var _a;
    return ((_a = this.owner.layer) == null ? void 0 : _a.objectIdField) ? this._findGraphics3DGraphicByObjectId(e2) : null;
  }
  _getGraphicObjectID(e2, i2 = this.owner.layer && this.owner.layer.objectIdField) {
    return O$7(e2, i2);
  }
  get graphics3DGraphicsByObjectID() {
    const e2 = this.owner.layer && this.owner.layer.objectIdField;
    if (!e2)
      return null;
    const i2 = new Map();
    return this.graphics3DGraphics.forEach((t2) => {
      if (!t2)
        return;
      const r2 = t2.graphic, s2 = this._getGraphicObjectID(r2, e2);
      r$d(s2) && i2.set(s2, t2);
    }), i2;
  }
  get labelsEnabled() {
    return !(!this._labeler || !this._labeler.layerLabelsEnabled());
  }
  async updateLabelingInfo(e2) {
    const i2 = this._deconflictor && this._deconflictor.labelingInfoChange(e2), t2 = this._labeler && this._labeler.labelingInfoChange(e2);
    await E$l([i2, t2]);
  }
  updateVisibilityInfo() {
    this._deconflictor && this._deconflictor.labelingInfoChange(), this._labeler && this._labeler.visibilityInfoChange();
  }
  get symbolUpdateType() {
    if (this._pendingUpdates.size > 0)
      return "unknown";
    let e2 = 0, i2 = 0;
    return n$t(this._symbols, (t2, r2) => {
      if (r$d(t2)) {
        const s2 = t2.getFastUpdateStatus();
        if (s2.loading > 0)
          return true;
        this._graphicsBySymbol.has(r2) && (i2 += s2.fast, e2 += s2.slow);
      }
      return false;
    }) ? "unknown" : i2 >= 0 && e2 === 0 ? "fast" : e2 >= 0 && i2 === 0 ? "slow" : "mixed";
  }
  runTask(e2) {
    this._frameTask.processQueue(e2), this._applyPendingUpdates(e2), this.notifyChange("running"), this.running || this.notifyChange("updating"), this.notifyChange("updatingRemaining");
  }
  setObjectIdVisibility(e2, i2) {
    i2 ? this._objectIdInvisibleSet.delete(e2) : this._objectIdInvisibleSet.add(e2);
    const t2 = this._findGraphics3DGraphicByObjectId(e2);
    r$d(t2) && this._updateUserVisibility(t2);
  }
  _findGraphics3DGraphicByObjectId(e2) {
    return t$p(this.graphics3DGraphics, (i2) => this._getGraphicObjectID(i2.graphic) === e2);
  }
  _updateUserVisibility(e2) {
    if (t$7(e2))
      return false;
    const i2 = e2.graphic, t2 = this._getGraphicObjectID(i2), r2 = i2.visible && !this.owner.suspended && (t$7(t2) || !this._objectIdInvisibleSet.has(t2));
    return e2.setVisibilityFlag(C$9.USER_SETTING, r2, E$a.GRAPHIC);
  }
  _whenGraphics3DGraphic(e2) {
    const i2 = this.graphics3DGraphics.get(e2.uid);
    if (i2)
      return Promise.resolve(i2);
    const t2 = this._whenGraphics3DGraphicRequests[e2.uid];
    if (t2)
      return t2.promise;
    const r2 = A$9();
    return this._whenGraphics3DGraphicRequests[e2.uid] = r2, r2.promise;
  }
  async _boundsForGraphics3DGraphic(e2, i2) {
    const t2 = this._viewSpatialReference, r2 = this.owner.view.renderSpatialReference, s2 = this.owner.view.basemapTerrain.spatialReference, a2 = (e3, i3, s3) => xn(e3, r2, i3, e3, t2, i3, s3), n2 = (e3, i3, r3) => xn(e3, s2, i3, e3, t2, i3, r3), o2 = this._viewElevationProvider ? { service: this._viewElevationProvider, useViewElevation: r$d(i2) && i2.useViewElevation, minDemResolution: r$d(i2) && i2.minDemResolution, minDemResolutionForPoints: this.owner.view.resolution } : null, l2 = await e2.getProjectedBoundingBox(a2, n2, o2, q$7(i2, "signal"));
    if (!l2)
      return null;
    const c2 = l2.boundingBox;
    if (l2.requiresDrapedElevation) {
      const e3 = this.symbolCreationContext.elevationProvider;
      if (e3) {
        p$9(c2, Oe);
        const i3 = i$a(e3.getElevation(Oe[0], Oe[1], 0, t2, "ground"), 0);
        c2[2] = Math.min(c2[2], i3), c2[5] = Math.max(c2[5], i3);
      }
    }
    return { boundingBox: c2, screenSpaceObjects: l2.screenSpaceObjects };
  }
  async whenGraphicBounds(e2, i2) {
    await j$5(() => {
      var _a;
      return (_a = this.owner) == null ? void 0 : _a.loadedGraphics;
    });
    const t2 = this.owner.layer && this.owner.layer.objectIdField, s2 = this.owner.loadedGraphics.find((i3) => i3 === e2 || t2 && i3.attributes && e2.attributes && i3.attributes[t2] === e2.attributes[t2]);
    if (!s2)
      throw new s$d("internal:graphic-not-part-of-view", "Graphic is not part of this view");
    const a2 = await this._whenGraphics3DGraphic(s2);
    return this._boundsForGraphics3DGraphic(a2, i2);
  }
  computeAttachmentOrigin(e2, i2) {
    const t2 = this.graphics3DGraphics.get(e2.uid);
    if (!t2)
      return null;
    const r2 = t2.computeAttachmentOrigin();
    if (r2.render.num === 0 && r2.draped.num === 0)
      return null;
    o$7(We, 0, 0, 0);
    let s2 = 0;
    if (r2.render.num > 0) {
      if (!jn(r2.render.origin, this.symbolCreationContext.renderCoordsHelper.spatialReference, Me, i2))
        return null;
      u$g(We, We, Me), s2++;
    }
    if (r2.draped.num > 0) {
      const [e3, t3] = r2.draped.origin, a2 = i$a(this._viewElevationProvider.getElevation(e3, t3, "ground"), 0);
      if (o$7(Me, e3, t3, a2), !jn(Me, this._viewElevationProvider.spatialReference, Me, i2))
        return null;
      u$g(We, We, Me), s2++;
    }
    return s2 > 1 && g$d(We, We, 1 / s2), new w$e({ x: We[0], y: We[1], z: We[2], spatialReference: i2 });
  }
  getSymbolLayerSize(e2, i2) {
    const t2 = this._symbols.get(e2.id);
    if (t$7(t2))
      throw new s$d("internal:symbol-not-part-of-view", "Symbol is not part of this view");
    const s2 = e2.symbolLayers.indexOf(i2);
    if (s2 === -1)
      throw new s$d("internal:missing-symbol-layer", "Symbol layer is not in symbol");
    const a2 = t2.getSymbolLayerSize(s2);
    if (a2 == null)
      throw new s$d("internal:missing-size", "Symbol layer has no valid size");
    return a2;
  }
  _graphicsCollectionChanged(e2) {
    this._startCreateGraphics && (this.add(e2.added), this.remove(e2.removed));
  }
  graphicUpdateHandler(e2) {
    const i2 = e2.graphic.uid, t2 = this.graphics3DGraphics.get(i2);
    if (!t$7(t2) || !t$7(this._graphicsWithoutSymbol.get(i2)))
      switch (e2.property) {
        case "visible":
          this._graphicUpdateVisibleHandler(t2);
          break;
        case "geometry":
          this._graphicUpdateGeometryHandler(t2, e2);
          break;
        case "symbol":
          this._graphicUpdateSymbolHandler(t2, e2);
          break;
        case "attributes":
          break;
        case "transform":
          this._graphicUpdateTransformHandler(t2, e2);
      }
  }
  _graphicUpdateGeometryHandler(e2, i2) {
    const t2 = i2.graphic.geometry;
    if (t$7(t2))
      return void this._recreateGraphic(i2.graphic);
    if (t$7(e2)) {
      const e3 = i2.graphic.symbol && i2.graphic.symbol.id;
      if (e3) {
        const i3 = this._symbols.get(e3);
        if (r$d(i3) && i3.loadStatus === e$9.LOADING)
          return;
      }
      return void this._recreateGraphic(i2.graphic);
    }
    const r2 = e2.graphics3DSymbol;
    !t$7(i2.newValue) && r2.updateGeometry(e2, i2.newValue) || this._recreateGraphic(e2.graphic), this._expandComputedExtent(t2);
  }
  _graphicUpdateSymbolHandler(e2, i2) {
    const t2 = i2.graphic, r2 = r$d(e2) ? e2.graphics3DSymbol : r$d(i2.oldValue) ? this._symbols.get(i2.oldValue.id) : null;
    if (t$7(r2) || t$7(i2.newValue))
      return void this._recreateGraphic(t2);
    const s2 = r2.symbol, a2 = this._getConvertedSymbol(i2.newValue);
    if (r$d(a2) && (a2.type !== s2.type || a2.type === "web-style") || s2.type === "web-style")
      return void this._recreateGraphic(t2);
    const n2 = this._graphicsBySymbol.get(s2.id);
    if (n2 && n2.size !== 1)
      return void this._recreateGraphic(t2);
    const o2 = m$h(s2, a2);
    if (t$7(o2))
      return void this._updateSymbolMapping(s2.id, a2);
    const l2 = { diff: o2, graphics3DGraphicPatches: [], symbolStatePatches: [] };
    if (r2.prepareSymbolPatch(l2), !d$q(l2.diff))
      return void this._recreateGraphic(t2);
    const d2 = this._getRenderingInfo(t2);
    if (t$7(d2))
      return void this._recreateGraphic(t2);
    const p2 = r2.extentPadding;
    for (const h2 of l2.symbolStatePatches)
      h2();
    if (p2 !== r2.extentPadding && this._recomputeExtentPadding(), r$d(e2))
      for (const h2 of l2.graphics3DGraphicPatches)
        h2(e2, d2);
    this._updateSymbolMapping(s2.id, a2);
  }
  _graphicUpdateVisibleHandler(e2) {
    this._updateUserVisibility(e2) && (this._labeler && this.owner.view.labeler.setDirty(), this.owner.view.deconflictor.setDirty());
  }
  _graphicUpdateTransformHandler(e2, i2) {
  }
  recreateGraphics(e2) {
    this._suspendSymbolCleanup = true, this.remove(e2), this.add(e2), this._suspendSymbolCleanup = false, this.effectiveUpdatePolicy === i$n.SYNC && this._cleanupSymbols();
  }
  _recreateGraphic(e2) {
    this.recreateGraphics([e2]);
  }
  _beginGraphicUpdate(e2) {
    const i2 = this._graphicsUpdateId;
    return this._graphicsUpdateId++, this._graphicsWaitingForSymbol.set(e2.uid, i2), this._graphicsWaitingForSymbol.size === 1 && this.notifyChange("updating"), i2;
  }
  _endGraphicUpdate(e2) {
    e2 && (this._graphicsWaitingForSymbol.delete(e2.uid), this._graphicsWaitingForSymbol.size === 0 && (this._cleanupSymbols(), this.notifyChange("updating")));
  }
  _recomputeExtentPadding() {
    let e2 = 0;
    this._symbols.forEach((i2) => {
      r$d(i2) && (e2 = Math.max(e2, i2.extentPadding));
    }), this._set("extentPadding", e2);
  }
  _expandComputedExtent(e2) {
    const i2 = je, t2 = e2.spatialReference;
    T$7(e2, i2);
    const r2 = this._viewSpatialReference, s2 = Ue.tmpVec;
    if (E$f(t2, r2) || Bn(i2[0], i2[1], 0, t2, s2, r2) && (i2[0] = s2[0], i2[1] = s2[1], Bn(i2[3], i2[4], 0, t2, s2, r2), i2[3] = s2[0], i2[4] = s2[1]), !(isFinite(i2[0]) && isFinite(i2[3]) && isFinite(i2[1]) && isFinite(i2[4])))
      return;
    const a2 = this.computedExtent;
    let n2 = null;
    const o2 = isFinite(i2[2]) && isFinite(i2[5]), l2 = o2 && (!a2 || a2.zmin == null || i2[2] < a2.zmin), h2 = o2 && (!a2 || a2.zmax == null || i2[5] > a2.zmax);
    if (a2) {
      (i2[0] < a2.xmin || i2[1] < a2.ymin || i2[3] > a2.xmax || i2[4] > a2.ymax || l2 || h2) && (n2 = this._propertiesPool.get("computedExtent"), n2.xmin = Math.min(i2[0], a2.xmin), n2.ymin = Math.min(i2[1], a2.ymin), n2.xmax = Math.max(i2[3], a2.xmax), n2.ymax = Math.max(i2[4], a2.ymax), n2.spatialReference = r2);
    } else
      n2 = this._propertiesPool.get("computedExtent"), n2.xmin = i2[0], n2.ymin = i2[1], n2.xmax = i2[3], n2.ymax = i2[4], n2.spatialReference = r2;
    n2 && (l2 && (n2.zmin = i2[2]), h2 && (n2.zmax = i2[5]), this._set("computedExtent", n2));
  }
  _abortElevationInfoChange() {
    this._elevationInfoChangeAbortController && (this._elevationInfoChangeAbortController.abort(), this._elevationInfoChangeAbortController = null);
  }
  async elevationInfoChange() {
    var _a, _b;
    this._abortElevationInfoChange();
    const e2 = new AbortController();
    this._elevationInfoChangeAbortController = e2;
    const i2 = d$d(this.layer.elevationInfo, this.elevationFeatureExpressionEnabled);
    this.symbolCreationContext.featureExpressionInfoContext = await u$e(i2, this._viewSpatialReference, e2.signal, Ve), f$a(e2.signal), this._elevationInfoChangeAbortController = null, (_a = this._labeler) == null ? void 0 : _a.elevationInfoChange(), this.forEachGraphics3DSymbol((e3, i3, t2) => {
      e3.globalPropertyChanged("elevationInfo", i3) ? i3.forEach((e4) => {
        const i4 = e4.graphic, t3 = e4.labelGraphics;
        for (const r2 of t3) {
          r2.graphics3DSymbolLayer.updateGraphicElevationContext(i4, r2);
        }
      }) : this._recreateSymbol(t2);
    }), this.updateStageLayerElevationProvider(), (_b = this._elevationAlignment) == null ? void 0 : _b.elevationInfoChange();
  }
  updateStageLayerElevationProvider() {
    this._stageLayerElevationProvider ? (this.layer.elevationInfo && this.layer.elevationInfo.mode === "relative-to-scene" || this._numberOfGraphicsProvidingElevation === 0) && (this.owner.view.elevationProvider.unregister(this._stageLayerElevationProvider), this._stageLayerElevationProvider.dispose(), this._stageLayerElevationProvider = null) : (!this.layer.elevationInfo || this.layer.elevationInfo && this.layer.elevationInfo.mode !== "relative-to-scene") && this._numberOfGraphicsProvidingElevation > 0 && (this._stageLayerElevationProvider = new b$2({ layer: this.layer, stageLayer: this.stageLayer, view: this.owner.view }), this.owner.view.elevationProvider.register("scene", this._stageLayerElevationProvider));
  }
  _clearSymbolsAndGraphics() {
    var _a, _b, _c, _d;
    this.clear(), r$d(this._filterVisibility) && this._filterVisibility.clear(), (_a = this._labeler) == null ? void 0 : _a.reset(), (_b = this._deconflictor) == null ? void 0 : _b.clear(), (_c = this._elevationAlignment) == null ? void 0 : _c.clear(), (_d = this.stageLayer) == null ? void 0 : _d.invalidateSpatialQueryAccelerator(), this._stageLayerElevationProvider && (this.owner.view.elevationProvider.unregister(this._stageLayerElevationProvider), this._stageLayerElevationProvider.dispose(), this._stageLayerElevationProvider = null);
  }
  startCreateGraphics() {
    this._startCreateGraphics = true, this.recreateAllGraphics();
  }
  recreateAllGraphics() {
    this._recreateAllGraphics(false);
  }
  recreateAllGraphicsAndSymbols() {
    this._recreateAllGraphics(true);
  }
  _recreateAllGraphics(e2 = false) {
    if (!this._startCreateGraphics)
      return;
    const { loadedGraphics: i2, view: t2 } = this.owner, r2 = t2.basemapTerrain.tilingScheme && i2 && i2.length ? i2.toArray() : null;
    !e2 && r2 || this._clearSymbolsAndGraphics(), this.symbolCreationContext.screenSizePerspectiveEnabled = this.owner.view.screenSizePerspectiveEnabled && this.layer.screenSizePerspectiveEnabled, this.symbolCreationContext.slicePlaneEnabled = !!this.owner.slicePlaneEnabled, this._set("computedExtent", null), r2 && (e2 ? this.add(r2) : this.recreateGraphics(r2));
  }
  _recreateSymbol(e2) {
    const i2 = this._graphicsBySymbol.get(e2), t2 = [];
    i2 && (i2.forEach((e3, i3) => {
      var _a;
      const r3 = e3.usedMemory;
      this._conditionalRemove(e3, i3), (_a = this._spatialIndex) == null ? void 0 : _a.remove(e3), t2.push(e3.graphic), e3.destroy(), this._removeGraphics3DGraphic(i3, r3), this._updateLayerVisibility(), this._featureStore.events.emit("changed");
    }), this._graphicsBySymbol.set(e2, new Map()));
    const r2 = this._symbols.get(e2);
    s$j(r2), this._symbols.delete(e2), this.add(t2);
  }
  _recreateGraphicsForSymbol(e2) {
    const i2 = this._graphicsBySymbol.get(e2);
    if (i2) {
      const e3 = [];
      i2.forEach((i3) => e3.push(i3.graphic)), this.recreateGraphics(e3);
    }
  }
  _conditionalRemove(e2, i2) {
    var _a, _b, _c;
    this._graphicsDrapedUids.delete(i2), (_a = this._objectStates) == null ? void 0 : _a.removeGraphic(e2), (_b = this._labeler) == null ? void 0 : _b.removeGraphic(e2), (_c = this._deconflictor) == null ? void 0 : _c.removeGraphic(e2), r$d(this._graphicStateTracking) && this._graphicStateTracking.removeGraphic(e2);
  }
  add(e2) {
    e2 && e2.length !== 0 && (this.owner.view.basemapTerrain && this.owner.view.basemapTerrain.tilingScheme ? (this._updatePolicyForGraphics(e2) === i$n.ASYNC ? this._addDelayed(e2) : this._addImmediate(e2), this.notifyChange("updating")) : Ve.error("#add()", "Cannot add graphics before terrain surface has been initialized"));
  }
  _updatePolicyForGraphics(e2) {
    if (this.effectiveUpdatePolicy === i$n.SYNC && (this.layer.geometryType === "mesh" || this.layer.geometryType == null)) {
      for (const i2 of e2)
        if (r$d(i2.geometry) && i2.geometry.type === "mesh" && !i2.geometry.loaded)
          return i$n.ASYNC;
    }
    return this.effectiveUpdatePolicy;
  }
  _addImmediate(e2) {
    this._geometryWarningLogged = false, this._symbolWarningLogged = false;
    for (const i2 of e2)
      this._addGraphic(i2, this._getRenderingInfo(i2, Ve), i$n.SYNC);
    this._cleanupSymbols(), this._labeler && (this.owner.view.labeler.setDirty(), this._cleanupSymbols()), this.owner.view.deconflictor.setDirty();
  }
  _addDelayed(e2) {
    for (const i2 of e2) {
      const e3 = i2.uid;
      let t2 = this._pendingUpdates.get(e3);
      t2 ? t2.add ? t2.state !== Te.NEW && t2.abortController.abort() : this._pendingAdds++ : (t2 = this._pendingUpdatesPool.pushNew(), this._pendingAdds++, this._pendingUpdates.set(e3, t2)), t2.add = i2;
    }
    this.notifyChange("running"), this.notifyChange("updatingRemaining");
  }
  remove(e2) {
    this.effectiveUpdatePolicy === i$n.ASYNC ? this._removeDelayed(e2) : this._removeImmediate(e2), this.notifyChange("updating");
  }
  _removeImmediate(e2) {
    for (const i2 of e2)
      this._removeGraphic(i2);
    this._cleanupSymbols(), this._labeler && this.owner.view.labeler.setDirty(), this.owner.view.deconflictor.setDirty();
  }
  _removeDelayed(e2) {
    for (const i2 of e2) {
      const e3 = i2.uid, t2 = this._pendingUpdates.get(e3);
      if (t2)
        t2.add && (t2.remove ? t2.add = null : this._pendingUpdates.delete(e3), t2.state === Te.LOADING && t2.abortController.abort(), this._pendingAdds--);
      else {
        const t3 = this._pendingUpdatesPool.pushNew();
        t3.remove = i2, this._pendingUpdates.set(e3, t3), this._pendingRemoves++;
      }
    }
    this._pendingUpdates.size === 0 && this._finishPendingUpdates(), this.notifyChange("running"), this.notifyChange("updatingRemaining");
  }
  _finishPendingUpdates() {
    this._pendingUpdatesPool.clear(), this._cleanupSymbols(), (this._pendingAdds || this._pendingRemoves) && Ve.warn("pendingAdds/Removes in inconsistent state!"), this._pendingAdds = 0, this._pendingRemoves = 0;
  }
  _applyPendingUpdates(e2) {
    var _a;
    if (this._geometryWarningLogged = false, this._symbolWarningLogged = false, this._pendingUpdates.size === 0 && ((_a = this._spatialIndex) == null ? void 0 : _a.updating))
      this._spatialIndex.update();
    else {
      for (const [i2, t2] of this._pendingUpdates) {
        if (e2.done)
          break;
        t2.add && t2.state === Te.NEW && this._processPendingUpdateNew(t2);
        let r2 = this.effectiveUpdatePolicy;
        if (!t2.remove || t2.add && t2.state !== Te.READY || (this._pendingRemoves--, e2.madeProgress(), this._removeGraphic(t2.remove), t2.remove = null, r2 = i$n.SYNC), t2.add)
          switch (t2.state) {
            case Te.READY:
              this._addGraphic(t2.add, t2.renderingInfo, r2), t2.add = null, this._pendingAdds--, e2.madeProgress();
              break;
            case Te.REJECTED:
              t2.add = null, this._pendingAdds--;
            case Te.LOADING:
          }
        t2.remove == null && t2.add == null && this._pendingUpdates.delete(i2);
      }
      this._pendingUpdates.size === 0 && (this._finishPendingUpdates(), this.notifyChange("running"));
    }
  }
  _processPendingUpdateNew(e2) {
    if (!e2.add)
      return void (e2.state = Te.READY);
    const i2 = e2.add.geometry;
    r$d(i2) && i2.type === "mesh" && !i2.loaded ? this._processPendingUpdateNewMesh(e2, i2) : this._processPendingUpdateNewRenderingInfo(e2);
  }
  async _processPendingUpdateNewMesh(e2, i2) {
    e2.state = Te.LOADING, e2.abortController = new AbortController();
    const t2 = e2.abortController.signal;
    try {
      await i2.load({ signal: t2 });
    } catch (r2) {
      return this._processPendingUpdateNewError(e2, r2);
    }
    e2.abortController = null, this._processPendingUpdateNewRenderingInfo(e2);
  }
  _processPendingUpdateNewError(e2, i2) {
    e2.abortController = null, j$7(i2) ? e2.state = Te.NEW : e2.state = Te.REJECTED;
  }
  async _processPendingUpdateNewRenderingInfo(e2) {
    if (t$7(this.layer.renderer) || this.layer.renderer.type !== "dictionary")
      return e2.renderingInfo = this._getRenderingInfo(e2.add, Ve), void (e2.state = Te.READY);
    e2.state = Te.LOADING, e2.abortController = new AbortController();
    let i2 = null;
    try {
      i2 = await this._getRenderingInfoAsync(e2.add, { signal: e2.abortController.signal });
    } catch (t2) {
      return e2.abortController = null, void (j$7(t2) ? e2.state = Te.NEW : e2.state = Te.REJECTED);
    }
    t$7(i2) || t$7(i2.symbol) ? (Ve && !this._symbolWarningLogged && (this._symbolWarningLogged = true, Ve.warn(`Graphic in layer ${this.layer.id} has no symbol and will not render`)), e2.renderingInfo = null) : e2.renderingInfo = i2, e2.state = Te.READY;
  }
  _addGraphic(e2, i2, t2) {
    if (this._graphicsWithoutSymbol.set(e2.uid, e2), t$7(i2) || t$7(i2.symbol) || !M$a(e2))
      return;
    has("enable-feature:objectAndLayerId-rendering") && this.setUidToIdOnAdd && this.stage.renderView._objectAndLayerIdRenderHelper.setUidToObjectAndLayerId(e2.objectId, e2.uid, this.layer.id, this.layer.uid, this.layer.popupEnabled);
    const r2 = i2.symbol, s2 = this.getOrCreateGraphics3DSymbol(r2, i2.renderer);
    if (t$7(s2))
      return;
    this._expandComputedExtent(e2.geometry);
    const a2 = this._beginGraphicUpdate(e2), n2 = new r$c(e2, i2, this.layer);
    let o2 = false;
    const l2 = (e3) => {
      e3 === s2.symbol.id && (o2 = true);
    };
    this._whenSymbolRemoved.push(l2);
    const d2 = () => {
      if (--this._loadingSymbols, this.destroyed)
        return;
      this._whenSymbolRemoved.removeUnordered(l2);
      if (this._graphicsWaitingForSymbol.get(e2.uid) !== a2 || o2 || s2.destroyed || this.graphicSymbolSupported && e2.symbol && e2.symbol.id !== s2.symbol.id)
        --s2.referenced, this._cleanupSymbols();
      else {
        const i3 = this._createGraphics3DGraphic(s2, n2);
        this._spatialIndex && r$d(i3) && this._spatialIndex.add(i3), --s2.referenced, this._endGraphicUpdate(e2);
      }
      this._featureStore.events.emit("changed"), this._labeler && this.owner.view.labeler.setDirty();
    }, p2 = (i3) => {
      --this._loadingSymbols, this.destroyed || (this._whenSymbolRemoved.removeUnordered(l2), o2 || (j$7(i3) ? this.add([e2]) : s2.destroyed || this._endGraphicUpdate(e2)));
    };
    ++this._loadingSymbols, t2 === i$n.ASYNC ? s2.load(() => this._frameTask.schedule(d2), (e3) => this._frameTask.schedule(() => p2(e3))) : s2.load(d2, p2);
  }
  _removeGraphic(e2) {
    var _a;
    const i2 = e2.uid, t2 = this.graphics3DGraphics.get(i2);
    if (t2) {
      t2.graphics3DSymbol.onRemoveGraphic(t2);
      const e3 = t2.usedMemory, r2 = t2.isElevationSource;
      this._conditionalRemove(t2, i2), (_a = this._spatialIndex) == null ? void 0 : _a.remove(t2);
      const s2 = t2.graphics3DSymbol.symbol.id;
      this._graphicsBySymbol.get(s2).delete(i2), this._graphicsWithoutSymbol.delete(i2), this._removeGraphics3DGraphic(i2, e3, r2), t2.destroy(), this._featureStore.events.emit("changed");
    } else
      this._graphicsWithoutSymbol.delete(i2), this._graphicsWaitingForSymbol.delete(i2), this._graphicsWaitingForSymbol.size === 0 && (this._cleanupSymbols(), this.notifyChange("updating"));
  }
  _hasLabelingContext(e2) {
    if (e2 instanceof b$l || e2 instanceof m$i) {
      const i2 = this.symbolCreationContext.layer;
      return !!i2.labelingInfo && i2.labelingInfo.some((i3) => i3.symbol === e2);
    }
    return false;
  }
  _hasValidSymbolCreationContext(e2) {
    return !(e2 instanceof b$l && !this._hasLabelingContext(e2)) || (Ve.error("LabelSymbol3D is only valid as part of a LabelClass. Using LabelSymbol3D as a renderer symbol is not supported."), false);
  }
  _getRenderingInfo(e2, i2) {
    const t2 = e2.geometry;
    if (t$7(t2))
      return i2 && !this._geometryWarningLogged && (this._geometryWarningLogged = true, i2.warn(`Graphic in layer ${this.layer.id} has no geometry and will not render`)), null;
    if (!An(t2.spatialReference, this._viewSpatialReference))
      return i2 && !this._geometryWarningLogged && (this._geometryWarningLogged = true, i2.warn(`Graphic in layer ${this.layer.id} has incompatible spatial reference and will not render`)), null;
    if (!this.graphicSymbolSupported && r$d(e2.symbol))
      return i2 && !this._symbolWarningLogged && (this._symbolWarningLogged = true, i2.warn(`Graphic in layer ${this.layer.id} is not allowed to have a symbol, use a renderer instead`)), null;
    const r2 = this.rendererHasGeometryOperations ? f$o(e2, this.layer) : e2;
    let s2;
    if (this.owner.getRenderingInfo && (this.getRenderingInfoWithoutRenderer || r$d(this.currentRenderer)))
      s2 = this.owner.getRenderingInfo(r2, this.currentRenderer, this._arcadeOnDemand);
    else {
      s2 = { symbol: r2.symbol || b$d(r2.geometry) };
    }
    return t$7(s2) || t$7(s2.symbol) ? (i2 && !this._symbolWarningLogged && (this._symbolWarningLogged = true, i2.warn(`Graphic in layer ${this.layer.id} has no symbol and will not render`)), null) : s2;
  }
  _getRenderingInfoAsync(e2, i2) {
    const t2 = e2.geometry;
    if (t$7(t2))
      return Ve && !this._geometryWarningLogged && (this._geometryWarningLogged = true, Ve.warn(`Graphic in layer ${this.layer.id} has no geometry and will not render`)), null;
    if (!this.graphicSymbolSupported && r$d(e2.symbol))
      return Ve && !this._symbolWarningLogged && (this._symbolWarningLogged = true, Ve.warn(`Graphic in layer ${this.layer.id} is not allowed to have a symbol, use a renderer instead`)), null;
    const r2 = this.rendererHasGeometryOperations ? f$o(e2, this.layer) : e2;
    return this.owner.getRenderingInfoAsync(r2, this.currentRenderer, this._arcadeOnDemand, i2);
  }
  _createGraphics3DSymbol(e2, i2) {
    if (!this._hasValidSymbolCreationContext(e2))
      return null;
    const t2 = this._getConvertedSymbol(e2);
    if (!t2)
      return null;
    let r2;
    if (r$d(i2) && "backgroundFillSymbol" in i2 && i2.backgroundFillSymbol) {
      const e3 = S$h(i2.backgroundFillSymbol, { ignoreDrivers: true });
      r$d(e3.symbol) && e3.symbol.type !== "web-style" && e3.symbol.type !== "cim" && (r2 = e3.symbol.symbolLayers);
    }
    const s2 = t$1(t2, this.symbolCreationContext, r2);
    return s2.load(() => {
      const e3 = s2.extentPadding;
      e3 > this.extentPadding && this._set("extentPadding", e3), this.notifyChange("averageSymbolComplexity");
    }, () => {
    }), s2;
  }
  getOrCreateGraphics3DSymbol(e2, i2) {
    let t2 = this._symbols.get(e2.id);
    return t2 === void 0 && (t2 = e2 instanceof f$p ? new e$2(e2, (e3) => this._frameTask.schedule(e3), (e3) => this._createGraphics3DSymbol(e3, i2)) : this._createGraphics3DSymbol(e2, i2), this._symbols.set(e2.id, t2)), r$d(t2) && ++t2.referenced, t2;
  }
  trackGraphicState(e2) {
    return t$7(this._graphicStateTracking) && (this._graphicStateTracking = new s$2(this)), this._graphicStateTracking.add(e2);
  }
  _addGraphics3DGraphic(e2) {
    this._usedMemory += e2.usedMemory, this.graphics3DGraphics.set(e2.graphic.uid, e2), this._numberOfGraphics++, e2.isElevationSource && (this._numberOfGraphicsProvidingElevation++, this.updateStageLayerElevationProvider()), this._updateLayerVisibility();
  }
  _removeGraphics3DGraphic(e2, i2, t2 = false) {
    this._usedMemory -= i2, this.graphics3DGraphics.delete(e2), this._numberOfGraphics--, t2 && (this._numberOfGraphicsProvidingElevation--, this.updateStageLayerElevationProvider()), this._updateLayerVisibility();
  }
  _createGraphics3DGraphic(e2, i2) {
    var _a, _b, _c;
    const t2 = i2.graphic;
    if (this._graphicsWithoutSymbol.delete(t2.uid), !this._symbols.has(e2.symbol.id))
      return this.add([t2]), null;
    if (this.graphics3DGraphics.has(t2.uid))
      return null;
    const r2 = e2.createGraphics3DGraphic(i2);
    if (t$7(r2))
      return null;
    this._addGraphics3DGraphic(r2);
    const s2 = e2.symbol.id;
    this._graphicsBySymbol.has(s2) || this._graphicsBySymbol.set(s2, new Map()), this._graphicsBySymbol.get(s2).set(t2.uid, r2);
    if (r2.isDraped && this._graphicsDrapedUids.add(t2.uid), r2.centroid = null, r$d(t2.geometry) && t2.geometry.type !== "point" && (r2.centroid = A$7(t2.geometry, this._viewSpatialReference)), this._updateUserVisibility(r2), r$d(this._scaleVisibility) && this._scaleVisibility.updateVisibility(r2), r$d(this._filterVisibility)) {
      const { defaultVisibility: e3 } = this._filterVisibility;
      r2.setVisibilityFlag(C$9.FILTER, e3, E$a.GRAPHIC), e3 || this._filterVisibility.reapply();
    }
    (_a = this._deconflictor) == null ? void 0 : _a.addGraphic(r2), (_b = this._labeler) == null ? void 0 : _b.addGraphic(r2), (_c = this._objectStates) == null ? void 0 : _c.addGraphic(r2), this._deconflictor && this.owner.view.deconflictor.setInitialIconVisibilityFlag(this, r2), r2.initialize(this.stage, this.stageLayer, this.owner), r$d(this._graphicStateTracking) && this._graphicStateTracking.addGraphic(r2);
    const a2 = this._whenGraphics3DGraphicRequests[t2.uid];
    return a2 && (delete this._whenGraphics3DGraphicRequests[t2.uid], a2.resolve(r2)), r2;
  }
  _abortRendererChange() {
    this._rendererChangeAbortController && (this._rendererChangeAbortController.abort(), this._rendererChangeAbortController = null);
  }
  async rendererChange(e2) {
    if (this._abortRendererChange(), e2 !== this.currentRenderer)
      if (this._validateRenderer(e2), t$7(e2) && this._currentRendererChange(null, false), s$m(e2))
        if (r$d(e2) && e2.arcadeRequired) {
          const i2 = new AbortController();
          this._rendererChangeAbortController = i2;
          const { arcadeUtils: t2 } = await this._ensureArcade();
          f$a(i2);
          const r2 = t2.hasGeometryOperations(e2);
          r2 && (await t2.enableGeometryOperations(), f$a(i2)), this.effectiveUpdatePolicy === i$n.ASYNC ? await this._frameTask.schedule(() => this._currentRendererChange(e2, r2), i2.signal) : this._currentRendererChange(e2, r2), this._rendererChangeAbortController = null;
        } else if (this.effectiveUpdatePolicy === i$n.ASYNC) {
          const i2 = new AbortController();
          this._rendererChangeAbortController = i2, await this._frameTask.schedule(() => this._currentRendererChange(e2, false), i2.signal), this._rendererChangeAbortController = null;
        } else
          this._currentRendererChange(e2, false);
      else
        this._currentRendererChange(e2, false);
  }
  async _ensureArcade() {
    return t$7(this._arcadeOnDemand) ? (this._arcadeOnDemand = await i$o(), this._arcadeOnDemand) : this._arcadeOnDemand;
  }
  _currentRendererChange(e2, i2) {
    this.currentRenderer = e2, this.rendererHasGeometryOperations = i2, this.symbolCreationContext.arcade = e$f(this._arcadeOnDemand);
    const t2 = this.symbolCreationContext.renderer;
    if (e2 === t2)
      return;
    if (this._symbolConversionCache.clear(), t$7(e2))
      return this.symbolCreationContext.renderer = null, void this.recreateAllGraphicsAndSymbols();
    const r2 = m$h(t2, e2);
    this._updateUnchangedSymbolMappings(r2, e2, t2), this.symbolCreationContext.renderer = e2, t$7(r2) || (r2.type === "complete" ? this.recreateAllGraphicsAndSymbols() : r2.type === "partial" && (this._applyRendererDiff(r2, e2, t2) ? this._volatileGraphicsUpdated() : this.recreateAllGraphicsAndSymbols()), this.notifyChange("averageSymbolComplexity"));
  }
  _diffHasSymbolChange(e2) {
    for (const i2 in e2.diff)
      switch (i2) {
        case "visualVariables":
        case "defaultSymbol":
        case "uniqueValueInfos":
          break;
        case "uniqueValueGroups":
        case "authoringInfo":
        case "fieldDelimiter":
          delete e2.diff[i2];
          break;
        default:
          return true;
      }
    return false;
  }
  _applySymbolSetDiff(e2, i2, t2) {
    e2 = e2 || [], i2 = i2 || [];
    const r2 = [];
    for (const s2 of i2) {
      const i3 = this._graphicsBySymbol.get(s2.id);
      i3 && i3.forEach((a2, n2) => {
        const o2 = a2.graphic, l2 = this.layer instanceof b$m ? this.layer : null, h2 = e$f(this._arcadeOnDemand);
        if (s2 === t2.defaultSymbol && t2.getSymbol(f$o(o2, l2), { arcade: h2 }) === t2.defaultSymbol)
          return;
        const d2 = a2.usedMemory;
        e2.length || t2.defaultSymbol ? r2.push(o2) : this._graphicsWithoutSymbol.set(n2, o2);
        const c2 = this.graphics3DGraphics.get(n2);
        this._conditionalRemove(c2, n2), a2.destroy(), i3.delete(n2), this._removeGraphics3DGraphic(n2, d2), this._updateLayerVisibility();
      }), this._whenSymbolRemoved.forAll((e3) => e3(s2.id));
    }
    (e2.length || r2.length) && (this._graphicsWithoutSymbol.forEach((e3) => r2.push(e3)), this._graphicsWithoutSymbol.clear(), this.add(r2)), this._cleanupSymbols(), this._labeler && this.owner.view.labeler.setDirty(), this.owner.view.deconflictor.setDirty();
  }
  _applyUniqueValueRendererDiff(e2, i2, t2) {
    const r2 = e2.diff.defaultSymbol, s2 = e2.diff.uniqueValueInfos;
    if (r2 || s2) {
      const a2 = s2 ? s2.added.map((e3) => e3.symbol) : [], n2 = s2 ? s2.removed.map((e3) => e3.symbol) : [];
      if (s2)
        for (let e3 = 0; e3 < s2.changed.length; e3++)
          a2.push(s2.changed[e3].newValue.symbol), n2.push(s2.changed[e3].oldValue.symbol);
      return r2 ? (t2.defaultSymbol && n2.push(t2.defaultSymbol), i2.defaultSymbol && a2.push(i2.defaultSymbol)) : t2.defaultSymbol && a2.length && n2.push(i2.defaultSymbol), this._applySymbolSetDiff(a2, n2, i2), delete e2.diff.defaultSymbol, delete e2.diff.uniqueValueInfos, true;
    }
    return false;
  }
  _calculateUnchangedSymbolMapping(e2, i2, t2) {
    if ((i2 == null ? void 0 : i2.type) !== "unique-value" || (t2 == null ? void 0 : t2.type) !== "unique-value" || r$d(e2) && e2.type !== "partial")
      return [];
    const r2 = (e3) => r$d(e3) ? e3.id : null, s2 = e2 && e2.diff, a2 = s2 && s2.defaultSymbol, n2 = s2 && s2.uniqueValueInfos;
    let o2;
    if (n2)
      o2 = n2.unchanged.map((e3) => ({ oldId: r2(e3.oldValue.symbol), newId: r2(e3.newValue.symbol) }));
    else {
      o2 = [];
      for (const e3 of t2.uniqueValueInfos) {
        const t3 = r2(e3.symbol), s3 = i2.uniqueValueInfos.find((i3) => i3.value === e3.value);
        s3 && t3 !== r2(s3.symbol) && o2.push({ oldId: t3, newId: r2(s3.symbol) });
      }
    }
    return !a2 && t2.defaultSymbol && o2.push({ oldId: r2(t2.defaultSymbol), newId: r2(i2.defaultSymbol) }), o2;
  }
  _updateSymbolMapping(e2, i2) {
    const t2 = r$d(i2) && i2 ? typeof i2 == "string" ? i2 : i2.id : null;
    if (!e2 || e2 === t2)
      return;
    const r2 = this._graphicsBySymbol.get(e2);
    this._graphicsBySymbol.delete(e2), r2 !== void 0 && this._graphicsBySymbol.set(t2, r2);
    const s2 = this._symbols.get(e2);
    if (s2 !== void 0 && (this._symbols.delete(e2), this._symbols.set(t2, s2), r$d(s2))) {
      const e3 = typeof i2 == "string" ? null : i2;
      r$d(e3) ? s2.symbol = e3 : s2.symbol.id = t2;
    }
  }
  _updateUnchangedSymbolMappings(e2, i2, t2) {
    const r2 = this._calculateUnchangedSymbolMapping(e2, i2, t2);
    for (const { oldId: s2, newId: a2 } of r2)
      this._updateSymbolMapping(s2, a2);
  }
  _applyRendererDiff(e2, t2, r2) {
    if (this._diffHasSymbolChange(e2))
      return false;
    if (t2 instanceof C$f && r2 instanceof C$f && this._applyUniqueValueRendererDiff(e2, t2, r2) && Object.keys(e2.diff).length === 0)
      return true;
    for (const [i2] of this._graphicsBySymbol) {
      const r3 = this._symbols.get(i2);
      if (r$d(r3))
        switch (r3.applyRendererDiff(e2, t2)) {
          case e$a.Recreate_Symbol:
            this._recreateSymbol(i2);
            break;
          case e$a.Recreate_Graphics:
            this._recreateGraphicsForSymbol(i2);
          case e$a.Fast_Update:
        }
    }
    return true;
  }
  opacityChange() {
    this.forEachGraphics3DSymbol((e2, i2) => e2.globalPropertyChanged("opacity", i2)), this._updateStageLayerVisibility();
  }
  _slicePlaneEnabledChange(e2) {
    e2 !== this.symbolCreationContext.slicePlaneEnabled && (this.symbolCreationContext.slicePlaneEnabled = e2, this.stageLayer.isSliceable = e2, this.forEachGraphics3DSymbol((e3, i2) => e3.globalPropertyChanged("slicePlaneEnabled", i2)), this._deconflictor && this._deconflictor.slicePlaneEnabledChange(), this._labeler && this._labeler.slicePlaneEnabledChange());
  }
  _physicalBasedRenderingChange(e2) {
    this.symbolCreationContext.physicalBasedRenderingEnabled = e2, this.forEachGraphics3DSymbol((e3, i2, t2) => {
      e3.globalPropertyChanged("physicalBasedRenderingEnabled", i2) || this._recreateSymbol(t2);
    });
  }
  _skipHighSymbolLoDsChange(e2) {
    this.symbolCreationContext.skipHighSymbolLods = e2, this.forEachGraphics3DSymbol((e3, i2, t2) => this._recreateSymbol(t2));
  }
  _pixelRatioChange() {
    this.forEachGraphics3DSymbol((e2, i2, t2) => {
      e2.globalPropertyChanged("pixelRatio", i2) || this._recreateSymbol(t2);
    });
  }
  _signalUpdatingDuringAsyncLoadedGraphicsChange() {
    this._updatingPendingLoadedGraphicsChange && this._updatingPendingLoadedGraphicsChange.remove(), this._updatingPendingLoadedGraphicsChange = v$m(() => {
      this._updatingPendingLoadedGraphicsChange = null;
    });
  }
  setClippingExtent(e2, i2) {
    const t2 = this.symbolCreationContext.clippingExtent, r2 = u$o();
    return e$1(e2, r2, i2) ? this.symbolCreationContext.clippingExtent = G$7(a$b(), r2) : this.symbolCreationContext.clippingExtent = null, !S$i(this.symbolCreationContext.clippingExtent, t2);
  }
  modifyGraphics3DGraphicVisibilities(e2) {
    var _a;
    let i2 = false;
    this.graphics3DGraphics.forEach((t2) => {
      e2(t2) && (i2 = true);
    }), i2 && ((_a = this.owner.view.labeler) == null ? void 0 : _a.setDirty(), this.owner.view.deconflictor.setDirty());
  }
  forEachGraphics3DSymbol(e2) {
    for (const [i2, t2] of this._symbols) {
      if (t$7(t2))
        return;
      e2(t2, this._graphicsBySymbol.get(i2) || Ne, i2);
    }
  }
  updateAllGraphicsVisibility() {
    r$d(this._filterVisibility) && this._filterVisibility.reapply(), this.modifyGraphics3DGraphicVisibilities((e2) => {
      const i2 = this._updateUserVisibility(e2), t2 = r$d(this._scaleVisibility) && this._scaleVisibility.updateVisibility(e2);
      return i2 || t2;
    });
  }
  _hideAllGraphics() {
    this.modifyGraphics3DGraphicVisibilities((e2) => e2.setVisibilityFlag(C$9.USER_SETTING, false, E$a.GRAPHIC));
  }
  _validateRenderer(e2) {
    var _a;
    const i2 = u$w(e2, { geometryType: (_a = this.layer) == null ? void 0 : _a.geometryType });
    if (i2) {
      const e3 = `Renderer for layer '${this.layer.title ? `${this.layer.title}, ` : ""}, id:${this.layer.id}' is not supported in a SceneView`;
      Ve.warn(e3, i2.message);
    }
  }
  _volatileGraphicsUpdated() {
    var _a;
    (_a = this._labeler) == null ? void 0 : _a.reset(), this.stageLayer.shaderTransformationChanged(), this.notifyChange("updating");
  }
  _cleanupSymbols() {
    if (this._graphicsWaitingForSymbol.size > 0 || this._suspendSymbolCleanup)
      return;
    let e2 = false;
    this._symbols.forEach((i2, t2) => {
      if (t$7(i2) || i2.referenced > 0)
        return;
      const r2 = this._graphicsBySymbol.get(t2);
      r2 && r2.size !== 0 || (this._graphicsBySymbol.delete(t2), this._symbols.delete(t2), s$j(i2), e2 = true);
    }), e2 && (this._recomputeExtentPadding(), this.notifyChange("averageSymbolComplexity"));
  }
  get test() {
    return { snapshotInternals: () => ({ graphics: [...this.graphics3DGraphics.keys()].sort(), symbols: [...this._symbols.keys()].sort(), graphicsBySymbol: [...this._graphicsBySymbol.keys()].sort().map((e2) => ({ symbolId: e2, graphics: [...this._graphicsBySymbol.get(e2).keys()].sort() })), graphicsWithoutSymbol: [...this._graphicsWithoutSymbol.keys()].sort(), graphicsDrapedUids: [...this._graphicsDrapedUids].sort(), pendingUpdates: this._pendingUpdates }), symbols: this._symbols, filterVisibility: this._filterVisibility, numPending: this._pendingUpdates.size, forceUpdatePolicy: (e2) => {
      this.forcedUpdatePolicy = e2;
    } };
  }
  get performanceInfo() {
    return { visible: this.graphics3DGraphics.size, missing: this._graphicsWithoutSymbol.size, pending: this._pendingUpdates.size };
  }
};
var Te;
Fe.tmpVec = n$h(), e$c([y$c({ readOnly: true })], Fe.prototype, "computedExtent", void 0), e$c([y$c()], Fe.prototype, "currentRenderer", void 0), e$c([y$c()], Fe.prototype, "rendererHasGeometryOperations", void 0), e$c([y$c()], Fe.prototype, "_frameTask", void 0), e$c([y$c()], Fe.prototype, "_rendererChangeAbortController", void 0), e$c([y$c()], Fe.prototype, "_elevationInfoChangeAbortController", void 0), e$c([y$c()], Fe.prototype, "_initializeAbortController", void 0), e$c([y$c()], Fe.prototype, "_elevationAlignment", void 0), e$c([y$c()], Fe.prototype, "_scaleVisibility", void 0), e$c([y$c()], Fe.prototype, "_filterVisibility", void 0), e$c([y$c()], Fe.prototype, "_initializePromise", void 0), e$c([y$c()], Fe.prototype, "_spatialIndex", void 0), e$c([y$c({ readOnly: true })], Fe.prototype, "extentPadding", void 0), e$c([y$c()], Fe.prototype, "_updatingPendingLoadedGraphicsChange", void 0), e$c([y$c()], Fe.prototype, "_featureStore", void 0), e$c([y$c()], Fe.prototype, "_deconflictor", void 0), e$c([y$c()], Fe.prototype, "_labeler", void 0), e$c([y$c()], Fe.prototype, "_objectStates", void 0), e$c([y$c()], Fe.prototype, "_loadingSymbols", void 0), e$c([y$c()], Fe.prototype, "preferredUpdatePolicy", void 0), e$c([y$c()], Fe.prototype, "forcedUpdatePolicy", void 0), e$c([y$c({ readOnly: true })], Fe.prototype, "effectiveUpdatePolicy", null), e$c([y$c({ constructOnly: true })], Fe.prototype, "elevationFeatureExpressionEnabled", void 0), e$c([y$c({ constructOnly: true })], Fe.prototype, "owner", void 0), e$c([y$c({ constructOnly: true })], Fe.prototype, "layer", void 0), e$c([y$c({ constructOnly: true })], Fe.prototype, "graphicSymbolSupported", void 0), e$c([y$c({ constructOnly: true })], Fe.prototype, "getRenderingInfoWithoutRenderer", void 0), e$c([y$c({ constructOnly: true })], Fe.prototype, "componentFactories", void 0), e$c([y$c({ constructOnly: true })], Fe.prototype, "setUidToIdOnAdd", void 0), e$c([y$c()], Fe.prototype, "featureStore", null), e$c([y$c()], Fe.prototype, "initializePromise", null), e$c([y$c()], Fe.prototype, "scaleVisibility", null), e$c([y$c()], Fe.prototype, "elevationAlignment", null), e$c([y$c()], Fe.prototype, "objectStates", null), e$c([y$c()], Fe.prototype, "filterVisibility", null), e$c([y$c({ readOnly: true })], Fe.prototype, "updating", null), e$c([y$c({ readOnly: true })], Fe.prototype, "running", null), e$c([y$c({ readOnly: true })], Fe.prototype, "suspendedOrOutsideOfView", null), e$c([y$c({ readOnly: true, dependsOn: [] })], Fe.prototype, "updatingRemaining", null), e$c([y$c({ readOnly: true, dependsOn: ["owner.view.qualitySettings.graphics3D.maxTotalNumberOfPrimitives", "owner.view.qualitySettings.graphics3D.maxTotalNumberOfFeatures", "averageSymbolComplexity"] })], Fe.prototype, "displayFeatureLimit", null), e$c([y$c({ readOnly: true, dependsOn: [] })], Fe.prototype, "averageSymbolComplexity", null), e$c([y$c({ constructOnly: true })], Fe.prototype, "hasZ", void 0), e$c([y$c({ constructOnly: true })], Fe.prototype, "hasM", void 0), e$c([y$c()], Fe.prototype, "_objectIdField", null), Fe = Ue = e$c([n$d(Le)], Fe), function(e2) {
  e2[e2.NEW = 0] = "NEW", e2[e2.LOADING = 1] = "LOADING", e2[e2.READY = 2] = "READY", e2[e2.REJECTED = 3] = "REJECTED";
}(Te || (Te = {}));
class ke {
  constructor() {
    this.add = null, this.renderingInfo = null, this.state = Te.NEW, this.remove = null;
  }
  clear() {
    this.add = null, this.renderingInfo = null, this.state = Te.NEW, this.abortController = null, this.remove = null;
  }
}
const ze = 10, We = n$h(), Me = n$h(), Ne = new Map();
const l$2 = 0.05;
class _$2 {
  constructor() {
    this._extents = new l$s({ allocator: (t2) => t2 || u$o() }), this._tmpExtent = u$o(), this._dirty = false;
  }
  get empty() {
    return this._extents.length === 0;
  }
  get size() {
    return this._extents.length;
  }
  clear() {
    this._extents.clear();
  }
  add(t2) {
    this._contains(t2) || (this._removeContained(t2), a$t(this._extents.pushNew(), t2), this._dirty = true);
  }
  pop() {
    return this._dirty && this._mergeTight(), this._extents.pop();
  }
  merge(t2) {
    return this._mergeTight(t2), t2.hasProgressed;
  }
  _mergeTight(t2 = F$c) {
    const e2 = this._extents, o2 = new Set();
    let i2 = 0;
    for (; i2 !== e2.length; ) {
      e2.sort((t3, e3) => t3[0] - e3[0]), i2 = e2.length, o2.clear();
      for (let i3 = 0; i3 < e2.length; ++i3) {
        if (t2.done)
          return;
        const h2 = e2.getItemAt(i3);
        if (h2) {
          for (let t3 = i3 + 1; t3 < e2.length; ++t3) {
            const r2 = e2.getItemAt(t3);
            if (r2 == null || r2[0] >= h2[2])
              break;
            o2.add(r2);
          }
          o2.forEach((i4) => {
            if (h2 === i4)
              return;
            if (i4[2] <= h2[0])
              return void o2.delete(i4);
            const _2 = y$g(h2), a2 = y$g(i4), c2 = this._tmpExtent;
            h$m(h2, i4, c2);
            const g2 = _2 + a2;
            (y$g(c2) - g2) / g2 < l$2 && (a$t(h2, c2), o2.delete(i4), e2.remove(i4), t2.madeProgress());
          }), o2.add(h2);
        }
      }
    }
    this._dirty = false;
  }
  _contains(t2) {
    return this._extents.some((e2) => R$d(e2, t2));
  }
  _removeContained(t2) {
    this._extents.filterInPlace((e2) => !R$d(t2, e2));
  }
  get test() {
    const t2 = this;
    return { containsPoint: (e2) => t2._extents.some((t3) => b$n(t3, e2)) };
  }
}
let c = class extends m$8 {
  constructor(e2) {
    super(e2), this._dirtyExtents = new _$2(), this._globalDirty = false, this._averageExtentUpdateSize = 0, this._dirtyGraphicsSet = new Set(), this._handles = new t$o(), this._updateElevation = false, this.graphicsCoreOwner = null, this.graphicsCore = null, this.events = new n$f();
  }
  initialize() {
    const e2 = this.elevationProvider, t2 = this.graphicsCoreOwner.view.resourceController.scheduler;
    this._handles.add([e2.on("elevation-change", (e3) => this._elevationChanged(e3)), l$t(() => this.graphicsCoreOwner.suspended, () => this._suspendedChange()), t2.registerTask(I$a.ELEVATION_ALIGNMENT, this)]);
  }
  destroy() {
    this._dirtyGraphicsSet.clear(), this._handles.destroy(), this._handles = null, this.graphicsCoreOwner = null, this.graphicsCore = null, this.queryGraphicUIDsInExtent = null, this.elevationProvider = null;
  }
  clear() {
    this._dirtyGraphicsSet.clear(), this.notifyChange("updating");
  }
  _suspendedChange() {
    this.graphicsCoreOwner.suspended === true ? this._updateElevation = false : this.graphicsCoreOwner.suspended === false && this._updateElevation && (this._globalDirty = true, this.notifyChange("updating"));
  }
  elevationInfoChange() {
    this._globalDirty = true, this.notifyChange("updating");
  }
  get updating() {
    return this.running;
  }
  get running() {
    return this._dirtyGraphicsSet.size > 0 || this._dirtyExtents && !this._dirtyExtents.empty || this._globalDirty;
  }
  get updatingRemaining() {
    return this._dirtyGraphicsSet.size + this._dirtyExtents.size * this._averageExtentUpdateSize;
  }
  runTask(e2) {
    for (this._globalDirty && (this._markAllGraphicsElevationDirty(), this._globalDirty = false, e2.madeProgress()), e2.run(() => this._dirtyExtents.merge(e2)); this.running && !e2.done; )
      this._updateDirtyGraphics(e2), this._updateDirtyExtents(e2);
    this.graphicsCoreOwner.view.deconflictor.setDirty(), this.notifyChange("updating");
  }
  _updateDirtyGraphics(e2) {
    const t2 = this.graphicsCoreOwner.view.renderCoordsHelper, i2 = this.graphicsCore.effectiveUpdatePolicy === i$n.ASYNC;
    for (const r2 of this._dirtyGraphicsSet.keys()) {
      const a2 = this.graphicsCore.getGraphics3DGraphicById(r2);
      if (this._dirtyGraphicsSet.delete(r2), r$d(a2) && (a2.alignWithElevation(this.elevationProvider, t2, i2), e2.madeProgress()), e2.done)
        return;
    }
  }
  _updateDirtyExtents(e2) {
    for (; !this._dirtyExtents.empty && !e2.done; ) {
      const t2 = this._dirtyExtents.pop(), i2 = this.elevationProvider.spatialReference;
      this.events.emit("invalidate-elevation", { extent: t2, spatialReference: i2 });
      const r2 = this._dirtyGraphicsSet.size;
      this.queryGraphicUIDsInExtent(t2, i2, (e3) => {
        const t3 = this.graphicsCore.getGraphics3DGraphicById(e3);
        r$d(t3) && t3.needsElevationUpdates() && this._dirtyGraphicsSet.add(e3);
      }), this._averageExtentUpdateSize = 0.1 * (this._dirtyGraphicsSet.size - r2) + 0.9 * this._averageExtentUpdateSize, e2.madeProgress();
    }
  }
  _markAllGraphicsElevationDirty() {
    this._dirtyExtents.clear(), this._dirtyGraphicsSet.clear(), this.graphicsCore.graphics3DGraphics.forEach((e2, t2) => this._dirtyGraphicsSet.add(t2));
  }
  _elevationChanged(e2) {
    if (e2.context === "scene" && (!this.graphicsCore.layer.elevationInfo || this.graphicsCore.layer.elevationInfo.mode !== "relative-to-scene"))
      return;
    const { extent: t2, spatialReference: i2 } = e2;
    if (this.graphicsCoreOwner.suspended) {
      if (!this._updateElevation) {
        const e3 = this.graphicsCore.computedExtent;
        e3 && t2[2] > e3.xmin && t2[0] < e3.xmax && t2[3] > e3.ymin && t2[1] < e3.ymax && (this._updateElevation = true);
      }
      this.events.emit("invalidate-elevation", { extent: t2, spatialReference: i2 });
    } else
      t2[0] === -1 / 0 ? this._globalDirty = true : this._dirtyExtents.add(t2), this.notifyChange("updating");
  }
};
e$c([y$c()], c.prototype, "graphicsCoreOwner", void 0), e$c([y$c()], c.prototype, "graphicsCore", void 0), e$c([y$c()], c.prototype, "queryGraphicUIDsInExtent", void 0), e$c([y$c()], c.prototype, "elevationProvider", void 0), e$c([y$c({ readOnly: true })], c.prototype, "updating", null), e$c([y$c({ readOnly: true })], c.prototype, "updatingRemaining", null), c = e$c([n$d("esri.views.3d.layers.graphics.Graphics3DElevationAlignment")], c);
const l$1 = c;
function h(r2, n2, t2, i2) {
  return b$1(r2, n2, t2, k$1(i2, n2, t2, true));
}
const g$2 = { dir: n$h(), len: 0, clip: n$k() };
function k$1(r2, n2, i2, s2) {
  const f2 = g$2;
  return r2 ? (i2 && s2 && (f2.len = x$i(n2, i2)), r$e(f2.dir, r2)) : s2 ? (f2.len = x$i(n2, i2), e$n(f2.dir, i2, n2), g$d(f2.dir, f2.dir, 1 / f2.len)) : (e$n(f2.dir, i2, n2), z$5(f2.dir, f2.dir)), f2;
}
function v$1(r2, t2, i2) {
  const e2 = P$9(Y$5(r2), i2.dir), c2 = -R$e(r2, t2);
  if (c2 < 0 && e2 >= 0)
    return false;
  if (e2 > -1e-6 && e2 < 1e-6)
    return c2 > 0;
  if ((c2 < 0 || e2 < 0) && !(c2 < 0 && e2 < 0))
    return true;
  const u2 = c2 / e2;
  return e2 > 0 ? u2 < i2.clip[1] && (i2.clip[1] = u2) : u2 > i2.clip[0] && (i2.clip[0] = u2), i2.clip[0] <= i2.clip[1];
}
function b$1(r2, n2, t2, i2) {
  i2.clip[0] = 0, i2.clip[1] = t2 ? i2.len : Number.MAX_VALUE;
  for (let e2 = 0; e2 < r2.length; e2++)
    if (!v$1(r2[e2], n2, i2))
      return false;
  return true;
}
const M = 0.5 * Math.PI, F = M / Math.PI * 180;
class N {
  constructor(t2) {
    this._renderCoordsHelper = t2.renderCoordsHelper, this._extent = new Array(4), this._planes = new Array(6), this._maxSpan = 0, this._center = { origin: n$h(), direction: n$h() };
    for (let e2 = 0; e2 < 4; e2++)
      this._extent[e2] = { origin: n$h(), direction: n$h(), cap: { next: null, direction: n$h() } }, this._planes[e2] = p$h();
    this._planes[U$7.NEAR] = p$h(), this._planes[U$7.FAR] = p$h(), this._planesWithoutFar = this._planes.slice(0, 5);
  }
  update(t2, e2, i2, r2 = true) {
    const a2 = this._extent;
    this._toRenderBoundingExtent(t2, e2, i2), u$g(this._center.origin, a2[0].origin, a2[2].origin), g$d(this._center.origin, this._center.origin, 0.5), this._renderCoordsHelper.worldUpAtPosition(this._center.origin, this._center.direction), r2 || g$d(this._center.direction, this._center.direction, -1);
    for (let n2 = 0; n2 < 4; n2++) {
      const t3 = a2[n2];
      this._renderCoordsHelper.worldUpAtPosition(t3.origin, t3.direction);
      const e3 = a2[n2 === 3 ? 0 : n2 + 1];
      t3.cap.next = e3.origin, H$6(t3.cap.direction, t3.origin, e3.origin), O$b(t3.direction, t3.cap.direction, t3.origin, this._planes[n2]), r2 || g$d(t3.direction, t3.direction, -1);
    }
    O$b(a2[0].cap.direction, a2[1].cap.direction, a2[0].origin, this._planes[U$7.NEAR]), r2 ? P$a(this._planes[U$7.NEAR], this._planes[U$7.FAR]) : (A$a(this._planes[U$7.FAR], this._planes[U$7.NEAR]), P$a(this._planes[U$7.NEAR], this._planes[U$7.NEAR])), this._maxSpan = Math.max(Math.abs(t2[0] - t2[2]), Math.abs(t2[1] - t2[3])), this._maxSpanSpatialReference = e2, this._minGlobalAltitude = 0.9 * u$v(this._maxSpanSpatialReference).radius;
  }
  isVisibleInFrustum(t2, e2, i2 = false) {
    if (t2 == null)
      return false;
    if (this._renderCoordsHelper.viewingMode === l$f.Global) {
      const i3 = this._maxSpanSpatialReference.isGeographic ? F : M * e2;
      if (this._maxSpan > i3)
        return true;
      if (t2.altitude != null && t2.altitude >= this._minGlobalAltitude)
        return this._isVisibleInFrustumGlobal(t2);
    }
    if (this._maxSpan === 0) {
      const e3 = this._extent[0];
      return !(i2 || !t2.intersectsRay(p$i(e3.origin, e3.direction)));
    }
    for (let n2 = 0; n2 < this._extent.length; n2++) {
      const e3 = this._extent[n2];
      if (!i2 && t2.intersectsRay(p$i(e3.origin, e3.direction)))
        return true;
      if (t2.intersectsLineSegment(b$o(e3.origin, e3.cap.next, V), e3.cap.direction))
        return true;
    }
    const r2 = i2 ? this._planes : this._planesWithoutFar;
    for (let n2 = 0; n2 < t2.lines.length; n2++) {
      const e3 = t2.lines[n2];
      if (h(r2, e3.origin, e3.endpoint, e3.direction))
        return true;
    }
    return false;
  }
  _toRenderBoundingExtentGlobal(t2, r2, n2) {
    const o2 = 5;
    p$k(t2, v), v[2] = n2, Zn(r2, v, I, this._renderCoordsHelper.spatialReference), h$d(U, I), A$6(L);
    for (const { x0: i2, x1: s2, y0: c2, y1: l2 } of k)
      for (let p2 = 0; p2 < o2; p2++) {
        const h2 = p2 / (o2 - 1);
        v[0] = h$n(t2[i2], t2[s2], h2), v[1] = h$n(t2[c2], t2[l2], h2), v[2] = n2, jn(v, r2, v, this._renderCoordsHelper.spatialReference), O$9(v, v, U), c$q(L, v);
      }
    o$7(this._extent[0].origin, L[0], L[1], L[2]), o$7(this._extent[1].origin, L[3], L[1], L[2]), o$7(this._extent[2].origin, L[3], L[4], L[2]), o$7(this._extent[3].origin, L[0], L[4], L[2]);
    for (let e2 = 0; e2 < 4; ++e2)
      O$9(this._extent[e2].origin, this._extent[e2].origin, I);
  }
  _toRenderBoundingExtentLocal(t2, e2, i2) {
    vn(t2, e2, P, this._renderCoordsHelper.spatialReference), o$7(this._extent[0].origin, P[0], P[1], i2), o$7(this._extent[1].origin, P[2], P[1], i2), o$7(this._extent[2].origin, P[2], P[3], i2), o$7(this._extent[3].origin, P[0], P[3], i2);
  }
  _toRenderBoundingExtent(e2, i2, r2) {
    switch (this._renderCoordsHelper.viewingMode) {
      case l$f.Global:
        this._toRenderBoundingExtentGlobal(e2, i2, r2);
        break;
      case l$f.Local:
        this._toRenderBoundingExtentLocal(e2, i2, r2);
        break;
      default:
        n$i(this._renderCoordsHelper.viewingMode);
    }
  }
  _isVisibleInFrustumGlobal(t2) {
    if (R$e(t2.planes[U$7.NEAR], this._center.origin) < 0 && P$9(this._center.direction, t2.direction) < 0)
      return true;
    for (let e2 = 0; e2 < 4; e2++) {
      const i2 = this._extent[e2];
      if (R$e(t2.planes[U$7.NEAR], i2.origin) < 0 && P$9(i2.direction, t2.direction) < 0)
        return true;
    }
    return false;
  }
}
const k = [{ x0: 0, y0: 1, x1: 2, y1: 1 }, { x0: 0, y0: 3, x1: 2, y1: 3 }, { x0: 0, y0: 1, x1: 0, y1: 3 }, { x0: 2, y0: 1, x1: 2, y1: 3 }], v = n$h(), I = e$e(), U = e$e(), L = a$b(), P = u$o(), V = v$n();
const u$1 = 1.2;
let d = class extends m$8 {
  constructor(e2) {
    super(e2), this.suspended = false, this._extent = null, this._extentIntersectionDirty = true, this._isVisibleBelowSurfaceInternal = false, this._handles = new t$o(), this.graphicsCoreOwner = null, this.updating = true;
  }
  initialize() {
    const { graphicsCoreOwner: e2 } = this;
    this._extentIntersection = new N({ renderCoordsHelper: e2.view.renderCoordsHelper });
    const t2 = e2.view, s2 = t2.basemapTerrain, i2 = t2.resourceController.scheduler;
    this._handles.add([t2.on("resize", () => this._viewChange()), l$t(() => t2.state.camera, () => this._viewChange(), U$8), i2.registerTask(I$a.FRUSTUM_VISIBILITY, this), l$t(() => s2.visibleElevationBounds, () => this._elevationBoundsChange())]), t2.viewingMode === "local" ? this._isVisibleBelowSurface = true : this._handles.add([l$t(() => {
      var _a, _b, _c;
      return [s2.baseOpacity, s2.wireframe, (_c = (_b = (_a = t2.map) == null ? void 0 : _a.ground) == null ? void 0 : _b.navigationConstraint) == null ? void 0 : _c.type];
    }, () => this._updateIsVisibleBelowSurface(), h$o)]);
  }
  destroy() {
    this._set("graphicsCoreOwner", null), this._extent = null, this._extentIntersection = null, this._handles = s$j(this._handles);
  }
  _setDirty() {
    this.updating || this._set("updating", true);
  }
  setExtent(e2) {
    this._extent = e2, this._extentIntersectionDirty = true, this._setDirty();
  }
  _viewChange() {
    this._setDirty();
  }
  _elevationBoundsChange() {
    this._setDirty(), this._extentIntersectionDirty = true;
  }
  set _isVisibleBelowSurface(e2) {
    this._isVisibleBelowSurfaceInternal = e2, this._setDirty(), this._extentIntersectionDirty = true;
  }
  _updateIsVisibleBelowSurface() {
    const e2 = this.graphicsCoreOwner.view, t2 = e2.basemapTerrain, s2 = e2.viewingMode === "local", i2 = e2.map.ground && e2.map.ground.navigationConstraint && e2.map.ground.navigationConstraint.type === "none";
    this._isVisibleBelowSurface = s2 || !t2.opaque || i2;
  }
  _updateExtentIntersection() {
    if (!this._extentIntersectionDirty)
      return;
    this._extentIntersectionDirty = false;
    const e2 = this.graphicsCoreOwner.view;
    let t2;
    if (this._isVisibleBelowSurfaceInternal)
      t2 = -0.3 * u$v(e2.spatialReference).radius;
    else {
      const { min: s2, max: i2 } = e2.basemapTerrain.visibleElevationBounds;
      t2 = s2 - Math.max(1, (i2 - s2) * (u$1 - 1));
    }
    this._extentIntersection.update(this._extent, e2.spatialReference, t2);
  }
  get running() {
    return this.updating;
  }
  runTask() {
    if (this._set("updating", false), !this._extent)
      return void this._set("suspended", false);
    this._updateExtentIntersection();
    const e2 = this.graphicsCoreOwner.view.frustum, t2 = u$v(this.graphicsCoreOwner.view.spatialReference).radius;
    this._set("suspended", !this._extentIntersection.isVisibleInFrustum(e2, t2));
  }
};
e$c([y$c({ readOnly: true })], d.prototype, "suspended", void 0), e$c([y$c({ constructOnly: true })], d.prototype, "graphicsCoreOwner", void 0), e$c([y$c({ readOnly: true })], d.prototype, "updating", void 0), d = e$c([n$d("esri.views.3d.layers.graphics.Graphics3DFrustumVisibility")], d);
const _$1 = d;
var t;
!function(e2) {
  e2[e2.Object = 0] = "Object", e2[e2.RenderGeometry = 1] = "RenderGeometry", e2[e2.External = 2] = "External", e2[e2.COUNT = 3] = "COUNT";
}(t || (t = {}));
class r {
  constructor() {
    this._items = [];
  }
  addObject(e2, r2) {
    this._items.push({ type: t.Object, objectStateId: r2, object: e2 });
  }
  addRenderGeometry(e2, r2, o2) {
    this._items.push({ type: t.RenderGeometry, objectStateId: r2, renderGeometry: e2, owner: o2 });
  }
  addExternal(e2, r2) {
    this._items.push({ type: t.External, objectStateId: r2, remove: e2 });
  }
  remove(e2) {
    for (let t2 = this._items.length - 1; t2 >= 0; --t2) {
      const r2 = this._items[t2];
      r2.objectStateId === e2 && (this._removeObjectStateItem(r2), this._items.splice(t2, 1));
    }
  }
  removeObject(e2) {
    for (let r2 = this._items.length - 1; r2 >= 0; --r2) {
      const o2 = this._items[r2];
      o2.type === t.Object && o2.object === e2 && (this._removeObjectStateItem(o2), this._items.splice(r2, 1));
    }
  }
  removeRenderGeometry(e2) {
    for (let r2 = this._items.length - 1; r2 >= 0; --r2) {
      const o2 = this._items[r2];
      o2.type === t.RenderGeometry && o2.renderGeometry === e2 && (this._removeObjectStateItem(o2), this._items.splice(r2, 1));
    }
  }
  removeAll() {
    this._items.forEach((e2) => {
      this._removeObjectStateItem(e2);
    }), this._items = [];
  }
  _removeObjectStateItem(r2) {
    switch (r2.type) {
      case t.Object:
        r2.objectStateId.channel === u$h.Highlight ? r2.object.removeHighlight(r2.objectStateId) : r2.objectStateId.channel === u$h.MaskOccludee && r2.object.removeOcclude(r2.objectStateId);
        break;
      case t.RenderGeometry:
        r2.owner.removeRenderGeometryObjectState(r2.renderGeometry, r2.objectStateId);
        break;
      case t.External:
        r2.remove(r2.objectStateId);
    }
  }
}
class e {
  constructor(e2, i2) {
    this.stateType = e2, this.objectIdField = i2, this.objectStateSet = new r(), this.ids = new Set(), this.paused = false;
  }
  hasGraphic(t2) {
    if (this.objectIdField) {
      const e2 = t2.graphic.attributes[this.objectIdField];
      return this.ids.has(e2);
    }
    return this.ids.has(t2.graphic.uid);
  }
}
class s$1 {
  constructor(t2) {
    this._graphicsCore = t2, this._stateSets = new Array();
  }
  destroy() {
    this._stateSets && this._stateSets.forEach((t2) => t2.objectStateSet.removeAll()), this._stateSets = null;
  }
  acquireSet(s2, a2) {
    const i2 = new e(s2, a2);
    this._stateSets.push(i2);
    const h2 = n$e(() => this.releaseSet(i2));
    return { set: i2, handle: h2 };
  }
  releaseSet(t2) {
    t2.objectStateSet.removeAll();
    const e2 = this._stateSets ? this._stateSets.indexOf(t2) : -1;
    e2 !== -1 && this._stateSets.splice(e2, 1);
  }
  _addObjectStateSet(t2, e2) {
    t2.addObjectStateSet(e2.stateType, e2.objectStateSet);
  }
  _removeObjectStateSet(t2, e2) {
    t2.removeObjectState(e2.objectStateSet);
  }
  setUid(t2, e2) {
    t2.ids.add(e2);
    const s2 = this._graphicsCore.graphics3DGraphics.get(e2);
    s2 && this._addObjectStateSet(s2, t2);
  }
  setUids(t2, e2) {
    e2.forEach((e3) => this.setUid(t2, e3));
  }
  setObjectIds(t2, e2) {
    e2.forEach((e3) => t2.ids.add(e3)), this._initializeSet(t2);
  }
  addGraphic(t2) {
    this._stateSets.forEach((e2) => {
      !e2.paused && e2.hasGraphic(t2) && this._addObjectStateSet(t2, e2);
    });
  }
  removeGraphic(t2) {
    this._stateSets.forEach((e2) => {
      e2.hasGraphic(t2) && this._removeObjectStateSet(t2, e2);
    });
  }
  allGraphicsDeleted() {
    this._stateSets && this._stateSets.forEach((t2) => t2.objectStateSet.removeAll());
  }
  _initializeSet(t2) {
    const e2 = this._graphicsCore.graphics3DGraphics;
    t2.objectIdField ? e2.forEach((e3) => {
      e3 && t2.hasGraphic(e3) && this._addObjectStateSet(e3, t2);
    }) : t2.ids.forEach((s2) => {
      const a2 = e2.get(s2);
      a2 && this._addObjectStateSet(a2, t2);
    });
  }
  get test() {
    return { states: this._stateSets };
  }
}
const y$1 = s$a.getLogger("esri.views.3d.layers.graphics.Graphics3DScaleVisibility");
let g$1 = class extends d$r {
  constructor(e2) {
    super(e2), this._scaleRangeActive = false, this._layerScaleRangeVisibilityQuery = false, this._extent = null, this.graphicsCoreOwner = null, this.layer = null, this.queryGraphicUIDsInExtent = null, this.graphicsCore = null, this.basemapTerrain = null, this.layerScaleEnabled = true, this.suspended = false, this._dirty = true;
  }
  initialize() {
    this.updateScaleRangeActive();
    const e2 = this.graphicsCoreOwner.view.resourceController.scheduler;
    this.handles.add(e2.registerTask(I$a.SCALE_VISIBILITY, this)), this.updatingHandles.add(() => this.layer.effectiveScaleRange, () => this.layerMinMaxScaleChangeHandler());
  }
  destroy() {
    this.updatingHandles.removeAll(), this.handles.removeAll(), this._dirty = false, this._extent = null, this.graphicsCoreOwner = null, this.layer = null, this.queryGraphicUIDsInExtent = null, this.graphicsCore = null, this.basemapTerrain = null;
  }
  get updating() {
    return this._dirty || this.updatingHandles.updating;
  }
  _setDirty() {
    this._dirty = true;
  }
  setExtent(e2) {
    const i2 = this.graphicsCoreOwner.view.spatialReference, t2 = this.graphicsCoreOwner.view.basemapTerrain.spatialReference;
    if (i2 === t2)
      this._extent = e2;
    else {
      const r2 = u$o();
      vn(e2, i2, r2, t2) ? this._extent = r2 : this._extent = null;
    }
    this._setDirty();
  }
  scaleRangeActive() {
    return this._scaleRangeActive;
  }
  updateScaleRangeActive() {
    const e2 = this.layer, i2 = e2.effectiveScaleRange;
    let t2 = this.layerScaleEnabled && u(i2.minScale, i2.maxScale);
    e2.labelingInfo && !t2 && (t2 = e2.labelingInfo.some((e3) => e3 && u(e3.minScale, e3.maxScale)));
    const r2 = this._scaleRangeActive !== t2;
    return this._scaleRangeActive = t2, t2 && !this.handles.has(b) && this.basemapTerrain ? (this.handles.add(this.basemapTerrain.on("scale-change", (e3) => this._scaleUpdateHandler(e3)), b), this.layerScaleEnabled && this.handles.add(this.basemapTerrain.on("tiles-visibility-changed", () => this._setDirty()), b)) : !t2 && this.handles.has(b) && this.handles.remove(b), r2;
  }
  get running() {
    return !(!this.graphicsCoreOwner.view.basemapTerrain || !this.updating);
  }
  runTask() {
    const e2 = this.graphicsCoreOwner.view.basemapTerrain;
    if (this._extent && e2 && e2.ready && this._scaleRangeActive && this.layerScaleEnabled) {
      if (!this._layerScaleRangeVisibilityQuery) {
        this._layerScaleRangeVisibilityQuery = true;
        const i2 = this.layer.effectiveScaleRange;
        e2.queryVisibleScaleRange(this._extent, i2.minScale, i2.maxScale, (e3) => this._finishUpdate(e3));
      }
    } else
      this._finishUpdate(true);
  }
  _finishUpdate(e2) {
    this._layerScaleRangeVisibilityQuery = false, this._set("suspended", !e2), this._dirty = false;
  }
  _visibleAtLayerScale(e2) {
    const i2 = this.layer.effectiveScaleRange;
    return !this.layerScaleEnabled || c$v(e2, i2.minScale || 0, i2.maxScale || 0);
  }
  _visibleAtLabelScale(e2, i2) {
    return c$v(e2, i2.minScale || 0, i2.maxScale || 0);
  }
  _graphicScale(e2) {
    let i2;
    if (r$d(e2.centroid) ? i2 = e2.centroid : r$d(e2.graphic.geometry) && e2.graphic.geometry.type === "point" && (i2 = e2.graphic.geometry), i2) {
      return this.graphicsCoreOwner.view.basemapTerrain ? this.graphicsCoreOwner.view.basemapTerrain.getScale(i2) : 1;
    }
    return null;
  }
  _graphicVisible(e2) {
    if (!this.layerScaleEnabled)
      return true;
    const i2 = this._graphicScale(e2);
    return this._visibleAtLayerScale(i2);
  }
  updateVisibility(e2) {
    if (this._scaleRangeActive) {
      const i2 = this._graphicVisible(e2);
      return e2.setVisibilityFlag(C$9.SCALE_RANGE, i2, E$a.GRAPHIC);
    }
    return false;
  }
  updateGraphicLabelScaleVisibility(e2) {
    if (!this._scaleRangeActive)
      return false;
    if (!e2.labelGraphics || e2.labelGraphics.length === 0)
      return false;
    const i2 = this._graphicScale(e2), t2 = this._updateLabelScaleVisibility(e2, i2);
    return t2 && (this.graphicsCoreOwner.view.deconflictor.setDirty(), this.graphicsCoreOwner.view.labeler.setDirty()), t2;
  }
  _updateLabelScaleVisibility(e2, i2) {
    if (!e2.labelGraphics || e2.labelGraphics.length === 0)
      return false;
    const t2 = e2.labelGraphics[0]._labelClass;
    if (t2 && t2.minScale != null && t2.maxScale != null) {
      const r2 = this._visibleAtLabelScale(i2, t2);
      if (e2.setVisibilityFlag(C$9.SCALE_RANGE, r2, E$a.LABEL))
        return true;
    }
    return false;
  }
  _scaleUpdateHandler(e2) {
    if (this._setDirty(), this.graphicsCoreOwner.suspended)
      return;
    const i2 = e2.extent, t2 = e2.scale, s2 = this._visibleAtLayerScale(t2);
    let l2 = false;
    const c2 = this.graphicsCoreOwner.view.spatialReference, p2 = e2.spatialReference;
    if (t$7(p2))
      return void y$1.error("scaleUpdate: Internal error, no SpatialReference given for tiles");
    const d2 = !p2.equals(c2);
    if (d2) {
      if (!vn(i2, p2, m, c2))
        return void y$1.error("scaleUpdate: Internal error, cannot project AABR from " + p2 + " to wkid " + c2);
    }
    const g2 = d2 ? m : i2;
    this.queryGraphicUIDsInExtent(g2, c2, (e3) => {
      const n2 = this.graphicsCore.getGraphics3DGraphicById(e3);
      if (t$7(n2))
        return;
      const c3 = n2.centroid;
      r$d(c3) && (i2[0] > c3.x || i2[1] > c3.y || i2[2] < c3.x || i2[3] < c3.y) || (n2.setVisibilityFlag(C$9.SCALE_RANGE, s2, E$a.GRAPHIC) && (l2 = true), this._updateLabelScaleVisibility(n2, t2) && (l2 = true));
    }), l2 && (this.graphicsCoreOwner.view.deconflictor.setDirty(), this.graphicsCoreOwner.view.labeler.setDirty());
  }
  layerMinMaxScaleChangeHandler() {
    this.updateScaleRangeActive() && !this._scaleRangeActive ? this.graphicsCore.modifyGraphics3DGraphicVisibilities((e2) => e2.clearVisibilityFlag(C$9.SCALE_RANGE)) : this._scaleRangeActive && this.graphicsCore.updateAllGraphicsVisibility(), this._setDirty();
  }
};
function u(e2, i2) {
  return e2 > 0 || i2 > 0;
}
e$c([y$c()], g$1.prototype, "graphicsCoreOwner", void 0), e$c([y$c()], g$1.prototype, "layer", void 0), e$c([y$c()], g$1.prototype, "queryGraphicUIDsInExtent", void 0), e$c([y$c()], g$1.prototype, "graphicsCore", void 0), e$c([y$c()], g$1.prototype, "basemapTerrain", void 0), e$c([y$c({ constructOnly: true })], g$1.prototype, "layerScaleEnabled", void 0), e$c([y$c({ readOnly: true })], g$1.prototype, "suspended", void 0), e$c([y$c({ readOnly: true })], g$1.prototype, "updating", null), e$c([y$c()], g$1.prototype, "_dirty", void 0), g$1 = e$c([n$d("esri.views.3d.layers.graphics.Graphics3DScaleVisibility")], g$1);
const b = "terrain-events", m = u$o(), S = g$1;
let A = class extends d$r {
  constructor(t2) {
    super(t2), this.type = "graphics-3d", this.graphicsCore = null, this.drapeSourceType = e$C.Features, this.scaleVisibilityEnabled = false, this.frustumVisibilityEnabled = false, this._suspendResumeExtent = null;
  }
  initialize() {
    const { layer: t2 } = this, e2 = "effectiveScaleRange" in t2 ? t2 : null, i2 = this.scaleVisibilityEnabled && r$d(e2), s2 = new Fe({ owner: this, layer: this.owner.layer, preferredUpdatePolicy: i$n.SYNC, graphicSymbolSupported: true, componentFactories: { elevationAlignment: (t3, e3) => new l$1({ graphicsCoreOwner: this, graphicsCore: t3, queryGraphicUIDsInExtent: e3, elevationProvider: this.view.elevationProvider }), scaleVisibility: i2 ? (t3, i3) => new S({ graphicsCoreOwner: this, layer: e2, queryGraphicUIDsInExtent: i3, graphicsCore: t3, basemapTerrain: this.owner.view.basemapTerrain }) : null, objectStates: (t3) => new s$1(t3) } });
    if (this._set("graphicsCore", s2), this.frustumVisibilityEnabled && this._set("frustumVisibility", new _$1({ graphicsCoreOwner: this })), "fullOpacity" in this.owner) {
      const t3 = this.owner;
      this.updatingHandles.add(() => t3.fullOpacity, () => this.graphicsCore.opacityChange());
    }
    if ("elevationInfo" in t2) {
      const e3 = t2;
      this.updatingHandles.add(() => e3.elevationInfo, (t3, e4) => {
        m$h(t3, e4) && this.updatingHandles.addPromise(this.graphicsCore.elevationInfoChange());
      });
    }
    this._set("initializePromise", this._initializeAsync()), this.updatingHandles.addPromise(this.initializePromise);
  }
  async _initializeAsync() {
    try {
      await this.graphicsCore.initializePromise;
    } catch (t2) {
      if (j$7(t2))
        return;
      throw t2;
    }
    this.destroyed || (this.handles.add(l$t(() => this.view.clippingArea, () => this._updateClippingExtent(), U$8)), this._updateClippingExtent(), this._setupSuspendResumeExtent(), this.graphicsCore.startCreateGraphics());
  }
  destroy() {
    this.handles.removeAll(), this.updatingHandles.removeAll(), this._set("frustumVisibility", s$j(this.frustumVisibility)), this._set("graphicsCore", s$j(this.graphicsCore));
  }
  get layer() {
    return this.owner.layer;
  }
  get view() {
    return this.owner.view;
  }
  get scaleVisibility() {
    var _a;
    return (_a = this.graphicsCore) == null ? void 0 : _a.scaleVisibility;
  }
  get elevationAlignment() {
    var _a;
    return (_a = this.graphicsCore) == null ? void 0 : _a.elevationAlignment;
  }
  get objectStates() {
    var _a;
    return (_a = this.graphicsCore) == null ? void 0 : _a.objectStates;
  }
  get scaleVisibilitySuspended() {
    return !(!r$d(this.scaleVisibility) || !this.scaleVisibility.suspended);
  }
  get frustumVisibilitySuspended() {
    return r$d(this.frustumVisibility) && this.frustumVisibility.suspended;
  }
  get suspended() {
    var _a;
    return (_a = this.owner.suspended) != null ? _a : false;
  }
  get updating() {
    var _a;
    return !!(((_a = this.graphicsCore) == null ? void 0 : _a.updating) || r$d(this.scaleVisibility) && this.scaleVisibility.updating || r$d(this.frustumVisibility) && this.frustumVisibility.updating || this.updatingHandles.updating);
  }
  get graphics3DGraphics() {
    var _a;
    return (_a = this.graphicsCore) == null ? void 0 : _a.graphics3DGraphics;
  }
  get graphics3DGraphicsByObjectID() {
    var _a;
    return (_a = this.graphicsCore) == null ? void 0 : _a.graphics3DGraphicsByObjectID;
  }
  get loadedGraphics() {
    return this.owner.loadedGraphics;
  }
  get fullOpacity() {
    var _a;
    return (_a = this.owner.fullOpacity) != null ? _a : 1;
  }
  get slicePlaneEnabled() {
    return this.owner.slicePlaneEnabled;
  }
  get updatePolicy() {
    return this.owner.updatePolicy;
  }
  notifyGraphicGeometryChanged(t2) {
    this.graphicsCore.notifyGraphicGeometryChanged(t2);
  }
  notifyGraphicVisibilityChanged(t2) {
    this.graphicsCore.notifyGraphicVisibilityChanged(t2);
  }
  getRenderingInfo(t2, e2, i2) {
    const s2 = a$8(t2, { renderer: e2, arcade: i2 });
    if (r$d(s2) && s2.color) {
      const t3 = s2.color;
      t3[0] = t3[0] / 255, t3[1] = t3[1] / 255, t3[2] = t3[2] / 255;
    }
    return s2;
  }
  getRenderingInfoAsync(t2, e2, i2, s2) {
    return s$8(t2, __spreadValues({ renderer: e2, arcade: i2 }, s2));
  }
  getHit(t2) {
    if (this.owner.loadedGraphics) {
      const e2 = this.owner.loadedGraphics.find((e3) => e3.uid === t2);
      if (e2) {
        const t3 = this.layer instanceof b$m ? this.layer : null, i2 = f$o(e2, t3);
        return { type: "graphic", graphic: i2, layer: i2.layer };
      }
    }
    return null;
  }
  whenGraphicBounds(t2, e2) {
    return this.graphicsCore ? this.graphicsCore.whenGraphicBounds(t2, e2) : Promise.reject();
  }
  computeAttachmentOrigin(t2, e2) {
    return this.graphicsCore ? this.graphicsCore.computeAttachmentOrigin(t2, e2) : null;
  }
  getSymbolLayerSize(t2, e2) {
    return this.graphicsCore ? this.graphicsCore.getSymbolLayerSize(t2, e2) : null;
  }
  maskOccludee(t2) {
    const { set: e2, handle: i2 } = this.objectStates.acquireSet(u$h.MaskOccludee, null);
    return this.objectStates.setUid(e2, t2.uid), i2;
  }
  highlight(t2) {
    if (t2 instanceof x$j)
      return _;
    if (typeof t2 == "number")
      return this.highlight([t2]);
    if (t2 instanceof g$j)
      return this.highlight([t2]);
    if (t2 instanceof j$d && (t2 = t2.toArray()), Array.isArray(t2) && t2.length > 0) {
      if (t2[0] instanceof g$j) {
        const e2 = t2.map((t3) => t3.uid), { set: i2, handle: s2 } = this.objectStates.acquireSet(u$h.Highlight, null);
        return this.objectStates.setUids(i2, e2), s2;
      }
      if (typeof t2[0] == "number") {
        const e2 = t2, { set: i2, handle: s2 } = this.objectStates.acquireSet(u$h.Highlight, null);
        return this.objectStates.setObjectIds(i2, e2), s2;
      }
    }
    return _;
  }
  _setupSuspendResumeExtent() {
    const { scaleVisibility: t2, frustumVisibility: e2 } = this;
    if (t$7(t2) && t$7(e2))
      return;
    const i2 = ({ computedExtent: i3, extentPadding: s2 }) => {
      this._suspendResumeExtent = z$6(i3, this._suspendResumeExtent, s$7, s2), r$d(t2) && t2.setExtent(this._suspendResumeExtent), r$d(e2) && e2.setExtent(this._suspendResumeExtent);
    };
    this.handles.add(l$t(() => {
      var _a, _b;
      return { computedExtent: (_a = this.graphicsCore) == null ? void 0 : _a.computedExtent, extentPadding: (_b = this.graphicsCore) == null ? void 0 : _b.extentPadding };
    }, (t3) => i2(t3), w$d));
  }
  _updateClippingExtent() {
    const t2 = this.view.clippingArea;
    this.graphicsCore.setClippingExtent(t2, this.view.spatialReference) && this.graphicsCore.recreateAllGraphics();
  }
};
e$c([y$c()], A.prototype, "type", void 0), e$c([y$c({ constructOnly: true })], A.prototype, "owner", void 0), e$c([y$c()], A.prototype, "layer", null), e$c([y$c()], A.prototype, "view", null), e$c([y$c({ constructOnly: true })], A.prototype, "graphicsCore", void 0), e$c([y$c()], A.prototype, "scaleVisibility", null), e$c([y$c({ constructOnly: true })], A.prototype, "frustumVisibility", void 0), e$c([y$c()], A.prototype, "elevationAlignment", null), e$c([y$c()], A.prototype, "objectStates", null), e$c([y$c()], A.prototype, "scaleVisibilitySuspended", null), e$c([y$c({ readOnly: true })], A.prototype, "frustumVisibilitySuspended", null), e$c([y$c()], A.prototype, "suspended", null), e$c([y$c({ readOnly: true })], A.prototype, "updating", null), e$c([y$c()], A.prototype, "loadedGraphics", null), e$c([y$c()], A.prototype, "fullOpacity", null), e$c([y$c()], A.prototype, "slicePlaneEnabled", null), e$c([y$c()], A.prototype, "drapeSourceType", void 0), e$c([y$c()], A.prototype, "updatePolicy", null), e$c([y$c({ constructOnly: true })], A.prototype, "scaleVisibilityEnabled", void 0), e$c([y$c({ constructOnly: true })], A.prototype, "frustumVisibilityEnabled", void 0), e$c([y$c()], A.prototype, "initializePromise", void 0), A = e$c([n$d("esri.views.3d.layers.graphics.GraphicsProcessor")], A);
const _ = n$e();
async function a(a2, o2, i2) {
  var _a;
  if (t$7(a2) || o2.candidates.length === 0)
    return s;
  const c2 = (_a = a2.graphics3DGraphicsByObjectID) != null ? _a : a2.graphics3DGraphics, p2 = [], d2 = [], { renderer: u2 } = a2, g2 = r$d(u2) && "arcadeRequired" in u2 && u2.arcadeRequired ? i$o() : null, l2 = async (n2, { graphic: r2, graphics3DSymbol: t2 }) => {
    const s2 = await g2, o3 = await a2.getRenderingInfoAsync(r2, u2, s2, { signal: i2 });
    return t$7(o3) ? [] : t2.queryForSnapping(n2, f2, o3, i2);
  }, { candidates: h2, spatialReference: f2 } = o2;
  for (let n2 = 0; n2 < h2.length; ++n2) {
    const r2 = h2[n2], { objectId: t2 } = r2, a3 = typeof t2 == "number" ? c2.get(t2) : void 0;
    if (t$7(a3))
      continue;
    const { graphics3DSymbol: s2 } = a3;
    s2.symbologySnappingSupported && (p2.push(l2(r2, a3)), d2.push(n2));
  }
  if (p2.length === 0)
    return s;
  const m2 = await Promise.all(p2);
  f$a(i2);
  const y2 = [], b2 = [];
  for (let e2 = 0; e2 < m2.length; ++e2) {
    const n2 = m2[e2], r2 = d2[e2];
    for (const e3 of n2)
      y2.push(e3), b2.push(r2);
  }
  return { candidates: y2, sourceCandidateIndices: b2 };
}
const s = { candidates: [], sourceCandidateIndices: [] };
function l(l2) {
  const s2 = l2.view.spatialReference, i2 = l2.layer.fullExtent, n2 = r$d(i2) && i2.spatialReference;
  if (t$7(i2) || !n2)
    return Promise.resolve(null);
  if (n2.equals(s2))
    return Promise.resolve(i2.clone());
  const a2 = M$b(i2, s2);
  return r$d(a2) ? Promise.resolve(a2) : l2.view.state.isLocal ? a$u(i2, s2, l2.layer.portalItem).then((e2) => !l2.destroyed && e2 ? e2 : void 0).catch(() => null) : Promise.resolve(null);
}
let g = class extends n$c(u$x) {
  constructor() {
    super(...arguments), this.type = "graphics-3d", this.symbologySnappingSupported = true, this.slicePlaneEnabled = false, this.fullExtentInLocalViewSpatialReference = null;
  }
  initialize() {
    this._set("processor", new A({ owner: this, scaleVisibilityEnabled: true, frustumVisibilityEnabled: true })), this.addResolvingPromise(this.processor.initializePromise), this.handles.add(this.layer.on("graphic-update", (e2) => this.processor.graphicsCore.graphicUpdateHandler(e2))), this.addResolvingPromise(l(this).then((e2) => this.fullExtentInLocalViewSpatialReference = e2)), this.layer.internal ? this.notifyChange("updating") : this.handles.add(f$n(() => {
      var _a, _b;
      return (_b = (_a = this.view) == null ? void 0 : _a.basemapTerrain) == null ? void 0 : _b.ready;
    }, () => () => this.notifyChange("updating"), { once: true }));
  }
  destroy() {
    this.handles.removeAll(), this.updatingHandles.removeAll(), this._set("processor", s$j(this.processor));
  }
  get loadedGraphics() {
    return this.layer.graphics;
  }
  get legendEnabled() {
    var _a;
    return this.canResume() && !((_a = this.processor) == null ? void 0 : _a.frustumVisibilitySuspended);
  }
  getSuspendInfo() {
    var _a, _b, _c, _d;
    const e2 = super.getSuspendInfo();
    return e2.outsideScaleRange = (_b = (_a = this.processor) == null ? void 0 : _a.scaleVisibilitySuspended) != null ? _b : false, e2.outsideOfView = (_d = (_c = this.processor) == null ? void 0 : _c.frustumVisibilitySuspended) != null ? _d : false, e2;
  }
  async fetchPopupFeatures(e2, r2) {
    return r$d(r2) ? r2.clientGraphics : null;
  }
  getHit(e2) {
    return this.processor.getHit(e2);
  }
  whenGraphicBounds(e2, r2) {
    return this.processor.whenGraphicBounds(e2, r2);
  }
  computeAttachmentOrigin(e2, r2) {
    var _a;
    return (_a = this.processor) == null ? void 0 : _a.computeAttachmentOrigin(e2, r2);
  }
  getSymbolLayerSize(e2, r2) {
    return this.processor.getSymbolLayerSize(e2, r2);
  }
  queryGraphics() {
    return Promise.resolve(this.loadedGraphics);
  }
  maskOccludee(e2) {
    return this.processor.maskOccludee(e2);
  }
  highlight(e2) {
    return this.processor.highlight(e2);
  }
  async elevationAlignPointsInFeatures(e2, s2) {
    const { processor: i2 } = this;
    if (t$7(i2))
      throw new s$d("graphicslayerview3d:missing-processor", "A Graphics3D processor is needed to resolve graphics elevation.");
    return m$7(this.view, this.layer, (e3) => typeof e3 == "number" ? i2.graphics3DGraphics.get(e3) : null, e2, s2);
  }
  async queryForSymbologySnapping(e2, r2) {
    return a(this.processor, e2, r2);
  }
  get updatePolicy() {
    var _a;
    return ((_a = this.processor) == null ? void 0 : _a.graphicsCore.effectiveUpdatePolicy) || i$n.SYNC;
  }
  canResume() {
    var _a;
    return super.canResume() && !((_a = this.processor) == null ? void 0 : _a.scaleVisibilitySuspended);
  }
  isUpdating() {
    var _a, _b, _c;
    return !(!((_a = this.processor) == null ? void 0 : _a.updating) && (this.layer.internal || ((_c = (_b = this.view) == null ? void 0 : _b.basemapTerrain) == null ? void 0 : _c.ready)));
  }
  get performanceInfo() {
    var _a, _b, _c;
    return { displayedNumberOfFeatures: this.loadedGraphics.length, maximumNumberOfFeatures: -1, totalNumberOfFeatures: -1, nodes: 0, core: null, updating: this.updating, elevationUpdating: (_b = (_a = this.processor) == null ? void 0 : _a.elevationAlignment.updating) != null ? _b : false, visibilityFrustum: !((_c = this.processor) == null ? void 0 : _c.frustumVisibilitySuspended) };
  }
  getUsedMemory() {
    var _a, _b, _c;
    return (_c = (_b = (_a = this.processor) == null ? void 0 : _a.graphicsCore) == null ? void 0 : _b.usedMemory) != null ? _c : 0;
  }
  getUnloadedMemory() {
    var _a, _b;
    return (_b = (_a = this.processor) == null ? void 0 : _a.graphicsCore) == null ? void 0 : _b.unprocessedMemoryEstimate;
  }
  ignoresMemoryFactor() {
    return true;
  }
};
e$c([y$c()], g.prototype, "loadedGraphics", null), e$c([y$c({ readOnly: true })], g.prototype, "legendEnabled", null), e$c([y$c()], g.prototype, "layer", void 0), e$c([y$c({ readOnly: true })], g.prototype, "processor", void 0), e$c([y$c({ type: Boolean })], g.prototype, "slicePlaneEnabled", void 0), g = e$c([n$d("esri.views.3d.layers.GraphicsLayerView3D")], g);
const y = g;
var GraphicsLayerView3D = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": y
});
export { C$6 as C, F$3 as F, GraphicsLayerView3D as G, S$a as S, x$2 as x };
