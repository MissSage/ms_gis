var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp(a2, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop))
        __defNormalProp(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps = (a2, b2) => __defProps(a2, __getOwnPropDescs(b2));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var _a, _b, _c, _d, _e2, _f, _g, _h, _i;
import { defineComponent, openBlock, createElementBlock, renderSlot, ref } from "vue";
var index_vue_vue_type_style_index_0_scoped_true_lang$1 = "";
var _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  emits: ["click"],
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("button", {
        class: "ms-button",
        onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
      }, [
        renderSlot(_ctx.$slots, "default", {}, void 0, true)
      ]);
    };
  }
});
var Button = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["__scopeId", "data-v-4342ae9c"]]);
const ButtonPlugin = {
  install(app) {
    app.component("ms-button", Button);
  }
};
function e$1W(e2, t2, r2, o2) {
  var c2, f2 = arguments.length, n2 = f2 < 3 ? t2 : o2 === null ? o2 = Object.getOwnPropertyDescriptor(t2, r2) : o2;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    n2 = Reflect.decorate(e2, t2, r2, o2);
  else
    for (var l2 = e2.length - 1; l2 >= 0; l2--)
      (c2 = e2[l2]) && (n2 = (f2 < 3 ? c2(n2) : f2 > 3 ? c2(t2, r2, n2) : c2(t2, r2)) || n2);
  return f2 > 3 && n2 && Object.defineProperty(t2, r2, n2), n2;
}
let e$1V;
function has(a2) {
  return typeof e$1V[a2] == "function" ? e$1V[a2] = e$1V[a2](globalThis) : e$1V[a2];
}
e$1V = ((_a = globalThis.dojoConfig) == null ? void 0 : _a.has) || ((_b = globalThis.esriConfig) == null ? void 0 : _b.has) ? __spreadValues(__spreadValues({}, (_c = globalThis.dojoConfig) == null ? void 0 : _c.has), (_d = globalThis.esriConfig) == null ? void 0 : _d.has) : {}, has.add = (a2, d2, o2, r2) => ((r2 || e$1V[a2] === void 0) && (e$1V[a2] = d2), o2 && has(a2)), has.cache = e$1V, has.add("esri-deprecation-warnings", true), (() => {
  var _a2;
  has.add("host-webworker", globalThis.WorkerGlobalScope !== void 0 && self instanceof globalThis.WorkerGlobalScope);
  const e2 = typeof window != "undefined" && typeof location != "undefined" && typeof document != "undefined" && window.location === location && window.document === document;
  if (has.add("host-browser", e2), has.add("host-node", typeof globalThis.process == "object" && ((_a2 = globalThis.process.versions) == null ? void 0 : _a2.node) && globalThis.process.versions.v8), has.add("dom", e2), has("host-browser")) {
    const e3 = navigator, a2 = e3.userAgent, d2 = e3.appVersion, o2 = parseFloat(d2);
    if (has.add("wp", parseFloat(a2.split("Windows Phone")[1]) || void 0), has.add("msapp", parseFloat(a2.split("MSAppHost/")[1]) || void 0), has.add("khtml", d2.includes("Konqueror") ? o2 : void 0), has.add("edge", parseFloat(a2.split("Edge/")[1]) || void 0), has.add("opr", parseFloat(a2.split("OPR/")[1]) || void 0), has.add("webkit", !has("wp") && !has("edge") && parseFloat(a2.split("WebKit/")[1]) || void 0), has.add("chrome", !has("edge") && !has("opr") && parseFloat(a2.split("Chrome/")[1]) || void 0), has.add("android", !has("wp") && parseFloat(a2.split("Android ")[1]) || void 0), has.add("safari", !d2.includes("Safari") || has("wp") || has("chrome") || has("android") || has("edge") || has("opr") ? void 0 : parseFloat(d2.split("Version/")[1])), has.add("mac", d2.includes("Macintosh")), !has("wp") && a2.match(/(iPhone|iPod|iPad)/)) {
      const e4 = RegExp.$1.replace(/P/, "p"), d3 = a2.match(/OS ([\d_]+)/) ? RegExp.$1 : "1", o3 = parseFloat(d3.replace(/_/, ".").replace(/_/g, ""));
      has.add(e4, o3), has.add("ios", o3);
    }
    has.add("trident", parseFloat(d2.split("Trident/")[1]) || void 0), has("webkit") || (!a2.includes("Gecko") || has("wp") || has("khtml") || has("trident") || has("edge") || has.add("mozilla", o2), has("mozilla") && has.add("ff", parseFloat(a2.split("Firefox/")[1] || a2.split("Minefield/")[1]) || void 0));
  }
})(), (() => {
  if (globalThis.navigator) {
    const e2 = navigator.userAgent, a2 = /Android|webOS|iPhone|iPad|iPod|BlackBerry|Opera Mini|IEMobile/i.test(e2), d2 = /iPhone/i.test(e2);
    a2 && has.add("esri-mobile", a2), d2 && has.add("esri-iPhone", d2), has.add("esri-geolocation", !!navigator.geolocation);
  }
  has.add("esri-canvas-svg-support", !has("trident")), has.add("esri-wasm", "WebAssembly" in globalThis), has.add("esri-shared-array-buffer", () => {
    const e2 = "SharedArrayBuffer" in globalThis, a2 = globalThis.crossOriginIsolated === false;
    return e2 && !a2;
  }), has.add("wasm-simd", () => {
    const e2 = [0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 123, 3, 2, 1, 0, 10, 10, 1, 8, 0, 65, 0, 253, 15, 253, 98, 11];
    return WebAssembly.validate(new Uint8Array(e2));
  }), has.add("esri-atomics", "Atomics" in globalThis), has.add("esri-workers", "Worker" in globalThis), has.add("web-feat:cache", "caches" in globalThis), has.add("esri-workers-arraybuffer-transfer", !has("safari") || Number(has("safari")) >= 12), has.add("featurelayer-simplify-thresholds", [0.5, 0.5, 0.5, 0.5]), has.add("featurelayer-simplify-payload-size-factors", [1, 1, 4]), has.add("featurelayer-snapshot-enabled", true), has.add("featurelayer-snapshot-point-min-threshold", 8e4), has.add("featurelayer-snapshot-point-max-threshold", 4e5), has.add("featurelayer-snapshot-point-coverage", 0.1), has.add("featurelayer-advanced-symbols", false), has.add("featurelayer-pbf", true), has.add("featurelayer-pbf-statistics", false), has.add("feature-layers-workers", true), has.add("feature-polyline-generalization-factor", 1), has.add("mapview-transitions-duration", 200), has.add("mapview-srswitch-adjust-rotation-scale-threshold", 24e6), has.add("mapserver-pbf-enabled", false), has.add("mapimagelayer-popup-identify-max-tolerance", 20), has.add("heatmap-allow-raster-fallback", true), has.add("heatmap-force-raster", false), has("host-webworker") || has("host-browser") && (has.add("esri-csp-restrictions", () => {
    try {
      new Function();
    } catch {
      return true;
    }
    return false;
  }), has.add("esri-image-decode", () => {
    if ("decode" in new Image()) {
      const e2 = new Image();
      return e2.src = 'data:image/svg+xml;charset=UTF-8,<svg version="1.1" xmlns="http://www.w3.org/2000/svg"></svg>', void e2.decode().then(() => {
        has.add("esri-image-decode", true, true, true);
      }).catch(() => {
        has.add("esri-image-decode", false, true, true);
      });
    }
    return false;
  }), has.add("esri-url-encodes-apostrophe", () => {
    const e2 = window.document.createElement("a");
    return e2.href = "?'", e2.href.includes("?%27");
  }));
})();
const n$2p = null;
function r$1t(n2) {
  return n2 != null;
}
function t$1W(n2) {
  return n2 == null;
}
function o$1Z(t2, u2) {
  return r$1t(t2) ? u2(t2) : n$2p;
}
function e$1U(n2) {
  return n2;
}
function f$1F(n2, r2) {
  return c$2W(n2, r2), n2;
}
function c$2W(n2, r2) {
  if (t$1W(n2))
    throw new Error(r2 != null ? r2 : "value is None");
}
function i$2y(n2, t2) {
  return r$1t(n2) ? n2 : typeof t2 == "function" ? t2() : t2;
}
function l$29(n2, t2) {
  return r$1t(n2) ? n2 : t2;
}
function s$26(n2) {
  return r$1t(n2) && n2.destroy(), null;
}
function a$2z(n2) {
  return r$1t(n2) && n2.dispose(), null;
}
function h$1s(n2) {
  return r$1t(n2) && n2.remove(), null;
}
function p$33(n2) {
  return r$1t(n2) && n2.abort(), null;
}
function w$R(n2) {
  return r$1t(n2) && n2.release(), null;
}
function y$1u(n2, t2, u2) {
  return r$1t(n2) && r$1t(t2) ? r$1t(u2) ? u2(n2, t2) : n2.equals(t2) : n2 === t2;
}
function d$1F(n2) {
  return null;
}
function A$u(n2, r2) {
  const t2 = new Array();
  for (const u2 of n2)
    t2.push(b$X(u2, null, r2));
  return t2;
}
function E$x(n2, r2) {
  for (const t2 of n2)
    o$1Z(t2, r2);
}
function b$X(n2, t2, u2) {
  return r$1t(n2) ? u2(n2) : t2;
}
function m$1U(n2) {
  return n2.filter((n3) => r$1t(n3));
}
function q$i(n2, ...r2) {
  let t2 = n2;
  for (let u2 = 0; u2 < r2.length && t2; ++u2)
    t2 = t2[r2[u2]];
  return t2;
}
function x$N(n2) {
  return n2;
}
class t$1V {
  constructor(t2 = 1) {
    this._seed = t2;
  }
  set seed(e2) {
    this._seed = e2 != null ? e2 : Math.random() * t$1V._m;
  }
  getInt() {
    return this._seed = (t$1V._a * this._seed + t$1V._c) % t$1V._m, this._seed;
  }
  getFloat() {
    return this.getInt() / (t$1V._m - 1);
  }
  getIntRange(t2, e2) {
    return Math.round(this.getFloatRange(t2, e2));
  }
  getFloatRange(e2, s2) {
    const n2 = s2 - e2;
    return e2 + this.getInt() / t$1V._m * n2;
  }
}
t$1V._m = 2147483647, t$1V._a = 48271, t$1V._c = 0;
function u$1Z(t2, n2) {
  return n2 ? t2.filter((t3, e2, r2) => r2.findIndex(n2.bind(null, t3)) === e2) : t2.filter((t3, n3, e2) => e2.indexOf(t3) === n3);
}
function i$2x(n2, e2, r2) {
  if (t$1W(n2) && t$1W(e2))
    return true;
  if (t$1W(n2) || t$1W(e2) || n2.length !== e2.length)
    return false;
  if (r2) {
    for (let t2 = 0; t2 < n2.length; t2++)
      if (!r2(n2[t2], e2[t2]))
        return false;
  } else
    for (let t2 = 0; t2 < n2.length; t2++)
      if (n2[t2] !== e2[t2])
        return false;
  return true;
}
function c$2V(t2, n2) {
  let e2 = t2.length !== n2.length;
  e2 && (t2.length = n2.length);
  for (let r2 = 0; r2 < n2.length; ++r2)
    t2[r2] !== n2[r2] && (t2[r2] = n2[r2], e2 = true);
  return e2;
}
function s$25(t2, n2, e2) {
  let r2, o2;
  return e2 ? (r2 = n2.filter((n3) => !t2.some((t3) => e2(t3, n3))), o2 = t2.filter((t3) => !n2.some((n3) => e2(n3, t3)))) : (r2 = n2.filter((n3) => !t2.includes(n3)), o2 = t2.filter((t3) => !n2.includes(t3))), { added: r2, removed: o2 };
}
function a$2y(t2) {
  return t2 && typeof t2.length == "number";
}
const d$1E = !!Array.prototype.fill;
function m$1T(t2, n2) {
  if (d$1E)
    return new Array(t2).fill(n2);
  const e2 = new Array(t2);
  for (let r2 = 0; r2 < t2; r2++)
    e2[r2] = n2;
  return e2;
}
function p$32(t2, n2) {
  n2 === void 0 && (n2 = t2, t2 = 0);
  const e2 = new Array(n2 - t2);
  for (let r2 = t2; r2 < n2; r2++)
    e2[r2 - t2] = r2;
  return e2;
}
class x$M {
  constructor() {
    this.last = 0;
  }
}
const y$1t = new x$M();
function b$W(t2, n2, e2, r2) {
  r2 = r2 || y$1t;
  const o2 = Math.max(0, r2.last - 10);
  for (let l2 = o2; l2 < e2; ++l2)
    if (t2[l2] === n2)
      return r2.last = l2, l2;
  const f2 = Math.min(o2, e2);
  for (let l2 = 0; l2 < f2; ++l2)
    if (t2[l2] === n2)
      return r2.last = l2, l2;
  return -1;
}
function v$W(t2, n2, e2, r2) {
  const o2 = e2 != null ? e2 : t2.length, f2 = b$W(t2, n2, o2, r2);
  if (f2 !== -1)
    return t2[f2] = t2[o2 - 1], e2 == null && t2.pop(), n2;
}
const A$t = new Set();
function j$Q(t2, n2, e2 = t2.length, r2 = n2.length, o2, f2) {
  if (r2 === 0 || e2 === 0)
    return e2;
  A$t.clear();
  for (let u2 = 0; u2 < r2; ++u2)
    A$t.add(n2[u2]);
  o2 = o2 || y$1t;
  const l2 = Math.max(0, o2.last - 10);
  for (let u2 = l2; u2 < e2; ++u2)
    if (A$t.has(t2[u2]) && (f2 && f2.push(t2[u2]), A$t.delete(t2[u2]), t2[u2] = t2[e2 - 1], --e2, --u2, A$t.size === 0 || e2 === 0))
      return A$t.clear(), e2;
  for (let u2 = 0; u2 < l2; ++u2)
    if (A$t.has(t2[u2]) && (f2 && f2.push(t2[u2]), A$t.delete(t2[u2]), t2[u2] = t2[e2 - 1], --e2, --u2, A$t.size === 0 || e2 === 0))
      return A$t.clear(), e2;
  return A$t.clear(), e2;
}
new t$1V();
function C$s(t2, n2) {
  const e2 = t2.indexOf(n2);
  return e2 !== -1 ? (t2.splice(e2, 1), n2) : null;
}
function n$2o(r2, n2) {
  if (r2.forEach)
    r2.forEach(n2);
  else
    for (let t2 = 0; t2 < r2.length; t2++)
      n2(r2[t2], t2, r2);
}
function t$1U(r2, n2, t2) {
  if (r2.slice)
    return r2.slice(n2, t2);
  n2 === void 0 ? n2 = 0 : (n2 < 0 && (n2 += r2.length), n2 = Math.min(r2.length, Math.max(0, n2))), t2 === void 0 ? t2 = r2.length : (t2 < 0 && (t2 += r2.length), t2 = Math.min(r2.length, Math.max(0, t2)));
  const o2 = Math.max(0, t2 - n2), c2 = new r2.constructor(o2);
  for (let e2 = 0; e2 < o2; e2++)
    c2[e2] = r2[n2 + e2];
  return c2;
}
function o$1Y(r2) {
  return r2 instanceof ArrayBuffer || r2 && r2.constructor && r2.constructor.name === "ArrayBuffer";
}
function c$2U(r2) {
  return r2 instanceof Int8Array || r2 && r2.constructor && r2.constructor.name === "Int8Array";
}
function e$1T(r2) {
  return r2 instanceof Uint8Array || r2 && r2.constructor && r2.constructor.name === "Uint8Array";
}
function a$2x(r2) {
  return r2 instanceof Uint8ClampedArray || r2 && r2.constructor && r2.constructor.name === "Uint8ClampedArray";
}
function u$1Y(r2) {
  return r2 instanceof Int16Array || r2 && r2.constructor && r2.constructor.name === "Int16Array";
}
function i$2w(r2) {
  return r2 instanceof Uint16Array || r2 && r2.constructor && r2.constructor.name === "Uint16Array";
}
function f$1E(r2) {
  return r2 instanceof Int32Array || r2 && r2.constructor && r2.constructor.name === "Int32Array";
}
function s$24(r2) {
  return r2 instanceof Uint32Array || r2 && r2.constructor && r2.constructor.name === "Uint32Array";
}
function y$1s(r2) {
  return r2 instanceof Float32Array || r2 && r2.constructor && r2.constructor.name === "Float32Array";
}
function A$s(r2) {
  return r2 instanceof Float64Array || r2 && r2.constructor && r2.constructor.name === "Float64Array";
}
function p$31(t2, n2) {
  let e2;
  if (n2)
    for (e2 in t2)
      t2.hasOwnProperty(e2) && (t2[e2] === void 0 ? delete t2[e2] : t2[e2] instanceof Object && p$31(t2[e2], true));
  else
    for (e2 in t2)
      t2.hasOwnProperty(e2) && t2[e2] === void 0 && delete t2[e2];
  return t2;
}
function y$1r(t2) {
  if (!t2 || typeof t2 != "object" || typeof t2 == "function")
    return t2;
  const e2 = h$1r(t2);
  if (r$1t(e2))
    return e2;
  if (b$V(t2))
    return t2.clone();
  if (g$17(t2))
    return t2.map(y$1r);
  if (O$p(t2))
    return t2.clone();
  const r2 = {};
  for (const n2 of Object.getOwnPropertyNames(t2))
    r2[n2] = y$1r(t2[n2]);
  return r2;
}
function m$1S(t2) {
  if (!t2 || typeof t2 != "object" || typeof t2 == "function" || "HTMLElement" in globalThis && t2 instanceof HTMLElement)
    return t2;
  const e2 = h$1r(t2);
  if (r$1t(e2))
    return e2;
  if (g$17(t2)) {
    let n2 = true;
    const e3 = t2.map((t3) => {
      const e4 = m$1S(t3);
      return t3 != null && e4 == null && (n2 = false), e4;
    });
    return n2 ? e3 : null;
  }
  if (b$V(t2))
    return t2.clone();
  if (!O$p(t2)) {
    const n2 = new (Object.getPrototypeOf(t2)).constructor();
    for (const e3 of Object.getOwnPropertyNames(t2)) {
      const r2 = t2[e3], o2 = m$1S(r2);
      if (r2 != null && o2 == null)
        return null;
      n2[e3] = o2;
    }
    return n2;
  }
  return null;
}
function b$V(t2) {
  return typeof t2.clone == "function";
}
function g$17(t2) {
  return typeof t2.map == "function" && typeof t2.forEach == "function";
}
function O$p(t2) {
  return typeof t2.notifyChange == "function" && typeof t2.watch == "function";
}
function j$P(t2) {
  if (Object.prototype.toString.call(t2) !== "[object Object]")
    return false;
  const n2 = Object.getPrototypeOf(t2);
  return n2 === null || n2 === Object.prototype;
}
function h$1r(t2) {
  if (c$2U(t2) || e$1T(t2) || a$2x(t2) || u$1Y(t2) || i$2w(t2) || f$1E(t2) || s$24(t2) || y$1s(t2) || A$s(t2))
    return t$1U(t2);
  if (t2 instanceof Date)
    return new Date(t2.getTime());
  if (t2 instanceof ArrayBuffer) {
    return t2.slice(0, t2.byteLength);
  }
  if (t2 instanceof Map) {
    const n2 = new Map();
    for (const [e2, r2] of t2)
      n2.set(e2, y$1r(r2));
    return n2;
  }
  if (t2 instanceof Set) {
    const n2 = new Set();
    for (const e2 of t2)
      n2.add(y$1r(e2));
    return n2;
  }
  return null;
}
function w$Q(t2, n2) {
  return t2 === n2 || typeof t2 == "number" && isNaN(t2) && typeof n2 == "number" && isNaN(n2) || typeof (t2 || {}).getTime == "function" && typeof (n2 || {}).getTime == "function" && t2.getTime() === n2.getTime() || false;
}
function N$i(n2, e2) {
  return n2 === e2 || (n2 == null || typeof n2 == "string" ? n2 === e2 : typeof n2 == "number" ? n2 === e2 || typeof e2 == "number" && isNaN(n2) && isNaN(e2) : n2 instanceof Date ? e2 instanceof Date && n2.getTime() === e2.getTime() : Array.isArray(n2) ? Array.isArray(e2) && i$2x(n2, e2) : n2 instanceof Set ? e2 instanceof Set && d$1D(n2, e2) : n2 instanceof Map ? e2 instanceof Map && P$r(n2, e2) : !!j$P(n2) && (j$P(e2) && T$s(n2, e2)));
}
function T$s(t2, n2) {
  if (t2 === null || n2 === null)
    return false;
  const e2 = Object.keys(t2);
  if (n2 === null || Object.keys(n2).length !== e2.length)
    return false;
  for (const r2 of e2)
    if (t2[r2] !== n2[r2] || !Object.prototype.hasOwnProperty.call(n2, r2))
      return false;
  return true;
}
function d$1D(t2, n2) {
  if (t2.size !== n2.size)
    return false;
  for (const e2 of t2)
    if (!n2.has(e2))
      return false;
  return true;
}
function P$r(t2, n2) {
  if (t2.size !== n2.size)
    return false;
  for (const [e2, r2] of t2) {
    const t3 = n2.get(e2);
    if (t3 !== r2 || t3 === void 0 && !n2.has(e2))
      return false;
  }
  return true;
}
function n$2n(r2, n2, t2 = false) {
  return i$2v(r2, n2, t2);
}
function t$1T(r2, n2) {
  if (n2 != null)
    return n2[r2] || e$1S(r2.split("."), false, n2);
}
function o$1X(r2, n2, t2) {
  const o2 = r2.split("."), i2 = o2.pop(), u2 = e$1S(o2, true, t2);
  u2 && i2 && (u2[i2] = n2);
}
function e$1S(r2, n2, t2) {
  let o2 = t2;
  for (const e2 of r2) {
    if (o2 == null)
      return;
    if (!(e2 in o2)) {
      if (!n2)
        return;
      o2[e2] = {};
    }
    o2 = o2[e2];
  }
  return o2;
}
function i$2v(n2, t2, o2) {
  return t2 ? Object.keys(t2).reduce((n3, e2) => {
    let u2 = n3[e2], c2 = t2[e2];
    return u2 === c2 ? n3 : u2 === void 0 ? (n3[e2] = y$1r(c2), n3) : (Array.isArray(c2) || Array.isArray(n3) ? (u2 = u2 ? Array.isArray(u2) ? n3[e2] = u2.concat() : n3[e2] = [u2] : n3[e2] = [], c2 && (Array.isArray(c2) || (c2 = [c2]), o2 ? c2.forEach((r2) => {
      u2.includes(r2) || u2.push(r2);
    }) : n3[e2] = c2.concat())) : c2 && typeof c2 == "object" ? n3[e2] = i$2v(u2, c2, o2) : n3.hasOwnProperty(e2) && !t2.hasOwnProperty(e2) || (n3[e2] = c2), n3);
  }, n2 || {}) : n2;
}
const s$23 = { analysisTheme: { accentColor: [255, 128, 0], textColor: "white" }, apiKey: void 0, applicationUrl: (_e2 = globalThis.location) == null ? void 0 : _e2.href, assetsPath: "", fontsUrl: "https://static.arcgis.com/fonts", geometryServiceUrl: "https://utility.arcgisonline.com/arcgis/rest/services/Geometry/GeometryServer", geoRSSServiceUrl: "https://utility.arcgis.com/sharing/rss", kmlServiceUrl: "https://utility.arcgis.com/sharing/kml", portalUrl: "https://www.arcgis.com", routeServiceUrl: "https://route-api.arcgis.com/arcgis/rest/services/World/Route/NAServer/Route_World", workers: { loaderConfig: { has: {}, paths: {}, map: {}, packages: [] } }, request: { crossOriginNoCorsDomains: null, httpsDomains: ["arcgis.com", "arcgisonline.com", "esrikr.com", "premiumservices.blackbridge.com", "esripremium.accuweather.com", "gbm.digitalglobe.com", "firstlook.digitalglobe.com", "msi.digitalglobe.com"], interceptors: [], maxUrlLength: 2e3, priority: "high", proxyRules: [], proxyUrl: null, timeout: 6e4, trustedServers: [], useIdentity: true }, log: { interceptors: [], level: null } };
if (globalThis.esriConfig && (n$2n(s$23, globalThis.esriConfig, true), delete s$23.has), !s$23.assetsPath) {
  {
    const e2 = "4.25.5";
    s$23.assetsPath = `https://js.arcgis.com/${e2.slice(0, -2)}/@arcgis/core/assets`;
  }
  s$23.defaultAssetsPath = s$23.assetsPath;
}
const e$1R = /\{([^\}]+)\}/g;
function r$1s(t2) {
  return t2 != null ? t2 : "";
}
function n$2m(n2, o2) {
  return n2.replace(e$1R, typeof o2 == "object" ? (e2, n3) => r$1s(t$1T(n3, o2)) : (t2, e2) => r$1s(o2(e2)));
}
function o$1W(t2, e2) {
  return t2.replace(/([\.$?*|{}\(\)\[\]\\\/\+\-^])/g, (t3) => e2 && e2.includes(t3) ? t3 : `\\${t3}`);
}
function c$2T(t2) {
  let e2 = 0;
  for (let r2 = 0; r2 < t2.length; r2++)
    e2 = (e2 << 5) - e2 + t2.charCodeAt(r2), e2 |= 0;
  return e2;
}
function u$1X(t2) {
  return new DOMParser().parseFromString(t2 || "", "text/html").body.innerText || "";
}
const o$1V = { info: 0, warn: 1, error: 2, none: 3 };
class s$22 {
  constructor(e2) {
    this.level = null, this._module = "", this._parent = null, this.writer = null, this._loggedMessages = { error: new Map(), warn: new Map(), info: new Map() }, e2.level != null && (this.level = e2.level), e2.writer != null && (this.writer = e2.writer), this._module = e2.module, s$22._loggers[this.module] = this;
    const t2 = this.module.lastIndexOf(".");
    t2 !== -1 && (this._parent = s$22.getLogger(this.module.slice(0, t2)));
  }
  get module() {
    return this._module;
  }
  get parent() {
    return this._parent;
  }
  error(...e2) {
    this._log("error", "always", ...e2);
  }
  warn(...e2) {
    this._log("warn", "always", ...e2);
  }
  info(...e2) {
    this._log("info", "always", ...e2);
  }
  errorOnce(...e2) {
    this._log("error", "once", ...e2);
  }
  warnOnce(...e2) {
    this._log("warn", "once", ...e2);
  }
  infoOnce(...e2) {
    this._log("info", "once", ...e2);
  }
  errorOncePerTick(...e2) {
    this._log("error", "oncePerTick", ...e2);
  }
  warnOncePerTick(...e2) {
    this._log("warn", "oncePerTick", ...e2);
  }
  infoOncePerTick(...e2) {
    this._log("info", "oncePerTick", ...e2);
  }
  get test() {
    const e2 = this;
    return { loggedMessages: e2._loggedMessages, clearLoggedWarnings: () => e2._loggedMessages.warn.clear() };
  }
  static get testSingleton() {
    return { resetLoggers(e2 = {}) {
      const t2 = s$22._loggers;
      return s$22._loggers = e2, t2;
    }, set throttlingDisabled(e2) {
      s$22._throttlingDisabled = e2;
    } };
  }
  static getLogger(e2) {
    let t2 = s$22._loggers[e2];
    return t2 || (t2 = new s$22({ module: e2 })), t2;
  }
  _log(t2, r2, ...o2) {
    if (!this._matchLevel(t2))
      return;
    if (r2 !== "always" && !s$22._throttlingDisabled) {
      const e2 = this._argsToKey(o2), n2 = this._loggedMessages[t2].get(e2);
      if (r2 === "once" && n2 != null || r2 === "oncePerTick" && n2 && n2 >= s$22._tickCounter)
        return;
      this._loggedMessages[t2].set(e2, s$22._tickCounter), s$22._scheduleTickCounterIncrement();
    }
    for (const s2 of s$23.log.interceptors)
      if (s2(t2, this.module, ...o2))
        return;
    this._inheritedWriter()(t2, this.module, ...o2);
  }
  _parentWithMember(e2, r2) {
    let o2 = this;
    for (; r$1t(o2); ) {
      const r3 = o2[e2];
      if (r$1t(r3))
        return r3;
      o2 = o2.parent;
    }
    return r2;
  }
  _inheritedWriter() {
    return this._parentWithMember("writer", this._consoleWriter);
  }
  _consoleWriter(e2, t2, ...r2) {
    console[e2](`[${t2}]`, ...r2);
  }
  _matchLevel(t2) {
    const r2 = s$23.log.level ? s$23.log.level : "warn";
    return o$1V[this._parentWithMember("level", r2)] <= o$1V[t2];
  }
  _argsToKey(...e2) {
    const t2 = (e3, t3) => typeof t3 != "object" || Array.isArray(t3) ? t3 : "[Object]";
    return c$2T(JSON.stringify(e2, t2));
  }
  static _scheduleTickCounterIncrement() {
    s$22._tickCounterScheduled || (s$22._tickCounterScheduled = true, Promise.resolve().then(() => {
      s$22._tickCounter++, s$22._tickCounterScheduled = false;
    }));
  }
}
s$22._loggers = {}, s$22._tickCounter = 0, s$22._tickCounterScheduled = false, s$22._throttlingDisabled = false;
function n$2l(n2, t2) {
  for (const [r2, o2] of n2)
    if (t2(o2, r2))
      return true;
  return false;
}
function r$1r(n2, t2, r2) {
  const o2 = n2.get(t2);
  if (o2 !== void 0)
    return o2;
  const u2 = r2();
  return n2.set(t2, u2), u2;
}
const r$1q = s$22.getLogger("esri.core.accessorSupport.ensureTypes");
function t$1S(e2) {
  return e2 == null ? e2 : new Date(e2);
}
function o$1U(e2) {
  return e2 == null ? e2 : !!e2;
}
function u$1W(e2) {
  return e2 == null ? e2 : e2.toString();
}
function a$2w(e2) {
  return e2 == null ? e2 : (e2 = parseFloat(e2), isNaN(e2) ? 0 : e2);
}
function s$21(e2) {
  return e2 == null ? e2 : Math.round(parseFloat(e2));
}
function i$2u(e2) {
  return e2 && e2.constructor && e2.constructor.__accessorMetadata__ !== void 0;
}
function l$28(e2, n2) {
  return n2 != null && e2 && !(n2 instanceof e2);
}
function c$2S(e2) {
  return e2 && "isCollection" in e2;
}
function f$1D(e2) {
  return e2 && e2.Type ? typeof e2.Type == "function" ? e2.Type : e2.Type.base : null;
}
function p$30(e2, n2) {
  if (!n2 || !n2.constructor || !c$2S(n2.constructor))
    return y$1q(e2, n2) ? n2 : new e2(n2);
  const r2 = f$1D(e2.prototype.itemType), t2 = f$1D(n2.constructor.prototype.itemType);
  return r2 ? t2 ? r2 === t2 ? n2 : r2.prototype.isPrototypeOf(t2.prototype) ? new e2(n2) : (y$1q(e2, n2), n2) : new e2(n2) : n2;
}
function y$1q(e2, n2) {
  return !!i$2u(n2) && (r$1q.error("Accessor#set", "Assigning an instance of '" + (n2.declaredClass || "unknown") + "' which is not a subclass of '" + g$16(e2) + "'"), true);
}
function v$V(e2, n2) {
  return n2 == null ? n2 : c$2S(e2) ? p$30(e2, n2) : l$28(e2, n2) ? y$1q(e2, n2) ? n2 : new e2(n2) : n2;
}
function g$16(e2) {
  return e2 && e2.prototype && e2.prototype.declaredClass || "unknown";
}
const d$1C = new WeakMap();
function h$1q(e2) {
  switch (e2) {
    case Number:
      return a$2w;
    case T$r:
      return s$21;
    case Boolean:
      return o$1U;
    case String:
      return u$1W;
    case Date:
      return t$1S;
    default:
      return r$1r(d$1C, e2, () => v$V.bind(null, e2));
  }
}
function b$U(e2, n2) {
  const r2 = h$1q(e2);
  return arguments.length === 1 ? r2 : r2(n2);
}
function m$1R(e2, n2, r2) {
  return arguments.length === 1 ? m$1R.bind(null, e2) : n2 ? Array.isArray(n2) ? n2.map((n3) => e2(n3, r2)) : [e2(n2, r2)] : n2;
}
function w$P(e2, n2) {
  return arguments.length === 1 ? m$1R(b$U.bind(null, e2)) : m$1R(b$U.bind(null, e2), n2);
}
function A$r(e2, n2, r2) {
  return n2 !== 0 && Array.isArray(r2) ? r2.map((r3) => A$r(e2, n2 - 1, r3)) : e2(r2);
}
function $$g(e2, n2, r2) {
  if (arguments.length === 2)
    return $$g.bind(null, e2, n2);
  if (!r2)
    return r2;
  let t2 = n2, o2 = r2 = A$r(e2, n2, r2);
  for (; t2 > 0 && Array.isArray(o2); )
    t2--, o2 = o2[0];
  if (o2 !== void 0)
    for (let u2 = 0; u2 < t2; u2++)
      r2 = [r2];
  return r2;
}
function j$O(e2, n2, r2) {
  return arguments.length === 2 ? $$g(b$U.bind(null, e2), n2) : $$g(b$U.bind(null, e2), n2, r2);
}
function k$u(e2) {
  return !!Array.isArray(e2) && !e2.some((n2) => {
    const r2 = typeof n2;
    return !(r2 === "string" || r2 === "number" || r2 === "function" && e2.length > 1);
  });
}
function M$u(e2, n2) {
  if (arguments.length === 2)
    return M$u(e2).call(null, n2);
  const t2 = new Set(), o2 = e2.filter((e3) => typeof e3 != "function"), u2 = e2.filter((e3) => typeof e3 == "function");
  for (const r2 of e2)
    typeof r2 != "string" && typeof r2 != "number" || t2.add(r2);
  let a2 = null, s2 = null;
  return (e3, n3) => {
    if (e3 == null)
      return e3;
    const i2 = typeof e3, c2 = i2 === "string" || i2 === "number";
    return c2 && (t2.has(e3) || u2.some((e4) => i2 === "string" && e4 === String || i2 === "number" && e4 === Number)) || i2 === "object" && u2.some((n4) => !l$28(e3, n4)) ? e3 : (c2 && o2.length ? (a2 || (a2 = o2.map((e4) => typeof e4 == "string" ? `'${e4}'` : `${e4}`).join(", ")), r$1q.error("Accessor#set", `'${e3}' is not a valid value for this property, only the following values are valid: ${a2}`)) : typeof e3 == "object" && u2.length ? (s2 || (s2 = u2.map((e4) => g$16(e4)).join(", ")), r$1q.error("Accessor#set", `'${e3}' is not a valid value for this property, value must be one of ${s2}`)) : r$1q.error("Accessor#set", `'${e3}' is not a valid value for this property`), n3 && (n3.valid = false), null);
  };
}
function S$H(e2, n2) {
  if (arguments.length === 2)
    return S$H(e2).call(null, n2);
  const t2 = {}, o2 = [], u2 = [];
  for (const r2 in e2.typeMap) {
    const n3 = e2.typeMap[r2];
    t2[r2] = b$U(n3), o2.push(g$16(n3)), u2.push(r2);
  }
  const a2 = () => `'${o2.join("', '")}'`, s2 = () => `'${u2.join("', '")}'`, c2 = typeof e2.key == "string" ? (n3) => n3[e2.key] : e2.key;
  return (n3) => {
    if (e2.base && !l$28(e2.base, n3))
      return n3;
    if (n3 == null)
      return n3;
    const o3 = c2(n3) || e2.defaultKeyValue, u3 = t2[o3];
    if (!u3)
      return r$1q.error("Accessor#set", `Invalid property value, value needs to be one of ${a2()}, or a plain object that can autocast (having .type = ${s2()})`), null;
    if (!l$28(e2.typeMap[o3], n3))
      return n3;
    if (typeof e2.key == "string" && !i$2u(n3)) {
      const r2 = {};
      for (const t3 in n3)
        t3 !== e2.key && (r2[t3] = n3[t3]);
      return u3(r2);
    }
    return u3(n3);
  };
}
class T$r {
}
const N$h = { native: (e2) => ({ type: "native", value: e2 }), array: (e2) => ({ type: "array", value: e2 }), oneOf: (e2) => ({ type: "one-of", values: e2 }) };
function _$E(e2) {
  if (!e2 || !("type" in e2))
    return false;
  switch (e2.type) {
    case "native":
    case "array":
    case "one-of":
      return true;
  }
  return false;
}
function B$l(e2) {
  switch (e2.type) {
    case "native":
      return b$U(e2.value);
    case "array":
      return m$1R(B$l(e2.value));
    case "one-of":
      return C$r(e2);
    default:
      return null;
  }
}
function C$r(e2) {
  let n2 = null;
  return (t2, o2) => F$l(t2, e2) ? t2 : (n2 == null && (n2 = D$t(e2)), r$1q.error("Accessor#set", `Invalid property value, value needs to be of type ${n2}`), o2 && (o2.valid = false), null);
}
function D$t(e2) {
  switch (e2.type) {
    case "native":
      switch (e2.value) {
        case Number:
          return "number";
        case String:
          return "string";
        case Boolean:
          return "boolean";
        case T$r:
          return "integer";
        case Date:
          return "date";
        default:
          return g$16(e2.value);
      }
    case "array":
      return `array of ${D$t(e2.value)}`;
    case "one-of": {
      const n2 = e2.values.map((e3) => D$t(e3));
      return `one of ${n2.slice(0, n2.length - 1)} or ${n2[n2.length - 1]}`;
    }
  }
  return "unknown";
}
function F$l(e2, n2) {
  if (e2 == null)
    return true;
  switch (n2.type) {
    case "native":
      switch (n2.value) {
        case Number:
        case T$r:
          return typeof e2 == "number";
        case Boolean:
          return typeof e2 == "boolean";
        case String:
          return typeof e2 == "string";
      }
      return e2 instanceof n2.value;
    case "array":
      return !!Array.isArray(e2) && !e2.some((e3) => !F$l(e3, n2.value));
    case "one-of":
      return n2.values.some((n3) => F$l(e2, n3));
  }
}
function r$1p(r2) {
  return n$2k(() => r2.forEach((r3) => r$1t(r3) && r3.remove()));
}
function n$2k(e2) {
  return { remove: () => {
    e2 && (e2(), e2 = void 0);
  } };
}
function e$1Q(r2) {
  return r2 ? r2.__accessor__ ? r2.__accessor__ : r2.propertyInvalidated ? r2 : null : null;
}
function i$2t(r2, n2) {
  return r2 != null && r2.metadatas && r2.metadatas[n2] != null;
}
function o$1T(r2, n2, t2) {
  if (t2) {
    return l$27(r2, n2, { policy: t2, path: "" });
  }
  return l$27(r2, n2, null);
}
function l$27(r2, e2, i2) {
  return e2 ? Object.keys(e2).reduce((r3, u2) => {
    let o2 = null, a2 = "merge";
    if (i2 && (o2 = i2.path ? `${i2.path}.${u2}` : u2, a2 = i2.policy(o2)), a2 === "replace")
      return r3[u2] = e2[u2], r3;
    if (r3[u2] === void 0)
      return r3[u2] = y$1r(e2[u2]), r3;
    let s2 = r3[u2], c2 = e2[u2];
    if (s2 === c2)
      return r3;
    if (Array.isArray(c2) || Array.isArray(r3))
      s2 = s2 ? Array.isArray(s2) ? r3[u2] = s2.concat() : r3[u2] = [s2] : r3[u2] = [], c2 && (Array.isArray(c2) || (c2 = [c2]), c2.forEach((r4) => {
        s2.includes(r4) || s2.push(r4);
      }));
    else if (c2 && typeof c2 == "object")
      if (i2) {
        const n2 = i2.path;
        i2.path = x$N(o2), r3[u2] = l$27(s2, c2, i2), i2.path = n2;
      } else
        r3[u2] = l$27(s2, c2, null);
    else
      r3.hasOwnProperty(u2) && !e2.hasOwnProperty(u2) || (r3[u2] = c2);
    return r3;
  }, r2 || {}) : r2;
}
function s$20(r2) {
  return Array.isArray(r2) ? r2 : r2.split(".");
}
function c$2R(r2) {
  return r2.includes(",") ? r2.split(",").map((r3) => r3.trim()) : [r2.trim()];
}
function f$1C(r2) {
  if (Array.isArray(r2)) {
    const n2 = [];
    for (const t2 of r2)
      n2.push(...c$2R(t2));
    return n2;
  }
  return c$2R(r2);
}
function y$1p(n2, t2, e2, i2) {
  const u2 = f$1C(t2);
  if (u2.length !== 1) {
    const t3 = u2.map((r2) => i2(n2, r2, e2));
    return r$1p(t3);
  }
  return i2(n2, u2[0], e2);
}
function h$1p(r2) {
  let n2 = false;
  return () => {
    n2 || (n2 = true, r2());
  };
}
function e$1P(t2, e2) {
  const i2 = t2[t2.length - 1] === "?" ? t2.slice(0, -1) : t2;
  if (e2.getItemAt != null || Array.isArray(e2)) {
    const t3 = parseInt(i2, 10);
    if (!isNaN(t3))
      return Array.isArray(e2) ? e2[t3] : e2.getItemAt(t3);
  }
  const u2 = e$1Q(e2);
  return i$2t(u2, i2) ? u2.get(i2) : e2[i2];
}
function i$2s(t2, n2, r2) {
  if (t2 == null)
    return t2;
  const u2 = e$1P(n2[r2], t2);
  return !u2 && r2 < n2.length - 1 ? void 0 : r2 === n2.length - 1 ? u2 : i$2s(u2, n2, r2 + 1);
}
function u$1V(n2, r2, u2 = 0) {
  return typeof r2 != "string" || r2.includes(".") ? i$2s(n2, s$20(r2), u2) : e$1P(r2, n2);
}
function o$1S(t2, n2) {
  return u$1V(t2, n2);
}
function s$1$(t2, n2) {
  return u$1V(n2, t2) !== void 0;
}
class o$1R {
  constructor(t2) {
    this.autoDestroy = false, this.properties = t2;
  }
}
function n$2j(r2) {
  let n2 = r2.constructor.__accessorMetadata__;
  const c2 = Object.prototype.hasOwnProperty.call(r2.constructor, "__accessorMetadata__");
  if (n2) {
    if (!c2) {
      const e2 = Object.create(n2.properties), c3 = n2.autoDestroy;
      for (const r3 in e2)
        e2[r3] = y$1r(e2[r3]);
      n2 = new o$1R(e2), n2.autoDestroy = c3, Object.defineProperty(r2.constructor, "__accessorMetadata__", { value: n2, enumerable: false, configurable: true, writable: true });
    }
  } else
    n2 = new o$1R({}), Object.defineProperty(r2.constructor, "__accessorMetadata__", { value: n2, enumerable: false, configurable: true, writable: true });
  return x$N(r2.constructor.__accessorMetadata__);
}
function c$2Q(t2) {
  return n$2j(t2).properties;
}
function s$1_(t2, e2) {
  const r2 = c$2Q(t2);
  let o2 = r2[e2];
  return o2 || (o2 = r2[e2] = {}), o2;
}
function i$2r(t2, e2) {
  return o$1T(t2, e2, _$D);
}
const p$2$ = /^(?:[^.]+\.)?(?:value|type|(?:json\.type|json\.origins\.[^.]\.type))$/;
function _$D(t2) {
  return p$2$.test(t2) ? "replace" : "merge";
}
function e$1O(e2, r2) {
  return e2.replace(/\$\{([^\s\:\}]*)(?:\:([^\s\:\}]+))?\}/g, (e3, s2) => {
    if (s2 === "")
      return "$";
    const n2 = t$1T(s2, r2), i2 = n2 != null ? n2 : "";
    if (i2 === void 0)
      throw new Error(`could not find key "${s2}" in template`);
    return i2.toString();
  });
}
class r$1o {
  constructor(t2, s2, n2) {
    var _a2;
    this.name = t2, this.details = n2, this instanceof r$1o && (this.message = (_a2 = s2 && e$1O(s2, n2)) != null ? _a2 : "");
  }
  toString() {
    return "[" + this.name + "]: " + this.message;
  }
}
class s$1Z extends r$1o {
  constructor(e2, t2, r2) {
    if (super(e2, t2, r2), !(this instanceof s$1Z))
      return new s$1Z(e2, t2, r2);
  }
  toJSON() {
    if (this.details != null)
      try {
        return { name: this.name, message: this.message, details: JSON.parse(JSON.stringify(this.details, (t2, r2) => {
          if (r2 && typeof r2 == "object" && typeof r2.toJSON == "function")
            return r2;
          try {
            return y$1r(r2);
          } catch (s2) {
            return "[object]";
          }
        })) };
      } catch (r2) {
        throw s$22.getLogger("esri.core.Error").error(r2), r2;
      }
    return { name: this.name, message: this.message, details: this.details };
  }
  static fromJSON(e2) {
    return new s$1Z(e2.name, e2.message, e2.details);
  }
}
s$1Z.prototype.type = "error";
function t$1R(o2, e2, s2) {
  if (o2 && e2)
    if (typeof e2 == "object")
      for (const r2 of Object.getOwnPropertyNames(e2))
        t$1R(o2, r2, e2[r2]);
    else {
      if (e2.includes(".")) {
        const n2 = e2.split("."), i3 = n2.splice(n2.length - 1, 1)[0];
        return void t$1R(o$1S(o2, n2), i3, s2);
      }
      const i2 = o2.__accessor__;
      i2 != null && n$2i(e2, i2), o2[e2] = s2;
    }
}
function n$2i(r2, t2) {
  if (has("esri-unknown-property-errors") && !e$1N(r2, t2))
    throw new s$1Z("set:unknown-property", s$1Y(r2, t2));
}
function e$1N(o2, r2) {
  return r2.metadatas[o2] != null;
}
function s$1Y(o2, r2) {
  return "setting unknown property '" + o2 + "' on instance of " + r2.host.declaredClass;
}
function y$1o(n2 = {}) {
  return (o2, s2) => {
    if (o2 === Function.prototype)
      throw new Error(`Inappropriate use of @property() on a static field: ${o2.name}.${s2}. Accessor does not support static properties.`);
    const i2 = Object.getOwnPropertyDescriptor(o2, s2), a2 = s$1_(o2, s2);
    i2 && (i2.get || i2.set ? (a2.get = i2.get || a2.get, a2.set = i2.set || a2.set) : "value" in i2 && ("value" in n2 && s$22.getLogger("esri.core.accessorSupport.decorators.property").warn(`@property() will redefine the value of "${s2}" on "${o2.constructor.name}" already defined in the metadata`, n2), a2.value = n2.value = i2.value)), n2.readOnly != null && (a2.readOnly = n2.readOnly);
    const p2 = n2.aliasOf;
    if (p2) {
      const t2 = typeof p2 == "string" ? p2 : p2.source, e2 = typeof p2 == "string" ? null : p2.overridable === true;
      let r2;
      a2.dependsOn = [t2], a2.get = function() {
        let e3 = o$1S(this, t2);
        if (typeof e3 == "function") {
          r2 || (r2 = t2.split(".").slice(0, -1).join("."));
          const n3 = o$1S(this, r2);
          n3 && (e3 = e3.bind(n3));
        }
        return e3;
      }, a2.readOnly || (a2.set = e2 ? function(t3) {
        this._override(s2, t3);
      } : function(e3) {
        t$1R(this, t2, e3);
      });
    }
    const u2 = n2.type, c2 = n2.types;
    a2.cast || (u2 ? a2.cast = h$1o(u2) : c2 && (Array.isArray(c2) ? a2.cast = m$1R(S$H(c2[0])) : a2.cast = S$H(c2))), i$2r(a2, n2), n2.range && (a2.cast = j$N(a2.cast, n2.range));
  };
}
function d$1B(t2, e2, r2) {
  const n2 = s$1_(t2, r2);
  n2.json || (n2.json = {});
  let o2 = n2.json;
  return e2 !== void 0 && (o2.origins || (o2.origins = {}), o2.origins[e2] || (o2.origins[e2] = {}), o2 = o2.origins[e2]), o2;
}
function h$1o(t2) {
  let e2 = 0, r2 = t2;
  if (_$E(t2))
    return B$l(t2);
  for (; Array.isArray(r2) && r2.length === 1 && typeof r2[0] != "string" && typeof r2[0] != "number"; )
    r2 = r2[0], e2++;
  const f2 = r2;
  if (k$u(f2))
    return e2 === 0 ? M$u(f2) : $$g(M$u(f2), e2);
  if (e2 === 1)
    return w$P(f2);
  if (e2 > 1)
    return j$O(f2, e2);
  const l2 = t2;
  return l2.from ? l2.from : b$U(l2);
}
function j$N(t2, e2) {
  return (r2) => {
    let n2 = +t2(r2);
    return e2.step != null && (n2 = Math.round(n2 / e2.step) * e2.step), e2.min != null && (n2 = Math.max(e2.min, n2)), e2.max != null && (n2 = Math.min(e2.max, n2)), n2;
  };
}
var I$x;
!function(I2) {
  I2[I2.INITIALIZING = 0] = "INITIALIZING", I2[I2.CONSTRUCTING = 1] = "CONSTRUCTING", I2[I2.CONSTRUCTED = 2] = "CONSTRUCTED";
}(I$x || (I$x = {}));
var i$2q;
!function(i2) {
  i2[i2.Dirty = 1] = "Dirty", i2[i2.Overriden = 2] = "Overriden", i2[i2.Computing = 4] = "Computing", i2[i2.NonNullable = 8] = "NonNullable", i2[i2.HasDefaultValue = 16] = "HasDefaultValue", i2[i2.DepTrackingInitialized = 32] = "DepTrackingInitialized", i2[i2.AutoTracked = 64] = "AutoTracked", i2[i2.ExplicitlyTracking = 128] = "ExplicitlyTracking";
}(i$2q || (i$2q = {}));
const o$1Q = { onObservableAccessed: () => {
}, onTrackingEnd: () => {
} }, c$2P = [];
let i$2p = o$1Q;
function s$1X(t2) {
  i$2p.onObservableAccessed(t2);
}
let l$26 = false, a$2v = false;
function f$1B(t2, n2, e2) {
  if (l$26)
    return u$1U(t2, n2, e2);
  p$2_(t2);
  const r2 = n2.call(e2);
  return d$1A(), r2;
}
function g$15(t2, n2) {
  return f$1B(o$1Q, t2, n2);
}
function u$1U(n2, e2, r2) {
  const o2 = l$26;
  l$26 = true, p$2_(n2);
  let c2 = null;
  try {
    c2 = e2.call(r2);
  } catch (i2) {
    a$2v && s$22.getLogger("esri.core.accessorSupport.tracking").error(i2);
  }
  return d$1A(), l$26 = o2, c2;
}
function p$2_(t2) {
  i$2p = t2, c$2P.push(t2);
}
function d$1A() {
  const t2 = c$2P.length;
  if (t2 > 1) {
    const n2 = c$2P.pop();
    i$2p = c$2P[t2 - 2], n2.onTrackingEnd();
  } else if (t2 === 1) {
    const t3 = c$2P.pop();
    i$2p = o$1Q, t3.onTrackingEnd();
  } else
    i$2p = o$1Q;
}
function m$1Q(t2, n2) {
  if (n2.flags & i$2q.DepTrackingInitialized)
    return;
  const e2 = a$2v;
  a$2v = false, n2.flags & i$2q.AutoTracked ? u$1U(n2, n2.metadata.get, t2) : y$1n(t2, n2), a$2v = e2;
}
const k$t = [];
function y$1n(t2, e2) {
  e2.flags & i$2q.ExplicitlyTracking || (e2.flags |= i$2q.ExplicitlyTracking, u$1U(e2, () => {
    const r2 = e2.metadata.dependsOn || k$t;
    for (const e3 of r2)
      if (typeof e3 != "string" || e3.includes(".")) {
        const r3 = s$20(e3);
        for (let n2 = 0, e4 = t2; n2 < r3.length && e4 != null && typeof e4 == "object"; ++n2)
          e4 = A$q(e4, r3[n2], n2 !== r3.length - 1);
      } else
        A$q(t2, e3, false);
  }), e2.flags &= ~i$2q.ExplicitlyTracking);
}
function A$q(t2, n2, r2) {
  var _a2;
  const o2 = n2[n2.length - 1] === "?" ? n2.slice(0, -1) : n2;
  if (t2.getItemAt != null || Array.isArray(t2)) {
    const n3 = parseInt(o2, 10);
    if (!isNaN(n3))
      return Array.isArray(t2) ? t2[n3] : t2.getItemAt(n3);
  }
  const c2 = (_a2 = e$1Q(t2)) == null ? void 0 : _a2.properties.get(o2);
  return c2 && (s$1X(c2), m$1Q(t2, c2)), r2 ? t2[o2] : void 0;
}
function n$2h(n2) {
  if (n2.json && n2.json.origins) {
    const o2 = n2.json.origins, e2 = { "web-document": ["web-scene", "web-map"] };
    for (const n3 in e2)
      if (o2[n3]) {
        const s2 = o2[n3];
        e2[n3].forEach((n4) => {
          o2[n4] = s2;
        }), delete o2[n3];
      }
  }
}
class t$1Q extends r$1o {
  constructor(e2, s2, r2) {
    if (super(e2, s2, r2), !(this instanceof t$1Q))
      return new t$1Q(e2, s2, r2);
  }
}
t$1Q.prototype.type = "warning";
function e$1M(e2) {
  return !!e2 && e2.prototype && e2.prototype.declaredClass && e2.prototype.declaredClass.indexOf("esri.core.Collection") === 0;
}
const i$2o = s$22.getLogger("esri.core.accessorSupport.extensions.serializableProperty.reader");
function p$2Z(t2, r2, n2) {
  var _a2, _b2;
  t2 && (!n2 && !r2.read || ((_a2 = r2.read) == null ? void 0 : _a2.reader) || ((_b2 = r2.read) == null ? void 0 : _b2.enabled) === false || l$25(t2) && o$1X("read.reader", s$1W(t2), r2));
}
function s$1W(t2) {
  var _a2, _b2, _c2;
  const e2 = (_a2 = t2.ndimArray) != null ? _a2 : 0;
  if (e2 > 1)
    return c$2O(t2);
  if (e2 === 1)
    return a$2u(t2);
  if ("type" in t2 && d$1z(t2.type)) {
    const e3 = (_c2 = (_b2 = t2.type.prototype) == null ? void 0 : _b2.itemType) == null ? void 0 : _c2.Type, r2 = a$2u(typeof e3 == "function" ? { type: e3 } : { types: e3 });
    return (e4, n2, o2) => {
      const i2 = r2(e4, n2, o2);
      return i2 ? new t2.type(i2) : i2;
    };
  }
  return u$1T(t2);
}
function u$1T(t2) {
  return "type" in t2 ? y$1m(t2.type) : g$14(t2.types);
}
function y$1m(t2) {
  return t2.prototype.read ? (e2, r2, n2) => {
    if (e2 == null)
      return e2;
    const o2 = typeof e2;
    if (o2 !== "object")
      return void i$2o.error(`Expected JSON value of type 'object' to deserialize type '${t2.prototype.declaredClass}', but got '${o2}'`);
    const p2 = new t2();
    return p2.read(e2, n2), p2;
  } : t2.fromJSON;
}
function f$1A(t2, e2, r2, n2) {
  return n2 !== 0 && Array.isArray(e2) ? e2.map((e3) => f$1A(t2, e3, r2, n2 - 1)) : t2(e2, void 0, r2);
}
function c$2O(t2) {
  var _a2;
  const e2 = u$1T(t2), r2 = f$1A.bind(null, e2), n2 = (_a2 = t2.ndimArray) != null ? _a2 : 0;
  return (t3, e3, o2) => {
    if (t3 == null)
      return t3;
    t3 = r2(t3, o2, n2);
    let i2 = n2, p2 = t3;
    for (; i2 > 0 && Array.isArray(p2); )
      i2--, p2 = p2[0];
    if (p2 !== void 0)
      for (let r3 = 0; r3 < i2; r3++)
        t3 = [t3];
    return t3;
  };
}
function a$2u(t2) {
  const e2 = u$1T(t2);
  return (t3, r2, n2) => {
    if (t3 == null)
      return t3;
    if (Array.isArray(t3)) {
      const r3 = [];
      for (const o3 of t3) {
        const t4 = e2(o3, void 0, n2);
        t4 !== void 0 && r3.push(t4);
      }
      return r3;
    }
    const o2 = e2(t3, void 0, n2);
    return o2 !== void 0 ? [o2] : void 0;
  };
}
function d$1z(t2) {
  if (!e$1M(t2))
    return false;
  const e2 = t2.prototype.itemType;
  return !(!e2 || !e2.Type) && (typeof e2.Type == "function" ? m$1P(e2.Type) : j$M(e2.Type));
}
function l$25(t2) {
  return "types" in t2 ? j$M(t2.types) : m$1P(t2.type);
}
function m$1P(t2) {
  return !Array.isArray(t2) && (!!t2 && t2.prototype && ("read" in t2.prototype || "fromJSON" in t2 || d$1z(t2)));
}
function j$M(t2) {
  for (const e2 in t2.typeMap) {
    if (!m$1P(t2.typeMap[e2]))
      return false;
  }
  return true;
}
function g$14(t2) {
  var _a2;
  let e2 = null;
  const n2 = (_a2 = t2.errorContext) != null ? _a2 : "type";
  return (o2, p2, s2) => {
    if (o2 == null)
      return o2;
    const u2 = typeof o2;
    if (u2 !== "object")
      return void i$2o.error(`Expected JSON value of type 'object' to deserialize, but got '${u2}'`);
    e2 || (e2 = v$U(t2));
    const y2 = t2.key;
    if (typeof y2 != "string")
      return;
    const f2 = o2[y2], c2 = f2 ? e2[f2] : t2.defaultKeyValue ? t2.typeMap[t2.defaultKeyValue] : void 0;
    if (!c2) {
      const t3 = `Type '${f2 || "unknown"}' is not supported`;
      return s2 && s2.messages && o2 && s2.messages.push(new t$1Q(`${n2}:unsupported`, t3, { definition: o2, context: s2 })), void i$2o.error(t3);
    }
    const a2 = new c2();
    return a2.read(o2, s2), a2;
  };
}
function v$U(t2) {
  var _a2, _b2;
  const e2 = {};
  for (const r2 in t2.typeMap) {
    const o2 = t2.typeMap[r2], i2 = n$2j(o2.prototype);
    if (typeof t2.key == "function")
      continue;
    const p2 = i2.properties[t2.key];
    if (!p2)
      continue;
    ((_a2 = p2.json) == null ? void 0 : _a2.type) && Array.isArray(p2.json.type) && p2.json.type.length === 1 && typeof p2.json.type[0] == "string" && (e2[p2.json.type[0]] = o2);
    const s2 = (_b2 = p2.json) == null ? void 0 : _b2.write;
    if (!s2 || !s2.writer) {
      e2[r2] = o2;
      continue;
    }
    const u2 = s2.target, y2 = typeof u2 == "string" ? u2 : t2.key, f2 = {};
    s2.writer(r2, f2, y2), f2[y2] && (e2[f2[y2]] = o2);
  }
  return e2;
}
function e$1L(e2) {
  if (e2.json || (e2.json = {}), o$1P(e2.json), n$2g(e2.json), r$1n(e2.json), e2.json.origins)
    for (const t2 in e2.json.origins)
      o$1P(e2.json.origins[t2]), n$2g(e2.json.origins[t2]), r$1n(e2.json.origins[t2]);
  return true;
}
function r$1n(e2) {
  e2.name && (e2.read && typeof e2.read == "object" ? e2.read.source === void 0 && (e2.read.source = e2.name) : e2.read = { source: e2.name }, e2.write && typeof e2.write == "object" ? e2.write.target === void 0 && (e2.write.target = e2.name) : e2.write = { target: e2.name });
}
function o$1P(e2) {
  typeof e2.read == "boolean" ? e2.read = { enabled: e2.read } : typeof e2.read == "function" ? e2.read = { enabled: true, reader: e2.read } : e2.read && typeof e2.read == "object" && e2.read.enabled === void 0 && (e2.read.enabled = true);
}
function n$2g(e2) {
  typeof e2.write == "boolean" ? e2.write = { enabled: e2.write } : typeof e2.write == "function" ? e2.write = { enabled: true, writer: e2.write } : e2.write && typeof e2.write == "object" && e2.write.enabled === void 0 && (e2.write.enabled = true);
}
function i$2n(r2, e2) {
  var _a2;
  if (!e2.write || e2.write.writer || e2.write.enabled === false && !e2.write.overridePolicy)
    return;
  const t2 = (_a2 = r2 == null ? void 0 : r2.ndimArray) != null ? _a2 : 0;
  r2 && (t2 === 1 || "type" in r2 && e$1M(r2.type)) ? e2.write.writer = a$2t : t2 > 1 ? e2.write.writer = l$24(t2) : e2.types ? Array.isArray(e2.types) ? e2.write.writer = f$1z(e2.types[0]) : e2.write.writer = o$1O(e2.types) : e2.write.writer = s$1V;
}
function o$1O(r2) {
  return (e2, t2, n2, i2) => e2 ? u$1S(e2, r2, i2) ? s$1V(e2, t2, n2, i2) : void 0 : s$1V(e2, t2, n2, i2);
}
function u$1S(t2, n2, i2) {
  var _a2, _b2;
  for (const r2 in n2.typeMap)
    if (t2 instanceof n2.typeMap[r2])
      return true;
  if (i2 == null ? void 0 : i2.messages) {
    const o2 = (_a2 = n2.errorContext) != null ? _a2 : "type", u2 = `Values of type '${(_b2 = typeof n2.key != "function" ? t2[n2.key] : t2.declaredClass) != null ? _b2 : "Unknown"}' cannot be written`;
    i2 && i2.messages && t2 && i2.messages.push(new s$1Z(`${o2}:unsupported`, u2, { definition: t2, context: i2 })), s$22.getLogger("esri.core.accessorSupport.extensions.serializableProperty.writer").error(u2);
  }
  return false;
}
function f$1z(r2) {
  return (e2, t2, n2, i2) => {
    if (!e2 || !Array.isArray(e2))
      return s$1V(e2, t2, n2, i2);
    return s$1V(e2.filter((e3) => u$1S(e3, r2, i2)), t2, n2, i2);
  };
}
function s$1V(r2, e2, n2, i2) {
  o$1X(n2, p$2Y(r2, i2), e2);
}
function p$2Y(r2, e2) {
  return r2 && typeof r2.write == "function" ? r2.write({}, e2) : r2 && typeof r2.toJSON == "function" ? r2.toJSON() : typeof r2 == "number" ? y$1l(r2) : r2;
}
function y$1l(r2) {
  return r2 === -1 / 0 ? -Number.MAX_VALUE : r2 === 1 / 0 ? Number.MAX_VALUE : isNaN(r2) ? null : r2;
}
function a$2t(r2, e2, n2, i2) {
  let o2;
  r2 === null ? o2 = null : r2 && typeof r2.map == "function" ? (o2 = r2.map((r3) => p$2Y(r3, i2)), typeof o2.toArray == "function" && (o2 = o2.toArray())) : o2 = [p$2Y(r2, i2)], o$1X(n2, o2, e2);
}
function c$2N(r2, e2, t2) {
  return t2 !== 0 && Array.isArray(r2) ? r2.map((r3) => c$2N(r3, e2, t2 - 1)) : p$2Y(r2, e2);
}
function l$24(r2) {
  return (e2, n2, i2, o2) => {
    let u2;
    if (e2 === null)
      u2 = null;
    else {
      u2 = c$2N(e2, o2, r2);
      let t2 = r2, n3 = u2;
      for (; t2 > 0 && Array.isArray(n3); )
        t2--, n3 = n3[0];
      if (n3 !== void 0)
        for (let r3 = 0; r3 < t2; r3++)
          u2 = [u2];
    }
    o$1X(i2, u2, n2);
  };
}
function t$1P(r2, n2) {
  return a$2s(r2, "read", n2);
}
function s$1U(r2, n2) {
  return a$2s(r2, "write", n2);
}
function a$2s(r2, n2, i2) {
  let e2 = r2 && r2.json;
  if (r2 && r2.json && r2.json.origins && i2) {
    const o2 = i2.origin && r2.json.origins[i2.origin];
    o2 && (n2 === "any" || n2 in o2) && (e2 = o2);
  }
  return e2;
}
function p$2X(r2) {
  const n2 = y$1k(r2);
  if (r2.json.origins)
    for (const e2 in r2.json.origins) {
      const t2 = r2.json.origins[e2], s2 = t2.types ? f$1y(t2) : n2;
      p$2Z(s2, t2, false), t2.types && !t2.write && r2.json.write && r2.json.write.enabled && (t2.write = __spreadValues({}, r2.json.write)), i$2n(s2, t2);
    }
  p$2Z(n2, r2.json, true), i$2n(n2, r2.json);
}
function y$1k(r2) {
  return r2.json.types ? u$1R(r2.json) : r2.type ? j$L(r2) : u$1R(r2);
}
function f$1y(r2) {
  return r2.type ? j$L(r2) : u$1R(r2);
}
function j$L(n2) {
  if (!n2.type)
    return;
  let i2 = 0, e2 = n2.type;
  for (; Array.isArray(e2) && !k$u(e2); )
    e2 = e2[0], i2++;
  return { type: e2, ndimArray: i2 };
}
function u$1R(r2) {
  if (!r2.types)
    return;
  let n2 = 0, i2 = r2.types;
  for (; Array.isArray(i2); )
    i2 = i2[0], n2++;
  return { types: i2, ndimArray: n2 };
}
function c$2M(r2) {
  e$1L(r2) && (n$2h(r2), p$2X(r2));
}
const s$1T = new Set(), i$2m = new Set();
function n$2f(e2) {
  return (r2) => {
    r2.prototype.declaredClass = e2, c$2L(r2);
    const o2 = [], n2 = [];
    let a2 = r2.prototype;
    for (; a2; )
      a2.hasOwnProperty("initialize") && !s$1T.has(a2.initialize) && (s$1T.add(a2.initialize), o2.push(a2.initialize)), a2.hasOwnProperty("destroy") && !i$2m.has(a2.destroy) && (i$2m.add(a2.destroy), n2.push(a2.destroy)), a2 = Object.getPrototypeOf(a2);
    s$1T.clear(), i$2m.clear();
    class l2 extends r2 {
      constructor(...e3) {
        if (super(...e3), this.constructor === l2 && typeof this.postscript == "function") {
          if (o2.length && Object.defineProperty(this, "initialize", { enumerable: false, configurable: true, value() {
            for (let e4 = o2.length - 1; e4 >= 0; e4--)
              o2[e4].call(this);
          } }), n2.length) {
            let e4 = false;
            Object.defineProperty(this, "destroy", { enumerable: false, configurable: true, value() {
              if (!e4) {
                e4 = true;
                for (let e5 = 0; e5 < n2.length; e5++)
                  n2[e5].call(this);
              }
            } });
          }
          this.postscript(...e3);
        }
      }
    }
    return l2.__accessorMetadata__ = n$2j(r2.prototype), l2.prototype.declaredClass = e2, l2;
  };
}
function a$2r(e2, t2) {
  return t2.get == null ? function() {
    const t3 = this.__accessor__.properties.get(e2);
    if (t3 === void 0)
      return;
    s$1X(t3);
    const o2 = this.__accessor__.store;
    return o2.has(e2) ? o2.get(e2) : t3.metadata.value;
  } : function() {
    const t3 = this.__accessor__.properties.get(e2);
    if (t3 !== void 0)
      return t3.getComputed();
  };
}
function c$2L(r2) {
  const s2 = r2.prototype, i2 = n$2j(s2).properties, n2 = {};
  for (const t2 of Object.getOwnPropertyNames(i2)) {
    const r3 = i2[t2];
    c$2M(r3), n2[t2] = { enumerable: true, configurable: true, get: a$2r(t2, r3), set(o2) {
      const s3 = this.__accessor__;
      if (s3 !== void 0) {
        if (!Object.isFrozen(this)) {
          if (s3.initialized && r3.readOnly)
            throw new TypeError(`[accessor] cannot assign to read-only property '${t2}' of ${this.declaredClass}`);
          if (s3.lifecycle === I$x.CONSTRUCTED && r3.constructOnly)
            throw new TypeError(`[accessor] cannot assign to construct-only property '${t2}' of ${this.declaredClass}`);
          s3.set(t2, o2);
        }
      } else
        Object.defineProperty(this, t2, { enumerable: true, configurable: true, writable: true, value: o2 });
    } };
  }
  Object.defineProperties(r2.prototype, n2);
}
function n$2e(n2) {
  const o2 = [];
  return function* () {
    yield* o2;
    for (const t2 of n2)
      o2.push(t2), yield t2;
  };
}
function o$1N(n2, o2) {
  for (const t2 of n2)
    if (t2 != null && o2(t2))
      return t2;
}
function t$1O(n2) {
  return n2 != null && typeof n2[Symbol.iterator] == "function";
}
class t$1N {
  constructor() {
    this._groups = new Map();
  }
  destroy() {
    this.removeAll();
  }
  get size() {
    let r2 = 0;
    return this._groups.forEach((e2) => {
      r2 += e2.length;
    }), r2;
  }
  add(e2, t2) {
    if (t$1O(e2)) {
      const r2 = this._getOrCreateGroup(t2);
      for (const t3 of e2)
        this._isHandle(t3) && r2.push(t3);
    } else if (this._isHandle(e2)) {
      this._getOrCreateGroup(t2).push(e2);
    }
    return this;
  }
  forEach(r2, e2) {
    if (typeof r2 == "function")
      this._groups.forEach((e3) => e3.forEach(r2));
    else {
      const t2 = this._getGroup(r2);
      t2 && e2 && t2.forEach(e2);
    }
  }
  has(r2) {
    return this._groups.has(this._ensureGroupKey(r2));
  }
  remove(e2) {
    if (typeof e2 != "string" && t$1O(e2)) {
      for (const r2 of e2)
        this.remove(r2);
      return this;
    }
    return this.has(e2) ? (this._removeAllFromGroup(this._getGroup(e2)), this._groups.delete(this._ensureGroupKey(e2)), this) : this;
  }
  removeAll() {
    return this._groups.forEach((r2) => this._removeAllFromGroup(r2)), this._groups.clear(), this;
  }
  _isHandle(r2) {
    return r2 && !!r2.remove;
  }
  _getOrCreateGroup(r2) {
    if (this.has(r2))
      return this._getGroup(r2);
    const e2 = [];
    return this._groups.set(this._ensureGroupKey(r2), e2), e2;
  }
  _getGroup(r2) {
    return x$N(this._groups.get(this._ensureGroupKey(r2)));
  }
  _ensureGroupKey(r2) {
    return r2 || "_default_";
  }
  _removeAllFromGroup(r2) {
    r2.forEach((r3) => r3.remove());
  }
}
function t$1M(t2) {
  return t2 && t2.release && typeof t2.release == "function";
}
function i$2l(t2) {
  return t2 && t2.acquire && typeof t2.acquire == "function";
}
class e$1K {
  constructor(t2, i2, e2, o2 = 1, s2 = 0) {
    if (this._ctor = t2, this._acquireFunction = i2, this._releaseFunction = e2, this.allocationSize = o2, this._pool = new Array(s2), this._initialSize = s2, this._ctor)
      for (let n2 = 0; n2 < s2; n2++)
        this._pool[n2] = new this._ctor();
    this.allocationSize = Math.max(o2, 1);
  }
  destroy() {
    this.prune(0);
  }
  acquire(...t2) {
    let o2;
    if (e$1K.test.disabled)
      o2 = new this._ctor();
    else {
      if (this._pool.length === 0) {
        const t3 = this.allocationSize;
        for (let i2 = 0; i2 < t3; i2++)
          this._pool[i2] = new this._ctor();
      }
      o2 = this._pool.pop();
    }
    return this._acquireFunction ? this._acquireFunction(o2, ...t2) : i$2l(o2) && o2.acquire(...t2), o2;
  }
  release(i2) {
    i2 && !e$1K.test.disabled && (this._releaseFunction ? this._releaseFunction(i2) : t$1M(i2) && i2.release(), this._pool.push(i2));
  }
  prune(t2 = this._initialSize) {
    if (!(t2 >= this._pool.length)) {
      for (let i2 = t2; i2 < this._pool.length; ++i2) {
        const t3 = this._pool[i2];
        this._dispose(t3);
      }
      this._pool.length = t2;
    }
  }
  _dispose(t2) {
    t2.dispose && typeof t2.dispose == "function" && t2.dispose();
  }
}
e$1K.test = { disabled: false };
var r$1m;
!function(e2) {
  e2[e2.DEFAULTS = 0] = "DEFAULTS", e2[e2.COMPUTED = 1] = "COMPUTED", e2[e2.SERVICE = 2] = "SERVICE", e2[e2.PORTAL_ITEM = 3] = "PORTAL_ITEM", e2[e2.WEB_SCENE = 4] = "WEB_SCENE", e2[e2.WEB_MAP = 5] = "WEB_MAP", e2[e2.USER = 6] = "USER";
}(r$1m || (r$1m = {}));
const E$w = r$1m.USER + 1;
function t$1L(e2) {
  switch (e2) {
    case "defaults":
      return r$1m.DEFAULTS;
    case "service":
      return r$1m.SERVICE;
    case "portal-item":
      return r$1m.PORTAL_ITEM;
    case "web-scene":
      return r$1m.WEB_SCENE;
    case "web-map":
      return r$1m.WEB_MAP;
    case "user":
      return r$1m.USER;
    default:
      return null;
  }
}
function n$2d(E2) {
  switch (E2) {
    case r$1m.DEFAULTS:
      return "defaults";
    case r$1m.SERVICE:
      return "service";
    case r$1m.PORTAL_ITEM:
      return "portal-item";
    case r$1m.WEB_SCENE:
      return "web-scene";
    case r$1m.WEB_MAP:
      return "web-map";
    case r$1m.USER:
      return "user";
  }
  return x$N(void 0);
}
function c$2K(e2) {
  return n$2d(e2);
}
class s$1S {
  constructor(r2, s2) {
    this._observers = r2, this._observer = s2;
  }
  remove() {
    C$s(this._observers, this._observer);
  }
}
class l$23 {
  constructor(s2, t2, e2) {
    this.properties = s2, this.propertyName = t2, this.metadata = e2, this._observers = null, this._accessed = null, this._handles = null, this.flags = i$2q.Dirty | (e2.nonNullable ? i$2q.NonNullable : 0) | (e2.hasOwnProperty("value") ? i$2q.HasDefaultValue : 0) | (e2.get === void 0 ? i$2q.DepTrackingInitialized : 0) | (e2.dependsOn === void 0 ? i$2q.AutoTracked : 0);
  }
  destroy() {
    if (this.flags & i$2q.Dirty && this._observers) {
      const s2 = this._observers.slice();
      for (const t2 of s2)
        t2.onCommitted();
    }
    this._accessed = null, this._observers = null, this._clearObservationHandles();
  }
  getComputed() {
    s$1X(this);
    const o2 = this.properties.store, l2 = this.propertyName, a2 = this.flags, h2 = o2.get(l2);
    if (a2 & i$2q.Computing)
      return h2;
    if (~a2 & i$2q.Dirty && o2.has(l2))
      return h2;
    this.flags |= i$2q.Computing;
    const d2 = this.properties.host;
    let c2;
    a2 & i$2q.AutoTracked ? c2 = f$1B(this, this.metadata.get, d2) : (y$1n(d2, this), c2 = this.metadata.get.call(d2)), o2.set(l2, c2, r$1m.COMPUTED);
    const u2 = o2.get(l2);
    return u2 === h2 ? this.flags &= ~i$2q.Dirty : g$15(this.commit, this), this.flags &= ~i$2q.Computing, u2;
  }
  onObservableAccessed(s2) {
    s2 !== this && (this._accessed === null && (this._accessed = []), this._accessed.includes(s2) || this._accessed.push(s2));
  }
  onTrackingEnd() {
    this._clearObservationHandles(), this.flags |= i$2q.DepTrackingInitialized;
    const s2 = this._accessed;
    if (s2 === null)
      return;
    let t2 = this._handles;
    t2 === null && (t2 = this._handles = []);
    for (let e2 = 0; e2 < s2.length; ++e2)
      t2.push(s2[e2].observe(this));
    s2.length = 0;
  }
  observe(s2) {
    return this._observers === null && (this._observers = []), this._observers.includes(s2) || this._observers.push(s2), new s$1S(this._observers, s2);
  }
  notifyChange() {
    this.onInvalidated(), this.onCommitted();
  }
  invalidate() {
    this.onInvalidated();
  }
  onInvalidated() {
    ~this.flags & i$2q.Overriden && (this.flags |= i$2q.Dirty);
    const s2 = this._observers;
    if (s2 !== null)
      for (let t2 = 0; t2 < s2.length; ++t2)
        s2[t2].onInvalidated();
  }
  commit() {
    this.flags &= ~i$2q.Dirty, this.onCommitted();
  }
  onCommitted() {
    if (this._observers === null)
      return;
    const s2 = this._observers.slice();
    for (let t2 = 0; t2 < s2.length; ++t2)
      s2[t2].onCommitted();
  }
  _clearObservationHandles() {
    const s2 = this._handles;
    if (s2 !== null) {
      for (let t2 = 0; t2 < s2.length; ++t2)
        s2[t2].remove();
      s2.length = 0;
    }
  }
}
class t$1K {
  constructor() {
    this._values = new Map(), this.multipleOriginsSupported = false;
  }
  clone(s2) {
    const r2 = new t$1K();
    return this._values.forEach((t2, i2) => {
      s2 && s2.has(i2) || r2.set(i2, y$1r(t2));
    }), r2;
  }
  get(e2) {
    return this._values.get(e2);
  }
  originOf() {
    return r$1m.USER;
  }
  keys() {
    return [...this._values.keys()];
  }
  set(e2, s2) {
    this._values.set(e2, s2);
  }
  delete(e2) {
    this._values.delete(e2);
  }
  has(e2) {
    return this._values.has(e2);
  }
  forEach(e2) {
    this._values.forEach(e2);
  }
}
function g$13(t2, e2, s2) {
  return t2 !== void 0;
}
function d$1y(t2, e2, s2, r2) {
  return t2 !== void 0 && (!(s2 == null && t2.flags & i$2q.NonNullable) || (r2.lifecycle, I$x.INITIALIZING, false));
}
function m$1O(t2) {
  return t2 && typeof t2.destroy == "function";
}
s$22.getLogger("esri.core.accessorSupport.Properties");
class v$T {
  constructor(t2) {
    this.host = t2, this.properties = new Map(), this.ctorArgs = null, this.destroyed = false, this.lifecycle = I$x.INITIALIZING, this.store = new t$1K(), this._origin = r$1m.USER;
    const e2 = this.host.constructor.__accessorMetadata__, s2 = e2.properties;
    for (const i2 in s2) {
      const t3 = new l$23(this, i2, s2[i2]);
      this.properties.set(i2, t3);
    }
    this.metadatas = s2, this._autoDestroy = e2.autoDestroy;
  }
  initialize() {
    this.lifecycle = I$x.CONSTRUCTING;
  }
  constructed() {
    this.lifecycle = I$x.CONSTRUCTED;
  }
  destroy() {
    if (this.destroyed = true, this._autoDestroy)
      for (const [t2, e2] of this.properties) {
        const s2 = this.internalGet(t2);
        s2 && m$1O(s2) && (s2.destroy(), ~e2.flags & i$2q.NonNullable && this._internalSet(e2, null)), e2.destroy();
      }
    else
      for (const [t2, e2] of this.properties)
        e2.destroy();
  }
  get initialized() {
    return this.lifecycle !== I$x.INITIALIZING;
  }
  get(t2) {
    const e2 = this.properties.get(t2);
    if (e2.metadata.get)
      return e2.getComputed();
    s$1X(e2);
    const s2 = this.store;
    return s2.has(t2) ? s2.get(t2) : e2.metadata.value;
  }
  originOf(t2) {
    const e2 = this.store.originOf(t2);
    if (e2 === void 0) {
      const e3 = this.properties.get(t2);
      if (e3 !== void 0 && e3.flags & i$2q.HasDefaultValue)
        return "defaults";
    }
    return n$2d(e2);
  }
  has(t2) {
    return !!this.properties.has(t2) && this.store.has(t2);
  }
  keys() {
    return [...this.properties.keys()];
  }
  internalGet(t2) {
    const e2 = this.properties.get(t2);
    if (g$13(e2))
      return this.store.has(t2) ? this.store.get(t2) : e2.metadata.value;
  }
  internalSet(t2, e2) {
    const s2 = this.properties.get(t2);
    g$13(s2) && this._internalSet(s2, e2);
  }
  getDependsInfo(t2, e2, s2) {
    const i2 = this.properties.get(e2);
    if (!g$13(i2))
      return "";
    const o2 = new Set(), n2 = f$1B({ onObservableAccessed: (t3) => o2.add(t3), onTrackingEnd: () => {
    } }, () => {
      var _a2;
      return (_a2 = i2.metadata.get) == null ? void 0 : _a2.call(t2);
    });
    let a2 = `${s2}${t2.declaredClass.split(".").pop()}.${e2}: ${n2}
`;
    if (o2.size === 0)
      return a2;
    s2 += "  ";
    for (const l2 of o2) {
      if (!(l2 instanceof l$23))
        continue;
      const t3 = l2.properties.host, e3 = l2.propertyName, i3 = e$1Q(t3);
      a2 += i3 ? i3.getDependsInfo(t3, e3, s2) : `${s2}${e3}: undefined
`;
    }
    return a2;
  }
  setAtOrigin(t2, e2, s2) {
    const i2 = this.properties.get(t2);
    if (g$13(i2))
      return this._setAtOrigin(i2, e2, s2);
  }
  isOverridden(t2) {
    const e2 = this.properties.get(t2);
    return e2 !== void 0 && !!(e2.flags & i$2q.Overriden);
  }
  clearOverride(t2) {
    const e2 = this.properties.get(t2);
    e2 !== void 0 && e2.flags & i$2q.Overriden && (e2.flags &= ~i$2q.Overriden, e2.notifyChange());
  }
  override(t2, e2) {
    const s2 = this.properties.get(t2);
    if (!d$1y(s2, t2, e2, this))
      return;
    const i2 = s2.metadata.cast;
    if (i2) {
      const t3 = this._cast(i2, e2), { valid: s3, value: r2 } = t3;
      if (I$w.release(t3), !s3)
        return;
      e2 = r2;
    }
    s2.flags |= i$2q.Overriden, this._internalSet(s2, e2);
  }
  set(t2, e2) {
    const s2 = this.properties.get(t2);
    if (!d$1y(s2, t2, e2, this))
      return;
    const i2 = s2.metadata.cast;
    if (i2) {
      const t3 = this._cast(i2, e2), { valid: s3, value: r3 } = t3;
      if (I$w.release(t3), !s3)
        return;
      e2 = r3;
    }
    const r2 = s2.metadata.set;
    r2 ? r2.call(this.host, e2) : this._internalSet(s2, e2);
  }
  setDefaultOrigin(t2) {
    this._origin = t$1L(t2);
  }
  getDefaultOrigin() {
    return n$2d(this._origin);
  }
  notifyChange(t2) {
    const e2 = this.properties.get(t2);
    e2 !== void 0 && e2.notifyChange();
  }
  invalidate(t2) {
    const e2 = this.properties.get(t2);
    e2 !== void 0 && e2.invalidate();
  }
  commit(t2) {
    const e2 = this.properties.get(t2);
    e2 !== void 0 && e2.commit();
  }
  _internalSet(t2, e2) {
    const s2 = this.lifecycle !== I$x.INITIALIZING ? this._origin : r$1m.DEFAULTS;
    this._setAtOrigin(t2, e2, s2);
  }
  _setAtOrigin(e2, s2, i2) {
    const r2 = this.store, o2 = e2.propertyName;
    r2.has(o2, i2) && w$Q(s2, r2.get(o2)) && ~e2.flags & i$2q.Overriden && i2 === r2.originOf(o2) || (e2.invalidate(), r2.set(o2, s2, i2), e2.commit(), m$1Q(this.host, e2));
  }
  _cast(t2, e2) {
    const s2 = I$w.acquire();
    return s2.valid = true, s2.value = e2, t2 && (s2.value = t2.call(this.host, e2, s2)), s2;
  }
}
class y$1j {
  constructor() {
    this.value = null, this.valid = true;
  }
  acquire() {
    this.valid = true;
  }
  release() {
    this.value = null;
  }
}
const I$w = new e$1K(y$1j);
function r$1l(e2) {
  e2.length = 0;
}
class t$1J {
  constructor(t2 = 50, o2 = 50) {
    this._pool = new e$1K(Array, void 0, r$1l, o2, t2);
  }
  acquire() {
    return this._pool.acquire();
  }
  release(e2) {
    this._pool.release(e2);
  }
  prune() {
    this._pool.prune(0);
  }
  static acquire() {
    return o$1M.acquire();
  }
  static release(e2) {
    return o$1M.release(e2);
  }
  static prune() {
    o$1M.prune();
  }
}
const o$1M = new t$1J(100);
class t$1I extends e$1K {
  constructor() {
    super(...arguments), this._set = new Set();
  }
  destroy() {
    super.destroy(), this._set = d$1F(this._set);
  }
  acquire(...e2) {
    const s2 = super.acquire(...e2);
    return this._set.delete(s2), s2;
  }
  release(e2) {
    e2 && !this._set.has(e2) && (super.release(e2), this._set.add(e2));
  }
  _dispose(e2) {
    this._set.delete(e2), super._dispose(e2);
  }
}
const o$1L = [];
function t$1H(t2) {
  o$1L.push(t2), o$1L.length === 1 && queueMicrotask(() => {
    const t3 = o$1L.slice();
    o$1L.length = 0;
    for (const o2 of t3)
      o2();
  });
}
class e$1J {
  constructor(s2, e2 = 30) {
    this.name = s2, this._counter = 0, this._samples = new Array(e2);
  }
  record(e2) {
    r$1t(e2) && (this._samples[++this._counter % this._samples.length] = e2);
  }
  get median() {
    return this._samples.slice().sort((s2, e2) => s2 - e2)[Math.floor(this._samples.length / 2)];
  }
  get average() {
    return this._samples.reduce((s2, e2) => s2 + e2, 0) / this._samples.length;
  }
  get last() {
    return this._samples[this._counter % this._samples.length];
  }
}
var o$1K;
!function(o2) {
  const t2 = (o3, t3, n3, e3) => {
    let i3 = t3, c2 = t3;
    const l2 = n3 >>> 1, r2 = o3[i3 - 1];
    for (; c2 <= l2; ) {
      c2 = i3 << 1, c2 < n3 && e3(o3[c2 - 1], o3[c2]) < 0 && ++c2;
      const t4 = o3[c2 - 1];
      if (e3(t4, r2) <= 0)
        break;
      o3[i3 - 1] = t4, i3 = c2;
    }
    o3[i3 - 1] = r2;
  }, n2 = (o3, t3) => o3 < t3 ? -1 : o3 > t3 ? 1 : 0;
  function e2(o3, e3, i3, c2) {
    e3 === void 0 && (e3 = 0), i3 === void 0 && (i3 = o3.length), c2 === void 0 && (c2 = n2);
    for (let n3 = i3 >>> 1; n3 > e3; n3--)
      t2(o3, n3, i3, c2);
    const l2 = e3 + 1;
    for (let n3 = i3 - 1; n3 > e3; n3--) {
      const i4 = o3[e3];
      o3[e3] = o3[n3], o3[n3] = i4, t2(o3, l2, n3, c2);
    }
  }
  function* i2(o3, e3, i3, c2) {
    e3 === void 0 && (e3 = 0), i3 === void 0 && (i3 = o3.length), c2 === void 0 && (c2 = n2);
    for (let n3 = i3 >>> 1; n3 > e3; n3--)
      t2(o3, n3, i3, c2), yield;
    const l2 = e3 + 1;
    for (let n3 = i3 - 1; n3 > e3; n3--) {
      const i4 = o3[e3];
      o3[e3] = o3[n3], o3[n3] = i4, t2(o3, l2, n3, c2), yield;
    }
  }
  o2.sort = e2, o2.iterableSort = i2;
}(o$1K || (o$1K = {}));
const t$1G = o$1K;
const a$2q = 1.5, e$1I = 1.1;
class l$22 {
  constructor(h2) {
    this.data = [], this._length = 0, this._allocator = void 0, this._deallocator = () => null, this._shrink = () => {
    }, this._hint = new x$M(), h2 && (h2.initialSize && (this.data = new Array(h2.initialSize)), h2.allocator && (this._allocator = h2.allocator), h2.deallocator !== void 0 && (this._deallocator = h2.deallocator), h2.shrink && (this._shrink = () => n$2c(this)));
  }
  toArray() {
    return this.data.slice(0, this.length);
  }
  filter(t2) {
    const h2 = new Array();
    for (let i2 = 0; i2 < this._length; i2++) {
      const s2 = this.data[i2];
      t2(s2) && h2.push(s2);
    }
    return h2;
  }
  getItemAt(t2) {
    if (!(t2 < 0 || t2 >= this._length))
      return this.data[t2];
  }
  includes(t2, h2) {
    const i2 = this.data.indexOf(t2, h2);
    return i2 !== -1 && i2 < this.length;
  }
  get length() {
    return this._length;
  }
  set length(t2) {
    if (t2 > this._length) {
      if (this._allocator) {
        for (; this._length < t2; )
          this.data[this._length++] = this._allocator(this.data[this._length]);
        return;
      }
      this._length = t2;
    } else {
      if (this._deallocator)
        for (let h2 = t2; h2 < this._length; ++h2)
          this.data[h2] = this._deallocator(this.data[h2]);
      this._length = t2, this._shrink();
    }
  }
  clear() {
    this.length = 0;
  }
  prune() {
    this.clear(), this.data = [];
  }
  push(t2) {
    this.data[this._length++] = t2;
  }
  pushArray(t2, h2 = t2.length) {
    for (let i2 = 0; i2 < h2; i2++)
      this.data[this._length++] = t2[i2];
  }
  fill(t2, h2) {
    for (let i2 = 0; i2 < h2; i2++)
      this.data[this._length++] = t2;
  }
  pushNew() {
    this._allocator && (this.data[this.length] = this._allocator(this.data[this.length]));
    const t2 = this.data[this._length];
    return ++this._length, t2;
  }
  unshift(t2) {
    this.data.unshift(t2), this._length++, n$2c(this);
  }
  pop() {
    if (this.length === 0)
      return;
    const t2 = this.data[this.length - 1];
    return this.length = this.length - 1, this._shrink(), t2;
  }
  remove(t2) {
    const i2 = b$W(this.data, t2, this.length, this._hint);
    if (i2 !== -1)
      return this.data.splice(i2, 1), this.length = this.length - 1, t2;
  }
  removeUnordered(t2) {
    return this.removeUnorderedIndex(b$W(this.data, t2, this.length, this._hint));
  }
  removeUnorderedIndex(t2) {
    if (!(t2 >= this.length || t2 < 0))
      return this.swapElements(t2, this.length - 1), this.pop();
  }
  removeUnorderedMany(t2, h2 = t2.length, s2) {
    this.length = j$Q(this.data, t2, this.length, h2, this._hint, s2), this._shrink();
  }
  front() {
    if (this.length !== 0)
      return this.data[0];
  }
  back() {
    if (this.length !== 0)
      return this.data[this.length - 1];
  }
  swapElements(t2, h2) {
    if (t2 >= this.length || h2 >= this.length || t2 === h2)
      return;
    const i2 = this.data[t2];
    this.data[t2] = this.data[h2], this.data[h2] = i2;
  }
  sort(t2) {
    t$1G.sort(this.data, 0, this.length, t2);
  }
  iterableSort(t2) {
    return t$1G.iterableSort(this.data, 0, this.length, t2);
  }
  some(t2, h2) {
    for (let i2 = 0; i2 < this.length; ++i2)
      if (t2.call(h2, this.data[i2], i2, this.data))
        return true;
    return false;
  }
  filterInPlace(t2, h2) {
    let i2 = 0;
    for (let s2 = 0; s2 < this._length; ++s2) {
      const a2 = this.data[s2];
      t2.call(h2, a2, s2, this.data) && (this.data[s2] = this.data[i2], this.data[i2] = a2, i2++);
    }
    if (this._deallocator)
      for (let s2 = i2; s2 < this._length; s2++)
        this.data[s2] = this._deallocator(this.data[s2]);
    return this._length = i2, this._shrink(), this;
  }
  forAll(t2, h2) {
    const i2 = this.length, s2 = this.data;
    for (let a2 = 0; a2 < i2; ++a2)
      t2.call(h2, s2[a2], a2, s2);
  }
  forEach(t2, h2) {
    for (let i2 = 0; i2 < this.length; ++i2)
      t2.call(h2, this.data[i2], i2, this.data);
  }
  map(t2, h2) {
    const i2 = new Array(this.length);
    for (let s2 = 0; s2 < this.length; ++s2)
      i2[s2] = t2.call(h2, this.data[s2], s2, this.data);
    return i2;
  }
  reduce(t2, h2) {
    let i2 = h2;
    for (let s2 = 0; s2 < this.length; ++s2)
      i2 = t2(i2, this.data[s2], s2, this.data);
    return i2;
  }
  has(t2) {
    const h2 = this.length, i2 = this.data;
    for (let s2 = 0; s2 < h2; ++s2)
      if (i2[s2] === t2)
        return true;
    return false;
  }
}
function n$2c(t2) {
  t2.data.length > a$2q * t2.length && (t2.data.length = Math.floor(t2.length * e$1I));
}
function e$1H(e2) {
  return { setTimeout: (t2, o2) => {
    const r2 = e2.setTimeout(t2, o2);
    return { remove: () => e2.clearTimeout(r2) };
  } };
}
const t$1F = e$1H(globalThis);
const n$2b = new Set();
function e$1G(e2, i2, o2 = false) {
  o2 && n$2b.has(i2) || (o2 && n$2b.add(i2), e2.warn(`\u{1F6D1} DEPRECATED - ${i2}`));
}
function t$1E(n2, e2, i2 = {}) {
  if (has("esri-deprecation-warnings")) {
    const { moduleName: o2 } = i2;
    r$1k(n2, `Property: ${(o2 ? o2 + "::" : "") + e2}`, i2);
  }
}
function r$1k(n2, i2, o2 = {}) {
  if (has("esri-deprecation-warnings")) {
    const { replacement: t2, version: r2, see: s2, warnOnce: a2 } = o2;
    let c2 = i2;
    t2 && (c2 += `
	\u{1F6E0}\uFE0F Replacement: ${t2}`), r2 && (c2 += `
	\u2699\uFE0F Version: ${r2}`), s2 && (c2 += `
	\u{1F517} See ${s2} for more details.`), e$1G(n2, c2, a2);
  }
}
function e$1F(e2) {
  return e2 && (typeof e2.on == "function" || typeof e2.addEventListener == "function");
}
function r$1j(r2, t2, n2) {
  if (!e$1F(r2))
    throw new TypeError("target is not a Evented or EventTarget object");
  if ("on" in r2)
    return r2.on(t2, n2);
  if (Array.isArray(t2)) {
    const e2 = t2.slice();
    for (const t3 of e2)
      r2.addEventListener(t3, n2);
    return { remove() {
      for (const t3 of e2)
        r2.removeEventListener(t3, n2);
    } };
  }
  return r2.addEventListener(t2, n2), { remove() {
    r2.removeEventListener(t2, n2);
  } };
}
function t$1D(t2, n2, o2) {
  if (!e$1F(t2))
    throw new TypeError("target is not a Evented or EventTarget object");
  if ("once" in t2)
    return t2.once(n2, o2);
  const i2 = r$1j(t2, n2, (e2) => {
    i2.remove(), o2.call(t2, e2);
  });
  return { remove() {
    i2.remove();
  } };
}
const o$1J = { Win: "Meta", Scroll: "ScrollLock", Spacebar: " ", Down: "ArrowDown", Left: "ArrowLeft", Right: "ArrowRight", Up: "ArrowUp", Del: "Delete", Apps: "ContextMenu", Esc: "Escape", Multiply: "*", Add: "+", Subtract: "-", Decimal: ".", Divide: "/" };
function i$2k({ key: e2 }) {
  return o$1J[e2] || e2;
}
function a$2p(t2 = "Aborted") {
  return new s$1Z("AbortError", t2);
}
function f$1x(t2, e2 = "Aborted") {
  if (p$2W(t2))
    throw a$2p(e2);
}
function h$1n(t2) {
  return r$1t(t2) ? "aborted" in t2 ? t2 : t2.signal : t2;
}
function p$2W(t2) {
  const e2 = h$1n(t2);
  return r$1t(e2) && e2.aborted;
}
function w$O(t2) {
  if (j$K(t2))
    throw t2;
}
function b$T(t2) {
  if (!j$K(t2))
    throw t2;
}
function v$S(t2, e2) {
  const r2 = h$1n(t2);
  if (!t$1W(r2)) {
    if (!r2.aborted)
      return t$1D(r2, "abort", () => e2());
    e2();
  }
}
function d$1x(t2, e2) {
  const r2 = h$1n(t2);
  if (!t$1W(r2))
    return f$1x(r2), t$1D(r2, "abort", () => e2(a$2p()));
}
function y$1i(t2, e2) {
  const r2 = h$1n(e2);
  return t$1W(r2) ? t2 : new Promise((r3, n2) => {
    let o2 = v$S(e2, () => n2(a$2p()));
    const i2 = () => o2 = h$1s(o2);
    t2.then(i2, i2), t2.then(r3, n2);
  });
}
function j$K(t2) {
  return (t2 == null ? void 0 : t2.name) === "AbortError";
}
async function g$12(t2) {
  try {
    return await t2;
  } catch (e2) {
    if (!j$K(e2))
      throw e2;
    return;
  }
}
function A$p() {
  let t2 = null;
  const e2 = new Promise((e3, r2) => {
    t2 = { promise: void 0, resolve: e3, reject: r2 };
  });
  return t2.promise = e2, t2;
}
async function E$v(t2) {
  if (!t2)
    return;
  if (typeof t2.forEach != "function") {
    const e3 = Object.keys(t2), r2 = e3.map((e4) => t2[e4]), n2 = await E$v(r2), o2 = {};
    return e3.map((t3, e4) => o2[t3] = n2[e4]), o2;
  }
  const e2 = t2;
  return new Promise((t3) => {
    const r2 = [];
    let n2 = e2.length;
    n2 === 0 && t3(r2), e2.forEach((e3) => {
      const o2 = { promise: e3 || Promise.resolve(e3) };
      r2.push(o2), o2.promise.then((t4) => {
        o2.value = t4;
      }).catch((t4) => {
        o2.error = t4;
      }).then(() => {
        --n2, n2 === 0 && t3(r2);
      });
    });
  });
}
async function L$r(t2) {
  return (await E$v(t2)).filter((t3) => !!t3.value).map((t3) => t3.value);
}
function U$q(t2, e2, r2) {
  const n2 = new AbortController();
  return v$S(r2, () => n2.abort()), new Promise((r3, o2) => {
    let i2 = setTimeout(() => {
      i2 = 0, r3(e2);
    }, t2);
    v$S(n2, () => {
      i2 && (clearTimeout(i2), o2(a$2p()));
    });
  });
}
function C$q(t2) {
  return t2 && typeof t2.then == "function";
}
function $$f(t2) {
  return C$q(t2) ? t2 : Promise.resolve(t2);
}
function x$L(t2, e2 = -1) {
  let r2, n2, o2, i2, s2 = null;
  const c2 = (...l2) => {
    if (r2) {
      n2 = l2, i2 && i2.reject(a$2p()), i2 = A$p();
      const t3 = x$N(i2.promise);
      if (s2) {
        const t4 = s2;
        s2 = null, t4.abort();
      }
      return t3;
    }
    if (o2 = i2 || A$p(), i2 = null, e2 > 0) {
      const n3 = new AbortController();
      r2 = $$f(t2(...l2, n3.signal));
      const o3 = r2;
      U$q(e2).then(() => {
        r2 === o3 && (i2 ? n3.abort() : s2 = n3);
      });
    } else
      r2 = 1, r2 = $$f(t2(...l2));
    const m2 = () => {
      const t3 = n2;
      n2 = o2 = r2 = s2 = null, t3 != null && c2(...t3);
    }, f2 = r2, h2 = o2;
    return f2.then(m2, m2), f2.then(h2.resolve, h2.reject), x$N(h2.promise);
  };
  return c2;
}
function D$s() {
  let e2, r2;
  const n2 = new Promise((t2, n3) => {
    e2 = t2, r2 = n3;
  }), o2 = (t2) => {
    e2(t2);
  };
  return o2.resolve = (t2) => e2(t2), o2.reject = (t2) => r2(t2), o2.timeout = (e3, r3) => t$1F.setTimeout(() => o2.reject(r3), e3), o2.promise = n2, o2;
}
async function O$o(t2) {
  await Promise.resolve(), f$1x(t2);
}
function n$2a(n2) {
  return n2;
}
class c$2J {
  constructor(e2) {
    this.phases = e2, this.paused = false, this.ticks = -1, this.removed = false;
  }
}
class m$1N {
  constructor(e2) {
    this.callback = e2, this.isActive = true;
  }
  remove() {
    this.isActive = false;
  }
}
let l$21 = 0;
const u$1Q = { time: n$2a(0), deltaTime: n$2a(0), elapsedFrameTime: n$2a(0), frameDuration: n$2a(0) }, f$1w = ["prepare", "preRender", "render", "postRender", "update", "finish"], h$1m = [], d$1w = new l$22();
class w$N {
  constructor(e2) {
    this._task = e2;
  }
  remove() {
    this._task.removed = true;
  }
  pause() {
    this._task.paused = true;
  }
  resume() {
    this._task.paused = false;
  }
}
const k$s = { frameTasks: d$1w, willDispatch: false, clearFrameTasks: j$J, dispatch: b$S, executeFrameTasks: D$r };
function v$R(e2) {
  const r2 = new m$1N(e2);
  return h$1m.push(r2), k$s.willDispatch || (k$s.willDispatch = true, t$1H(b$S)), r2;
}
function A$o(e2) {
  const t2 = new c$2J(e2);
  return d$1w.push(t2), T$q == null && (l$21 = performance.now(), T$q = requestAnimationFrame(x$K)), new w$N(t2);
}
let T$q = null;
function j$J(e2 = false) {
  d$1w.forAll((e3) => {
    e3.removed = true;
  }), e2 && _$C();
}
function x$K() {
  const e2 = performance.now();
  T$q = null, T$q = d$1w.length > 0 ? requestAnimationFrame(x$K) : null, k$s.executeFrameTasks(e2);
}
function D$r(e2) {
  const t2 = n$2a(e2 - l$21);
  l$21 = e2;
  const r2 = 1e3 / 60, s2 = Math.max(0, t2 - r2);
  for (let o2 = 0; o2 < f$1w.length; o2++) {
    const n2 = performance.now(), a2 = f$1w[o2];
    d$1w.forAll((n3) => {
      var _a2;
      if (n3.paused || n3.removed)
        return;
      o2 === 0 && n3.ticks++;
      n3.phases[a2] && (u$1Q.time = e2, u$1Q.deltaTime = n3.ticks === 0 ? n$2a(0) : t2, u$1Q.elapsedFrameTime = n$2a(performance.now() - e2), u$1Q.frameDuration = n$2a(r2 - s2), (_a2 = n3.phases[a2]) == null ? void 0 : _a2.call(n3, u$1Q));
    }), R$o[o2].record(performance.now() - n2);
  }
  _$C(), q$h.record(performance.now() - e2);
}
const g$11 = new l$22();
function _$C() {
  d$1w.forAll((e2) => {
    e2.removed && g$11.push(e2);
  }), d$1w.removeUnorderedMany(g$11.data, g$11.length), g$11.clear();
}
function b$S() {
  for (; h$1m.length; ) {
    const t2 = x$N(h$1m.shift());
    t2.isActive && t2.callback();
  }
  k$s.willDispatch = false;
}
function y$1h(e2 = 1, r2) {
  const s2 = D$s(), i2 = () => {
    p$2W(r2) ? s2.reject(a$2p()) : e2 === 0 ? s2() : (--e2, t$1H(() => i2()));
  };
  return i2(), s2.promise;
}
const R$o = f$1w.map((e2) => new e$1J(e2)), q$h = new e$1J("total");
function n$29(r2, n2) {
  for (const o2 of r2.entries())
    if (n2(o2[0]))
      return true;
  return false;
}
let t$1C = 0;
function e$1E() {
  return ++t$1C;
}
class s$1R {
  constructor(s2) {
    this._notify = s2, this._accessed = [], this._handles = [], this._invalidCount = 0;
  }
  destroy() {
    this._accessed.length = 0, this.clear();
  }
  onInvalidated() {
    this._invalidCount++;
  }
  onCommitted() {
    const s2 = this._invalidCount;
    if (s2 === 1)
      return this._invalidCount = 0, void this._notify();
    this._invalidCount = s2 > 0 ? s2 - 1 : 0;
  }
  onObservableAccessed(s2) {
    this._accessed.includes(s2) || this._accessed.push(s2);
  }
  onTrackingEnd() {
    const s2 = this._handles, t2 = this._accessed;
    for (let e2 = 0; e2 < t2.length; ++e2)
      s2.push(t2[e2].observe(this));
    t2.length = 0;
  }
  clear() {
    const s2 = this._handles;
    for (let t2 = 0; t2 < s2.length; ++t2)
      s2[t2].remove();
    s2.length = 0;
  }
}
let r$1i = false;
const e$1D = [];
function o$1I(e2, o2) {
  let u2 = new s$1R(s2), l2 = null, f2 = false;
  function s2() {
    if (!u2 || f2)
      return;
    if (r$1i)
      return void i$2j(s2);
    const t2 = l2;
    u2.clear(), r$1i = true, f2 = true, l2 = f$1B(u2, e2), f2 = false, r$1i = false, o2(l2, t2), c$2I();
  }
  function m2() {
    u2 && (u2.destroy(), u2 = null, l2 = null);
  }
  return f2 = true, l2 = f$1B(u2, e2), f2 = false, { remove: m2 };
}
function u$1P(r2, e2) {
  let o2 = new s$1R(l2), u2 = null;
  function l2() {
    e2(u2, c2);
  }
  function i2() {
    o2 && (o2.destroy(), o2 = null), u2 = null;
  }
  function c2() {
    return o2 ? (o2.clear(), u2 = f$1B(o2, r2), u2) : null;
  }
  return c2(), { remove: i2 };
}
function l$20(e2) {
  let o2 = new s$1R(l2), u2 = false;
  function l2() {
    o2 && !u2 && (r$1i ? i$2j(l2) : (o2.clear(), r$1i = true, u2 = true, f$1B(o2, e2), u2 = false, r$1i = false, c$2I()));
  }
  function f2() {
    o2 && (o2.destroy(), o2 = null);
  }
  return u2 = true, f$1B(o2, e2), u2 = false, { remove: f2 };
}
function i$2j(n2) {
  e$1D.includes(n2) || e$1D.unshift(n2);
}
function c$2I() {
  for (; e$1D.length; )
    e$1D.pop()();
}
var h$1l;
!function(e2) {
  e2[e2.Untracked = 0] = "Untracked", e2[e2.Tracked = 1] = "Tracked";
}(h$1l || (h$1l = {}));
class f$1v {
  constructor() {
    this.uid = e$1E(), this.removed = false, this.type = null, this.oldValue = null, this.callback = null, this.getValue = null, this.target = null, this.path = null, this.equals = null;
  }
  static acquireUntracked(e2, r2, o2, l2, n2) {
    return this.pool.acquire(h$1l.Untracked, e2, r2, o2, l2, n2, w$Q);
  }
  static acquireTracked(e2, t2, r2, o2) {
    return this.pool.acquire(h$1l.Tracked, e2, t2, r2, null, null, o2);
  }
  notify(e2, t2) {
    this.type === h$1l.Untracked ? this.callback.call(this.target, e2, t2, this.path, this.target) : this.callback.call(null, e2, t2);
  }
  acquire(e2, t2, r2, o2, l2, n2, s2) {
    this.uid = e$1E(), this.removed = false, this.type = e2, this.oldValue = t2, this.callback = r2, this.getValue = o2, this.target = l2, this.path = n2, this.equals = s2;
  }
  release() {
    this.target = this.path = this.oldValue = this.callback = this.getValue = null, this.uid = e$1E(), this.removed = true;
  }
}
f$1v.pool = new t$1I(f$1v);
const m$1M = new t$1J(), p$2V = new Set();
let v$Q;
function k$r(e2) {
  p$2V.delete(e2), p$2V.add(e2), v$Q || (v$Q = v$R(q$g));
}
function _$B(e2) {
  if (e2.removed)
    return;
  const t2 = e2.oldValue, r2 = e2.getValue();
  e2.equals(t2, r2) || (e2.oldValue = r2, e2.notify(r2, t2));
}
function g$10(e2) {
  for (const t2 of p$2V.values())
    t2.target === e2 && (t2.removed = true);
}
function q$g() {
  let e2 = 10;
  for (; v$Q && e2--; ) {
    v$Q = null;
    const e3 = j$I(), t2 = m$1M.acquire();
    for (const r2 of e3) {
      const e4 = r2.uid;
      _$B(r2), e4 === r2.uid && r2.removed && t2.push(r2);
    }
    for (const r2 of p$2V)
      r2.removed && (t2.push(r2), p$2V.delete(r2));
    for (const r2 of t2)
      f$1v.pool.release(r2);
    m$1M.release(t2), m$1M.release(e3), V$c.forEach((e4) => e4());
  }
}
function j$I() {
  const e2 = m$1M.acquire();
  e2.length = p$2V.size;
  let t2 = 0;
  for (const r2 of p$2V)
    e2[t2] = r2, ++t2;
  return p$2V.clear(), e2;
}
const V$c = new Set();
function y$1g(e2) {
  return V$c.add(e2), { remove() {
    V$c.delete(e2);
  } };
}
function U$p(e2, t2, r2) {
  let o2 = y$1p(e2, t2, r2, (e3, t3, r3) => {
    let l2, n2, i2 = u$1P(() => u$1V(e3, t3), (i3, s2) => {
      e3.__accessor__.destroyed || l2 && l2.uid !== n2 ? o2.remove() : (l2 || (l2 = f$1v.acquireUntracked(i3, r3, s2, e3, t3), n2 = l2.uid), k$r(l2));
    });
    return { remove: h$1p(() => {
      i2.remove(), l2 && (l2.uid !== n2 || l2.removed || (l2.removed = true, k$r(l2)), l2 = null), o2 = i2 = null;
    }) };
  });
  return o2;
}
function b$R(e2, r2, o2) {
  const l2 = y$1p(e2, r2, o2, (e3, r3, o3) => {
    let n2 = false;
    return o$1I(() => u$1V(e3, r3), (i2, s2) => {
      e3.__accessor__.destroyed ? l2.remove() : n2 || (n2 = true, w$Q(s2, i2) || o3.call(e3, i2, s2, r3, e3), n2 = false);
    });
  });
  return l2;
}
function T$p(e2, t2, r2, o2 = false) {
  return !e2.__accessor__ || e2.__accessor__.destroyed ? { remove() {
  } } : o2 ? b$R(e2, t2, r2) : U$p(e2, t2, r2);
}
function w$M(e2, t2, r2) {
  let o2, l2, n2 = u$1P(e2, (e3, i2) => {
    o2 && o2.uid !== l2 ? n2.remove() : (o2 || (o2 = f$1v.acquireTracked(e3, t2, i2, r2), l2 = o2.uid), k$r(o2));
  });
  return { remove: h$1p(() => {
    n2.remove(), o2 && (o2.uid !== l2 || o2.removed || (o2.removed = true, k$r(o2)), o2 = null), n2 = null;
  }) };
}
function S$G(e2, t2, r2) {
  let o2 = false;
  return o$1I(e2, (e3, l2) => {
    o2 || (o2 = true, r2(l2, e3) || t2(e3, l2), o2 = false);
  });
}
function P$q(e2, t2, o2 = false, l2 = N$i) {
  return o2 ? S$G(e2, t2, l2) : w$M(e2, t2, l2);
}
function x$J(e2) {
  return n$29(p$2V, (t2) => t2.oldValue === e2);
}
var l$1$, p$2U;
function d$1v(t2) {
  var _a2;
  if (t2 == null)
    return { value: t2 };
  if (Array.isArray(t2))
    return { type: [t2[0]], value: null };
  switch (typeof t2) {
    case "object":
      return ((_a2 = t2.constructor) == null ? void 0 : _a2.__accessorMetadata__) || t2 instanceof Date ? { type: t2.constructor, value: t2 } : t2;
    case "boolean":
      return { type: Boolean, value: t2 };
    case "string":
      return { type: String, value: t2 };
    case "number":
      return { type: Number, value: t2 };
    case "function":
      return { type: t2, value: null };
    default:
      return;
  }
}
const y$1f = Symbol("Accessor-Handles"), f$1u = Symbol("Accessor-Initialized");
class m$1L {
  constructor(...t2) {
    if (this[l$1$] = null, this[p$2U] = false, this.constructor === m$1L)
      throw new Error("[accessor] cannot instantiate Accessor. This can be fixed by creating a subclass of Accessor");
    Object.defineProperty(this, "__accessor__", { enumerable: false, value: new v$T(this) }), t2.length > 0 && this.normalizeCtorArgs && (this.__accessor__.ctorArgs = this.normalizeCtorArgs.apply(this, t2));
  }
  static createSubclass(t2 = {}) {
    if (Array.isArray(t2))
      throw new Error("Multi-inheritance unsupported since 4.16");
    const { properties: r2, declaredClass: e2, constructor: s2 } = t2;
    delete t2.declaredClass, delete t2.properties, delete t2.constructor;
    const o2 = this;
    class c2 extends o2 {
      constructor(...t3) {
        super(...t3), this.inherited = null, s2 && s2.apply(this, t3);
      }
    }
    n$2j(c2.prototype);
    for (const i2 in t2) {
      const r3 = t2[i2];
      c2.prototype[i2] = typeof r3 == "function" ? function(...t3) {
        const e3 = this.inherited;
        let s3;
        this.inherited = function(...t4) {
          if (o2.prototype[i2])
            return o2.prototype[i2].apply(this, t4);
        };
        try {
          s3 = r3.apply(this, t3);
        } catch (c3) {
          throw this.inherited = e3, c3;
        }
        return this.inherited = e3, s3;
      } : t2[i2];
    }
    for (const i2 in r2) {
      const t3 = d$1v(r2[i2]);
      y$1o(t3)(c2.prototype, i2);
    }
    return n$2f(e2)(c2);
  }
  postscript(t2) {
    const r2 = this.__accessor__, e2 = r2.ctorArgs || t2;
    r2.initialize(), e2 && (this.set(e2), r2.ctorArgs = null), r2.constructed(), this.initialize(), this[f$1u] = true;
  }
  initialize() {
  }
  destroy() {
    this.destroyed || (this[y$1f] = s$26(this[y$1f]), g$10(this), this.__accessor__.destroy());
  }
  get constructed() {
    return this.__accessor__ && this.__accessor__.initialized || false;
  }
  get initialized() {
    return this[f$1u];
  }
  get destroyed() {
    return this.__accessor__ && this.__accessor__.destroyed || false;
  }
  commitProperty(t2) {
    this.get(t2);
  }
  get(t2) {
    return o$1S(this, t2);
  }
  hasOwnProperty(t2) {
    return this.__accessor__ ? this.__accessor__.has(t2) : Object.prototype.hasOwnProperty.call(this, t2);
  }
  keys() {
    return this.__accessor__ ? this.__accessor__.keys() : [];
  }
  set(t2, r2) {
    return t$1R(this, t2, r2), this;
  }
  watch(t2, r2, e2) {
    return T$p(this, t2, r2, e2);
  }
  own(t2) {
    this.addHandles(t2);
  }
  addHandles(r2, s2) {
    let o2 = this[y$1f];
    t$1W(o2) && (o2 = this[y$1f] = new t$1N()), o2.add(r2, s2);
  }
  removeHandles(t2) {
    const r2 = this[y$1f];
    t$1W(r2) || r2.remove(t2);
  }
  hasHandles(t2) {
    const r2 = this[y$1f];
    return !!r$1t(r2) && r2.has(t2);
  }
  _override(t2, r2) {
    r2 === void 0 ? this.__accessor__.clearOverride(t2) : this.__accessor__.override(t2, r2);
  }
  _clearOverride(t2) {
    return this.__accessor__.clearOverride(t2);
  }
  _overrideIfSome(t2, r2) {
    r2 == null ? this.__accessor__.clearOverride(t2) : this.__accessor__.override(t2, r2);
  }
  _isOverridden(t2) {
    return this.__accessor__.isOverridden(t2);
  }
  notifyChange(t2) {
    this.__accessor__.notifyChange(t2);
  }
  _get(t2) {
    return this.__accessor__.internalGet(t2);
  }
  _set(t2, r2) {
    return this.__accessor__.internalSet(t2, r2), this;
  }
}
l$1$ = y$1f, p$2U = f$1u;
class s$1Q {
  constructor() {
    this._values = new Map(), this.multipleOriginsSupported = false;
  }
  clone(e2) {
    const t2 = new s$1Q();
    return this._values.forEach((s2, r2) => {
      e2 && e2.has(r2) || t2.set(r2, y$1r(s2.value), s2.origin);
    }), t2;
  }
  get(i2, e2) {
    e2 = this._normalizeOrigin(e2);
    const s2 = this._values.get(i2);
    return e2 == null || (s2 == null ? void 0 : s2.origin) === e2 ? s2 == null ? void 0 : s2.value : void 0;
  }
  originOf(i2) {
    var _a2, _b2;
    return (_b2 = (_a2 = this._values.get(i2)) == null ? void 0 : _a2.origin) != null ? _b2 : r$1m.USER;
  }
  keys(i2) {
    i2 = this._normalizeOrigin(i2);
    const e2 = [...this._values.keys()];
    return i2 == null ? e2 : e2.filter((e3) => {
      var _a2;
      return ((_a2 = this._values.get(e3)) == null ? void 0 : _a2.origin) === i2;
    });
  }
  set(i2, s2, r2) {
    if ((r2 = this._normalizeOrigin(r2)) === r$1m.DEFAULTS) {
      const e2 = this._values.get(i2);
      if (e2 && e2.origin != null && e2.origin > r2)
        return;
    }
    this._values.set(i2, new t$1B(s2, r2));
  }
  delete(i2, e2) {
    var _a2;
    (e2 = this._normalizeOrigin(e2)) != null && ((_a2 = this._values.get(i2)) == null ? void 0 : _a2.origin) !== e2 || this._values.delete(i2);
  }
  has(i2, e2) {
    var _a2;
    return (e2 = this._normalizeOrigin(e2)) != null ? ((_a2 = this._values.get(i2)) == null ? void 0 : _a2.origin) === e2 : this._values.has(i2);
  }
  forEach(i2) {
    this._values.forEach(({ value: e2 }, s2) => i2(e2, s2));
  }
  _normalizeOrigin(i2) {
    if (i2 != null)
      return i2 === r$1m.DEFAULTS ? i2 : r$1m.USER;
  }
}
class t$1B {
  constructor(i2, e2) {
    this.value = i2, this.origin = e2;
  }
}
function e$1C(e2, r2, n2) {
  r2.keys().forEach((e3) => {
    n2.set(e3, r2.get(e3), r$1m.DEFAULTS);
  });
  const o2 = e2.metadatas;
  Object.keys(o2).forEach((r3) => {
    e2.internalGet(r3) && n2.set(r3, e2.internalGet(r3), r$1m.DEFAULTS);
  });
}
function s$1P(e2, r2, n2) {
  if (!e2 || !e2.read || e2.read.enabled === false || !e2.read.source)
    return false;
  const o2 = e2.read.source;
  if (typeof o2 == "string") {
    if (o2 === r2)
      return true;
    if (o2.includes(".") && o2.indexOf(r2) === 0 && s$1$(o2, n2))
      return true;
  } else
    for (const s2 of o2) {
      if (s2 === r2)
        return true;
      if (s2.includes(".") && s2.indexOf(r2) === 0 && s$1$(s2, n2))
        return true;
    }
  return false;
}
function i$2i(e2) {
  return e2 && (!e2.read || e2.read.enabled !== false && !e2.read.source);
}
function a$2o(e2, t2, r2, o2, a2) {
  let f2 = t$1P(t2[r2], a2);
  i$2i(f2) && (e2[r2] = true);
  for (const i2 of Object.getOwnPropertyNames(t2))
    f2 = t$1P(t2[i2], a2), s$1P(f2, r2, o2) && (e2[i2] = true);
}
function f$1t(e2, t2, r2, n2) {
  const s2 = r2.metadatas, i2 = a$2s(s2[t2], "any", n2), a2 = i2 && i2.default;
  if (a2 === void 0)
    return;
  const f2 = typeof a2 == "function" ? a2.call(e2, t2, n2) : a2;
  f2 !== void 0 && r2.set(t2, f2);
}
const c$2H = { origin: "service" };
function u$1O(t2, o2, s2 = c$2H) {
  if (!o2 || typeof o2 != "object")
    return;
  const i2 = e$1Q(t2), u2 = i2.metadatas, d2 = {};
  for (const e2 of Object.getOwnPropertyNames(o2))
    a$2o(d2, u2, e2, o2, s2);
  i2.setDefaultOrigin(s2.origin);
  for (const r2 of Object.getOwnPropertyNames(d2)) {
    const a2 = t$1P(u2[r2], s2).read, f2 = a2 && a2.source;
    let c2;
    c2 = f2 && typeof f2 == "string" ? u$1V(o2, f2) : o2[r2], a2 && a2.reader && (c2 = a2.reader.call(t2, c2, o2, s2)), c2 !== void 0 && i2.set(r2, c2);
  }
  if (!s2 || !s2.ignoreDefaults) {
    i2.setDefaultOrigin("defaults");
    for (const e2 of Object.getOwnPropertyNames(u2))
      d2[e2] || f$1t(t2, e2, i2, s2);
  }
  i2.setDefaultOrigin("user");
}
function d$1u(e2, t2, r2, n2 = c$2H) {
  var _a2;
  const o2 = __spreadProps(__spreadValues({}, n2), { messages: [] });
  r2(o2), (_a2 = o2.messages) == null ? void 0 : _a2.forEach((t3) => {
    t3.type !== "warning" || e2.loaded ? n2 && n2.messages && n2.messages.push(t3) : e2.loadWarnings.push(t3);
  });
}
function a$2n(r2, e2, t2, i2, o2) {
  var _a2, _b2;
  const n2 = {};
  return (_b2 = (_a2 = e2.write) == null ? void 0 : _a2.writer) == null ? void 0 : _b2.call(r2, i2, n2, t2, o2), n2;
}
function f$1s(r2, i2, s2, u2, l2, a2) {
  if (!u2 || !u2.write)
    return false;
  const f2 = r2.get(s2);
  if (!l2 && u2.write.overridePolicy) {
    const e2 = u2.write.overridePolicy.call(r2, f2, s2, a2);
    e2 !== void 0 && (l2 = e2);
  }
  if (l2 || (l2 = u2.write), !l2 || l2.enabled === false)
    return false;
  if ((f2 === null && !l2.allowNull && !l2.writerEnsuresNonNull || f2 === void 0) && l2.isRequired) {
    const i3 = new s$1Z("web-document-write:property-required", `Missing value for required property '${s2}' on '${r2.declaredClass}'`, { propertyName: s2, target: r2 });
    return i3 && a2 && a2.messages ? a2.messages.push(i3) : i3 && !a2 && s$22.getLogger("esri.core.accessorSupport.write").error(i3.name, i3.message), false;
  }
  if (f2 === void 0)
    return false;
  if (f2 === null && !l2.allowNull && !l2.writerEnsuresNonNull)
    return false;
  if ((!i2.store.multipleOriginsSupported || i2.store.originOf(s2) === r$1m.DEFAULTS) && p$2T(r2, s2, a2, u2, f2))
    return false;
  if (!l2.ignoreOrigin && a2 && a2.origin && i2.store.multipleOriginsSupported) {
    if (i2.store.originOf(s2) < t$1L(a2.origin))
      return false;
  }
  return true;
}
function p$2T(e2, t2, i2, o2, n2) {
  const s2 = o2.default;
  if (s2 === void 0)
    return false;
  if (o2.defaultEquals != null)
    return o2.defaultEquals(n2);
  if (typeof s2 == "function") {
    if (Array.isArray(n2)) {
      const o3 = s2.call(e2, t2, i2);
      return i$2x(o3, n2);
    }
    return false;
  }
  return s2 === n2;
}
function g$$(r2, e2, t2, i2) {
  const o2 = e$1Q(r2), n2 = o2.metadatas, u2 = s$1U(n2[e2], i2);
  return !!u2 && f$1s(r2, o2, e2, u2, t2, i2);
}
function c$2G(r2, e2, t2) {
  var _a2, _b2;
  if (r2 && typeof r2.toJSON == "function" && (!r2.toJSON.isDefaultToJSON || !r2.write))
    return o$1T(e2, r2.toJSON(t2));
  const o2 = e$1Q(r2), n2 = o2.metadatas;
  for (const s2 in n2) {
    const p2 = s$1U(n2[s2], t2);
    if (!f$1s(r2, o2, s2, p2, void 0, t2))
      continue;
    const g2 = r2.get(s2), c2 = a$2n(r2, p2, p2.write && typeof p2.write.target == "string" ? p2.write.target : s2, g2, t2);
    Object.keys(c2).length > 0 && (e2 = o$1T(e2, c2), ((_b2 = (_a2 = t2 == null ? void 0 : t2.resources) == null ? void 0 : _a2.pendingOperations) == null ? void 0 : _b2.length) && Promise.all(t2.resources.pendingOperations).then(() => o$1T(e2, c2)), t2 && t2.writtenProperties && t2.writtenProperties.push({ target: r2, propName: s2, oldOrigin: c$2K(o2.store.originOf(s2)), newOrigin: t2.origin }));
  }
  return e2;
}
const u$1N = (t2) => {
  let u2 = class extends t2 {
    constructor(...r2) {
      super(...r2);
      const t3 = x$N(e$1Q(this)), i2 = t3.store, p2 = new s$1Q();
      t3.store = p2, e$1C(t3, i2, p2);
    }
    read(r2, t3) {
      u$1O(this, r2, t3);
    }
    write(r2 = {}, t3) {
      return c$2G(this, r2, t3);
    }
    toJSON(r2) {
      return this.write({}, r2);
    }
    static fromJSON(r2, t3) {
      return n$28.call(this, r2, t3);
    }
  };
  return u2 = e$1W([n$2f("esri.core.JSONSupport")], u2), u2.prototype.toJSON.isDefaultToJSON = true, u2;
};
function n$28(r2, t2) {
  if (!r2)
    return null;
  if (r2.declaredClass)
    throw new Error("JSON object is already hydrated");
  const s2 = new this();
  return s2.read(r2, t2), s2;
}
let l$1_ = class extends u$1N(m$1L) {
};
l$1_ = e$1W([n$2f("esri.core.JSONSupport")], l$1_);
function o$1H(o2, e2, t2) {
  let a2, c2;
  return e2 === void 0 || Array.isArray(e2) ? (c2 = o2, t2 = e2, a2 = [void 0]) : (c2 = e2, a2 = Array.isArray(o2) ? o2 : [o2]), (o3, e3) => {
    const d2 = o3.constructor.prototype;
    a2.forEach((a3) => {
      const s2 = d$1B(o3, a3, c2);
      s2.read && typeof s2.read == "object" || (s2.read = {}), s2.read.reader = d2[e3], t2 && (s2.read.source = (s2.read.source || []).concat(t2));
    });
  };
}
function r$1h(r2, o2, e2) {
  let i2, n2;
  return o2 === void 0 ? (n2 = r2, i2 = [void 0]) : typeof o2 != "string" ? (n2 = r2, i2 = [void 0], e2 = o2) : (n2 = o2, i2 = Array.isArray(r2) ? r2 : [r2]), (r3, o3) => {
    const p2 = r3.constructor.prototype;
    for (const c2 of i2) {
      const i3 = d$1B(r3, c2, n2);
      i3.write && typeof i3.write == "object" || (i3.write = {}), e2 && (i3.write.target = e2), i3.write.writer = p2[o3];
    }
  };
}
var S$F;
!function(S2) {
  S2[S2.CGCS2000 = 4490] = "CGCS2000", S2[S2.GCSMARS2000 = 104971] = "GCSMARS2000", S2[S2.GCSMARS2000_SPHERE = 104905] = "GCSMARS2000_SPHERE", S2[S2.GCSMOON2000 = 104903] = "GCSMOON2000";
}(S$F || (S$F = {}));
let o$1G;
const r$1g = { values: [1, 0.3048, 0.3048006096012192, 0.3047972654, 0.9143917962, 0.201166195164, 0.9143984146160287, 0.3047994715386762, 20.11676512155263, 20.11678249437587, 0.9143985307444408, 0.91439523, 0.3047997101815088, 20.1168, 20.116756, 5e4, 15e4], units: ["Meter", "Foot", "Foot_US", "Foot_Clarke", "Yard_Clarke", "Link_Clarke", "Yard_Sears", "Foot_Sears", "Chain_Sears", "Chain_Benoit_1895_B", "Yard_Indian", "Yard_Indian_1937", "Foot_Gold_Coast", "Chain", "Chain_Sears_1922_Truncated", "50_Kilometers", "150_Kilometers"], 2066: 5, 2136: 12, 2155: 2, 2157: 0, 2158: 0, 2159: 12, 2160: 12, 2204: 2, 2219: 0, 2220: 0, 2254: 2, 2255: 2, 2256: 1, 2265: 1, 2266: 1, 2267: 2, 2268: 2, 2269: 1, 2270: 1, 2271: 2, 2272: 2, 2273: 1, 2294: 0, 2295: 0, 2314: 3, 2899: 2, 2900: 2, 2901: 1, 2909: 1, 2910: 1, 2911: 2, 2912: 2, 2913: 1, 2914: 1, 2992: 1, 2993: 0, 2994: 1, 3080: 1, 3089: 2, 3090: 0, 3091: 2, 3102: 2, 3141: 0, 3142: 0, 3167: 14, 3359: 2, 3360: 0, 3361: 1, 3362: 0, 3363: 2, 3364: 0, 3365: 2, 3366: 3, 3404: 2, 3405: 0, 3406: 0, 3407: 3, 3439: 0, 3440: 0, 3479: 1, 3480: 0, 3481: 1, 3482: 0, 3483: 1, 3484: 0, 3485: 2, 3486: 0, 3487: 2, 3488: 0, 3489: 0, 3490: 2, 3491: 0, 3492: 2, 3493: 0, 3494: 2, 3495: 0, 3496: 2, 3497: 0, 3498: 2, 3499: 0, 3500: 2, 3501: 0, 3502: 2, 3503: 0, 3504: 2, 3505: 0, 3506: 2, 3507: 0, 3508: 2, 3509: 0, 3510: 2, 3511: 0, 3512: 2, 3513: 0, 3514: 0, 3515: 2, 3516: 0, 3517: 2, 3518: 0, 3519: 2, 3520: 0, 3521: 2, 3522: 0, 3523: 2, 3524: 0, 3525: 2, 3526: 0, 3527: 2, 3528: 0, 3529: 2, 3530: 0, 3531: 2, 3532: 0, 3533: 2, 3534: 0, 3535: 2, 3536: 0, 3537: 2, 3538: 0, 3539: 2, 3540: 0, 3541: 2, 3542: 0, 3543: 2, 3544: 0, 3545: 2, 3546: 0, 3547: 2, 3548: 0, 3549: 2, 3550: 0, 3551: 2, 3552: 0, 3553: 2, 3582: 2, 3583: 0, 3584: 2, 3585: 0, 3586: 2, 3587: 0, 3588: 1, 3589: 0, 3590: 1, 3591: 0, 3592: 0, 3593: 1, 3598: 2, 3599: 0, 3600: 2, 3605: 1, 3606: 0, 3607: 0, 3608: 2, 3609: 0, 3610: 2, 3611: 0, 3612: 2, 3613: 0, 3614: 2, 3615: 0, 3616: 2, 3617: 0, 3618: 2, 3619: 0, 3620: 2, 3621: 0, 3622: 2, 3623: 0, 3624: 2, 3625: 0, 3626: 2, 3627: 0, 3628: 2, 3629: 0, 3630: 2, 3631: 0, 3632: 2, 3633: 0, 3634: 1, 3635: 0, 3636: 1, 3640: 2, 3641: 0, 3642: 2, 3643: 0, 3644: 1, 3645: 0, 3646: 1, 3647: 0, 3648: 1, 3649: 0, 3650: 2, 3651: 0, 3652: 2, 3653: 0, 3654: 2, 3655: 0, 3656: 1, 3657: 0, 3658: 2, 3659: 0, 3660: 2, 3661: 0, 3662: 2, 3663: 0, 3664: 2, 3668: 2, 3669: 0, 3670: 2, 3671: 0, 3672: 2, 3673: 0, 3674: 2, 3675: 0, 3676: 1, 3677: 2, 3678: 0, 3679: 1, 3680: 2, 3681: 0, 3682: 1, 3683: 2, 3684: 0, 3685: 0, 3686: 2, 3687: 0, 3688: 2, 3689: 0, 3690: 2, 3691: 0, 3692: 2, 3696: 2, 3697: 0, 3698: 2, 3699: 0, 3700: 2, 3793: 0, 3794: 0, 3812: 0, 3854: 0, 3857: 0, 3920: 0, 3978: 0, 3979: 0, 3991: 2, 3992: 2, 4026: 0, 4037: 0, 4038: 0, 4071: 0, 4082: 0, 4083: 0, 4087: 0, 4088: 0, 4217: 2, 4414: 0, 4415: 0, 4417: 0, 4434: 0, 4437: 0, 4438: 2, 4439: 2, 4462: 0, 4467: 0, 4471: 0, 4474: 0, 4559: 0, 4647: 0, 4822: 0, 4826: 0, 4839: 0, 5018: 0, 5048: 0, 5167: 0, 5168: 0, 5221: 0, 5223: 0, 5234: 0, 5235: 0, 5243: 0, 5247: 0, 5266: 0, 5316: 0, 5320: 0, 5321: 0, 5325: 0, 5337: 0, 5361: 0, 5362: 0, 5367: 0, 5382: 0, 5383: 0, 5396: 0, 5456: 0, 5457: 0, 5469: 0, 5472: 4, 5490: 0, 5513: 0, 5514: 0, 5523: 0, 5559: 0, 5588: 1, 5589: 3, 5596: 0, 5627: 0, 5629: 0, 5641: 0, 5643: 0, 5644: 0, 5646: 2, 5654: 2, 5655: 2, 5659: 0, 5700: 0, 5825: 0, 5836: 0, 5837: 0, 5839: 0, 5842: 0, 5844: 0, 5858: 0, 5879: 0, 5880: 0, 5887: 0, 5890: 0, 6128: 1, 6129: 1, 6141: 1, 6204: 0, 6210: 0, 6211: 0, 6307: 0, 6312: 0, 6316: 0, 6362: 0, 6391: 1, 6405: 1, 6406: 0, 6407: 1, 6408: 0, 6409: 1, 6410: 0, 6411: 2, 6412: 0, 6413: 2, 6414: 0, 6415: 0, 6416: 2, 6417: 0, 6418: 2, 6419: 0, 6420: 2, 6421: 0, 6422: 2, 6423: 0, 6424: 2, 6425: 0, 6426: 2, 6427: 0, 6428: 2, 6429: 0, 6430: 2, 6431: 0, 6432: 2, 6433: 0, 6434: 2, 6435: 0, 6436: 2, 6437: 0, 6438: 2, 6439: 0, 6440: 0, 6441: 2, 6442: 0, 6443: 2, 6444: 0, 6445: 2, 6446: 0, 6447: 2, 6448: 0, 6449: 2, 6450: 0, 6451: 2, 6452: 0, 6453: 2, 6454: 0, 6455: 2, 6456: 0, 6457: 2, 6458: 0, 6459: 2, 6460: 0, 6461: 2, 6462: 0, 6463: 2, 6464: 0, 6465: 2, 6466: 0, 6467: 2, 6468: 0, 6469: 2, 6470: 0, 6471: 2, 6472: 0, 6473: 2, 6474: 0, 6475: 2, 6476: 0, 6477: 2, 6478: 0, 6479: 2, 6484: 2, 6485: 0, 6486: 2, 6487: 0, 6488: 2, 6489: 0, 6490: 2, 6491: 0, 6492: 2, 6493: 0, 6494: 1, 6495: 0, 6496: 1, 6497: 0, 6498: 0, 6499: 1, 6500: 0, 6501: 2, 6502: 0, 6503: 2, 6504: 0, 6505: 2, 6506: 0, 6507: 2, 6508: 0, 6509: 0, 6510: 2, 6515: 1, 6516: 0, 6518: 0, 6519: 2, 6520: 0, 6521: 2, 6522: 0, 6523: 2, 6524: 0, 6525: 2, 6526: 0, 6527: 2, 6528: 0, 6529: 2, 6530: 0, 6531: 2, 6532: 0, 6533: 2, 6534: 0, 6535: 2, 6536: 0, 6537: 2, 6538: 0, 6539: 2, 6540: 0, 6541: 2, 6542: 0, 6543: 2, 6544: 0, 6545: 1, 6546: 0, 6547: 1, 6548: 0, 6549: 2, 6550: 0, 6551: 2, 6552: 0, 6553: 2, 6554: 0, 6555: 2, 6556: 0, 6557: 1, 6558: 0, 6559: 1, 6560: 0, 6561: 1, 6562: 0, 6563: 2, 6564: 0, 6565: 2, 6566: 0, 6567: 0, 6568: 2, 6569: 0, 6570: 1, 6571: 0, 6572: 2, 6573: 0, 6574: 2, 6575: 0, 6576: 2, 6577: 0, 6578: 2, 6582: 2, 6583: 0, 6584: 2, 6585: 0, 6586: 2, 6587: 0, 6588: 2, 6589: 0, 6590: 2, 6591: 0, 6592: 0, 6593: 2, 6594: 0, 6595: 2, 6596: 0, 6597: 2, 6598: 0, 6599: 2, 6600: 0, 6601: 2, 6602: 0, 6603: 2, 6605: 2, 6606: 0, 6607: 2, 6608: 0, 6609: 2, 6610: 0, 6611: 0, 6612: 2, 6613: 0, 6614: 2, 6615: 0, 6616: 2, 6617: 0, 6618: 2, 6633: 2, 6646: 0, 6703: 0, 6784: 0, 6785: 1, 6786: 0, 6787: 1, 6788: 0, 6789: 1, 6790: 0, 6791: 1, 6792: 0, 6793: 1, 6794: 0, 6795: 1, 6796: 0, 6797: 1, 6798: 0, 6799: 1, 6800: 0, 6801: 1, 6802: 0, 6803: 1, 6804: 0, 6805: 1, 6806: 0, 6807: 1, 6808: 0, 6809: 1, 6810: 0, 6811: 1, 6812: 0, 6813: 1, 6814: 0, 6815: 1, 6816: 0, 6817: 1, 6818: 0, 6819: 1, 6820: 0, 6821: 1, 6822: 0, 6823: 1, 6824: 0, 6825: 1, 6826: 0, 6827: 1, 6828: 0, 6829: 1, 6830: 0, 6831: 1, 6832: 0, 6833: 1, 6834: 0, 6835: 1, 6836: 0, 6837: 1, 6838: 0, 6839: 1, 6840: 0, 6841: 1, 6842: 0, 6843: 1, 6844: 0, 6845: 1, 6846: 0, 6847: 1, 6848: 0, 6849: 1, 6850: 0, 6851: 1, 6852: 0, 6853: 1, 6854: 0, 6855: 1, 6856: 0, 6857: 1, 6858: 0, 6859: 1, 6860: 0, 6861: 1, 6862: 0, 6863: 1, 6867: 0, 6868: 1, 6870: 0, 6875: 0, 6876: 0, 6879: 0, 6880: 2, 6884: 0, 6885: 1, 6886: 0, 6887: 1, 6915: 0, 6922: 0, 6923: 2, 6924: 0, 6925: 2, 6962: 0, 6984: 0, 6991: 0, 7128: 2, 7131: 0, 7132: 2, 7142: 0, 7257: 0, 7258: 2, 7259: 0, 7260: 2, 7261: 0, 7262: 2, 7263: 0, 7264: 2, 7265: 0, 7266: 2, 7267: 0, 7268: 2, 7269: 0, 7270: 2, 7271: 0, 7272: 2, 7273: 0, 7274: 2, 7275: 0, 7276: 2, 7277: 0, 7278: 2, 7279: 0, 7280: 2, 7281: 0, 7282: 2, 7283: 0, 7284: 2, 7285: 0, 7286: 2, 7287: 0, 7288: 2, 7289: 0, 7290: 2, 7291: 0, 7292: 2, 7293: 0, 7294: 2, 7295: 0, 7296: 2, 7297: 0, 7298: 2, 7299: 0, 7300: 2, 7301: 0, 7302: 2, 7303: 0, 7304: 2, 7305: 0, 7306: 2, 7307: 0, 7308: 2, 7309: 0, 7310: 2, 7311: 0, 7312: 2, 7313: 0, 7314: 2, 7315: 0, 7316: 2, 7317: 0, 7318: 2, 7319: 0, 7320: 2, 7321: 0, 7322: 2, 7323: 0, 7324: 2, 7325: 0, 7326: 2, 7327: 0, 7328: 2, 7329: 0, 7330: 2, 7331: 0, 7332: 2, 7333: 0, 7334: 2, 7335: 0, 7336: 2, 7337: 0, 7338: 2, 7339: 0, 7340: 2, 7341: 0, 7342: 2, 7343: 0, 7344: 2, 7345: 0, 7346: 2, 7347: 0, 7348: 2, 7349: 0, 7350: 2, 7351: 0, 7352: 2, 7353: 0, 7354: 2, 7355: 0, 7356: 2, 7357: 0, 7358: 2, 7359: 0, 7360: 2, 7361: 0, 7362: 2, 7363: 0, 7364: 2, 7365: 0, 7366: 2, 7367: 0, 7368: 2, 7369: 0, 7370: 2, 7877: 0, 7878: 0, 7882: 0, 7883: 0, 7887: 0, 7899: 0, 7991: 0, 7992: 0, 8035: 2, 8036: 2, 8058: 0, 8059: 0, 8082: 0, 8083: 0, 8088: 0, 8090: 0, 8091: 2, 8092: 0, 8093: 2, 8095: 0, 8096: 2, 8097: 0, 8098: 2, 8099: 0, 8100: 2, 8101: 0, 8102: 2, 8103: 0, 8104: 2, 8105: 0, 8106: 2, 8107: 0, 8108: 2, 8109: 0, 8110: 2, 8111: 0, 8112: 2, 8113: 0, 8114: 2, 8115: 0, 8116: 2, 8117: 0, 8118: 2, 8119: 0, 8120: 2, 8121: 0, 8122: 2, 8123: 0, 8124: 2, 8125: 0, 8126: 2, 8127: 0, 8128: 2, 8129: 0, 8130: 2, 8131: 0, 8132: 2, 8133: 0, 8134: 2, 8135: 0, 8136: 2, 8137: 0, 8138: 2, 8139: 0, 8140: 2, 8141: 0, 8142: 2, 8143: 0, 8144: 2, 8145: 0, 8146: 2, 8147: 0, 8148: 2, 8149: 0, 8150: 2, 8151: 0, 8152: 2, 8153: 0, 8154: 2, 8155: 0, 8156: 2, 8157: 0, 8158: 2, 8159: 0, 8160: 2, 8161: 0, 8162: 2, 8163: 0, 8164: 2, 8165: 0, 8166: 2, 8167: 0, 8168: 2, 8169: 0, 8170: 2, 8171: 0, 8172: 2, 8173: 0, 8177: 2, 8179: 0, 8180: 2, 8181: 0, 8182: 2, 8184: 0, 8185: 2, 8187: 0, 8189: 2, 8191: 0, 8193: 2, 8196: 0, 8197: 2, 8198: 0, 8200: 2, 8201: 0, 8202: 2, 8203: 0, 8204: 2, 8205: 0, 8206: 2, 8207: 0, 8208: 2, 8209: 0, 8210: 2, 8212: 0, 8213: 2, 8214: 0, 8216: 2, 8218: 0, 8220: 2, 8222: 0, 8224: 2, 8225: 0, 8226: 2, 8311: 0, 8312: 1, 8313: 0, 8314: 1, 8315: 0, 8316: 1, 8317: 0, 8318: 1, 8319: 0, 8320: 1, 8321: 0, 8322: 1, 8323: 0, 8324: 1, 8325: 0, 8326: 1, 8327: 0, 8328: 1, 8329: 0, 8330: 1, 8331: 0, 8332: 1, 8333: 0, 8334: 1, 8335: 0, 8336: 1, 8337: 0, 8338: 1, 8339: 0, 8340: 1, 8341: 0, 8342: 1, 8343: 0, 8344: 1, 8345: 0, 8346: 1, 8347: 0, 8348: 1, 8352: 0, 8353: 0, 8379: 0, 8380: 2, 8381: 0, 8382: 2, 8383: 0, 8384: 2, 8385: 0, 8387: 2, 8391: 0, 8395: 0, 8433: 0, 8441: 0, 8455: 0, 8456: 0, 8531: 2, 8682: 0, 8686: 0, 8687: 0, 8692: 0, 8693: 0, 8826: 0, 8903: 0, 8950: 0, 8951: 0, 9039: 0, 9040: 0, 9141: 0, 9149: 0, 9150: 0, 9191: 0, 9221: 0, 9222: 0, 9249: 0, 9250: 0, 9252: 0, 9254: 0, 9265: 0, 9284: 0, 9285: 0, 9300: 0, 9354: 0, 9367: 0, 9373: 0, 9377: 0, 9387: 0, 9391: 0, 9456: 0, 9473: 0, 9498: 0, 9674: 0, 9678: 0, 9680: 0, 9709: 0, 9712: 0, 9713: 0, 9716: 0, 9741: 0, 9748: 2, 9749: 2, 9761: 0, 9766: 0, 20499: 0, 20538: 0, 20539: 0, 20790: 0, 20791: 0, 21291: 0, 21292: 0, 21500: 0, 21817: 0, 21818: 0, 22032: 0, 22033: 0, 22091: 0, 22092: 0, 22332: 0, 22391: 0, 22392: 0, 22700: 0, 22770: 0, 22780: 0, 22832: 0, 23090: 0, 23095: 0, 23239: 0, 23240: 0, 23433: 0, 23700: 0, 24047: 0, 24048: 0, 24100: 3, 24200: 0, 24305: 0, 24306: 0, 24382: 10, 24383: 0, 24500: 0, 24547: 0, 24548: 0, 24571: 9, 24600: 0, 25e3: 0, 25231: 0, 25884: 0, 25932: 0, 26237: 0, 26331: 0, 26332: 0, 26432: 0, 26591: 0, 26592: 0, 26632: 0, 26692: 0, 27120: 0, 27200: 0, 27291: 6, 27292: 6, 27429: 0, 27492: 0, 27493: 0, 27500: 0, 27700: 0, 28232: 0, 28600: 0, 28991: 0, 28992: 0, 29100: 0, 29101: 0, 29220: 0, 29221: 0, 29333: 0, 29635: 0, 29636: 0, 29701: 0, 29738: 0, 29739: 0, 29849: 0, 29850: 0, 29871: 8, 29872: 7, 29873: 0, 29874: 0, 30200: 5, 30339: 0, 30340: 0, 30591: 0, 30592: 0, 30791: 0, 30792: 0, 30800: 0, 31028: 0, 31121: 0, 31154: 0, 31170: 0, 31171: 0, 31370: 0, 31528: 0, 31529: 0, 31600: 0, 31700: 0, 31838: 0, 31839: 0, 31900: 0, 31901: 0, 32061: 0, 32062: 0, 32098: 0, 32099: 2, 32100: 0, 32104: 0, 32161: 0, 32766: 0, 53048: 0, 53049: 0, 54090: 0, 54091: 0, 65061: 2, 65062: 2, 65161: 0, 65163: 0, 102041: 2, 102064: 11, 102068: 15, 102069: 16, 102118: 2, 102119: 1, 102120: 2, 102121: 2, 102217: 2, 102218: 0, 102219: 2, 102220: 2, 102378: 1, 102379: 1, 102380: 0, 102381: 1, 102589: 2, 102599: 2, 102600: 2, 102604: 2, 102647: 0, 102704: 2, 102705: 2, 102706: 0, 102759: 1, 102760: 1, 102761: 2, 102762: 0, 102763: 2, 102764: 0, 102765: 0, 102766: 2, 102970: 1, 102974: 2, 102993: 0, 102994: 0, 102995: 2, 102996: 2, 103015: 0, 103016: 2, 103017: 0, 103018: 2, 103025: 0, 103026: 0, 103027: 2, 103028: 2, 103035: 0, 103036: 0, 103037: 2, 103038: 2, 103039: 0, 103040: 0, 103041: 2, 103042: 2, 103043: 0, 103044: 0, 103045: 2, 103046: 2, 103047: 0, 103048: 0, 103049: 2, 103050: 2, 103051: 0, 103052: 2, 103053: 0, 103054: 2, 103055: 0, 103056: 2, 103057: 0, 103058: 0, 103059: 2, 103060: 2, 103061: 0, 103062: 0, 103063: 2, 103064: 2, 103069: 2, 103070: 0, 103071: 0, 103072: 2, 103073: 2, 103086: 0, 103087: 0, 103088: 2, 103089: 2, 103094: 1, 103095: 0, 103096: 2, 103103: 0, 103104: 2, 103105: 0, 103106: 2, 103121: 0, 103122: 2, 103123: 0, 103124: 0, 103125: 1, 103126: 1, 103127: 0, 103128: 0, 103129: 2, 103130: 2, 103131: 0, 103132: 0, 103133: 2, 103134: 2, 103135: 0, 103136: 0, 103137: 1, 103138: 1, 103139: 0, 103140: 2, 103141: 0, 103142: 2, 103143: 0, 103144: 2, 103145: 0, 103146: 1, 103147: 0, 103148: 0, 103149: 2, 103150: 2, 103151: 0, 103152: 2, 103172: 0, 103173: 2, 103174: 0, 103175: 0, 103176: 2, 103177: 2, 103178: 0, 103179: 0, 103180: 2, 103181: 2, 103182: 0, 103183: 0, 103184: 2, 103185: 2, 103228: 0, 103229: 0, 103230: 2, 103231: 2, 103250: 0, 103251: 2, 103252: 0, 103253: 2, 103260: 0, 103261: 0, 103262: 2, 103263: 2, 103270: 0, 103271: 0, 103272: 2, 103273: 2, 103274: 0, 103275: 0, 103276: 2, 103277: 2, 103278: 0, 103279: 0, 103280: 2, 103281: 2, 103282: 0, 103283: 0, 103284: 2, 103285: 2, 103286: 0, 103287: 2, 103288: 0, 103289: 2, 103290: 0, 103291: 2, 103292: 0, 103293: 0, 103294: 2, 103295: 2, 103296: 0, 103297: 0, 103298: 2, 103299: 2, 103376: 2, 103377: 0, 103378: 0, 103379: 2, 103380: 2, 103393: 0, 103394: 0, 103395: 2, 103396: 2, 103472: 0, 103473: 1, 103474: 0, 103475: 2, 103482: 0, 103483: 2, 103484: 0, 103485: 2, 103500: 0, 103501: 2, 103502: 0, 103503: 0, 103504: 1, 103505: 1, 103506: 0, 103507: 0, 103508: 2, 103509: 2, 103510: 0, 103511: 0, 103512: 2, 103513: 2, 103514: 0, 103515: 2, 103516: 0, 103517: 2, 103518: 0, 103519: 2, 103520: 0, 103521: 1, 103522: 0, 103523: 0, 103524: 2, 103525: 2, 103526: 0, 103527: 2, 103561: 2, 103562: 2, 103563: 0, 103564: 0, 103565: 2, 103566: 2, 103567: 0, 103568: 0, 103569: 2, 103570: 2, 103584: 0, 103585: 2, 103586: 0, 103587: 2, 103588: 1, 103589: 0, 103590: 2, 103591: 1, 103592: 0, 103593: 2, 103594: 1, 103695: 2 };
for (o$1G = 2e3; o$1G <= 2045; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 2056; o$1G <= 2065; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 2067; o$1G <= 2135; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 2137; o$1G <= 2154; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 2161; o$1G <= 2170; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 2172; o$1G <= 2193; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 2195; o$1G <= 2198; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 2200; o$1G <= 2203; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 2205; o$1G <= 2217; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 2222; o$1G <= 2224; o$1G++)
  r$1g[o$1G] = 1;
for (o$1G = 2225; o$1G <= 2250; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 2251; o$1G <= 2253; o$1G++)
  r$1g[o$1G] = 1;
for (o$1G = 2257; o$1G <= 2264; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 2274; o$1G <= 2279; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 2280; o$1G <= 2282; o$1G++)
  r$1g[o$1G] = 1;
for (o$1G = 2283; o$1G <= 2289; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 2290; o$1G <= 2292; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 2308; o$1G <= 2313; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 2315; o$1G <= 2491; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 2494; o$1G <= 2866; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 2867; o$1G <= 2869; o$1G++)
  r$1g[o$1G] = 1;
for (o$1G = 2870; o$1G <= 2888; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 2891; o$1G <= 2895; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 2896; o$1G <= 2898; o$1G++)
  r$1g[o$1G] = 1;
for (o$1G = 2902; o$1G <= 2908; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 2915; o$1G <= 2920; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 2921; o$1G <= 2923; o$1G++)
  r$1g[o$1G] = 1;
for (o$1G = 2924; o$1G <= 2930; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 2931; o$1G <= 2962; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 2964; o$1G <= 2968; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 2969; o$1G <= 2973; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 2975; o$1G <= 2991; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 2995; o$1G <= 3051; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 3054; o$1G <= 3079; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 3081; o$1G <= 3088; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 3092; o$1G <= 3101; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 3106; o$1G <= 3138; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 3146; o$1G <= 3151; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 3153; o$1G <= 3166; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 3168; o$1G <= 3172; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 3174; o$1G <= 3203; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 3294; o$1G <= 3358; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 3367; o$1G <= 3403; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 3408; o$1G <= 3416; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 3417; o$1G <= 3438; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 3441; o$1G <= 3446; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 3447; o$1G <= 3450; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 3451; o$1G <= 3459; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 3460; o$1G <= 3478; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 3554; o$1G <= 3559; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 3560; o$1G <= 3570; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 3571; o$1G <= 3581; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 3594; o$1G <= 3597; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 3601; o$1G <= 3604; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 3637; o$1G <= 3639; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 3665; o$1G <= 3667; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 3693; o$1G <= 3695; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 3701; o$1G <= 3727; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 3728; o$1G <= 3739; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 3740; o$1G <= 3751; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 3753; o$1G <= 3760; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 3761; o$1G <= 3773; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 3775; o$1G <= 3777; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 3779; o$1G <= 3781; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 3783; o$1G <= 3785; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 3788; o$1G <= 3791; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 3797; o$1G <= 3802; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 3814; o$1G <= 3816; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 3825; o$1G <= 3829; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 3832; o$1G <= 3841; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 3844; o$1G <= 3852; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 3873; o$1G <= 3885; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 3890; o$1G <= 3893; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 3907; o$1G <= 3912; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 3942; o$1G <= 3950; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 3968; o$1G <= 3970; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 3973; o$1G <= 3976; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 3986; o$1G <= 3989; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 3994; o$1G <= 3997; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 4048; o$1G <= 4051; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 4056; o$1G <= 4063; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 4093; o$1G <= 4096; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 4390; o$1G <= 4398; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 4399; o$1G <= 4413; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 4418; o$1G <= 4433; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 4455; o$1G <= 4457; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 4484; o$1G <= 4489; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 4491; o$1G <= 4554; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 4568; o$1G <= 4589; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 4652; o$1G <= 4656; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 4766; o$1G <= 4800; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 5014; o$1G <= 5016; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 5069; o$1G <= 5072; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 5105; o$1G <= 5130; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 5173; o$1G <= 5188; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 5253; o$1G <= 5259; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 5269; o$1G <= 5275; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 5292; o$1G <= 5311; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 5329; o$1G <= 5331; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 5343; o$1G <= 5349; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 5355; o$1G <= 5357; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 5387; o$1G <= 5389; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 5459; o$1G <= 5463; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 5479; o$1G <= 5482; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 5518; o$1G <= 5520; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 5530; o$1G <= 5539; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 5550; o$1G <= 5552; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 5562; o$1G <= 5583; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 5623; o$1G <= 5625; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 5631; o$1G <= 5639; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 5649; o$1G <= 5653; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 5663; o$1G <= 5680; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 5682; o$1G <= 5685; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 5875; o$1G <= 5877; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 5896; o$1G <= 5899; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 5921; o$1G <= 5940; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 6050; o$1G <= 6125; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 6244; o$1G <= 6275; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 6328; o$1G <= 6348; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 6350; o$1G <= 6356; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 6366; o$1G <= 6372; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 6381; o$1G <= 6387; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 6393; o$1G <= 6404; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 6480; o$1G <= 6483; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 6511; o$1G <= 6514; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 6579; o$1G <= 6581; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 6619; o$1G <= 6624; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 6625; o$1G <= 6627; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 6628; o$1G <= 6632; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 6634; o$1G <= 6637; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 6669; o$1G <= 6692; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 6707; o$1G <= 6709; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 6720; o$1G <= 6723; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 6732; o$1G <= 6738; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 6931; o$1G <= 6933; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 6956; o$1G <= 6959; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 7005; o$1G <= 7007; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 7057; o$1G <= 7070; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 7074; o$1G <= 7082; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 7109; o$1G <= 7118; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 7119; o$1G <= 7127; o$1G++)
  r$1g[o$1G] = 1;
for (o$1G = 7374; o$1G <= 7376; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 7528; o$1G <= 7586; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 7587; o$1G <= 7645; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 7692; o$1G <= 7696; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 7755; o$1G <= 7787; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 7791; o$1G <= 7795; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 7799; o$1G <= 7801; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 7803; o$1G <= 7805; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 7825; o$1G <= 7831; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 7845; o$1G <= 7859; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 8013; o$1G <= 8032; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 8065; o$1G <= 8068; o$1G++)
  r$1g[o$1G] = 1;
for (o$1G = 8518; o$1G <= 8529; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 8533; o$1G <= 8536; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 8538; o$1G <= 8540; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 8677; o$1G <= 8679; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 8836; o$1G <= 8840; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 8857; o$1G <= 8859; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 8908; o$1G <= 8910; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 9154; o$1G <= 9159; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 9205; o$1G <= 9218; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 9271; o$1G <= 9273; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 9295; o$1G <= 9297; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 9356; o$1G <= 9360; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 9404; o$1G <= 9407; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 9476; o$1G <= 9482; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 9487; o$1G <= 9494; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 9697; o$1G <= 9699; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 20002; o$1G <= 20032; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 20062; o$1G <= 20092; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 20135; o$1G <= 20138; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 20248; o$1G <= 20258; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 20348; o$1G <= 20358; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 20436; o$1G <= 20440; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 20822; o$1G <= 20824; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 20904; o$1G <= 20932; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 20934; o$1G <= 20936; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 21004; o$1G <= 21032; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 21035; o$1G <= 21037; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 21095; o$1G <= 21097; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 21148; o$1G <= 21150; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 21207; o$1G <= 21264; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 21307; o$1G <= 21364; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 21413; o$1G <= 21423; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 21453; o$1G <= 21463; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 21473; o$1G <= 21483; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 21780; o$1G <= 21782; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 21891; o$1G <= 21894; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 21896; o$1G <= 21899; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 22171; o$1G <= 22177; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 22181; o$1G <= 22187; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 22191; o$1G <= 22197; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 22234; o$1G <= 22236; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 22521; o$1G <= 22525; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 22991; o$1G <= 22994; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 23028; o$1G <= 23038; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 23830; o$1G <= 23853; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 23866; o$1G <= 23872; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 23877; o$1G <= 23884; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 23886; o$1G <= 23894; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 23946; o$1G <= 23948; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 24311; o$1G <= 24313; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 24342; o$1G <= 24347; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 24370; o$1G <= 24374; o$1G++)
  r$1g[o$1G] = 10;
for (o$1G = 24375; o$1G <= 24381; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 24718; o$1G <= 24721; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 24817; o$1G <= 24821; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 24877; o$1G <= 24882; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 24891; o$1G <= 24893; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 25391; o$1G <= 25395; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 25828; o$1G <= 25838; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 26191; o$1G <= 26195; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 26391; o$1G <= 26393; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 26701; o$1G <= 26722; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 26729; o$1G <= 26799; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 26801; o$1G <= 26803; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 26811; o$1G <= 26813; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 26847; o$1G <= 26870; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 26891; o$1G <= 26899; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 26901; o$1G <= 26923; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 26929; o$1G <= 26946; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 26948; o$1G <= 26998; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 27037; o$1G <= 27040; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 27205; o$1G <= 27232; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 27258; o$1G <= 27260; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 27391; o$1G <= 27398; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 27561; o$1G <= 27564; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 27571; o$1G <= 27574; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 27581; o$1G <= 27584; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 27591; o$1G <= 27594; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 28191; o$1G <= 28193; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 28348; o$1G <= 28358; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 28402; o$1G <= 28432; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 28462; o$1G <= 28492; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 29118; o$1G <= 29122; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 29168; o$1G <= 29172; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 29177; o$1G <= 29185; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 29187; o$1G <= 29195; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 29900; o$1G <= 29903; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 30161; o$1G <= 30179; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 30491; o$1G <= 30494; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 30729; o$1G <= 30732; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 31251; o$1G <= 31259; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 31265; o$1G <= 31268; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 31275; o$1G <= 31279; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 31281; o$1G <= 31297; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 31461; o$1G <= 31469; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 31491; o$1G <= 31495; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 31917; o$1G <= 31922; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 31965; o$1G <= 32e3; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 32001; o$1G <= 32003; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 32005; o$1G <= 32031; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 32033; o$1G <= 32060; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 32064; o$1G <= 32067; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 32074; o$1G <= 32077; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 32081; o$1G <= 32086; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 32107; o$1G <= 32130; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 32133; o$1G <= 32158; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 32164; o$1G <= 32167; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 32180; o$1G <= 32199; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 32201; o$1G <= 32260; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 32301; o$1G <= 32360; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 32601; o$1G <= 32662; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 32664; o$1G <= 32667; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 32701; o$1G <= 32761; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 53001; o$1G <= 53004; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 53008; o$1G <= 53019; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 53021; o$1G <= 53032; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 53034; o$1G <= 53037; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 53042; o$1G <= 53046; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 53074; o$1G <= 53080; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 54001; o$1G <= 54004; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 54008; o$1G <= 54019; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 54021; o$1G <= 54032; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 54034; o$1G <= 54037; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 54042; o$1G <= 54046; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 54048; o$1G <= 54053; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 54074; o$1G <= 54080; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 54098; o$1G <= 54101; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 102001; o$1G <= 102040; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 102042; o$1G <= 102063; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 102065; o$1G <= 102067; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 102070; o$1G <= 102117; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 102122; o$1G <= 102216; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 102221; o$1G <= 102377; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 102382; o$1G <= 102388; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 102389; o$1G <= 102398; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 102399; o$1G <= 102444; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 102445; o$1G <= 102447; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 102448; o$1G <= 102458; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 102459; o$1G <= 102468; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 102469; o$1G <= 102499; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 102500; o$1G <= 102519; o$1G++)
  r$1g[o$1G] = 1;
for (o$1G = 102520; o$1G <= 102524; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 102525; o$1G <= 102529; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 102530; o$1G <= 102588; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 102590; o$1G <= 102598; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 102601; o$1G <= 102603; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 102605; o$1G <= 102628; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 102629; o$1G <= 102646; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 102648; o$1G <= 102700; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 102701; o$1G <= 102703; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 102707; o$1G <= 102730; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 102733; o$1G <= 102758; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 102767; o$1G <= 102900; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 102901; o$1G <= 102933; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 102934; o$1G <= 102950; o$1G++)
  r$1g[o$1G] = 13;
for (o$1G = 102951; o$1G <= 102955; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 102961; o$1G <= 102963; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 102965; o$1G <= 102969; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 102971; o$1G <= 102973; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 102975; o$1G <= 102989; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 102990; o$1G <= 102992; o$1G++)
  r$1g[o$1G] = 1;
for (o$1G = 102997; o$1G <= 103002; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 103003; o$1G <= 103008; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 103009; o$1G <= 103011; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 103012; o$1G <= 103014; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 103019; o$1G <= 103021; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 103022; o$1G <= 103024; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 103029; o$1G <= 103031; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 103032; o$1G <= 103034; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 103065; o$1G <= 103068; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 103074; o$1G <= 103076; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 103077; o$1G <= 103079; o$1G++)
  r$1g[o$1G] = 1;
for (o$1G = 103080; o$1G <= 103082; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 103083; o$1G <= 103085; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 103090; o$1G <= 103093; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 103097; o$1G <= 103099; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 103100; o$1G <= 103102; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 103107; o$1G <= 103109; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 103110; o$1G <= 103112; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 103113; o$1G <= 103116; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 103117; o$1G <= 103120; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 103153; o$1G <= 103157; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 103158; o$1G <= 103162; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 103163; o$1G <= 103165; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 103166; o$1G <= 103168; o$1G++)
  r$1g[o$1G] = 1;
for (o$1G = 103169; o$1G <= 103171; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 103186; o$1G <= 103188; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 103189; o$1G <= 103191; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 103192; o$1G <= 103195; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 103196; o$1G <= 103199; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 103200; o$1G <= 103224; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 103225; o$1G <= 103227; o$1G++)
  r$1g[o$1G] = 1;
for (o$1G = 103232; o$1G <= 103237; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 103238; o$1G <= 103243; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 103244; o$1G <= 103246; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 103247; o$1G <= 103249; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 103254; o$1G <= 103256; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 103257; o$1G <= 103259; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 103264; o$1G <= 103266; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 103267; o$1G <= 103269; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 103300; o$1G <= 103375; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 103381; o$1G <= 103383; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 103384; o$1G <= 103386; o$1G++)
  r$1g[o$1G] = 1;
for (o$1G = 103387; o$1G <= 103389; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 103390; o$1G <= 103392; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 103397; o$1G <= 103399; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 103400; o$1G <= 103471; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 103476; o$1G <= 103478; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 103479; o$1G <= 103481; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 103486; o$1G <= 103488; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 103489; o$1G <= 103491; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 103492; o$1G <= 103495; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 103496; o$1G <= 103499; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 103528; o$1G <= 103543; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 103544; o$1G <= 103548; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 103549; o$1G <= 103551; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 103552; o$1G <= 103554; o$1G++)
  r$1g[o$1G] = 1;
for (o$1G = 103555; o$1G <= 103557; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 103558; o$1G <= 103560; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 103571; o$1G <= 103573; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 103574; o$1G <= 103576; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 103577; o$1G <= 103580; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 103581; o$1G <= 103583; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 103595; o$1G <= 103694; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 103696; o$1G <= 103699; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 103700; o$1G <= 103793; o$1G++)
  r$1g[o$1G] = 2;
for (o$1G = 103794; o$1G <= 103887; o$1G++)
  r$1g[o$1G] = 0;
for (o$1G = 103900; o$1G <= 103971; o$1G++)
  r$1g[o$1G] = 2;
const t$1A = { 102113: true, 102100: true, 3857: true, 3785: true }, _$A = { 4326: true, 3785: true, 3857: true, 102113: true, 102100: true, 104905: true, 104971: true }, l$1Z = 'PROJCS["WGS_1984_Web_Mercator_Auxiliary_Sphere",GEOGCS["GCS_WGS_1984",DATUM["D_WGS_1984",SPHEROID["WGS_1984",6378137.0,298.257223563]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Mercator_Auxiliary_Sphere"],PARAMETER["False_Easting",0.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",{Central_Meridian}],PARAMETER["Standard_Parallel_1",0.0],PARAMETER["Auxiliary_Sphere_Type",0.0],UNIT["Meter",1.0]]', M$t = [-20037508342788905e-9, 20037508342788905e-9], S$E = [-20037508342787e-6, 20037508342787e-6], d$1t = { 102113: { wkTemplate: 'PROJCS["WGS_1984_Web_Mercator",GEOGCS["GCS_WGS_1984_Major_Auxiliary_Sphere",DATUM["D_WGS_1984_Major_Auxiliary_Sphere",SPHEROID["WGS_1984_Major_Auxiliary_Sphere",6378137.0,0.0]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Mercator"],PARAMETER["False_Easting",0.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",{Central_Meridian}],PARAMETER["Standard_Parallel_1",0.0],UNIT["Meter",1.0]]', valid: M$t, origin: S$E, dx: 1e-5 }, 102100: { wkTemplate: l$1Z, valid: M$t, origin: S$E, dx: 1e-5 }, 3785: { wkTemplate: 'PROJCS["WGS_1984_Web_Mercator",GEOGCS["GCS_WGS_1984_Major_Auxiliary_Sphere",DATUM["D_WGS_1984_Major_Auxiliary_Sphere",SPHEROID["WGS_1984_Major_Auxiliary_Sphere",6378137.0,0.0]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Mercator"],PARAMETER["False_Easting",0.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",{Central_Meridian}],PARAMETER["Standard_Parallel_1",0.0],UNIT["Meter",1.0]]', valid: M$t, origin: S$E, dx: 1e-5 }, 3857: { wkTemplate: l$1Z, valid: M$t, origin: S$E, dx: 1e-5 }, 4326: { wkTemplate: 'GEOGCS["GCS_WGS_1984",DATUM["D_WGS_1984",SPHEROID["WGS_1984",6378137.0,298.257223563]],PRIMEM["Greenwich",{Central_Meridian}],UNIT["Degree",0.0174532925199433]]', altTemplate: 'PROJCS["WGS_1984_Plate_Carree",GEOGCS["GCS_WGS_1984",DATUM["D_WGS_1984",SPHEROID["WGS_1984",6378137.0,298.257223563]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]],PROJECTION["Plate_Carree"],PARAMETER["False_Easting",0.0],PARAMETER["False_Northing",0.0],PARAMETER["Central_Meridian",{Central_Meridian}],UNIT["Degrees",111319.491]]', valid: [-180, 180], origin: [-180, 90], dx: 1e-5 }, 104971: { wkTemplate: 'GEOGCS["Mars_2000_(Sphere)",DATUM["Mars_2000_(Sphere)",SPHEROID["Mars_2000_(Sphere)",3396190.0,0.0]],PRIMEM["Reference_Meridian",0.0],UNIT["Degree",0.0174532925199433]]', valid: [-180, 180], origin: [-180, 90], dx: 1e-5 }, 104905: { wkTemplate: 'GEOGCS["GCS_Mars_2000",DATUM["D_Mars_2000",SPHEROID["Mars_2000_IAU_IAG",3396190.0,169.8944472236118]],PRIMEM["Reference_Meridian",0.0],UNIT["Degree",0.0174532925199433]]', valid: [-180, 180], origin: [-180, 90], dx: 1e-5 } };
function E$u(r2, i2) {
  return r2 === i2 || !t$1W(r2) && !t$1W(i2) && (r2.wkid != null || i2.wkid != null ? r2.wkid === i2.wkid || k$q(r2) && k$q(i2) || i2.latestWkid != null && r2.wkid === i2.latestWkid || r2.latestWkid != null && i2.wkid === r2.latestWkid : !(!r2.wkt || !i2.wkt) && r2.wkt.toUpperCase() === i2.wkt.toUpperCase());
}
function R$n(e2) {
  return I$v(e2) && e2.wkid && d$1t[e2.wkid] || null;
}
function o$1F(e2) {
  return !!I$v(e2) && (e2.wkid ? r$1g[e2.wkid] == null : !!e2.wkt && !!/^\s*GEOGCS/i.test(e2.wkt));
}
function A$n(e2) {
  return !(P$p(e2) || s$1O(e2));
}
function G$i(e2) {
  return I$v(e2) && e2.wkid === 4326;
}
function u$1M(e2) {
  return I$v(e2) && e2.wkid === S$F.CGCS2000;
}
function k$q(e2) {
  return I$v(e2) && e2.wkid != null && t$1A[e2.wkid] === true;
}
function T$o(e2) {
  return I$v(e2) && e2.wkid === 32662;
}
function w$L(e2) {
  return e2 === S$F.GCSMARS2000 || e2 === S$F.GCSMARS2000_SPHERE;
}
function P$p(e2) {
  return I$v(e2) && e2.wkid != null && w$L(e2.wkid);
}
function C$p(e2) {
  return e2 === S$F.GCSMOON2000;
}
function s$1O(e2) {
  return I$v(e2) && e2.wkid != null && C$p(e2.wkid);
}
function p$2S(e2) {
  return I$v(e2) && e2.wkid != null && _$A[e2.wkid] === true;
}
function I$v(e2) {
  return r$1t(e2) && (e2.wkid != null && e2.wkid >= 2e3 || e2.wkt != null);
}
const c$2F = { wkid: 4326, wkt: n$2m(d$1t[4326].wkTemplate, { Central_Meridian: "0.0" }) }, D$q = { wkid: 102100, latestWkid: 3857 }, O$n = { wkid: 32662 };
var y$1e;
let S$D = y$1e = class extends l$1_ {
  constructor(e2) {
    super(e2), this.latestWkid = null, this.wkid = null, this.wkt = null, this.vcsWkid = null, this.latestVcsWkid = null, this.imageCoordinateSystem = null;
  }
  static fromJSON(e2) {
    if (!e2)
      return null;
    if (e2.wkid) {
      if (e2.wkid === 102100)
        return y$1e.WebMercator;
      if (e2.wkid === 4326)
        return y$1e.WGS84;
    }
    const t2 = new y$1e();
    return t2.read(e2), t2;
  }
  normalizeCtorArgs(e2) {
    if (e2 && typeof e2 == "object")
      return e2;
    return { [typeof e2 == "string" ? "wkt" : "wkid"]: e2 };
  }
  get isWGS84() {
    return G$i(this);
  }
  get isWebMercator() {
    return k$q(this);
  }
  get isGeographic() {
    return o$1F(this);
  }
  get isWrappable() {
    return p$2S(this);
  }
  writeWkt(e2, t2) {
    this.wkid || (t2.wkt = e2);
  }
  clone() {
    if (this === y$1e.WGS84)
      return y$1e.WGS84;
    if (this === y$1e.WebMercator)
      return y$1e.WebMercator;
    const e2 = new y$1e();
    return this.wkid != null ? (e2.wkid = this.wkid, this.latestWkid != null && (e2.latestWkid = this.latestWkid), this.vcsWkid != null && (e2.vcsWkid = this.vcsWkid), this.latestVcsWkid != null && (e2.latestVcsWkid = this.latestVcsWkid)) : this.wkt != null && (e2.wkt = this.wkt), this.imageCoordinateSystem && (e2.imageCoordinateSystem = y$1r(this.imageCoordinateSystem)), e2;
  }
  equals(e2) {
    if (e2 == null)
      return false;
    if (this.imageCoordinateSystem || e2.imageCoordinateSystem) {
      if (this.imageCoordinateSystem == null || e2.imageCoordinateSystem == null)
        return false;
      const { id: t2, referenceServiceName: r2 } = e2.imageCoordinateSystem, { geodataXform: i2 } = e2.imageCoordinateSystem, o2 = this.imageCoordinateSystem;
      return t2 == null || i2 ? JSON.stringify(o2) === JSON.stringify(e2.imageCoordinateSystem) : r2 ? o2.id === t2 && o2.referenceServiceName === r2 : o2.id === t2;
    }
    return E$u(this, e2);
  }
  toJSON(e2) {
    return this.write(void 0, e2);
  }
};
S$D.GCS_NAD_1927 = null, S$D.WGS84 = null, S$D.WebMercator = null, S$D.PlateCarree = null, e$1W([y$1o({ readOnly: true })], S$D.prototype, "isWGS84", null), e$1W([y$1o({ readOnly: true })], S$D.prototype, "isWebMercator", null), e$1W([y$1o({ readOnly: true })], S$D.prototype, "isGeographic", null), e$1W([y$1o({ readOnly: true })], S$D.prototype, "isWrappable", null), e$1W([y$1o({ type: T$r, json: { write: true } })], S$D.prototype, "latestWkid", void 0), e$1W([y$1o({ type: T$r, json: { write: true, origins: { "web-scene": { write: { overridePolicy() {
  return { isRequired: this.wkt === null };
} } } } } })], S$D.prototype, "wkid", void 0), e$1W([y$1o({ type: String, json: { origins: { "web-scene": { write: { overridePolicy() {
  return { isRequired: this.wkid === null };
} } } } } })], S$D.prototype, "wkt", void 0), e$1W([r$1h("wkt"), r$1h("web-scene", "wkt")], S$D.prototype, "writeWkt", null), e$1W([y$1o({ type: T$r, json: { write: true } })], S$D.prototype, "vcsWkid", void 0), e$1W([y$1o({ type: T$r, json: { write: true } })], S$D.prototype, "latestVcsWkid", void 0), e$1W([y$1o()], S$D.prototype, "imageCoordinateSystem", void 0), S$D = y$1e = e$1W([n$2f("esri.geometry.SpatialReference")], S$D), S$D.prototype.toJSON.isDefaultToJSON = true, S$D.GCS_NAD_1927 = new S$D({ wkid: 4267, wkt: 'GEOGCS["GCS_North_American_1927",DATUM["D_North_American_1927",SPHEROID["Clarke_1866",6378206.4,294.9786982]],PRIMEM["Greenwich",0.0],UNIT["Degree",0.0174532925199433]]' }), S$D.WGS84 = new S$D(c$2F), S$D.WebMercator = new S$D(D$q), S$D.PlateCarree = new S$D(O$n), Object.freeze && (Object.freeze(S$D.GCS_NAD_1927), Object.freeze(S$D.WGS84), Object.freeze(S$D.WebMercator));
const k$p = S$D;
let c$2E = class extends l$1_ {
  constructor(...e2) {
    super(...e2), this.type = null, this.hasM = false, this.hasZ = false, this.spatialReference = k$p.WGS84;
  }
  get cache() {
    return this.commitProperty("spatialReference"), {};
  }
  get extent() {
    return null;
  }
  readSpatialReference(e2, r2) {
    if (e2 instanceof k$p)
      return e2;
    if (e2 != null) {
      const t2 = new k$p();
      return t2.read(e2, r2), t2;
    }
    return e2;
  }
  clone() {
    return console.warn(".clone() is not implemented for " + this.declaredClass), null;
  }
  clearCache() {
    this.notifyChange("cache");
  }
  getCacheValue(e2) {
    return this.cache[e2];
  }
  setCacheValue(e2, r2) {
    this.cache[e2] = r2;
  }
};
e$1W([y$1o()], c$2E.prototype, "type", void 0), e$1W([y$1o({ readOnly: true })], c$2E.prototype, "cache", null), e$1W([y$1o({ readOnly: true })], c$2E.prototype, "extent", null), e$1W([y$1o({ type: Boolean, json: { write: { overridePolicy: (e2) => ({ enabled: e2 }) } } })], c$2E.prototype, "hasM", void 0), e$1W([y$1o({ type: Boolean, json: { write: { overridePolicy: (e2) => ({ enabled: e2 }) } } })], c$2E.prototype, "hasZ", void 0), e$1W([y$1o({ type: k$p, json: { write: true } })], c$2E.prototype, "spatialReference", void 0), e$1W([o$1H("spatialReference")], c$2E.prototype, "readSpatialReference", null), c$2E = e$1W([n$2f("esri.geometry.Geometry")], c$2E);
const p$2R = c$2E;
const r$1f = Object.prototype.toString;
function o$1E(n2) {
  const r2 = "__accessorMetadata__" in n2 ? b$U(n2) : n2;
  return function(...t2) {
    if (t2.push(r2), typeof t2[2] == "number")
      throw new Error("Using @cast has parameter decorator is not supported since 4.16");
    return e$1B.apply(this, t2);
  };
}
function e$1B(t2, r2, o2, e2) {
  s$1_(t2, r2).cast = e2;
}
function i$2h(t2) {
  return (r2, o2) => {
    s$1_(r2, t2).cast = r2[o2];
  };
}
function s$1N(...t2) {
  if (t2.length !== 3 || typeof t2[1] != "string")
    return t2.length === 1 && r$1f.call(t2[0]) === "[object Function]" ? o$1E(t2[0]) : t2.length === 1 && typeof t2[0] == "string" ? i$2h(t2[0]) : void 0;
}
function t$1z(t2, n2) {
  const s2 = t2.x - n2.x, r2 = t2.y - n2.y, a2 = t2.hasZ && n2.hasZ ? t2.z - n2.z : 0;
  return Math.sqrt(s2 * s2 + r2 * r2 + a2 * a2);
}
class i$2g {
  constructor(i2, s2, t2, e2) {
    this.semiMajorAxis = i2, this.flattening = s2, this.outerAtmosphereRimWidth = t2;
    const h2 = 1 - this.flattening;
    this.semiMinorAxis = this.semiMajorAxis * h2, this.halfSemiMajorAxis = this.semiMajorAxis / 2, this.halfCircumference = Math.PI * this.semiMajorAxis, this.metersPerDegree = this.halfCircumference / 180, this.inverseFlattening = 1 / (1 - this.flattening) - 1, this.eccentricitySquared = e2 || 2 * this.flattening - this.flattening * this.flattening, this.meanRadiusSemiAxes = (2 * this.semiMajorAxis + this.semiMinorAxis) / 3;
  }
  get radius() {
    return this.semiMajorAxis;
  }
}
const s$1M = new i$2g(6378137, 1 / 298.257223563, 3e5, 0.006694379990137799), t$1y = new i$2g(3396190, 1 / 169.8944472236118, 23e4), e$1A = new i$2g(1737400, 0, 0);
const o$1D = 57.29577951308232, u$1L = 0.017453292519943;
function l$1Y(n2) {
  return n2 * o$1D;
}
function p$2Q(n2) {
  return n2 * u$1L;
}
function c$2D(n2) {
  return Math.PI / 2 - 2 * Math.atan(Math.exp(-n2 / s$1M.radius));
}
function h$1k(n2) {
  return n2.wkid != null || n2.wkt != null;
}
const m$1K = [0, 0];
function x$I(n2, t2, e2, i2, r2) {
  const s2 = n2, a2 = r2;
  if (a2.spatialReference = e2, "x" in s2 && "x" in a2)
    [a2.x, a2.y] = t2(s2.x, s2.y, m$1K, i2);
  else if ("xmin" in s2 && "xmin" in a2)
    [a2.xmin, a2.ymin] = t2(s2.xmin, s2.ymin, m$1K, i2), [a2.xmax, a2.ymax] = t2(s2.xmax, s2.ymax, m$1K, i2);
  else if ("paths" in s2 && "paths" in a2 || "rings" in s2 && "rings" in a2) {
    const n3 = "paths" in s2 ? s2.paths : s2.rings, e3 = [];
    let r3;
    for (let s3 = 0; s3 < n3.length; s3++) {
      const a3 = n3[s3];
      r3 = [], e3.push(r3);
      for (let n4 = 0; n4 < a3.length; n4++)
        r3.push(t2(a3[n4][0], a3[n4][1], [0, 0], i2)), a3[n4].length > 2 && r3[n4].push(a3[n4][2]), a3[n4].length > 3 && r3[n4].push(a3[n4][3]);
    }
    "paths" in a2 ? a2.paths = e3 : a2.rings = e3;
  } else if ("points" in s2 && "points" in a2) {
    const n3 = s2.points, e3 = [];
    for (let r3 = 0; r3 < n3.length; r3++)
      e3[r3] = t2(n3[r3][0], n3[r3][1], [0, 0], i2), n3[r3].length > 2 && e3[r3].push(n3[r3][2]), n3[r3].length > 3 && e3[r3].push(n3[r3][3]);
    a2.points = e3;
  }
  return r2;
}
function g$_(n2, t2) {
  const e2 = n2 && (h$1k(n2) ? n2 : n2.spatialReference), i2 = t2 && (h$1k(t2) ? t2 : t2.spatialReference);
  return !(n2 && "type" in n2 && n2.type === "mesh" || t2 && "type" in t2 && t2.type === "mesh" || !e2 || !i2) && (!!E$u(i2, e2) || (k$q(i2) && G$i(e2) || k$q(e2) && G$i(i2)));
}
function M$s(i2, o2) {
  if (t$1W(i2))
    return null;
  const u2 = i2.spatialReference, l2 = o2 && (h$1k(o2) ? o2 : o2.spatialReference);
  return g$_(u2, l2) ? E$u(u2, l2) ? y$1r(i2) : k$q(l2) ? x$I(i2, y$1d, k$p.WebMercator, false, y$1r(i2)) : G$i(l2) ? x$I(i2, d$1s, k$p.WGS84, false, y$1r(i2)) : null : null;
}
function y$1d(n2, t2, e2 = [0, 0]) {
  t2 > 89.99999 ? t2 = 89.99999 : t2 < -89.99999 && (t2 = -89.99999);
  const r2 = p$2Q(t2);
  return e2[0] = p$2Q(n2) * s$1M.radius, e2[1] = s$1M.halfSemiMajorAxis * Math.log((1 + Math.sin(r2)) / (1 - Math.sin(r2))), e2;
}
function d$1s(n2, t2, e2 = [0, 0], r2 = false) {
  const s2 = l$1Y(n2 / s$1M.radius);
  return e2[0] = r2 ? s2 : s2 - 360 * Math.floor((s2 + 180) / 360), e2[1] = l$1Y(Math.PI / 2 - 2 * Math.atan(Math.exp(-t2 / s$1M.radius))), e2;
}
function R$m(t2, i2 = false, r2 = y$1r(t2)) {
  return x$I(t2, y$1d, k$p.WebMercator, i2, r2);
}
function j$H(t2, i2 = false, r2 = y$1r(t2)) {
  return x$I(t2, d$1s, k$p.WGS84, i2, r2);
}
var m$1J;
const f$1r = [0, 0];
function g$Z(e2) {
  return e2 && (e2.declaredClass === "esri.geometry.SpatialReference" || e2.wkid != null);
}
let x$H = m$1J = class extends p$2R {
  constructor(...e2) {
    super(...e2), this.x = 0, this.y = 0, this.z = void 0, this.m = void 0, this.type = "point";
  }
  static copy(e2, t2) {
    t2._set("x", e2._get("x")), t2._set("y", e2._get("y")), t2._set("z", e2._get("z")), t2._set("m", e2._get("m"));
    const r2 = e2._get("spatialReference");
    t2._set("spatialReference", Object.isFrozen(r2) ? r2 : r2.clone());
  }
  normalizeCtorArgs(e2, r2, s2, i2, o2) {
    let a2;
    if (Array.isArray(e2))
      a2 = e2, o2 = r2, e2 = a2[0], r2 = a2[1], s2 = a2[2], i2 = a2[3];
    else if (e2 && typeof e2 == "object") {
      if (a2 = e2, e2 = a2.x != null ? a2.x : a2.longitude, r2 = a2.y != null ? a2.y : a2.latitude, s2 = a2.z, i2 = a2.m, (o2 = a2.spatialReference) && o2.declaredClass !== "esri.geometry.SpatialReference" && (o2 = new k$p(o2)), a2.longitude != null || a2.latitude != null) {
        if (a2.longitude == null)
          s$22.getLogger(this.declaredClass).warn(".longitude=", "Latitude was defined without longitude");
        else if (a2.latitude == null)
          s$22.getLogger(this.declaredClass).warn(".latitude=", "Longitude was defined without latitude");
        else if (!a2.declaredClass && o2 && o2.isWebMercator) {
          const t2 = y$1d(a2.longitude, a2.latitude, f$1r);
          e2 = t2[0], r2 = t2[1];
        }
      }
    } else
      g$Z(s2) ? (o2 = s2, s2 = null) : g$Z(i2) && (o2 = i2, i2 = null);
    const l2 = { x: e2, y: r2 };
    return l2.x == null && l2.y != null ? s$22.getLogger(this.declaredClass).warn(".y=", "Y coordinate was defined without an X coordinate") : l2.y == null && l2.x != null && s$22.getLogger(this.declaredClass).warn(".x=", "X coordinate was defined without a Y coordinate"), o2 != null && (l2.spatialReference = o2), s2 != null && (l2.z = s2), i2 != null && (l2.m = i2), l2;
  }
  get cache() {
    return this.commitProperty("x"), this.commitProperty("y"), this.commitProperty("z"), this.commitProperty("m"), this.commitProperty("spatialReference"), {};
  }
  get hasM() {
    return this.m !== void 0;
  }
  set hasM(e2) {
    e2 !== (this._get("m") !== void 0) && (this._set("m", e2 ? 0 : void 0), this._set("hasM", e2));
  }
  get hasZ() {
    return this.z !== void 0;
  }
  set hasZ(e2) {
    e2 !== (this._get("z") !== void 0) && (this._set("z", e2 ? 0 : void 0), this._set("hasZ", e2));
  }
  get latitude() {
    const { spatialReference: e2, x: t2, y: r2 } = this;
    if (e2) {
      if (e2.isWebMercator)
        return d$1s(t2, r2, f$1r)[1];
      if (e2.isGeographic)
        return r2;
    }
    return null;
  }
  set latitude(e2) {
    const { spatialReference: t2, x: r2 } = this;
    e2 != null && t2 && (t2.isWebMercator ? this._set("y", y$1d(r2, e2, f$1r)[1]) : t2.isGeographic && this._set("y", e2), this._set("latitude", e2));
  }
  get longitude() {
    const { x: e2, y: t2, spatialReference: r2 } = this;
    if (r2) {
      if (r2.isWebMercator)
        return d$1s(e2, t2, f$1r)[0];
      if (r2.isGeographic)
        return e2;
    }
    return null;
  }
  set longitude(e2) {
    const { y: t2, spatialReference: r2 } = this;
    e2 != null && r2 && (r2.isWebMercator ? this._set("x", y$1d(e2, t2, f$1r)[0]) : r2.isGeographic && this._set("x", e2), this._set("longitude", e2));
  }
  writeX(e2, t2, r2) {
    t2[r2] = isNaN(e2) ? "NaN" : e2;
  }
  readX(e2) {
    return typeof e2 == "string" ? NaN : e2;
  }
  clone() {
    const e2 = new m$1J();
    return e2.x = this.x, e2.y = this.y, e2.z = this.z, e2.m = this.m, e2.spatialReference = this.spatialReference, e2;
  }
  copy(e2) {
    return m$1J.copy(e2, this), this;
  }
  equals(e2) {
    if (t$1W(e2))
      return false;
    const { x: t2, y: s2, z: i2, m: o2, spatialReference: a2 } = this, { z: l2, m: n2 } = e2;
    let { x: c2, y: u2, spatialReference: p2 } = e2;
    if (!a2.equals(p2))
      if (a2.isWebMercator && p2.isWGS84)
        [c2, u2] = y$1d(c2, u2), p2 = a2;
      else {
        if (!a2.isWGS84 || !p2.isWebMercator)
          return false;
        [c2, u2] = d$1s(c2, u2), p2 = a2;
      }
    return t2 === c2 && s2 === u2 && i2 === l2 && o2 === n2 && a2.wkid === p2.wkid;
  }
  offset(e2, t2, r2) {
    var _a2;
    return this.x += e2, this.y += t2, r2 != null && (this.z = ((_a2 = this.z) != null ? _a2 : 0) + r2), this;
  }
  normalize() {
    if (!this.spatialReference)
      return this;
    const e2 = R$n(this.spatialReference);
    if (!e2)
      return this;
    let t2 = this.x;
    const [r2, s2] = e2.valid, i2 = 2 * s2;
    let o2;
    return t2 > s2 ? (o2 = Math.ceil(Math.abs(t2 - s2) / i2), t2 -= o2 * i2) : t2 < r2 && (o2 = Math.ceil(Math.abs(t2 - r2) / i2), t2 += o2 * i2), this._set("x", t2), this;
  }
  distance(e2) {
    return t$1z(this, e2);
  }
  toArray() {
    const e2 = this.hasZ, t2 = this.hasM;
    return e2 && t2 ? [this.x, this.y, this.z, this.m] : e2 ? [this.x, this.y, this.z] : t2 ? [this.x, this.y, this.m] : [this.x, this.y];
  }
  toJSON(e2) {
    return this.write({}, e2);
  }
};
e$1W([y$1o({ readOnly: true })], x$H.prototype, "cache", null), e$1W([y$1o({ type: Boolean, json: { read: false, write: { enabled: false, overridePolicy: null } } })], x$H.prototype, "hasM", null), e$1W([y$1o({ type: Boolean, json: { read: false, write: { enabled: false, overridePolicy: null } } })], x$H.prototype, "hasZ", null), e$1W([y$1o({ type: Number })], x$H.prototype, "latitude", null), e$1W([y$1o({ type: Number })], x$H.prototype, "longitude", null), e$1W([y$1o({ type: Number, json: { type: [Number, String], write: { isRequired: true, allowNull: true } } }), s$1N((e2) => isNaN(e2) ? e2 : a$2w(e2))], x$H.prototype, "x", void 0), e$1W([r$1h("x")], x$H.prototype, "writeX", null), e$1W([o$1H("x")], x$H.prototype, "readX", null), e$1W([y$1o({ type: Number, json: { write: true } })], x$H.prototype, "y", void 0), e$1W([y$1o({ type: Number, json: { write: { overridePolicy() {
  return { enabled: this.hasZ };
} } } })], x$H.prototype, "z", void 0), e$1W([y$1o({ type: Number, json: { write: { overridePolicy() {
  return { enabled: this.hasM };
} } } })], x$H.prototype, "m", void 0), x$H = m$1J = e$1W([n$2f("esri.geometry.Point")], x$H), x$H.prototype.toJSON.isDefaultToJSON = true;
const w$K = x$H;
const t$1x = [0, 0];
function r$1e(t2, r2) {
  return !!r$1t(r2) && f$1q(t2, r2.x, r2.y, r2.z);
}
function i$2f(n2, t2) {
  if (!t2.points || t2.points.length)
    return false;
  for (const r2 of t2.points)
    if (!u$1K(n2, r2))
      return false;
  return true;
}
function o$1C(n2, t2) {
  const { xmin: r2, ymin: i2, zmin: o2, xmax: u2, ymax: e2, zmax: c2 } = t2;
  return n2.hasZ && t2.hasZ ? f$1q(n2, r2, i2, o2) && f$1q(n2, r2, e2, o2) && f$1q(n2, u2, e2, o2) && f$1q(n2, u2, i2, o2) && f$1q(n2, r2, i2, c2) && f$1q(n2, r2, e2, c2) && f$1q(n2, u2, e2, c2) && f$1q(n2, u2, i2, c2) : f$1q(n2, r2, i2) && f$1q(n2, r2, e2) && f$1q(n2, u2, e2) && f$1q(n2, u2, i2);
}
function u$1K(n2, t2) {
  return f$1q(n2, t2[0], t2[1]);
}
function e$1z(n2, t2) {
  return f$1q(n2, t2[0], t2[1], t2[2]);
}
function f$1q(n2, t2, r2, i2) {
  return t2 >= n2.xmin && t2 <= n2.xmax && r2 >= n2.ymin && r2 <= n2.ymax && (i2 == null || !n2.hasZ || i2 >= n2.zmin && i2 <= n2.zmax);
}
function c$2C(n2, r2) {
  return t$1x[1] = r2.y, t$1x[0] = r2.x, m$1I(n2, t$1x);
}
function m$1I(n2, t2) {
  return s$1L(n2.rings, t2);
}
function s$1L(n2, t2) {
  if (!n2)
    return false;
  if (x$G(n2))
    return a$2m(false, n2, t2);
  let r2 = false;
  for (let i2 = 0, o2 = n2.length; i2 < o2; i2++)
    r2 = a$2m(r2, n2[i2], t2);
  return r2;
}
function x$G(n2) {
  return !Array.isArray(n2[0][0]);
}
function a$2m(n2, t2, r2) {
  const [i2, o2] = r2;
  let u2 = n2, e2 = 0;
  for (let f2 = 0, c2 = t2.length; f2 < c2; f2++) {
    e2++, e2 === c2 && (e2 = 0);
    const [n3, r3] = t2[f2], [m2, s2] = t2[e2];
    (r3 < o2 && s2 >= o2 || s2 < o2 && r3 >= o2) && n3 + (o2 - r3) / (s2 - r3) * (m2 - n3) < i2 && (u2 = !u2);
  }
  return u2;
}
function i$2e(t2, e2) {
  return r$1e(t2, e2);
}
function o$1B(n2, t2) {
  const e2 = n2.hasZ && t2.hasZ;
  let r2, i2, o2;
  if (n2.xmin <= t2.xmin) {
    if (r2 = t2.xmin, n2.xmax < r2)
      return false;
  } else if (r2 = n2.xmin, t2.xmax < r2)
    return false;
  if (n2.ymin <= t2.ymin) {
    if (i2 = t2.ymin, n2.ymax < i2)
      return false;
  } else if (i2 = n2.ymin, t2.ymax < i2)
    return false;
  if (e2 && t2.hasZ) {
    if (n2.zmin <= t2.zmin) {
      if (o2 = t2.zmin, n2.zmax < o2)
        return false;
    } else if (o2 = n2.zmin, t2.zmax < o2)
      return false;
  }
  return true;
}
function f$1p(n2, t2) {
  const { points: i2, hasZ: o2 } = t2, f2 = o2 ? e$1z : u$1K;
  for (const e2 of i2)
    if (f2(n2, e2))
      return true;
  return false;
}
const s$1K = [0, 0], u$1J = [0, 0], c$2B = [0, 0], m$1H = [0, 0], l$1X = [s$1K, u$1J, c$2B, m$1H], a$2l = [[c$2B, s$1K], [s$1K, u$1J], [u$1J, m$1H], [m$1H, c$2B]];
function x$F(n2, t2) {
  return y$1c(n2, t2.rings);
}
function y$1c(n2, r2) {
  s$1K[0] = n2.xmin, s$1K[1] = n2.ymax, u$1J[0] = n2.xmax, u$1J[1] = n2.ymax, c$2B[0] = n2.xmin, c$2B[1] = n2.ymin, m$1H[0] = n2.xmax, m$1H[1] = n2.ymin;
  for (const e2 of l$1X)
    if (s$1L(r2, e2))
      return true;
  for (const t2 of r2) {
    if (!t2.length)
      continue;
    let r3 = t2[0];
    if (u$1K(n2, r3))
      return true;
    for (let i2 = 1; i2 < t2.length; i2++) {
      const o2 = t2[i2];
      if (u$1K(n2, o2) || z$r(r3, o2, a$2l))
        return true;
      r3 = o2;
    }
  }
  return false;
}
function h$1j(n2, t2) {
  s$1K[0] = n2.xmin, s$1K[1] = n2.ymax, u$1J[0] = n2.xmax, u$1J[1] = n2.ymax, c$2B[0] = n2.xmin, c$2B[1] = n2.ymin, m$1H[0] = n2.xmax, m$1H[1] = n2.ymin;
  const r2 = t2.paths;
  for (const i2 of r2) {
    if (!r2.length)
      continue;
    let t3 = i2[0];
    if (u$1K(n2, t3))
      return true;
    for (let r3 = 1; r3 < i2.length; r3++) {
      const o2 = i2[r3];
      if (u$1K(n2, o2) || z$r(t3, o2, a$2l))
        return true;
      t3 = o2;
    }
  }
  return false;
}
const g$Y = [0, 0];
function p$2P(n2) {
  for (let t2 = 0; t2 < n2.length; t2++) {
    const e2 = n2[t2];
    for (let i2 = 0; i2 < e2.length - 1; i2++) {
      const r3 = e2[i2], o2 = e2[i2 + 1];
      for (let e3 = t2 + 1; e3 < n2.length; e3++)
        for (let t3 = 0; t3 < n2[e3].length - 1; t3++) {
          const i3 = n2[e3][t3], f2 = n2[e3][t3 + 1];
          if (G$h(r3, o2, i3, f2, g$Y) && !(g$Y[0] === r3[0] && g$Y[1] === r3[1] || g$Y[0] === i3[0] && g$Y[1] === i3[1] || g$Y[0] === o2[0] && g$Y[1] === o2[1] || g$Y[0] === f2[0] && g$Y[1] === f2[1]))
            return true;
        }
    }
    const r2 = e2.length;
    if (!(r2 <= 4))
      for (let n3 = 0; n3 < r2 - 3; n3++) {
        let t3 = r2 - 1;
        n3 === 0 && (t3 = r2 - 2);
        const i2 = e2[n3], o2 = e2[n3 + 1];
        for (let r3 = n3 + 2; r3 < t3; r3++) {
          const n4 = e2[r3], t4 = e2[r3 + 1];
          if (G$h(i2, o2, n4, t4, g$Y) && !(g$Y[0] === i2[0] && g$Y[1] === i2[1] || g$Y[0] === n4[0] && g$Y[1] === n4[1] || g$Y[0] === o2[0] && g$Y[1] === o2[1] || g$Y[0] === t4[0] && g$Y[1] === t4[1]))
            return true;
        }
      }
  }
  return false;
}
function z$r(n2, t2, e2) {
  for (let r2 = 0; r2 < e2.length; r2++)
    if (G$h(n2, t2, e2[r2][0], e2[r2][1]))
      return true;
  return false;
}
function G$h(n2, t2, e2, r2, i2) {
  const [o2, f2] = n2, [s2, u2] = t2, [c2, m2] = e2, [l2, a2] = r2, x2 = l2 - c2, y2 = o2 - c2, h2 = s2 - o2, g2 = a2 - m2, p2 = f2 - m2, z2 = u2 - f2, G2 = g2 * h2 - x2 * z2;
  if (G2 === 0)
    return false;
  const Z2 = (x2 * p2 - g2 * y2) / G2, P2 = (h2 * p2 - z2 * y2) / G2;
  return Z2 >= 0 && Z2 <= 1 && P2 >= 0 && P2 <= 1 && (i2 && (i2[0] = o2 + Z2 * (s2 - o2), i2[1] = f2 + Z2 * (u2 - f2)), true);
}
function Z$7(n2) {
  switch (n2) {
    case "esriGeometryEnvelope":
    case "extent":
      return o$1B;
    case "esriGeometryMultipoint":
    case "multipoint":
      return f$1p;
    case "esriGeometryPoint":
    case "point":
      return i$2e;
    case "esriGeometryPolygon":
    case "polygon":
      return x$F;
    case "esriGeometryPolyline":
    case "polyline":
      return h$1j;
  }
}
var f$1o;
function d$1r(t2) {
  return t2 && (t2.declaredClass === "esri.geometry.SpatialReference" || t2.wkid != null);
}
function z$q(t2, i2, e2) {
  return i2 == null ? e2 : e2 == null ? i2 : t2(i2, e2);
}
let M$r = f$1o = class extends p$2R {
  constructor(...t2) {
    super(...t2), this.type = "extent", this.xmin = 0, this.ymin = 0, this.mmin = void 0, this.zmin = void 0, this.xmax = 0, this.ymax = 0, this.mmax = void 0, this.zmax = void 0;
  }
  normalizeCtorArgs(t2, i2, e2, s2, n2) {
    return d$1r(t2) ? { spatialReference: t2, xmin: 0, ymin: 0, xmax: 0, ymax: 0 } : typeof t2 == "object" ? (t2.spatialReference = t2.spatialReference == null ? k$p.WGS84 : t2.spatialReference, t2) : { xmin: t2, ymin: i2, xmax: e2, ymax: s2, spatialReference: n2 != null ? n2 : k$p.WGS84 };
  }
  static fromBounds(t2, i2) {
    return new f$1o({ xmin: t2[0], ymin: t2[1], xmax: t2[2], ymax: t2[3], spatialReference: i2 });
  }
  static fromPoint(t2) {
    return new f$1o({ xmin: t2.x, ymin: t2.y, zmin: t2.z, xmax: t2.x, ymax: t2.y, zmax: t2.z, spatialReference: t2.spatialReference });
  }
  get cache() {
    return this.commitProperty("xmin"), this.commitProperty("ymin"), this.commitProperty("zmin"), this.commitProperty("mmin"), this.commitProperty("xmax"), this.commitProperty("ymax"), this.commitProperty("zmax"), this.commitProperty("mmax"), this.commitProperty("spatialReference"), {};
  }
  get center() {
    const t2 = new w$K({ x: 0.5 * (this.xmin + this.xmax), y: 0.5 * (this.ymin + this.ymax), spatialReference: this.spatialReference });
    return this.hasZ && (t2.z = 0.5 * (this.zmin + this.zmax)), this.hasM && (t2.m = 0.5 * (this.mmin + this.mmax)), t2;
  }
  get extent() {
    return this.clone();
  }
  get hasM() {
    return this.mmin != null && this.mmax != null;
  }
  get hasZ() {
    return this.zmin != null && this.zmax != null;
  }
  get height() {
    return Math.abs(this.ymax - this.ymin);
  }
  get width() {
    return Math.abs(this.xmax - this.xmin);
  }
  centerAt(t2) {
    const i2 = this.center;
    return t2.z != null && this.hasZ ? this.offset(t2.x - i2.x, t2.y - i2.y, t2.z - i2.z) : this.offset(t2.x - i2.x, t2.y - i2.y);
  }
  clone() {
    const t2 = new f$1o();
    return t2.xmin = this.xmin, t2.ymin = this.ymin, t2.xmax = this.xmax, t2.ymax = this.ymax, t2.spatialReference = this.spatialReference, this.zmin != null && (t2.zmin = this.zmin, t2.zmax = this.zmax), this.mmin != null && (t2.mmin = this.mmin, t2.mmax = this.mmax), t2;
  }
  contains(t2) {
    if (!t2)
      return false;
    const i2 = this.spatialReference, e2 = t2.spatialReference;
    return i2 && e2 && !i2.equals(e2) && g$_(i2, e2) && (t2 = i2.isWebMercator ? R$m(t2) : j$H(t2, true)), t2.type === "point" ? r$1e(this, t2) : t2.type === "extent" && o$1C(this, t2);
  }
  equals(t2) {
    if (this === t2)
      return true;
    if (t$1W(t2))
      return false;
    const e2 = this.spatialReference, s2 = t2.spatialReference;
    return e2 && s2 && !e2.equals(s2) && g$_(e2, s2) && (t2 = e2.isWebMercator ? R$m(t2) : j$H(t2, true)), this.xmin === t2.xmin && this.ymin === t2.ymin && this.zmin === t2.zmin && this.mmin === t2.mmin && this.xmax === t2.xmax && this.ymax === t2.ymax && this.zmax === t2.zmax && this.mmax === t2.mmax;
  }
  expand(t2) {
    const i2 = 0.5 * (1 - t2), e2 = this.width * i2, s2 = this.height * i2;
    if (this.xmin += e2, this.ymin += s2, this.xmax -= e2, this.ymax -= s2, this.hasZ) {
      const t3 = (this.zmax - this.zmin) * i2;
      this.zmin += t3, this.zmax -= t3;
    }
    if (this.hasM) {
      const t3 = (this.mmax - this.mmin) * i2;
      this.mmin += t3, this.mmax -= t3;
    }
    return this;
  }
  intersects(t2) {
    if (t$1W(t2))
      return false;
    t2.type === "mesh" && (t2 = t2.extent);
    const e2 = this.spatialReference, s2 = t2.spatialReference;
    e2 && s2 && !E$u(e2, s2) && g$_(e2, s2) && (t2 = e2.isWebMercator ? R$m(t2) : j$H(t2, true));
    return Z$7(t2.type)(this, t2);
  }
  normalize() {
    const t2 = this._normalize(false, true);
    return Array.isArray(t2) ? t2 : [t2];
  }
  offset(t2, i2, e2) {
    return this.xmin += t2, this.ymin += i2, this.xmax += t2, this.ymax += i2, e2 != null && (this.zmin += e2, this.zmax += e2), this;
  }
  shiftCentralMeridian() {
    return this._normalize(true);
  }
  union(t2) {
    return this === t2 || (this.xmin = Math.min(this.xmin, t2.xmin), this.ymin = Math.min(this.ymin, t2.ymin), this.xmax = Math.max(this.xmax, t2.xmax), this.ymax = Math.max(this.ymax, t2.ymax), (this.hasZ || t2.hasZ) && (this.zmin = z$q(Math.min, this.zmin, t2.zmin), this.zmax = z$q(Math.max, this.zmax, t2.zmax)), (this.hasM || t2.hasM) && (this.mmin = z$q(Math.min, this.mmin, t2.mmin), this.mmax = z$q(Math.max, this.mmax, t2.mmax))), this;
  }
  intersection(t2) {
    return this === t2 ? this : t$1W(t2) || !this.intersects(t2) ? null : (this.xmin = Math.max(this.xmin, t2.xmin), this.ymin = Math.max(this.ymin, t2.ymin), this.xmax = Math.min(this.xmax, t2.xmax), this.ymax = Math.min(this.ymax, t2.ymax), (this.hasZ || t2.hasZ) && (this.zmin = z$q(Math.max, this.zmin, t2.zmin), this.zmax = z$q(Math.min, this.zmax, t2.zmax)), (this.hasM || t2.hasM) && (this.mmin = z$q(Math.max, this.mmin, t2.mmin), this.mmax = z$q(Math.min, this.mmax, t2.mmax)), this);
  }
  toJSON(t2) {
    return this.write({}, t2);
  }
  _shiftCM(t2 = R$n(this.spatialReference)) {
    var _a2;
    if (!t2 || !this.spatialReference)
      return this;
    const i2 = this.spatialReference, s2 = this._getCM(t2);
    if (s2) {
      const n2 = i2.isWebMercator ? j$H(s2) : s2;
      this.xmin -= s2.x, this.xmax -= s2.x, i2.isWebMercator || (n2.x = this._normalizeX(n2.x, t2).x), this.spatialReference = new k$p(n$2m((_a2 = i2.isWGS84 ? t2.altTemplate : null) != null ? _a2 : t2.wkTemplate, { Central_Meridian: n2.x }));
    }
    return this;
  }
  _getCM(t2) {
    let i2 = null;
    const [e2, s2] = t2.valid, n2 = this.xmin, m2 = this.xmax;
    return n2 >= e2 && n2 <= s2 && (m2 >= e2 && m2 <= s2) || (i2 = this.center), i2;
  }
  _normalize(t2, i2, e2) {
    const s2 = this.spatialReference;
    if (!s2)
      return this;
    const n2 = e2 != null ? e2 : R$n(s2);
    if (n2 == null)
      return this;
    const m2 = this._getParts(n2).map((t3) => t3.extent);
    if (m2.length < 2)
      return m2[0] || this;
    if (m2.length > 2)
      return t2 ? this._shiftCM(n2) : this.set({ xmin: n2.valid[0], xmax: n2.valid[1] });
    if (t2)
      return this._shiftCM(n2);
    if (i2)
      return m2;
    let r2 = true, a2 = true;
    return m2.forEach((t3) => {
      t3.hasZ || (r2 = false), t3.hasM || (a2 = false);
    }), { rings: m2.map((t3) => {
      const i3 = [[t3.xmin, t3.ymin], [t3.xmin, t3.ymax], [t3.xmax, t3.ymax], [t3.xmax, t3.ymin], [t3.xmin, t3.ymin]];
      if (r2) {
        const e3 = (t3.zmax - t3.zmin) / 2;
        for (let t4 = 0; t4 < i3.length; t4++)
          i3[t4].push(e3);
      }
      if (a2) {
        const e3 = (t3.mmax - t3.mmin) / 2;
        for (let t4 = 0; t4 < i3.length; t4++)
          i3[t4].push(e3);
      }
      return i3;
    }), hasZ: r2, hasM: a2, spatialReference: s2 };
  }
  _getParts(t2) {
    let i2 = this.cache._parts;
    if (!i2) {
      i2 = [];
      const { ymin: e3, ymax: s3, spatialReference: n2 } = this, m2 = this.width, r2 = this.xmin, a2 = this.xmax;
      let h2;
      t2 = t2 || R$n(n2);
      const [o2, x2] = t2.valid;
      h2 = this._normalizeX(this.xmin, t2);
      const l2 = h2.x, c2 = h2.frameId;
      h2 = this._normalizeX(this.xmax, t2);
      const y2 = h2.x, u2 = h2.frameId, d2 = l2 === y2 && m2 > 0;
      if (m2 > 2 * x2) {
        const t3 = new f$1o(r2 < a2 ? l2 : y2, e3, x2, s3, n2), m3 = new f$1o(o2, e3, r2 < a2 ? y2 : l2, s3, n2), h3 = new f$1o(0, e3, x2, s3, n2), p2 = new f$1o(o2, e3, 0, s3, n2), d3 = [], z2 = [];
        t3.contains(h3) && d3.push(c2), t3.contains(p2) && z2.push(c2), m3.contains(h3) && d3.push(u2), m3.contains(p2) && z2.push(u2);
        for (let i3 = c2 + 1; i3 < u2; i3++)
          d3.push(i3), z2.push(i3);
        i2.push({ extent: t3, frameIds: [c2] }, { extent: m3, frameIds: [u2] }, { extent: h3, frameIds: d3 }, { extent: p2, frameIds: z2 });
      } else
        l2 > y2 || d2 ? i2.push({ extent: new f$1o(l2, e3, x2, s3, n2), frameIds: [c2] }, { extent: new f$1o(o2, e3, y2, s3, n2), frameIds: [u2] }) : i2.push({ extent: new f$1o(l2, e3, y2, s3, n2), frameIds: [c2] });
      this.cache._parts = i2;
    }
    const e2 = this.hasZ, s2 = this.hasM;
    if (e2 || s2) {
      const t3 = {};
      e2 && (t3.zmin = this.zmin, t3.zmax = this.zmax), s2 && (t3.mmin = this.mmin, t3.mmax = this.mmax);
      for (let e3 = 0; e3 < i2.length; e3++)
        i2[e3].extent.set(t3);
    }
    return i2;
  }
  _normalizeX(t2, i2) {
    const [e2, s2] = i2.valid, n2 = 2 * s2;
    let m2, r2 = 0;
    return t2 > s2 ? (m2 = Math.ceil(Math.abs(t2 - s2) / n2), t2 -= m2 * n2, r2 = m2) : t2 < e2 && (m2 = Math.ceil(Math.abs(t2 - e2) / n2), t2 += m2 * n2, r2 = -m2), { x: t2, frameId: r2 };
  }
};
e$1W([y$1o({ readOnly: true })], M$r.prototype, "cache", null), e$1W([y$1o({ readOnly: true })], M$r.prototype, "center", null), e$1W([y$1o({ readOnly: true })], M$r.prototype, "extent", null), e$1W([y$1o({ readOnly: true, json: { write: { enabled: false, overridePolicy: null } } })], M$r.prototype, "hasM", null), e$1W([y$1o({ readOnly: true, json: { write: { enabled: false, overridePolicy: null } } })], M$r.prototype, "hasZ", null), e$1W([y$1o({ readOnly: true })], M$r.prototype, "height", null), e$1W([y$1o({ readOnly: true })], M$r.prototype, "width", null), e$1W([y$1o({ type: Number, json: { type: [Number, String], write: { enabled: true, allowNull: true } } })], M$r.prototype, "xmin", void 0), e$1W([y$1o({ type: Number, json: { write: true } })], M$r.prototype, "ymin", void 0), e$1W([y$1o({ type: Number, json: { origins: { "web-scene": { write: false } }, write: { overridePolicy() {
  return { enabled: this.hasM };
} } } })], M$r.prototype, "mmin", void 0), e$1W([y$1o({ type: Number, json: { origins: { "web-scene": { write: false } }, write: { overridePolicy() {
  return { enabled: this.hasZ };
} } } })], M$r.prototype, "zmin", void 0), e$1W([y$1o({ type: Number, json: { write: true } })], M$r.prototype, "xmax", void 0), e$1W([y$1o({ type: Number, json: { write: true } })], M$r.prototype, "ymax", void 0), e$1W([y$1o({ type: Number, json: { origins: { "web-scene": { write: false } }, write: { overridePolicy() {
  return { enabled: this.hasM };
} } } })], M$r.prototype, "mmax", void 0), e$1W([y$1o({ type: Number, json: { origins: { "web-scene": { write: false } }, write: { overridePolicy() {
  return { enabled: this.hasZ };
} } } })], M$r.prototype, "zmax", void 0), M$r = f$1o = e$1W([n$2f("esri.geometry.Extent")], M$r), M$r.prototype.toJSON.isDefaultToJSON = true;
const w$J = M$r;
function h$1i(h2, a2, s2 = false) {
  let { hasM: t2, hasZ: e2 } = h2;
  Array.isArray(a2) ? a2.length !== 4 || t2 || e2 ? a2.length === 3 && s2 && !t2 ? (e2 = true, t2 = false) : a2.length === 3 && t2 && e2 && (t2 = false, e2 = false) : (t2 = true, e2 = true) : (e2 = !e2 && a2.hasZ && (!t2 || a2.hasM), t2 = !t2 && a2.hasM && (!e2 || a2.hasZ)), h2.hasZ = e2, h2.hasM = t2;
}
var h$1h;
function l$1W(t2) {
  return (s2, e2) => s2 == null ? e2 : e2 == null ? s2 : t2(s2, e2);
}
function c$2A(t2) {
  return t2 && (t2.declaredClass === "esri.geometry.SpatialReference" || t2.wkid != null);
}
let m$1G = h$1h = class extends p$2R {
  constructor(...t2) {
    super(...t2), this.points = [], this.type = "multipoint";
  }
  normalizeCtorArgs(t2, s2) {
    if (!t2 && !s2)
      return {};
    const e2 = {};
    Array.isArray(t2) ? (e2.points = t2, e2.spatialReference = s2) : c$2A(t2) ? e2.spatialReference = t2 : (t2.points && (e2.points = t2.points), t2.spatialReference && (e2.spatialReference = t2.spatialReference), t2.hasZ && (e2.hasZ = t2.hasZ), t2.hasM && (e2.hasM = t2.hasM));
    const i2 = e2.points && e2.points[0];
    return i2 && (e2.hasZ === void 0 && e2.hasM === void 0 ? (e2.hasZ = i2.length > 2, e2.hasM = false) : e2.hasZ === void 0 ? e2.hasZ = i2.length > 3 : e2.hasM === void 0 && (e2.hasM = i2.length > 3)), e2;
  }
  get cache() {
    return this.commitProperty("points"), this.commitProperty("hasZ"), this.commitProperty("hasM"), this.commitProperty("spatialReference"), {};
  }
  get extent() {
    const t2 = this.points;
    if (!t2.length)
      return null;
    const s2 = new w$J(), e2 = this.hasZ, i2 = this.hasM, r2 = e2 ? 3 : 2, n2 = t2[0], a2 = l$1W(Math.min), p2 = l$1W(Math.max);
    let h2, c2, m2, u2, [f2, y2] = n2, [d2, g2] = n2;
    for (let o2 = 0, l2 = t2.length; o2 < l2; o2++) {
      const s3 = t2[o2], [n3, l3] = s3;
      if (f2 = a2(f2, n3), y2 = a2(y2, l3), d2 = p2(d2, n3), g2 = p2(g2, l3), e2 && s3.length > 2) {
        const t3 = s3[2];
        h2 = a2(h2, t3), m2 = p2(m2, t3);
      }
      if (i2 && s3.length > r2) {
        const t3 = s3[r2];
        c2 = a2(c2, t3), u2 = p2(u2, t3);
      }
    }
    return s2.xmin = f2, s2.ymin = y2, s2.xmax = d2, s2.ymax = g2, s2.spatialReference = this.spatialReference, e2 ? (s2.zmin = h2, s2.zmax = m2) : (s2.zmin = void 0, s2.zmax = void 0), i2 ? (s2.mmin = c2, s2.mmax = u2) : (s2.mmin = void 0, s2.mmax = void 0), s2;
  }
  writePoints(t2, e2) {
    e2.points = y$1r(this.points);
  }
  addPoint(t2) {
    return h$1i(this, t2), Array.isArray(t2) ? this.points.push(t2) : this.points.push(t2.toArray()), this.notifyChange("points"), this;
  }
  clone() {
    const t2 = { points: y$1r(this.points), spatialReference: this.spatialReference };
    return this.hasZ && (t2.hasZ = true), this.hasM && (t2.hasM = true), new h$1h(t2);
  }
  getPoint(t2) {
    if (!this._validateInputs(t2))
      return null;
    const s2 = this.points[t2], e2 = { x: s2[0], y: s2[1], spatialReference: this.spatialReference };
    let i2 = 2;
    return this.hasZ && (e2.z = s2[2], i2 = 3), this.hasM && (e2.m = s2[i2]), new w$K(e2);
  }
  removePoint(t2) {
    if (!this._validateInputs(t2))
      return null;
    const s2 = new w$K(this.points.splice(t2, 1)[0], this.spatialReference);
    return this.notifyChange("points"), s2;
  }
  setPoint(t2, s2) {
    return this._validateInputs(t2) ? (h$1i(this, s2), Array.isArray(s2) || (s2 = s2.toArray()), this.points[t2] = s2, this.notifyChange("points"), this) : this;
  }
  toJSON(t2) {
    return this.write({}, t2);
  }
  _validateInputs(t2) {
    return t2 != null && t2 >= 0 && t2 < this.points.length;
  }
};
e$1W([y$1o({ readOnly: true })], m$1G.prototype, "cache", null), e$1W([y$1o()], m$1G.prototype, "extent", null), e$1W([y$1o({ type: [[Number]], json: { write: { isRequired: true } } })], m$1G.prototype, "points", void 0), e$1W([r$1h("points")], m$1G.prototype, "writePoints", null), m$1G = h$1h = e$1W([n$2f("esri.geometry.Multipoint")], m$1G), m$1G.prototype.toJSON.isDefaultToJSON = true;
const u$1I = m$1G;
function e$1y(n2, t2) {
  const r2 = t2[0] - n2[0], e2 = t2[1] - n2[1];
  if (n2.length > 2 && t2.length > 2) {
    const o2 = n2[2] - t2[2];
    return Math.sqrt(r2 * r2 + e2 * e2 + o2 * o2);
  }
  return Math.sqrt(r2 * r2 + e2 * e2);
}
function o$1A(n2, t2, r2) {
  const e2 = n2[0] + r2 * (t2[0] - n2[0]), o2 = n2[1] + r2 * (t2[1] - n2[1]);
  return n2.length > 2 && t2.length > 2 ? [e2, o2, n2[2] + r2 * (t2[2] - n2[2])] : [e2, o2];
}
function i$2d(n2, t2, r2, e2) {
  const [o2, i2] = t2, [s2, l2] = r2[e2], [f2, c2] = r2[e2 + 1], u2 = f2 - s2, h2 = c2 - l2, a2 = u2 * u2 + h2 * h2, g2 = (o2 - s2) * u2 + (i2 - l2) * h2, m2 = Math.min(1, Math.max(0, g2 / a2));
  return n2[0] = s2 + u2 * m2, n2[1] = l2 + h2 * m2, n2;
}
function s$1J(n2, t2, r2) {
  const e2 = r2.rings;
  let o2, i2, s2 = false, f2 = 1 / 0;
  for (let c2 = 0; c2 < e2.length; c2++) {
    const r3 = e2[c2];
    for (let e3 = 0, c3 = r3.length - 1; e3 < r3.length; c3 = e3++)
      o2 = r3[e3], i2 = r3[c3], o2[1] > t2 != i2[1] > t2 && n2 < (i2[0] - o2[0]) * (t2 - o2[1]) / (i2[1] - o2[1]) + o2[0] && (s2 = !s2), f2 = Math.min(f2, l$1V(n2, t2, o2, i2));
  }
  return f2 === 0 ? 0 : (s2 ? 1 : -1) * Math.sqrt(f2);
}
function l$1V(n2, t2, r2, e2) {
  let o2 = r2[0], i2 = r2[1], s2 = e2[0] - o2, l2 = e2[1] - i2;
  if (s2 !== 0 || l2 !== 0) {
    const r3 = ((n2 - o2) * s2 + (t2 - i2) * l2) / (s2 * s2 + l2 * l2);
    r3 > 1 ? (o2 = e2[0], i2 = e2[1]) : r3 > 0 && (o2 += s2 * r3, i2 += l2 * r3);
  }
  return s2 = n2 - o2, l2 = t2 - i2, s2 * s2 + l2 * l2;
}
function f$1n(n2, t2) {
  return o$1A(n2, t2, 0.5);
}
function h$1g(n2, t2, r2) {
  const e2 = n2.length;
  let o2 = 0, i2 = 0, s2 = 0;
  for (let l2 = 0; l2 < e2; l2++) {
    const f2 = n2[l2], c2 = n2[(l2 + 1) % e2];
    let u2 = 2;
    o2 += f2[0] * c2[1] - c2[0] * f2[1], f2.length > 2 && c2.length > 2 && r2 && (i2 += f2[0] * c2[2] - c2[0] * f2[2], u2 = 3), f2.length > u2 && c2.length > u2 && t2 && (s2 += f2[0] * c2[u2] - c2[0] * f2[u2]);
  }
  return o2 <= 0 && i2 <= 0 && s2 <= 0;
}
function a$2k(t2) {
  const r2 = t2.length;
  return r2 > 2 && i$2x(t2[0], t2[r2 - 1]);
}
function g$X(n2) {
  var _a2, _b2;
  if ("rings" in n2 && (m$1F(n2), n2.rings.length > 0 && !h$1g(n2.rings[0], (_a2 = n2.hasM) != null ? _a2 : false, (_b2 = n2.hasZ) != null ? _b2 : false)))
    for (const t2 of n2.rings)
      t2.reverse();
}
function m$1F(n2) {
  if ("rings" in n2)
    for (const t2 of n2.rings)
      a$2k(t2) || t2.push(t2[0].slice());
}
function M$q(n2) {
  if (!n2 || n2.length < 3)
    return 0;
  let t2 = 0;
  const r2 = n2.length - 1;
  for (let e2 = 0; e2 < r2; e2++)
    t2 += (n2[e2][0] - n2[e2 + 1][0]) * (n2[e2][1] + n2[e2 + 1][1]);
  return t2 += (n2[r2][0] - n2[0][0]) * (n2[r2][1] + n2[0][1]), -0.5 * t2;
}
function e$1x(n2) {
  return n2 ? n2.hasZ ? [n2.xmax - n2.xmin / 2, n2.ymax - n2.ymin / 2, n2.zmax - n2.zmin / 2] : [n2.xmax - n2.xmin / 2, n2.ymax - n2.ymin / 2] : null;
}
function r$1d(n2) {
  var _a2;
  return n2 ? o$1z(n2.rings, (_a2 = n2.hasZ) != null ? _a2 : false) : null;
}
function o$1z(n2, t2) {
  if (!n2 || !n2.length)
    return null;
  const l2 = [], e2 = [], r2 = t2 ? [1 / 0, -1 / 0, 1 / 0, -1 / 0, 1 / 0, -1 / 0] : [1 / 0, -1 / 0, 1 / 0, -1 / 0];
  for (let o2 = 0, i2 = n2.length; o2 < i2; o2++) {
    const l3 = u$1H(n2[o2], t2, r2);
    l3 && e2.push(l3);
  }
  if (e2.sort((n3, l3) => {
    let e3 = n3[2] - l3[2];
    return e3 === 0 && t2 && (e3 = n3[4] - l3[4]), e3;
  }), e2.length && (l2[0] = e2[0][0], l2[1] = e2[0][1], t2 && (l2[2] = e2[0][3]), (l2[0] < r2[0] || l2[0] > r2[1] || l2[1] < r2[2] || l2[1] > r2[3] || t2 && (l2[2] < r2[4] || l2[2] > r2[5])) && (l2.length = 0)), !l2.length) {
    const e3 = n2[0] && n2[0].length ? i$2c(n2[0], t2) : null;
    if (!e3)
      return null;
    l2[0] = e3[0], l2[1] = e3[1], t2 && e3.length > 2 && (l2[2] = e3[2]);
  }
  return l2;
}
function u$1H(n2, t2, l2) {
  let e2 = 0, r2 = 0, o2 = 0, u2 = 0, i2 = 0;
  const s2 = n2.length ? n2[0][0] : 0, g2 = n2.length ? n2[0][1] : 0, h2 = n2.length && t2 ? n2[0][2] : 0;
  for (let f2 = 0; f2 < n2.length; f2++) {
    const c3 = n2[f2], m2 = n2[(f2 + 1) % n2.length], [x2, a2, y2] = c3, p2 = x2 - s2, z2 = a2 - g2, [Z2, d2, j2] = m2, U2 = Z2 - s2, b2 = d2 - g2, k2 = p2 * b2 - U2 * z2;
    if (u2 += k2, e2 += (p2 + U2) * k2, r2 += (z2 + b2) * k2, t2 && c3.length > 2 && m2.length > 2) {
      const n3 = y2 - h2, t3 = j2 - h2, l3 = p2 * t3 - U2 * n3;
      o2 += (n3 + t3) * l3, i2 += l3;
    }
    x2 < l2[0] && (l2[0] = x2), x2 > l2[1] && (l2[1] = x2), a2 < l2[2] && (l2[2] = a2), a2 > l2[3] && (l2[3] = a2), t2 && (y2 < l2[4] && (l2[4] = y2), y2 > l2[5] && (l2[5] = y2));
  }
  if (u2 > 0 && (u2 *= -1), i2 > 0 && (i2 *= -1), !u2)
    return null;
  u2 *= 0.5, i2 *= 0.5;
  const c2 = [e2 / (6 * u2) + s2, r2 / (6 * u2) + g2, u2];
  return t2 && (l2[4] === l2[5] || i2 === 0 ? (c2[3] = (l2[4] + l2[5]) / 2, c2[4] = 0) : (c2[3] = o2 / (6 * i2) + h2, c2[4] = i2)), c2;
}
function i$2c(l2, e2) {
  const r2 = e2 ? [0, 0, 0] : [0, 0], o2 = e2 ? [0, 0, 0] : [0, 0];
  let u2 = 0, i2 = 0, s2 = 0, g2 = 0;
  for (let h2 = 0, c2 = l2.length; h2 < c2 - 1; h2++) {
    const c3 = l2[h2], f2 = l2[h2 + 1];
    if (c3 && f2) {
      r2[0] = c3[0], r2[1] = c3[1], o2[0] = f2[0], o2[1] = f2[1], e2 && c3.length > 2 && f2.length > 2 && (r2[2] = c3[2], o2[2] = f2[2]);
      const l3 = e$1y(r2, o2);
      if (l3) {
        u2 += l3;
        const n2 = f$1n(c3, f2);
        i2 += l3 * n2[0], s2 += l3 * n2[1], e2 && n2.length > 2 && (g2 += l3 * n2[2]);
      }
    }
  }
  return u2 > 0 ? e2 ? [i2 / u2, s2 / u2, g2 / u2] : [i2 / u2, s2 / u2] : l2.length ? l2[0] : null;
}
const s$1I = 1e-6;
function g$W(n2) {
  if (!n2 || !n2.rings)
    return null;
  const { rings: t2 } = n2;
  let e2 = 0;
  for (let o2 = 0; o2 < t2.length; o2++)
    e2 += M$q(t2[o2]);
  if (e2 < s$1I)
    return o$1z(t2, false);
  const r2 = [0, 0], u2 = t2[0][0];
  for (let l2 = 0; l2 < t2.length; l2++)
    c$2z(r2, u2, t2[l2]);
  return r2[0] *= 1 / e2, r2[1] *= 1 / e2, r2[0] += u2[0], r2[1] += u2[1], r2;
}
const h$1f = 1 / 3;
function c$2z(n2, t2, e2) {
  if (!n2 || !e2 || e2.length < 3)
    return null;
  const r2 = e2[0], o2 = [0, 0], u2 = [e2[1][0] - r2[0], e2[1][1] - r2[1]];
  let i2;
  for (let l2 = 2; l2 < e2.length; l2++)
    o2[0] = e2[l2][0] - r2[0], o2[1] = e2[l2][1] - r2[1], i2 = 0.5 * h$1f * (o2[0] * u2[1] - o2[1] * u2[0]), n2[0] += i2 * (u2[0] + o2[0]), n2[1] += i2 * (u2[1] + o2[1]), u2[0] = o2[0], u2[1] = o2[1];
  const s2 = M$q(e2), g2 = [r2[0], r2[1]];
  return g2[0] -= t2[0], g2[1] -= t2[1], g2[0] *= s2, g2[1] *= s2, n2[0] += g2[0], n2[1] += g2[1], n2;
}
function n$27(n2) {
  return n2.xmin !== void 0 && n2.ymin !== void 0 && n2.xmax !== void 0 && n2.ymax !== void 0;
}
function t$1w(n2) {
  return n2.points !== void 0;
}
function e$1w(n2) {
  return n2.x !== void 0 && n2.y !== void 0;
}
function o$1y(n2) {
  return n2.paths !== void 0;
}
function r$1c(n2) {
  return n2.rings !== void 0;
}
function i$2b(n2) {
  function t2(t3, e2) {
    return t3 == null ? e2 : e2 == null ? t3 : n2(t3, e2);
  }
  return t2;
}
const l$1U = i$2b(Math.min), u$1G = i$2b(Math.max);
function c$2y(i2, l2) {
  return o$1y(l2) ? h$1e(i2, l2.paths, false, false) : r$1c(l2) ? h$1e(i2, l2.rings, false, false) : t$1w(l2) ? s$1H(i2, l2.points, false, false, false, false) : n$27(l2) ? g$V(i2, l2) : (e$1w(l2) && (i2[0] = l2.x, i2[1] = l2.y, i2[2] = l2.x, i2[3] = l2.y), i2);
}
function f$1m(i2, l2) {
  return o$1y(l2) ? h$1e(i2, l2.paths, true, false) : r$1c(l2) ? h$1e(i2, l2.rings, true, false) : t$1w(l2) ? s$1H(i2, l2.points, true, false, true, false) : n$27(l2) ? g$V(i2, l2, true, false, true, false) : (e$1w(l2) && (i2[0] = l2.x, i2[1] = l2.y, i2[2] = l2.z, i2[3] = l2.x, i2[4] = l2.y, i2[5] = l2.z), i2);
}
function h$1e(n2, t2, e2, o2) {
  const r2 = e2 ? 3 : 2;
  if (!t2.length || !t2[0].length)
    return null;
  let i2, c2, f2, h2, [g2, s2] = t2[0][0], [x2, m2] = t2[0][0];
  for (let a2 = 0; a2 < t2.length; a2++) {
    const n3 = t2[a2];
    for (let t3 = 0; t3 < n3.length; t3++) {
      const a3 = n3[t3], [d2, v2] = a3;
      if (g2 = l$1U(g2, d2), s2 = l$1U(s2, v2), x2 = u$1G(x2, d2), m2 = u$1G(m2, v2), e2 && a3.length > 2) {
        const n4 = a3[2];
        i2 = l$1U(i2, n4), c2 = u$1G(c2, n4);
      }
      if (o2 && a3.length > r2) {
        const n4 = a3[r2];
        f2 = l$1U(i2, n4), h2 = u$1G(c2, n4);
      }
    }
  }
  return e2 ? o2 ? (n2[0] = g2, n2[1] = s2, n2[2] = i2, n2[3] = f2, n2[4] = x2, n2[5] = m2, n2[6] = c2, n2[7] = h2, n2.length = 8, n2) : (n2[0] = g2, n2[1] = s2, n2[2] = i2, n2[3] = x2, n2[4] = m2, n2[5] = c2, n2.length = 6, n2) : o2 ? (n2[0] = g2, n2[1] = s2, n2[2] = f2, n2[3] = x2, n2[4] = m2, n2[5] = h2, n2.length = 6, n2) : (n2[0] = g2, n2[1] = s2, n2[2] = x2, n2[3] = m2, n2.length = 4, n2);
}
function g$V(n2, t2, e2, o2, r2, i2) {
  const l2 = t2.xmin, u2 = t2.xmax, c2 = t2.ymin, f2 = t2.ymax;
  let h2 = t2.zmin, g2 = t2.zmax, s2 = t2.mmin, x2 = t2.mmax;
  return r2 ? (h2 = h2 || 0, g2 = g2 || 0, i2 ? (s2 = s2 || 0, x2 = x2 || 0, n2[0] = l2, n2[1] = c2, n2[2] = h2, n2[3] = s2, n2[4] = u2, n2[5] = f2, n2[6] = g2, n2[7] = x2, n2) : (n2[0] = l2, n2[1] = c2, n2[2] = h2, n2[3] = u2, n2[4] = f2, n2[5] = g2, n2)) : i2 ? (s2 = s2 || 0, x2 = x2 || 0, n2[0] = l2, n2[1] = c2, n2[2] = s2, n2[3] = u2, n2[4] = f2, n2[5] = x2, n2) : (n2[0] = l2, n2[1] = c2, n2[2] = u2, n2[3] = f2, n2);
}
function s$1H(n2, t2, e2, o2, r2, i2) {
  const c2 = e2 ? 3 : 2, f2 = o2 && i2, h2 = e2 && r2;
  if (!t2.length || !t2[0].length)
    return null;
  let g2, s2, x2, m2, [a2, d2] = t2[0], [v2, y2] = t2[0];
  for (let p2 = 0; p2 < t2.length; p2++) {
    const n3 = t2[p2], [e3, o3] = n3;
    if (a2 = l$1U(a2, e3), d2 = l$1U(d2, o3), v2 = u$1G(v2, e3), y2 = u$1G(y2, o3), h2 && n3.length > 2) {
      const t3 = n3[2];
      g2 = l$1U(g2, t3), s2 = u$1G(s2, t3);
    }
    if (f2 && n3.length > c2) {
      const t3 = n3[c2];
      x2 = l$1U(g2, t3), m2 = u$1G(s2, t3);
    }
  }
  return r2 ? (g2 = g2 || 0, s2 = s2 || 0, i2 ? (x2 = x2 || 0, m2 = m2 || 0, n2[0] = a2, n2[1] = d2, n2[2] = g2, n2[3] = x2, n2[4] = v2, n2[5] = y2, n2[6] = s2, n2[7] = m2, n2) : (n2[0] = a2, n2[1] = d2, n2[2] = g2, n2[3] = v2, n2[4] = y2, n2[5] = s2, n2)) : i2 ? (x2 = x2 || 0, m2 = m2 || 0, n2[0] = a2, n2[1] = d2, n2[2] = x2, n2[3] = v2, n2[4] = y2, n2[5] = m2, n2) : (n2[0] = a2, n2[1] = d2, n2[2] = v2, n2[3] = y2, n2);
}
function t$1v(n2) {
  return n2.xmin !== void 0 && n2.ymin !== void 0 && n2.xmax !== void 0 && n2.ymax !== void 0;
}
function u$1F(n2) {
  return n2.points !== void 0;
}
function m$1E(n2) {
  return n2.x !== void 0 && n2.y !== void 0;
}
function o$1x(n2) {
  return n2.paths !== void 0;
}
function r$1b(n2) {
  return n2.rings !== void 0;
}
const x$E = [];
function a$2j(n2, i2, t2, u2) {
  return { xmin: n2, ymin: i2, xmax: t2, ymax: u2 };
}
function c$2x(n2, i2, t2, u2, m2, o2) {
  return { xmin: n2, ymin: i2, zmin: t2, xmax: u2, ymax: m2, zmax: o2 };
}
function s$1G(n2, i2, t2, u2, m2, o2) {
  return { xmin: n2, ymin: i2, mmin: t2, xmax: u2, ymax: m2, mmax: o2 };
}
function e$1v(n2, i2, t2, u2, m2, o2, r2, x2) {
  return { xmin: n2, ymin: i2, zmin: t2, mmin: u2, xmax: m2, ymax: o2, zmax: r2, mmax: x2 };
}
function f$1l(n2, i2 = false, t2 = false) {
  return i2 ? t2 ? e$1v(n2[0], n2[1], n2[2], n2[3], n2[4], n2[5], n2[6], n2[7]) : c$2x(n2[0], n2[1], n2[2], n2[3], n2[4], n2[5]) : t2 ? s$1G(n2[0], n2[1], n2[2], n2[3], n2[4], n2[5]) : a$2j(n2[0], n2[1], n2[2], n2[3]);
}
function l$1T(n2) {
  return n2 ? t$1v(n2) ? n2 : m$1E(n2) ? d$1q(n2) : r$1b(n2) ? v$P(n2) : o$1x(n2) ? h$1d(n2) : u$1F(n2) ? y$1b(n2) : null : null;
}
function y$1b(i2) {
  const { hasZ: t2, hasM: u2, points: m2 } = i2;
  return f$1l(s$1H(x$E, m2, t2 != null ? t2 : false, u2 != null ? u2 : false), t2, u2);
}
function d$1q(n2) {
  const { x: i2, y: t2, z: u2, m: m2 } = n2, o2 = m2 != null;
  return u2 != null ? o2 ? e$1v(i2, t2, u2, m2, i2, t2, u2, m2) : c$2x(i2, t2, u2, i2, t2, u2) : o2 ? s$1G(i2, t2, m2, i2, t2, m2) : a$2j(i2, t2, i2, t2);
}
function v$P(n2) {
  const { hasZ: t2, hasM: u2, rings: m2 } = n2, o2 = h$1e(x$E, m2, t2 != null ? t2 : false, u2 != null ? u2 : false);
  return o2 ? f$1l(o2, t2, u2) : null;
}
function h$1d(n2) {
  const { hasZ: t2, hasM: u2, paths: m2 } = n2, o2 = h$1e(x$E, m2, t2 != null ? t2 : false, u2 != null ? u2 : false);
  return o2 ? f$1l(o2, t2, u2) : null;
}
var x$D;
function j$G(t2) {
  return !Array.isArray(t2[0]);
}
let w$I = x$D = class extends p$2R {
  constructor(...t2) {
    super(...t2), this.rings = [], this.type = "polygon";
  }
  static fromExtent(t2) {
    const r2 = t2.clone().normalize(), e2 = t2.spatialReference;
    let s2 = false, i2 = false;
    for (const o2 of r2)
      o2.hasZ && (s2 = true), o2.hasM && (i2 = true);
    const n2 = { rings: r2.map((t3) => {
      const r3 = [[t3.xmin, t3.ymin], [t3.xmin, t3.ymax], [t3.xmax, t3.ymax], [t3.xmax, t3.ymin], [t3.xmin, t3.ymin]];
      if (s2 && t3.hasZ) {
        const e3 = t3.zmin + 0.5 * (t3.zmax - t3.zmin);
        for (let t4 = 0; t4 < r3.length; t4++)
          r3[t4].push(e3);
      }
      if (i2 && t3.hasM) {
        const e3 = t3.mmin + 0.5 * (t3.mmax - t3.mmin);
        for (let t4 = 0; t4 < r3.length; t4++)
          r3[t4].push(e3);
      }
      return r3;
    }), spatialReference: e2 };
    return s2 && (n2.hasZ = true), i2 && (n2.hasM = true), new x$D(n2);
  }
  normalizeCtorArgs(t2, r2) {
    let e2, s2, i2 = null, n2 = null;
    return t2 && !Array.isArray(t2) ? (i2 = t2.rings ? t2.rings : null, r2 || (t2.spatialReference ? r2 = t2.spatialReference : t2.rings || (r2 = t2)), e2 = t2.hasZ, s2 = t2.hasM) : i2 = t2, i2 = i2 || [], r2 = r2 || k$p.WGS84, i2.length && i2[0] && i2[0][0] != null && typeof i2[0][0] == "number" && (i2 = [i2]), n2 = i2[0] && i2[0][0], n2 && (e2 === void 0 && s2 === void 0 ? (e2 = n2.length > 2, s2 = n2.length > 3) : e2 === void 0 ? e2 = s2 ? n2.length > 3 : n2.length > 2 : s2 === void 0 && (s2 = e2 ? n2.length > 3 : n2.length > 2)), { rings: i2, spatialReference: r2, hasZ: e2, hasM: s2 };
  }
  get cache() {
    return this.commitProperty("rings"), this.commitProperty("hasZ"), this.commitProperty("hasM"), this.commitProperty("spatialReference"), {};
  }
  get centroid() {
    const t2 = r$1d(this);
    if (!t2 || isNaN(t2[0]) || isNaN(t2[1]) || this.hasZ && isNaN(t2[2]))
      return null;
    const r2 = new w$K();
    return r2.x = t2[0], r2.y = t2[1], r2.spatialReference = this.spatialReference, this.hasZ && (r2.z = t2[2]), r2;
  }
  get extent() {
    const { spatialReference: t2 } = this, r2 = v$P(this);
    if (!r2)
      return null;
    const e2 = new w$J(r2);
    return e2.spatialReference = t2, e2;
  }
  get isSelfIntersecting() {
    return p$2P(this.rings);
  }
  writeRings(t2, r2) {
    r2.rings = y$1r(this.rings);
  }
  addRing(t2) {
    if (!t2)
      return;
    const r2 = this.rings, e2 = r2.length;
    if (j$G(t2)) {
      const s2 = [];
      for (let r3 = 0, e3 = t2.length; r3 < e3; r3++)
        s2[r3] = t2[r3].toArray();
      r2[e2] = s2;
    } else
      r2[e2] = t2.concat();
    return this.notifyChange("rings"), this;
  }
  clone() {
    const t2 = new x$D();
    return t2.spatialReference = this.spatialReference, t2.rings = y$1r(this.rings), t2.hasZ = this.hasZ, t2.hasM = this.hasM, t2;
  }
  equals(t2) {
    if (this === t2)
      return true;
    if (t$1W(t2))
      return false;
    const e2 = this.spatialReference, n2 = t2.spatialReference;
    if (r$1t(e2) !== r$1t(n2))
      return false;
    if (r$1t(e2) && r$1t(n2) && !e2.equals(n2))
      return false;
    if (this.rings.length !== t2.rings.length)
      return false;
    const o2 = ([t3, r2, e3, s2], [i2, n3, o3, a2]) => t3 === i2 && r2 === n3 && (e3 == null && o3 == null || e3 === o3) && (s2 == null && a2 == null || s2 === a2);
    for (let s2 = 0; s2 < this.rings.length; s2++) {
      const e3 = this.rings[s2], i2 = t2.rings[s2];
      if (!i$2x(e3, i2, o2))
        return false;
    }
    return true;
  }
  contains(t2) {
    if (!t2)
      return false;
    const r2 = M$s(t2, this.spatialReference);
    return c$2C(this, r$1t(r2) ? r2 : t2);
  }
  isClockwise(t2) {
    let r2;
    return r2 = j$G(t2) ? t2.map((t3) => this.hasZ ? this.hasM ? [t3.x, t3.y, t3.z, t3.m] : [t3.x, t3.y, t3.z] : [t3.x, t3.y]) : t2, h$1g(r2, this.hasM, this.hasZ);
  }
  getPoint(t2, r2) {
    if (!this._validateInputs(t2, r2))
      return null;
    const e2 = this.rings[t2][r2], s2 = this.hasZ, i2 = this.hasM;
    return s2 && !i2 ? new w$K(e2[0], e2[1], e2[2], void 0, this.spatialReference) : i2 && !s2 ? new w$K(e2[0], e2[1], void 0, e2[2], this.spatialReference) : s2 && i2 ? new w$K(e2[0], e2[1], e2[2], e2[3], this.spatialReference) : new w$K(e2[0], e2[1], this.spatialReference);
  }
  insertPoint(t2, r2, e2) {
    return this._validateInputs(t2, r2, true) ? (h$1i(this, e2), Array.isArray(e2) || (e2 = e2.toArray()), this.rings[t2].splice(r2, 0, e2), this.notifyChange("rings"), this) : this;
  }
  removePoint(t2, r2) {
    if (!this._validateInputs(t2, r2))
      return null;
    const e2 = new w$K(this.rings[t2].splice(r2, 1)[0], this.spatialReference);
    return this.notifyChange("rings"), e2;
  }
  removeRing(t2) {
    if (!this._validateInputs(t2, null))
      return null;
    const r2 = this.rings.splice(t2, 1)[0], e2 = this.spatialReference, s2 = r2.map((t3) => new w$K(t3, e2));
    return this.notifyChange("rings"), s2;
  }
  setPoint(t2, r2, e2) {
    return this._validateInputs(t2, r2) ? (h$1i(this, e2), Array.isArray(e2) || (e2 = e2.toArray()), this.rings[t2][r2] = e2, this.notifyChange("rings"), this) : this;
  }
  _validateInputs(t2, r2, e2 = false) {
    if (t2 == null || t2 < 0 || t2 >= this.rings.length)
      return false;
    if (r2 != null) {
      const s2 = this.rings[t2];
      if (e2 && (r2 < 0 || r2 > s2.length))
        return false;
      if (!e2 && (r2 < 0 || r2 >= s2.length))
        return false;
    }
    return true;
  }
  toJSON(t2) {
    return this.write({}, t2);
  }
};
e$1W([y$1o({ readOnly: true })], w$I.prototype, "cache", null), e$1W([y$1o({ readOnly: true })], w$I.prototype, "centroid", null), e$1W([y$1o({ readOnly: true })], w$I.prototype, "extent", null), e$1W([y$1o({ readOnly: true })], w$I.prototype, "isSelfIntersecting", null), e$1W([y$1o({ type: [[[Number]]], json: { write: { isRequired: true } } })], w$I.prototype, "rings", void 0), e$1W([r$1h("rings")], w$I.prototype, "writeRings", null), w$I = x$D = e$1W([n$2f("esri.geometry.Polygon")], w$I), w$I.prototype.toJSON.isDefaultToJSON = true;
const v$O = w$I;
var c$2w;
function u$1E(t2) {
  return !Array.isArray(t2[0]);
}
let f$1k = c$2w = class extends p$2R {
  constructor(...t2) {
    super(...t2), this.paths = [], this.type = "polyline";
  }
  normalizeCtorArgs(t2, e2) {
    let s2, r2, i2 = null, a2 = null;
    return t2 && !Array.isArray(t2) ? (i2 = t2.paths ? t2.paths : null, e2 || (t2.spatialReference ? e2 = t2.spatialReference : t2.paths || (e2 = t2)), s2 = t2.hasZ, r2 = t2.hasM) : i2 = t2, i2 = i2 || [], e2 = e2 || k$p.WGS84, i2.length && i2[0] && i2[0][0] != null && typeof i2[0][0] == "number" && (i2 = [i2]), a2 = i2[0] && i2[0][0], a2 && (s2 === void 0 && r2 === void 0 ? (s2 = a2.length > 2, r2 = false) : s2 === void 0 ? s2 = !r2 && a2.length > 3 : r2 === void 0 && (r2 = !s2 && a2.length > 3)), { paths: i2, spatialReference: e2, hasZ: s2, hasM: r2 };
  }
  get cache() {
    return this.commitProperty("paths"), this.commitProperty("hasZ"), this.commitProperty("hasM"), this.commitProperty("spatialReference"), {};
  }
  get extent() {
    const { spatialReference: t2 } = this, e2 = h$1d(this);
    if (!e2)
      return null;
    const s2 = new w$J(e2);
    return s2.spatialReference = t2, s2;
  }
  writePaths(t2, s2) {
    s2.paths = y$1r(this.paths);
  }
  addPath(t2) {
    if (!t2)
      return;
    const e2 = this.paths, s2 = e2.length;
    if (u$1E(t2)) {
      const r2 = [];
      for (let e3 = 0, s3 = t2.length; e3 < s3; e3++)
        r2[e3] = t2[e3].toArray();
      e2[s2] = r2;
    } else
      e2[s2] = t2.concat();
    return this.notifyChange("paths"), this;
  }
  clone() {
    const t2 = new c$2w();
    return t2.spatialReference = this.spatialReference, t2.paths = y$1r(this.paths), t2.hasZ = this.hasZ, t2.hasM = this.hasM, t2;
  }
  getPoint(t2, e2) {
    if (!this._validateInputs(t2, e2))
      return null;
    const s2 = this.paths[t2][e2], r2 = this.hasZ, i2 = this.hasM;
    return r2 && !i2 ? new w$K(s2[0], s2[1], s2[2], void 0, this.spatialReference) : i2 && !r2 ? new w$K(s2[0], s2[1], void 0, s2[2], this.spatialReference) : r2 && i2 ? new w$K(s2[0], s2[1], s2[2], s2[3], this.spatialReference) : new w$K(s2[0], s2[1], this.spatialReference);
  }
  insertPoint(t2, e2, s2) {
    return this._validateInputs(t2, e2, true) ? (h$1i(this, s2), Array.isArray(s2) || (s2 = s2.toArray()), this.paths[t2].splice(e2, 0, s2), this.notifyChange("paths"), this) : this;
  }
  removePath(t2) {
    if (!this._validateInputs(t2, null))
      return null;
    const e2 = this.paths.splice(t2, 1)[0], s2 = this.spatialReference, r2 = e2.map((t3) => new w$K(t3, s2));
    return this.notifyChange("paths"), r2;
  }
  removePoint(t2, e2) {
    if (!this._validateInputs(t2, e2))
      return null;
    const s2 = new w$K(this.paths[t2].splice(e2, 1)[0], this.spatialReference);
    return this.notifyChange("paths"), s2;
  }
  setPoint(t2, e2, s2) {
    return this._validateInputs(t2, e2) ? (h$1i(this, s2), Array.isArray(s2) || (s2 = s2.toArray()), this.paths[t2][e2] = s2, this.notifyChange("paths"), this) : this;
  }
  _validateInputs(t2, e2, s2 = false) {
    if (t2 == null || t2 < 0 || t2 >= this.paths.length)
      return false;
    if (e2 != null) {
      const r2 = this.paths[t2];
      if (s2 && (e2 < 0 || e2 > r2.length))
        return false;
      if (!s2 && (e2 < 0 || e2 >= r2.length))
        return false;
    }
    return true;
  }
  toJSON(t2) {
    return this.write({}, t2);
  }
};
e$1W([y$1o({ readOnly: true })], f$1k.prototype, "cache", null), e$1W([y$1o({ readOnly: true })], f$1k.prototype, "extent", null), e$1W([y$1o({ type: [[[Number]]], json: { write: { isRequired: true } } })], f$1k.prototype, "paths", void 0), e$1W([r$1h("paths")], f$1k.prototype, "writePaths", null), f$1k = c$2w = e$1W([n$2f("esri.geometry.Polyline")], f$1k), f$1k.prototype.toJSON.isDefaultToJSON = true;
const m$1D = f$1k;
class s$1F {
  constructor(s2, o2 = { ignoreUnknown: false, useNumericKeys: false }) {
    this._jsonToAPI = s2, this._options = o2, this.apiValues = [], this.jsonValues = [], this._apiToJSON = this._invertMap(s2), this.apiValues = this._getKeysSorted(this._apiToJSON), this.jsonValues = this._getKeysSorted(this._jsonToAPI), this.read = (t2) => this.fromJSON(t2), this.write = (s3, o3, i2) => {
      const n2 = this.toJSON(s3);
      n2 !== void 0 && o$1X(i2, n2, o3);
    }, this.write.isJSONMapWriter = true;
  }
  toJSON(t2) {
    if (this._apiToJSON.hasOwnProperty(t2)) {
      const s2 = this._apiToJSON[t2];
      return this._options.useNumericKeys ? +s2 : s2;
    }
    return this._options.ignoreUnknown ? void 0 : t2;
  }
  fromJSON(t2) {
    return this._jsonToAPI.hasOwnProperty(t2) ? this._jsonToAPI[t2] : this._options.ignoreUnknown ? void 0 : t2;
  }
  _invertMap(t2) {
    const s2 = {};
    for (const o2 in t2)
      s2[t2[o2]] = o2;
    return s2;
  }
  _getKeysSorted(t2) {
    const s2 = [];
    for (const o2 in t2)
      s2.push(o2);
    return s2.sort(), s2;
  }
}
function o$1w() {
  return function(t2, o2) {
    return new s$1F(t2, __spreadValues({ ignoreUnknown: true }, o2));
  };
}
const i$2a = o$1w()({ esriGeometryPoint: "point", esriGeometryMultipoint: "multipoint", esriGeometryPolyline: "polyline", esriGeometryPolygon: "polygon" }), t$1u = o$1w()({ esriGeometryPoint: "point", esriGeometryMultipoint: "multipoint", esriGeometryPolyline: "polyline", esriGeometryPolygon: "polygon", esriGeometryEnvelope: "extent", mesh: "mesh" });
function u$1D(o2) {
  return o2.xmin !== void 0 && o2.ymin !== void 0 && o2.xmax !== void 0 && o2.ymax !== void 0;
}
function l$1S(o2) {
  return o2.points !== void 0;
}
function s$1E(o2) {
  return o2.x !== void 0 && o2.y !== void 0;
}
function f$1j(o2) {
  return o2.paths !== void 0;
}
function y$1a(o2) {
  return o2.rings !== void 0;
}
function v$N(p2) {
  return t$1W(p2) ? null : p2 instanceof p$2R ? p2 : s$1E(p2) ? w$K.fromJSON(p2) : f$1j(p2) ? m$1D.fromJSON(p2) : y$1a(p2) ? v$O.fromJSON(p2) : l$1S(p2) ? u$1I.fromJSON(p2) : u$1D(p2) ? w$J.fromJSON(p2) : null;
}
function c$2v(o2) {
  return o2 ? s$1E(o2) ? "esriGeometryPoint" : f$1j(o2) ? "esriGeometryPolyline" : y$1a(o2) ? "esriGeometryPolygon" : u$1D(o2) ? "esriGeometryEnvelope" : l$1S(o2) ? "esriGeometryMultipoint" : null : null;
}
const G$g = { esriGeometryPoint: w$K, esriGeometryPolyline: m$1D, esriGeometryPolygon: v$O, esriGeometryEnvelope: w$J, esriGeometryMultipoint: u$1I };
function d$1p(o2) {
  return o2 && G$g[o2] || null;
}
const i$29 = { base: p$2R, key: "type", typeMap: { extent: w$J, multipoint: u$1I, point: w$K, polyline: m$1D, polygon: v$O } };
S$H(i$29);
const i$28 = (s2) => {
  let i2 = class extends s2 {
    clone() {
      var _a2;
      const o2 = f$1F(e$1Q(this), "unable to clone instance of non-accessor class"), s3 = o2.metadatas, c2 = o2.store, i3 = {}, l2 = new Map();
      for (const r2 in s3) {
        const o3 = s3[r2], n2 = c2 == null ? void 0 : c2.originOf(r2), a3 = o3.clonable;
        if (o3.readOnly || a3 === false || n2 !== r$1m.USER && n2 !== r$1m.DEFAULTS && n2 !== r$1m.WEB_MAP && n2 !== r$1m.WEB_SCENE)
          continue;
        const p2 = this[r2];
        let f2 = null;
        f2 = typeof a3 == "function" ? a3(p2) : a3 === "reference" ? p2 : m$1S(p2), p2 != null && f2 == null || (n2 === r$1m.DEFAULTS ? l2.set(r2, f2) : i3[r2] = f2);
      }
      const a2 = new (Object.getPrototypeOf(this)).constructor(i3);
      if (l2.size) {
        const o3 = (_a2 = e$1Q(a2)) == null ? void 0 : _a2.store;
        if (o3)
          for (const [s4, t2] of l2)
            o3.set(s4, t2, r$1m.DEFAULTS);
      }
      return a2;
    }
  };
  return i2 = e$1W([n$2f("esri.core.Clonable")], i2), i2;
};
let l$1R = class extends i$28(m$1L) {
};
l$1R = e$1W([n$2f("esri.core.Clonable")], l$1R);
class i$27 {
  constructor() {
    this._emitter = new i$27.EventEmitter(this);
  }
  emit(t2, e2) {
    return this._emitter.emit(t2, e2);
  }
  on(t2, e2) {
    return this._emitter.on(t2, e2);
  }
  once(t2, e2) {
    return this._emitter.once(t2, e2);
  }
  hasEventListener(t2) {
    return this._emitter.hasEventListener(t2);
  }
}
!function(n2) {
  class o2 {
    constructor(t2 = null) {
      this._target = t2, this._listenersMap = null;
    }
    clear() {
      this._listenersMap && this._listenersMap.clear(), this._listenersMap = null;
    }
    emit(t2, e2) {
      const s2 = this._listenersMap && this._listenersMap.get(t2);
      if (!s2)
        return false;
      const r2 = this._target || this;
      return [...s2].forEach((t3) => {
        t3.call(r2, e2);
      }), s2.length > 0;
    }
    on(t2, e2) {
      if (Array.isArray(t2)) {
        const r3 = t2.map((t3) => this.on(t3, e2));
        return r$1p(r3);
      }
      if (t2.includes(","))
        throw new TypeError("Evented.on() with a comma delimited string of event types is not supported");
      this._listenersMap || (this._listenersMap = new Map());
      const r2 = this._listenersMap.get(t2) || [];
      return r2.push(e2), this._listenersMap.set(t2, r2), { remove: () => {
        const s2 = this._listenersMap && this._listenersMap.get(t2) || [], r3 = s2.indexOf(e2);
        r3 >= 0 && s2.splice(r3, 1);
      } };
    }
    once(t2, e2) {
      const s2 = this.on(t2, (t3) => {
        s2.remove(), e2.call(null, t3);
      });
      return s2;
    }
    hasEventListener(t2) {
      const e2 = this._listenersMap && this._listenersMap.get(t2);
      return e2 != null && e2.length > 0;
    }
  }
  n2.EventEmitter = o2, n2.EventedMixin = (e2) => {
    let s2 = class extends e2 {
      constructor() {
        super(...arguments), this._emitter = new o2();
      }
      destroy() {
        this._emitter.clear();
      }
      emit(t2, e3) {
        return this._emitter.emit(t2, e3);
      }
      on(t2, e3) {
        return this._emitter.on(t2, e3);
      }
      once(t2, e3) {
        return this._emitter.once(t2, e3);
      }
      hasEventListener(t2) {
        return this._emitter.hasEventListener(t2);
      }
    };
    return s2 = e$1W([n$2f("esri.core.Evented")], s2), s2;
  };
  let h2 = class extends m$1L {
    constructor() {
      super(...arguments), this._emitter = new i$27.EventEmitter(this);
    }
    destroy() {
      this._emitter.clear();
    }
    emit(t2, e2) {
      return this._emitter.emit(t2, e2);
    }
    on(t2, e2) {
      return this._emitter.on(t2, e2);
    }
    once(t2, e2) {
      return this._emitter.once(t2, e2);
    }
    hasEventListener(t2) {
      return this._emitter.hasEventListener(t2);
    }
  };
  h2 = e$1W([n$2f("esri.core.Evented")], h2), n2.EventedAccessor = h2;
}(i$27 || (i$27 = {}));
const n$26 = i$27;
var E$t;
!function(E2) {
  E2[E2.ADD = 1] = "ADD", E2[E2.REMOVE = 2] = "REMOVE", E2[E2.MOVE = 4] = "MOVE";
}(E$t || (E$t = {}));
function n$25(n2) {
  return (r2, t2) => {
    r2[t2] = n2;
  };
}
class e$1u {
  constructor() {
    this._observers = [];
  }
  observe(e2) {
    return this._observers.includes(e2) || this._observers.push(e2), new s$1S(this._observers, e2);
  }
  notify() {
    const s2 = this._observers.slice();
    for (let e2 = 0; e2 < s2.length; ++e2) {
      const r2 = s2[e2];
      r2.onInvalidated(), r2.onCommitted();
    }
  }
}
var g$U;
class p$2O {
  constructor() {
    this.target = null, this.cancellable = false, this.defaultPrevented = false, this.item = void 0, this.type = void 0;
  }
  preventDefault() {
    this.cancellable && (this.defaultPrevented = true);
  }
  reset(e2) {
    this.defaultPrevented = false, this.item = e2;
  }
}
const b$Q = new e$1K(p$2O, void 0, (e2) => {
  e2.item = null, e2.target = null, e2.defaultPrevented = false, e2.cancellable = false;
}), d$1o = () => {
};
function v$M(e2) {
  return e2 ? e2 instanceof V$b ? e2.toArray() : e2.length ? Array.prototype.slice.apply(e2) : [] : [];
}
function E$s(e2) {
  if (e2 && e2.length)
    return e2[0];
}
function y$19(e2, t2, s2, i2) {
  const r2 = Math.min(e2.length - s2, t2.length - i2);
  let n2 = 0;
  for (; n2 < r2 && e2[s2 + n2] === t2[i2 + n2]; )
    n2++;
  return n2;
}
function C$o(e2, t2, s2, i2) {
  t2 && t2.forEach((t3, r2, n2) => {
    e2.push(t3), C$o(e2, s2.call(i2, t3, r2, n2), s2, i2);
  });
}
const A$m = new Set(), O$m = new Set(), M$p = new Set(), D$p = new Map();
let x$C = 0, V$b = g$U = class extends n$26.EventedAccessor {
  constructor(e2) {
    super(e2), this._chgListeners = [], this._notifications = null, this._timer = null, this._observable = new e$1u(), this.length = 0, this._items = [], Object.defineProperty(this, "uid", { value: x$C++ });
  }
  static isCollection(e2) {
    return e2 != null && e2 instanceof g$U;
  }
  normalizeCtorArgs(e2) {
    return e2 ? Array.isArray(e2) || e2 instanceof g$U ? { items: e2 } : e2 : {};
  }
  destroy() {
    this.removeAll();
  }
  *[Symbol.iterator]() {
    yield* this.items;
  }
  get items() {
    return s$1X(this._observable), this._items;
  }
  set items(e2) {
    this._emitBeforeChanges(E$t.ADD) || (this._splice(0, this.length, v$M(e2)), this._emitAfterChanges(E$t.ADD));
  }
  hasEventListener(e2) {
    return e2 === "change" ? this._chgListeners.length > 0 : this._emitter.hasEventListener(e2);
  }
  on(e2, t2) {
    if (e2 === "change") {
      const e3 = this._chgListeners, s2 = { removed: false, callback: t2 };
      return e3.push(s2), this._notifications && this._notifications.push({ listeners: e3.slice(), items: this._items.slice(), changes: [] }), { remove() {
        this.remove = d$1o, s2.removed = true, e3.splice(e3.indexOf(s2), 1);
      } };
    }
    return this._emitter.on(e2, t2);
  }
  once(e2, t2) {
    const s2 = this.on(e2, t2);
    return { remove() {
      s2.remove();
    } };
  }
  add(e2, t2) {
    if (s$1X(this._observable), this._emitBeforeChanges(E$t.ADD))
      return this;
    const s2 = this.getNextIndex(t2 != null ? t2 : null);
    return this._splice(s2, 0, [e2]), this._emitAfterChanges(E$t.ADD), this;
  }
  addMany(e2, t2 = this._items.length) {
    if (s$1X(this._observable), !e2 || !e2.length)
      return this;
    if (this._emitBeforeChanges(E$t.ADD))
      return this;
    const s2 = this.getNextIndex(t2);
    return this._splice(s2, 0, v$M(e2)), this._emitAfterChanges(E$t.ADD), this;
  }
  at(e2) {
    if (s$1X(this._observable), (e2 = Math.trunc(e2) || 0) < 0 && (e2 += this.length), !(e2 < 0 || e2 >= this.length))
      return this._items[e2];
  }
  removeAll() {
    if (s$1X(this._observable), !this.length || this._emitBeforeChanges(E$t.REMOVE))
      return [];
    const e2 = this._splice(0, this.length) || [];
    return this._emitAfterChanges(E$t.REMOVE), e2;
  }
  clone() {
    return s$1X(this._observable), this._createNewInstance({ items: this._items.map(y$1r) });
  }
  concat(...e2) {
    s$1X(this._observable);
    const t2 = e2.map(v$M);
    return this._createNewInstance({ items: this._items.concat(...t2) });
  }
  drain(e2, t2) {
    if (s$1X(this._observable), !this.length || this._emitBeforeChanges(E$t.REMOVE))
      return;
    const s2 = x$N(this._splice(0, this.length)), i2 = s2.length;
    for (let r2 = 0; r2 < i2; r2++)
      e2.call(t2, s2[r2], r2, s2);
    this._emitAfterChanges(E$t.REMOVE);
  }
  every(e2, t2) {
    return s$1X(this._observable), this._items.every(e2, t2);
  }
  filter(e2, t2) {
    let s2;
    return s$1X(this._observable), s2 = arguments.length === 2 ? this._items.filter(e2, t2) : this._items.filter(e2), this._createNewInstance({ items: s2 });
  }
  find(e2, t2) {
    return s$1X(this._observable), this._items.find(e2, t2);
  }
  findIndex(e2, t2) {
    return s$1X(this._observable), this._items.findIndex(e2, t2);
  }
  flatten(e2, t2) {
    s$1X(this._observable);
    const s2 = [];
    return C$o(s2, this, e2, t2), new g$U(s2);
  }
  forEach(e2, t2) {
    return s$1X(this._observable), this._items.forEach(e2, t2);
  }
  getItemAt(e2) {
    return s$1X(this._observable), this._items[e2];
  }
  getNextIndex(e2) {
    s$1X(this._observable);
    const t2 = this.length;
    return (e2 = e2 != null ? e2 : t2) < 0 ? e2 = 0 : e2 > t2 && (e2 = t2), e2;
  }
  includes(e2, t2 = 0) {
    return s$1X(this._observable), this._items.includes(e2, t2);
  }
  indexOf(e2, t2 = 0) {
    return s$1X(this._observable), this._items.indexOf(e2, t2);
  }
  join(e2 = ",") {
    return s$1X(this._observable), this._items.join(e2);
  }
  lastIndexOf(e2, t2 = this.length - 1) {
    return s$1X(this._observable), this._items.lastIndexOf(e2, t2);
  }
  map(e2, t2) {
    s$1X(this._observable);
    const s2 = this._items.map(e2, t2);
    return new g$U({ items: s2 });
  }
  reorder(e2, t2 = this.length - 1) {
    s$1X(this._observable);
    const s2 = this.indexOf(e2);
    if (s2 !== -1) {
      if (t2 < 0 ? t2 = 0 : t2 >= this.length && (t2 = this.length - 1), s2 !== t2) {
        if (this._emitBeforeChanges(E$t.MOVE))
          return e2;
        this._splice(s2, 1), this._splice(t2, 0, [e2]), this._emitAfterChanges(E$t.MOVE);
      }
      return e2;
    }
  }
  pop() {
    if (s$1X(this._observable), !this.length || this._emitBeforeChanges(E$t.REMOVE))
      return;
    const e2 = E$s(this._splice(this.length - 1, 1));
    return this._emitAfterChanges(E$t.REMOVE), e2;
  }
  push(...e2) {
    return s$1X(this._observable), this._emitBeforeChanges(E$t.ADD) || (this._splice(this.length, 0, e2), this._emitAfterChanges(E$t.ADD)), this.length;
  }
  reduce(e2, t2) {
    s$1X(this._observable);
    const s2 = this._items;
    return arguments.length === 2 ? s2.reduce(e2, t2) : s2.reduce(e2);
  }
  reduceRight(e2, t2) {
    s$1X(this._observable);
    const s2 = this._items;
    return arguments.length === 2 ? s2.reduceRight(e2, t2) : s2.reduceRight(e2);
  }
  remove(e2) {
    return s$1X(this._observable), this.removeAt(this.indexOf(e2));
  }
  removeAt(e2) {
    if (s$1X(this._observable), e2 < 0 || e2 >= this.length || this._emitBeforeChanges(E$t.REMOVE))
      return;
    const t2 = E$s(this._splice(e2, 1));
    return this._emitAfterChanges(E$t.REMOVE), t2;
  }
  removeMany(e2) {
    if (s$1X(this._observable), !e2 || !e2.length || this._emitBeforeChanges(E$t.REMOVE))
      return [];
    const t2 = e2 instanceof g$U ? e2.toArray() : e2, s2 = this._items, i2 = [], r2 = t2.length;
    for (let n2 = 0; n2 < r2; n2++) {
      const e3 = t2[n2], r3 = s2.indexOf(e3);
      if (r3 > -1) {
        const e4 = 1 + y$19(t2, s2, n2 + 1, r3 + 1), h2 = this._splice(r3, e4);
        h2 && h2.length > 0 && i2.push.apply(i2, h2), n2 += e4 - 1;
      }
    }
    return this._emitAfterChanges(E$t.REMOVE), i2;
  }
  reverse() {
    if (s$1X(this._observable), this._emitBeforeChanges(E$t.MOVE))
      return this;
    const e2 = this._splice(0, this.length);
    return e2 && (e2.reverse(), this._splice(0, 0, e2)), this._emitAfterChanges(E$t.MOVE), this;
  }
  shift() {
    if (s$1X(this._observable), !this.length || this._emitBeforeChanges(E$t.REMOVE))
      return;
    const e2 = E$s(this._splice(0, 1));
    return this._emitAfterChanges(E$t.REMOVE), e2;
  }
  slice(e2 = 0, t2 = this.length) {
    return s$1X(this._observable), this._createNewInstance({ items: this._items.slice(e2, t2) });
  }
  some(e2, t2) {
    return s$1X(this._observable), this._items.some(e2, t2);
  }
  sort(e2) {
    if (s$1X(this._observable), !this.length || this._emitBeforeChanges(E$t.MOVE))
      return this;
    const t2 = x$N(this._splice(0, this.length));
    return arguments.length ? t2.sort(e2) : t2.sort(), this._splice(0, 0, t2), this._emitAfterChanges(E$t.MOVE), this;
  }
  splice(e2, t2, ...s2) {
    s$1X(this._observable);
    const i2 = (t2 ? E$t.REMOVE : 0) | (s2.length ? E$t.ADD : 0);
    if (this._emitBeforeChanges(i2))
      return [];
    const r2 = this._splice(e2, t2, s2) || [];
    return this._emitAfterChanges(i2), r2;
  }
  toArray() {
    return s$1X(this._observable), this._items.slice();
  }
  toJSON() {
    return s$1X(this._observable), this.toArray();
  }
  toLocaleString() {
    return s$1X(this._observable), this._items.toLocaleString();
  }
  toString() {
    return s$1X(this._observable), this._items.toString();
  }
  unshift(...e2) {
    return s$1X(this._observable), !e2.length || this._emitBeforeChanges(E$t.ADD) || (this._splice(0, 0, e2), this._emitAfterChanges(E$t.ADD)), this.length;
  }
  _createNewInstance(e2) {
    return new this.constructor(e2);
  }
  _splice(e2, t2, s2) {
    const i2 = this._items, r2 = this.itemType;
    let n2, h2;
    if (!this._notifications && this.hasEventListener("change") && (this._notifications = [{ listeners: this._chgListeners.slice(), items: this._items.slice(), changes: [] }], this._timer && this._timer.remove(), this._timer = v$R(() => this._dispatchChange())), t2) {
      if (h2 = i2.splice(e2, t2), this.hasEventListener("before-remove")) {
        const t3 = b$Q.acquire();
        t3.target = this, t3.cancellable = true;
        for (let s3 = 0, r3 = h2.length; s3 < r3; s3++)
          n2 = h2[s3], t3.reset(n2), this.emit("before-remove", t3), t3.defaultPrevented && (h2.splice(s3, 1), i2.splice(e2, 0, n2), e2 += 1, s3 -= 1, r3 -= 1);
        b$Q.release(t3);
      }
      if (this.length = this._items.length, this.hasEventListener("after-remove")) {
        const e3 = b$Q.acquire();
        e3.target = this, e3.cancellable = false;
        const t3 = h2.length;
        for (let s3 = 0; s3 < t3; s3++)
          e3.reset(h2[s3]), this.emit("after-remove", e3);
        b$Q.release(e3);
      }
    }
    if (s2 && s2.length) {
      if (r2) {
        const e3 = [];
        for (const t4 of s2) {
          const s3 = r2.ensureType(t4);
          s3 == null && t4 != null || e3.push(s3);
        }
        s2 = e3;
      }
      const t3 = this.hasEventListener("before-add"), n3 = this.hasEventListener("after-add"), h3 = e2 === this.length;
      if (t3 || n3) {
        const r3 = b$Q.acquire();
        r3.target = this, r3.cancellable = true;
        const o2 = b$Q.acquire();
        o2.target = this, o2.cancellable = false;
        for (const l2 of s2)
          t3 ? (r3.reset(l2), this.emit("before-add", r3), r3.defaultPrevented || (h3 ? i2.push(l2) : i2.splice(e2++, 0, l2), this._set("length", i2.length), n3 && (o2.reset(l2), this.emit("after-add", o2)))) : (h3 ? i2.push(l2) : i2.splice(e2++, 0, l2), this._set("length", i2.length), o2.reset(l2), this.emit("after-add", o2));
        b$Q.release(o2), b$Q.release(r3);
      } else {
        if (h3)
          for (const e3 of s2)
            i2.push(e3);
        else
          i2.splice(e2, 0, ...s2);
        this._set("length", i2.length);
      }
    }
    return (s2 && s2.length || h2 && h2.length) && this._notifyChangeEvent(s2, h2), h2;
  }
  _emitBeforeChanges(e2) {
    let t2 = false;
    if (this.hasEventListener("before-changes")) {
      const s2 = b$Q.acquire();
      s2.target = this, s2.cancellable = true, s2.type = e2, this.emit("before-changes", s2), t2 = s2.defaultPrevented, b$Q.release(s2);
    }
    return t2;
  }
  _emitAfterChanges(e2) {
    if (this.hasEventListener("after-changes")) {
      const t2 = b$Q.acquire();
      t2.target = this, t2.cancellable = false, t2.type = e2, this.emit("after-changes", t2), b$Q.release(t2);
    }
    this._observable.notify();
  }
  _notifyChangeEvent(e2, t2) {
    this.hasEventListener("change") && this._notifications && this._notifications[this._notifications.length - 1].changes.push({ added: e2, removed: t2 });
  }
  _dispatchChange() {
    if (this._timer && (this._timer.remove(), this._timer = null), !this._notifications)
      return;
    const e2 = this._notifications;
    this._notifications = null;
    for (const s2 of e2) {
      const e3 = s2.changes;
      A$m.clear(), O$m.clear(), M$p.clear();
      for (const { added: t2, removed: s3 } of e3) {
        if (t2)
          if (M$p.size === 0 && O$m.size === 0)
            for (const e4 of t2)
              A$m.add(e4);
          else
            for (const e4 of t2)
              O$m.has(e4) ? (M$p.add(e4), O$m.delete(e4)) : M$p.has(e4) || A$m.add(e4);
        if (s3)
          if (M$p.size === 0 && A$m.size === 0)
            for (const e4 of s3)
              O$m.add(e4);
          else
            for (const e4 of s3)
              A$m.has(e4) ? A$m.delete(e4) : (M$p.delete(e4), O$m.add(e4));
      }
      const i2 = t$1J.acquire();
      A$m.forEach((e4) => {
        i2.push(e4);
      });
      const r2 = t$1J.acquire();
      O$m.forEach((e4) => {
        r2.push(e4);
      });
      const n2 = this._items, h2 = s2.items, o2 = t$1J.acquire();
      if (M$p.forEach((e4) => {
        h2.indexOf(e4) !== n2.indexOf(e4) && o2.push(e4);
      }), s2.listeners && (i2.length || r2.length || o2.length)) {
        const e4 = { target: this, added: i2, removed: r2, moved: o2 }, t2 = s2.listeners.length;
        for (let i3 = 0; i3 < t2; i3++) {
          const t3 = s2.listeners[i3];
          t3.removed || t3.callback.call(this, e4);
        }
      }
      t$1J.release(i2), t$1J.release(r2), t$1J.release(o2);
    }
    A$m.clear(), O$m.clear(), M$p.clear();
  }
};
V$b.ofType = (t2) => {
  if (!t2)
    return g$U;
  if (D$p.has(t2))
    return D$p.get(t2);
  let s2 = null;
  if (typeof t2 == "function")
    s2 = t2.prototype.declaredClass;
  else if (t2.base)
    s2 = t2.base.prototype.declaredClass;
  else
    for (const e2 in t2.typeMap) {
      const i3 = t2.typeMap[e2].prototype.declaredClass;
      s2 ? s2 += ` | ${i3}` : s2 = i3;
    }
  let i2 = class extends g$U {
  };
  return e$1W([n$25({ Type: t2, ensureType: typeof t2 == "function" ? b$U(t2) : S$H(t2) })], i2.prototype, "itemType", void 0), i2 = e$1W([n$2f(`esri.core.Collection<${s2}>`)], i2), D$p.set(t2, i2), i2;
}, e$1W([y$1o()], V$b.prototype, "length", void 0), e$1W([y$1o()], V$b.prototype, "items", null), V$b = g$U = e$1W([n$2f("esri.core.Collection")], V$b);
const j$F = V$b;
var e$1t;
function n$24(n2, a2) {
  switch (n2.type) {
    case "range": {
      const r2 = "range" in n2 ? n2.range[0] : n2.minValue, u2 = "range" in n2 ? n2.range[1] : n2.maxValue;
      if (r2 != null && +a2 < r2 || u2 != null && +a2 > u2)
        return e$1t.VALUE_OUT_OF_RANGE;
      break;
    }
    case "coded-value":
    case "codedValue":
      if (n2.codedValues == null || n2.codedValues.every((e2) => e2 == null || e2.code !== a2))
        return e$1t.INVALID_CODED_VALUE;
  }
  return null;
}
!function(e2) {
  e2.VALUE_OUT_OF_RANGE = "domain-validation-error::value-out-of-range", e2.INVALID_CODED_VALUE = "domain-validation-error::invalid-coded-value";
}(e$1t || (e$1t = {}));
const s$1D = s$22.getLogger("esri.support.arcadeOnDemand");
let c$2u;
function i$26() {
  return c$2u || (c$2u = (async () => {
    const e2 = await import("./arcadeUtils.js").then(function(n2) {
      return n2.ay;
    });
    return { arcade: e2.arcade, arcadeUtils: e2, Dictionary: e2.Dictionary, Feature: e2.arcadeFeature };
  })()), c$2u;
}
const n$23 = (e2, r2, t2) => p$2N.create(e2, r2, t2, null, ["$feature"]), o$1v = (e2, r2, t2) => p$2N.create(e2, r2, t2, null, ["$feature", "$view"]), u$1C = (e2, r2, t2, a2) => p$2N.create(e2, r2, t2, a2, ["$feature", "$view"]);
class p$2N {
  constructor(e2, r2, t2, a2, s2, c2, i2, n2) {
    this.script = e2, this.evaluate = s2;
    const o2 = Array.isArray(i2) ? i2 : i2.fields;
    this.fields = o2, this._syntaxTree = a2, this._arcade = r2, this._arcadeDictionary = t2, this._arcadeFeature = c2, this._spatialReference = n2, this._referencesGeometry = r2.scriptTouchesGeometry(this._syntaxTree), this._referencesScale = this._arcade.referencesMember(this._syntaxTree, "scale");
  }
  static async create(r2, c2, n2, o2, l2, u2) {
    const { arcade: d2, Feature: m2, Dictionary: f2 } = await i$26(), y2 = k$p.fromJSON(c2);
    let h2 = null;
    try {
      h2 = d2.parseScript(r2, u2);
    } catch (R2) {
      return s$1D.error(new s$1Z("arcade-bad-expression", "Failed to parse arcade script", { script: r2, error: R2 })), null;
    }
    const _2 = l2.reduce((e2, r3) => __spreadProps(__spreadValues({}, e2), { [r3]: null }), {});
    let w2 = null;
    r$1t(o2) && (w2 = new f2(o2), w2.immutable = true, _2.$config = null);
    const F2 = d2.scriptUsesGeometryEngine(h2), g2 = F2 && d2.enableGeometrySupport(), S2 = d2.scriptUsesFeatureSet(h2) && d2.enableFeatureSetSupport(), b2 = d2.scriptIsAsync(h2), x2 = b2 && d2.enableAsyncSupport(), $2 = { vars: _2, spatialReference: y2, useAsync: !!x2 };
    await Promise.all([g2, S2, x2]);
    const v2 = new Set();
    await d2.loadDependentModules(v2, h2, null, b2, F2);
    const D2 = new f2();
    D2.immutable = false, D2.setField("scale", 0);
    const j2 = d2.compileScript(h2, $2), G2 = (e2) => ("$view" in e2 && e2.$view && (D2.setField("scale", e2.$view.scale), e2.$view = D2), w2 && (e2.$config = w2), j2({ vars: e2, spatialReference: y2 }));
    return new p$2N(r2, d2, f2, h2, G2, new m2(), n2, y2);
  }
  repurposeFeature(e2) {
    return e2.geometry && !e2.geometry.spatialReference && (e2.geometry.spatialReference = this._spatialReference), this._arcadeFeature.repurposeFromGraphicLikeObject(e2.geometry, e2.attributes, { fields: this.fields }), this._arcadeFeature;
  }
  createDictionary() {
    return new this._arcadeDictionary();
  }
  referencesMember(e2) {
    return this._arcade.referencesMember(this._syntaxTree, e2);
  }
  referencesFunction(e2) {
    return this._arcade.referencesFunction(this._syntaxTree, e2);
  }
  referencesGeometry() {
    return this._referencesGeometry;
  }
  referencesScale() {
    return this._referencesScale;
  }
  extractFieldLiterals() {
    return this._arcade.extractExpectedFieldLiterals(this._syntaxTree);
  }
}
const f$1i = /^([0-9])/, u$1B = /[^A-Za-z0-9_\u0080-\uffff]/g, c$2t = /_{2,}/g, d$1n = /^_/, m$1C = /_$/;
function p$2M(e2) {
  return e2 ? e2.trim().replace(u$1B, "_").replace(c$2t, "_").replace(d$1n, "").replace(m$1C, "").replace(f$1i, "F$1") : null;
}
const y$18 = ["field", "field2", "field3", "normalizationField", "rotationInfo.field", "proportionalSymbolInfo.field", "proportionalSymbolInfo.normalizationField", "colorInfo.field", "colorInfo.normalizationField"], g$T = ["field", "normalizationField"];
function F$k(e2, n2) {
  if (e2 != null && n2 != null) {
    for (const i2 of Array.isArray(e2) ? e2 : [e2])
      if (I$u(y$18, i2, n2), "visualVariables" in i2 && i2.visualVariables)
        for (const e3 of i2.visualVariables)
          I$u(g$T, e3, n2);
  }
}
function I$u(e2, n2, i2) {
  if (e2)
    for (const l2 of e2) {
      const e3 = t$1T(l2, n2), o2 = e3 && typeof e3 != "function" && i2.get(e3);
      o2 && o$1X(l2, o2.name, n2);
    }
}
function x$B(e2, n2) {
  var _a2, _b2, _c2, _d2, _e3;
  if (e2 != null && ((_a2 = n2 == null ? void 0 : n2.fields) == null ? void 0 : _a2.length))
    if ("startField" in e2) {
      const i2 = n2.get(e2.startField), t2 = n2.get(e2.endField);
      e2.startField = (_b2 = i2 == null ? void 0 : i2.name) != null ? _b2 : null, e2.endField = (_c2 = t2 == null ? void 0 : t2.name) != null ? _c2 : null;
    } else {
      const i2 = n2.get(e2.startTimeField), t2 = n2.get(e2.endTimeField);
      e2.startTimeField = (_d2 = i2 == null ? void 0 : i2.name) != null ? _d2 : null, e2.endTimeField = (_e3 = t2 == null ? void 0 : t2.name) != null ? _e3 : null;
    }
}
const b$P = new Set();
function T$n(e2, n2) {
  return e2 && n2 ? (b$P.clear(), h$1c(b$P, e2, n2), Array.from(b$P).sort()) : [];
}
function h$1c(e2, n2, i2) {
  var _a2;
  if (i2)
    if ((_a2 = n2 == null ? void 0 : n2.fields) == null ? void 0 : _a2.length)
      if (i2.includes("*"))
        for (const { name: t2 } of n2.fields)
          e2.add(t2);
      else
        for (const t2 of i2)
          w$H(e2, n2, t2);
    else {
      if (i2.includes("*"))
        return e2.clear(), void e2.add("*");
      for (const n3 of i2)
        n3 != null && e2.add(n3);
    }
}
function w$H(e2, n2, i2) {
  if (typeof i2 == "string")
    if (n2) {
      const t2 = n2.get(i2);
      t2 && e2.add(t2.name);
    } else
      e2.add(i2);
}
function v$L(e2, i2) {
  var _a2;
  return t$1W(i2) || t$1W(e2) ? [] : i2.includes("*") ? ((_a2 = e2.fields) != null ? _a2 : []).map((e3) => e3.name) : i2;
}
async function S$C(e2, n2, i2) {
  var _a2;
  if (!i2)
    return;
  const { arcadeUtils: t2 } = await i$26(), r2 = t2.extractFieldNames(i2, (_a2 = n2 == null ? void 0 : n2.fields) == null ? void 0 : _a2.map((e3) => e3.name));
  for (const l2 of r2)
    w$H(e2, n2, l2);
}
async function _$z(n2, i2, t2) {
  if (t2 && t2 !== "1=1") {
    const r2 = (await import("./WhereClause.js")).WhereClause.create(t2, i2);
    if (!r2.isStandardized)
      throw new s$1Z("fieldUtils:collectFilterFields", "Where clause is not standardized", { where: t2 });
    h$1c(n2, i2, r2.fieldNames);
  }
}
function E$r({ displayField: e2, fields: n2 }) {
  return e2 || (n2 && n2.length ? $$e(n2, "name-or-title") || $$e(n2, "unique-identifier") || $$e(n2, "type-or-category") || N$g(n2) : null);
}
function N$g(e2) {
  for (const n2 of e2) {
    if (!n2 || !n2.name)
      continue;
    const e3 = n2.name.toLowerCase();
    if (e3.includes("name") || e3.includes("title"))
      return n2.name;
  }
  return null;
}
function $$e(e2, n2) {
  for (const i2 of e2)
    if (i2 && i2.valueType && i2.valueType === n2)
      return i2.name;
  return null;
}
async function D$o(e2, n2) {
  if (!n2)
    return;
  const i2 = t$1T("elevationInfo.featureExpressionInfo", n2);
  return i2 ? i2.collectRequiredFields(e2, n2.fieldsIndex) : void 0;
}
function L$q(e2, n2, i2) {
  i2.onStatisticExpression ? S$C(e2, n2, i2.onStatisticExpression.expression) : e2.add(i2.onStatisticField);
}
async function O$l(e2, n2, i2) {
  if (!n2 || !i2 || !("fields" in i2))
    return;
  const t2 = [], r2 = i2.popupTemplate;
  t2.push(U$o(e2, n2, r2)), i2.fields && t2.push(...i2.fields.map(async (i3) => L$q(e2, n2.fieldsIndex, i3))), await Promise.all(t2);
}
async function U$o(e2, n2, i2) {
  const t2 = [];
  (i2 == null ? void 0 : i2.expressionInfos) && t2.push(...i2.expressionInfos.map((i3) => S$C(e2, n2.fieldsIndex, i3.expression)));
  const r2 = i2 == null ? void 0 : i2.content;
  if (Array.isArray(r2))
    for (const l2 of r2)
      l2.type === "expression" && l2.expressionInfo && t2.push(S$C(e2, n2.fieldsIndex, l2.expressionInfo.expression));
  await Promise.all(t2);
}
async function j$E(e2, n2, t2) {
  n2 && (n2.timeInfo && r$1t(t2) && t2.timeExtent && h$1c(e2, n2.fieldsIndex, [n2.timeInfo.startField, n2.timeInfo.endField]), n2.floorInfo && h$1c(e2, n2.fieldsIndex, [n2.floorInfo.floorField]), r$1t(t2) && r$1t(t2.where) && await _$z(e2, n2.fieldsIndex, t2.where));
}
async function z$p(e2, n2, i2) {
  n2 && i2 && await Promise.all(i2.map((i3) => P$o(e2, n2, i3)));
}
async function P$o(e2, n2, i2) {
  n2 && i2 && (i2.valueExpression ? await S$C(e2, n2.fieldsIndex, i2.valueExpression) : i2.field && w$H(e2, n2.fieldsIndex, i2.field));
}
function C$n(e2) {
  if (!e2)
    return [];
  const n2 = "editFieldsInfo" in e2 && e2.editFieldsInfo;
  return n2 ? T$n(e2.fieldsIndex, [n2 && n2.creatorField, n2 && n2.creationDateField, n2 && n2.editorField, n2 && n2.editDateField]) : [];
}
async function W$a(e2, n2) {
  const { labelingInfo: i2, fieldsIndex: t2 } = n2;
  i2 && i2.length && await Promise.all(i2.map((n3) => q$f(e2, t2, n3)));
}
async function q$f(e2, n2, i2) {
  if (!i2)
    return;
  const t2 = i2.getLabelExpression(), r2 = i2.where;
  if (t2.type === "arcade")
    await S$C(e2, n2, t2.expression);
  else {
    const i3 = t2.expression.match(/{[^}]*}/g);
    i3 && i3.forEach((i4) => {
      w$H(e2, n2, i4.slice(1, -1));
    });
  }
  await _$z(e2, n2, r2);
}
function M$o(e2) {
  const n2 = e2.defaultValue;
  return n2 !== void 0 && Q$b(e2, n2) ? n2 : e2.nullable ? null : void 0;
}
function Y$9(e2) {
  return typeof e2 == "number" && !isNaN(e2) && isFinite(e2);
}
function J$c(e2) {
  return e2 === null || Y$9(e2);
}
const X$8 = "isInteger" in Number ? Number.isInteger : (e2) => typeof e2 == "number" && isFinite(e2) && Math.floor(e2) === e2;
function Z$6(e2) {
  return e2 === null || X$8(e2);
}
function B$k(e2) {
  return e2 != null && typeof e2 == "string";
}
function H$d(e2) {
  return e2 === null || B$k(e2);
}
function K$a() {
  return true;
}
function Q$b(e2, n2) {
  let i2;
  switch (e2.type) {
    case "date":
    case "integer":
    case "long":
    case "small-integer":
    case "esriFieldTypeDate":
    case "esriFieldTypeInteger":
    case "esriFieldTypeLong":
    case "esriFieldTypeSmallInteger":
      i2 = e2.nullable ? Z$6 : X$8;
      break;
    case "double":
    case "single":
    case "esriFieldTypeSingle":
    case "esriFieldTypeDouble":
      i2 = e2.nullable ? J$c : Y$9;
      break;
    case "string":
    case "esriFieldTypeString":
      i2 = e2.nullable ? H$d : B$k;
      break;
    default:
      i2 = K$a;
  }
  return arguments.length === 1 ? i2 : i2(n2);
}
const ee$2 = ["integer", "small-integer", "single", "double"], ne$3 = new Set([...ee$2, "esriFieldTypeInteger", "esriFieldTypeSmallInteger", "esriFieldTypeSingle", "esriFieldTypeDouble"]);
function ie$3(e2) {
  return e2 != null && ne$3.has(e2.type);
}
function te$3(e2) {
  return e2 != null && (e2.type === "string" || e2.type === "esriFieldTypeString");
}
var oe$3, se$2;
function ae$2(e2) {
  return e2 == null || typeof e2 == "number" && isNaN(e2) ? null : e2;
}
function fe$2(e2, n2) {
  return e2.nullable && n2 === null ? null : ie$3(e2) && !ue$3(e2.type, Number(n2)) ? oe$3.OUT_OF_RANGE : Q$b(e2, n2) ? e2.domain ? n$24(e2.domain, n2) : null : se$2.INVALID_TYPE;
}
function ue$3(e2, n2) {
  const i2 = typeof e2 == "string" ? de$3(e2) : e2;
  if (!i2)
    return false;
  const t2 = i2.min, r2 = i2.max;
  return i2.isInteger ? X$8(n2) && n2 >= t2 && n2 <= r2 : n2 >= t2 && n2 <= r2;
}
function de$3(e2) {
  switch (e2) {
    case "esriFieldTypeSmallInteger":
    case "small-integer":
      return pe$3;
    case "esriFieldTypeInteger":
    case "integer":
      return ye$3;
    case "esriFieldTypeSingle":
    case "single":
      return ge$3;
    case "esriFieldTypeDouble":
    case "double":
      return Fe$1;
  }
}
!function(e2) {
  e2.OUT_OF_RANGE = "numeric-range-validation-error::out-of-range";
}(oe$3 || (oe$3 = {})), function(e2) {
  e2.INVALID_TYPE = "type-validation-error::invalid-type";
}(se$2 || (se$2 = {}));
const pe$3 = { min: -32768, max: 32767, isInteger: true }, ye$3 = { min: -2147483648, max: 2147483647, isInteger: true }, ge$3 = { min: -34e37, max: 12e37, isInteger: false }, Fe$1 = { min: -Number.MAX_VALUE, max: Number.MAX_VALUE, isInteger: false };
function Ie$1(e2, n2, i2) {
  switch (e2) {
    case e$1t.INVALID_CODED_VALUE:
      return `Value ${i2} is not in the coded domain - field: ${n2.name}, domain: ${JSON.stringify(n2.domain)}`;
    case e$1t.VALUE_OUT_OF_RANGE:
      return `Value ${i2} is out of the range of valid values - field: ${n2.name}, domain: ${JSON.stringify(n2.domain)}`;
    case se$2.INVALID_TYPE:
      return `Value ${i2} is not a valid value for the field type - field: ${n2.name}, type: ${n2.type}, nullable: ${n2.nullable}`;
    case oe$3.OUT_OF_RANGE: {
      const { min: e3, max: t2 } = de$3(n2.type);
      return `Value ${i2} is out of range for the number type - field: ${n2.name}, type: ${n2.type}, value range is ${e3} to ${t2}`;
    }
  }
}
function xe$1(e2, n2) {
  return !be$1(e2, n2, null);
}
function be$1(e2, n2, t2) {
  if (!n2 || !n2.attributes || !e2) {
    if (r$1t(t2))
      for (const n3 of e2 != null ? e2 : [])
        t2.add(n3);
    return true;
  }
  const r2 = n2.attributes;
  let l2 = false;
  for (const o2 of e2)
    if (!(o2 in r2)) {
      if (l2 = true, !r$1t(t2))
        break;
      t2.add(o2);
    }
  return l2;
}
function he$2(e2) {
  return ["raster.itempixelvalue", "raster.servicepixelvalue"].some((n2) => e2.toLowerCase().startsWith(n2));
}
let e$1s = class extends l$1_ {
  constructor(r2) {
    super(r2), this.type = null;
  }
};
e$1W([y$1o({ type: ["attachments", "custom", "fields", "media", "text", "expression", "relationship"], readOnly: true, json: { read: false, write: true } })], e$1s.prototype, "type", void 0), e$1s = e$1W([n$2f("esri.popup.content.Content")], e$1s);
const p$2L = e$1s;
var s$1C;
let p$2K = s$1C = class extends p$2L {
  constructor(t2) {
    super(t2), this.description = null, this.displayType = "auto", this.title = null, this.type = "attachments";
  }
  clone() {
    return new s$1C({ description: this.description, displayType: this.displayType, title: this.title });
  }
};
e$1W([y$1o({ type: String, json: { write: true } })], p$2K.prototype, "description", void 0), e$1W([y$1o({ type: ["auto", "preview", "list"], json: { write: true } })], p$2K.prototype, "displayType", void 0), e$1W([y$1o({ type: String, json: { write: true } })], p$2K.prototype, "title", void 0), e$1W([y$1o({ type: ["attachments"], readOnly: true, json: { read: false, write: true } })], p$2K.prototype, "type", void 0), p$2K = s$1C = e$1W([n$2f("esri.popup.content.AttachmentsContent")], p$2K);
const i$25 = p$2K;
var p$2J;
let c$2s = p$2J = class extends p$2L {
  constructor(o2) {
    super(o2), this.creator = null, this.destroyer = null, this.outFields = null, this.type = "custom";
  }
  clone() {
    return new p$2J({ creator: this.creator, destroyer: this.destroyer, outFields: Array.isArray(this.outFields) ? y$1r(this.outFields) : null });
  }
};
e$1W([y$1o()], c$2s.prototype, "creator", void 0), e$1W([y$1o()], c$2s.prototype, "destroyer", void 0), e$1W([y$1o()], c$2s.prototype, "outFields", void 0), e$1W([y$1o({ type: ["custom"], readOnly: true })], c$2s.prototype, "type", void 0), c$2s = p$2J = e$1W([n$2f("esri.popup.content.CustomContent")], c$2s);
const i$24 = c$2s;
var s$1B;
let p$2I = s$1B = class extends l$1_ {
  constructor(r2) {
    super(r2), this.title = null, this.expression = null, this.returnType = "dictionary";
  }
  clone() {
    return new s$1B({ title: this.title, expression: this.expression });
  }
};
e$1W([y$1o({ type: String, json: { write: true } })], p$2I.prototype, "title", void 0), e$1W([y$1o({ type: String, json: { write: true } })], p$2I.prototype, "expression", void 0), e$1W([y$1o({ type: ["dictionary"], readOnly: true, json: { read: false, write: true } })], p$2I.prototype, "returnType", void 0), p$2I = s$1B = e$1W([n$2f("esri.popup.ElementExpressionInfo")], p$2I);
const i$23 = p$2I;
var p$2H;
let n$22 = p$2H = class extends p$2L {
  constructor(o2) {
    super(o2), this.expressionInfo = null, this.type = "expression";
  }
  clone() {
    var _a2;
    return new p$2H({ expressionInfo: (_a2 = this.expressionInfo) == null ? void 0 : _a2.clone() });
  }
};
e$1W([y$1o({ type: i$23, json: { write: true } })], n$22.prototype, "expressionInfo", void 0), e$1W([y$1o({ type: ["expression"], readOnly: true, json: { read: false, write: true } })], n$22.prototype, "type", void 0), n$22 = p$2H = e$1W([n$2f("esri.popup.content.ExpressionContent")], n$22);
const i$22 = n$22;
function r$1a(r2, o2 = {}) {
  var _a2;
  const a2 = r2 instanceof s$1F ? r2 : new s$1F(r2, o2), t2 = { type: ((_a2 = o2 == null ? void 0 : o2.ignoreUnknown) != null ? _a2 : 1) ? a2.apiValues : String, json: { type: a2.jsonValues, read: !(o2 == null ? void 0 : o2.readOnly) && { reader: a2.read }, write: { writer: a2.write } } };
  return (o2 == null ? void 0 : o2.readOnly) !== void 0 && (t2.readOnly = !!o2.readOnly), (o2 == null ? void 0 : o2.default) !== void 0 && (t2.json.default = o2.default), (o2 == null ? void 0 : o2.name) !== void 0 && (t2.json.name = o2.name), y$1o(t2);
}
const a$2i = o$1w()({ shortDate: "short-date", shortDateShortTime: "short-date-short-time", shortDateShortTime24: "short-date-short-time-24", shortDateLongTime: "short-date-long-time", shortDateLongTime24: "short-date-long-time-24", shortDateLE: "short-date-le", shortDateLEShortTime: "short-date-le-short-time", shortDateLEShortTime24: "short-date-le-short-time-24", shortDateLELongTime: "short-date-le-long-time", shortDateLELongTime24: "short-date-le-long-time-24", longMonthDayYear: "long-month-day-year", longMonthDayYearShortTime: "long-month-day-year-short-time", longMonthDayYearShortTime24: "long-month-day-year-short-time-24", longMonthDayYearLongTime: "long-month-day-year-long-time", longMonthDayYearLongTime24: "long-month-day-year-long-time-24", dayShortMonthYear: "day-short-month-year", dayShortMonthYearShortTime: "day-short-month-year-short-time", dayShortMonthYearShortTime24: "day-short-month-year-short-time-24", dayShortMonthYearLongTime: "day-short-month-year-long-time", dayShortMonthYearLongTime24: "day-short-month-year-long-time-24", longDate: "long-date", longDateShortTime: "long-date-short-time", longDateShortTime24: "long-date-short-time-24", longDateLongTime: "long-date-long-time", longDateLongTime24: "long-date-long-time-24", longMonthYear: "long-month-year", shortMonthYear: "short-month-year", year: "year" });
a$2i.toJSON.bind(a$2i);
a$2i.fromJSON.bind(a$2i);
let o$1u;
const e$1r = (_h = (_f = globalThis.esriConfig) == null ? void 0 : _f.locale) != null ? _h : (_g = globalThis.dojoConfig) == null ? void 0 : _g.locale;
function t$1t() {
  var _a2, _b2;
  return (_b2 = e$1r != null ? e$1r : (_a2 = globalThis.navigator) == null ? void 0 : _a2.language) != null ? _b2 : "en";
}
function l$1Q() {
  return o$1u === void 0 && (o$1u = t$1t()), o$1u;
}
const u$1A = [];
function s$1A(n2) {
  return u$1A.push(n2), { remove() {
    u$1A.splice(u$1A.indexOf(n2), 1);
  } };
}
const f$1h = [];
function g$S(n2) {
  return f$1h.push(n2), { remove() {
    u$1A.splice(f$1h.indexOf(n2), 1);
  } };
}
function h$1b() {
  const e2 = t$1t();
  o$1u !== e2 && (o$1u = e2, [...f$1h].forEach((n2) => {
    n2.call(null, e2);
  }), [...u$1A].forEach((n2) => {
    n2.call(null, e2);
  }));
}
(_i = globalThis.addEventListener) == null ? void 0 : _i.call(globalThis, "languagechange", h$1b);
const r$19 = { year: "numeric", month: "numeric", day: "numeric" }, n$21 = { year: "numeric", month: "long", day: "numeric" }, a$2h = { year: "numeric", month: "short", day: "numeric" }, h$1a = { year: "numeric", month: "long", weekday: "long", day: "numeric" }, m$1B = { hour: "numeric", minute: "numeric" }, i$21 = __spreadProps(__spreadValues({}, m$1B), { second: "numeric" }), s$1z = { "short-date": r$19, "short-date-short-time": __spreadValues(__spreadValues({}, r$19), m$1B), "short-date-short-time-24": __spreadProps(__spreadValues(__spreadValues({}, r$19), m$1B), { hour12: false }), "short-date-long-time": __spreadValues(__spreadValues({}, r$19), i$21), "short-date-long-time-24": __spreadProps(__spreadValues(__spreadValues({}, r$19), i$21), { hour12: false }), "short-date-le": r$19, "short-date-le-short-time": __spreadValues(__spreadValues({}, r$19), m$1B), "short-date-le-short-time-24": __spreadProps(__spreadValues(__spreadValues({}, r$19), m$1B), { hour12: false }), "short-date-le-long-time": __spreadValues(__spreadValues({}, r$19), i$21), "short-date-le-long-time-24": __spreadProps(__spreadValues(__spreadValues({}, r$19), i$21), { hour12: false }), "long-month-day-year": n$21, "long-month-day-year-short-time": __spreadValues(__spreadValues({}, n$21), m$1B), "long-month-day-year-short-time-24": __spreadProps(__spreadValues(__spreadValues({}, n$21), m$1B), { hour12: false }), "long-month-day-year-long-time": __spreadValues(__spreadValues({}, n$21), i$21), "long-month-day-year-long-time-24": __spreadProps(__spreadValues(__spreadValues({}, n$21), i$21), { hour12: false }), "day-short-month-year": a$2h, "day-short-month-year-short-time": __spreadValues(__spreadValues({}, a$2h), m$1B), "day-short-month-year-short-time-24": __spreadProps(__spreadValues(__spreadValues({}, a$2h), m$1B), { hour12: false }), "day-short-month-year-long-time": __spreadValues(__spreadValues({}, a$2h), i$21), "day-short-month-year-long-time-24": __spreadProps(__spreadValues(__spreadValues({}, a$2h), i$21), { hour12: false }), "long-date": h$1a, "long-date-short-time": __spreadValues(__spreadValues({}, h$1a), m$1B), "long-date-short-time-24": __spreadProps(__spreadValues(__spreadValues({}, h$1a), m$1B), { hour12: false }), "long-date-long-time": __spreadValues(__spreadValues({}, h$1a), i$21), "long-date-long-time-24": __spreadProps(__spreadValues(__spreadValues({}, h$1a), i$21), { hour12: false }), "long-month-year": { month: "long", year: "numeric" }, "short-month-year": { month: "short", year: "numeric" }, year: { year: "numeric" }, "short-time": m$1B, "long-time": i$21 }, l$1P = o$1w()({ shortDate: "short-date", shortDateShortTime: "short-date-short-time", shortDateShortTime24: "short-date-short-time-24", shortDateLongTime: "short-date-long-time", shortDateLongTime24: "short-date-long-time-24", shortDateLE: "short-date-le", shortDateLEShortTime: "short-date-le-short-time", shortDateLEShortTime24: "short-date-le-short-time-24", shortDateLELongTime: "short-date-le-long-time", shortDateLELongTime24: "short-date-le-long-time-24", longMonthDayYear: "long-month-day-year", longMonthDayYearShortTime: "long-month-day-year-short-time", longMonthDayYearShortTime24: "long-month-day-year-short-time-24", longMonthDayYearLongTime: "long-month-day-year-long-time", longMonthDayYearLongTime24: "long-month-day-year-long-time-24", dayShortMonthYear: "day-short-month-year", dayShortMonthYearShortTime: "day-short-month-year-short-time", dayShortMonthYearShortTime24: "day-short-month-year-short-time-24", dayShortMonthYearLongTime: "day-short-month-year-long-time", dayShortMonthYearLongTime24: "day-short-month-year-long-time-24", longDate: "long-date", longDateShortTime: "long-date-short-time", longDateShortTime24: "long-date-short-time-24", longDateLongTime: "long-date-long-time", longDateLongTime24: "long-date-long-time-24", longMonthYear: "long-month-year", shortMonthYear: "short-month-year", year: "year" });
l$1P.apiValues;
l$1P.toJSON.bind(l$1P);
l$1P.fromJSON.bind(l$1P);
const u$1z = { ar: "ar-u-nu-latn-ca-gregory" };
let c$2r = new WeakMap(), D$n = s$1z["short-date-short-time"];
function T$m(t2) {
  const o2 = t2 || D$n;
  let r2 = c$2r.get(o2);
  if (!r2) {
    const t3 = l$1Q(), n2 = u$1z[l$1Q()] || t3;
    r2 = new Intl.DateTimeFormat(n2, o2), c$2r.set(o2, r2);
  }
  return r2;
}
function S$B(t2) {
  return t2 ? s$1z[t2] : null;
}
function L$p(t2, o2) {
  return T$m(o2).format(t2);
}
g$S(() => {
  c$2r = new WeakMap(), D$n = s$1z["short-date-short-time"];
});
const a$2g = { ar: "ar-u-nu-latn" };
let e$1q = new WeakMap(), o$1t = {};
function i$20(n2) {
  const i2 = n2 || o$1t;
  if (!e$1q.has(i2)) {
    const t2 = l$1Q(), o2 = a$2g[l$1Q()] || t2;
    e$1q.set(i2, new Intl.NumberFormat(o2, n2));
  }
  return x$N(e$1q.get(i2));
}
function u$1y(t2 = {}) {
  const n2 = {};
  return t2.digitSeparator != null && (n2.useGrouping = t2.digitSeparator), t2.places != null && (n2.minimumFractionDigits = n2.maximumFractionDigits = t2.places), n2;
}
function m$1A(t2, n2) {
  return t2 === -0 && (t2 = 0), i$20(n2).format(t2);
}
g$S(() => {
  e$1q = new WeakMap(), o$1t = {};
});
var d$1m;
let l$1O = d$1m = class extends l$1_ {
  constructor(t2) {
    super(t2), this.dateFormat = null, this.dateTimeFormatOptions = null, this.digitSeparator = false, this.places = null;
  }
  clone() {
    return new d$1m({ dateFormat: this.dateFormat, digitSeparator: this.digitSeparator, places: this.places });
  }
  format(t2) {
    return this.dateFormat ? L$p(t2, __spreadValues(__spreadValues({}, S$B(this.dateFormat)), this.dateTimeFormatOptions)) : m$1A(t2, u$1y(this));
  }
  formatRasterPixelValue(t2) {
    if (t2.includes("-"))
      return t2;
    let r2, o2;
    return t2.trim().includes(",") ? (r2 = ",", o2 = r2 + " ", this._formatDelimitedString(t2, r2, o2, this)) : t2.trim().includes(";") ? (r2 = ";", o2 = r2 + " ", this._formatDelimitedString(t2, r2, o2, this)) : t2.trim().includes(" ") ? (r2 = o2 = " ", this._formatDelimitedString(t2, r2, o2, this)) : this.format(Number(t2));
  }
  _formatDelimitedString(t2, r2, o2, e2) {
    return t2 && r2 && o2 && e2 ? t2.trim().split(r2).map((t3) => this.format(Number(t3))).join(o2) : t2;
  }
};
e$1W([r$1a(a$2i)], l$1O.prototype, "dateFormat", void 0), e$1W([y$1o({ type: Object, json: { read: false } })], l$1O.prototype, "dateTimeFormatOptions", void 0), e$1W([y$1o({ type: Boolean, json: { write: true } })], l$1O.prototype, "digitSeparator", void 0), e$1W([y$1o({ type: T$r, json: { write: true } })], l$1O.prototype, "places", void 0), l$1O = d$1m = e$1W([n$2f("esri.popup.support.FieldInfoFormat")], l$1O);
const u$1x = l$1O;
var a$2f;
let n$20 = a$2f = class extends l$1_ {
  constructor(t2) {
    super(t2), this.fieldName = null, this.format = null, this.isEditable = false, this.label = null, this.stringFieldOption = "text-box", this.statisticType = null, this.tooltip = null, this.visible = true;
  }
  clone() {
    return new a$2f({ fieldName: this.fieldName, format: this.format ? y$1r(this.format) : null, isEditable: this.isEditable, label: this.label, stringFieldOption: this.stringFieldOption, statisticType: this.statisticType, tooltip: this.tooltip, visible: this.visible });
  }
};
e$1W([y$1o({ type: String, json: { write: true } })], n$20.prototype, "fieldName", void 0), e$1W([y$1o({ type: u$1x, json: { write: true } })], n$20.prototype, "format", void 0), e$1W([y$1o({ type: Boolean, json: { write: true, default: false } })], n$20.prototype, "isEditable", void 0), e$1W([y$1o({ type: String, json: { write: true } })], n$20.prototype, "label", void 0), e$1W([r$1a(new s$1F({ richtext: "rich-text", textarea: "text-area", textbox: "text-box" }), { default: "text-box" })], n$20.prototype, "stringFieldOption", void 0), e$1W([y$1o({ type: ["count", "sum", "min", "max", "avg", "stddev", "var"], json: { write: true } })], n$20.prototype, "statisticType", void 0), e$1W([y$1o({ type: String, json: { write: true } })], n$20.prototype, "tooltip", void 0), e$1W([y$1o({ type: Boolean, json: { write: true } })], n$20.prototype, "visible", void 0), n$20 = a$2f = e$1W([n$2f("esri.popup.FieldInfo")], n$20);
const c$2q = n$20;
var n$1$;
let l$1N = n$1$ = class extends p$2L {
  constructor(t2) {
    super(t2), this.attributes = null, this.description = null, this.fieldInfos = null, this.title = null, this.type = "fields";
  }
  writeFieldInfos(t2, o2) {
    o2.fieldInfos = t2 && t2.map((t3) => t3.toJSON());
  }
  clone() {
    return new n$1$(y$1r({ attributes: this.attributes, description: this.description, fieldInfos: this.fieldInfos, title: this.title }));
  }
};
e$1W([y$1o({ type: Object, json: { write: true } })], l$1N.prototype, "attributes", void 0), e$1W([y$1o({ type: String, json: { write: true } })], l$1N.prototype, "description", void 0), e$1W([y$1o({ type: [c$2q] })], l$1N.prototype, "fieldInfos", void 0), e$1W([r$1h("fieldInfos")], l$1N.prototype, "writeFieldInfos", null), e$1W([y$1o({ type: String, json: { write: true } })], l$1N.prototype, "title", void 0), e$1W([y$1o({ type: ["fields"], readOnly: true, json: { read: false, write: true } })], l$1N.prototype, "type", void 0), l$1N = n$1$ = e$1W([n$2f("esri.popup.content.FieldsContent")], l$1N);
const c$2p = l$1N;
let s$1y = class extends l$1_ {
  constructor(t2) {
    super(t2), this.altText = null, this.caption = "", this.title = "", this.type = null;
  }
};
e$1W([y$1o({ type: String, json: { write: true } })], s$1y.prototype, "altText", void 0), e$1W([y$1o({ type: String, json: { write: true } })], s$1y.prototype, "caption", void 0), e$1W([y$1o({ type: String, json: { write: true } })], s$1y.prototype, "title", void 0), e$1W([y$1o({ type: ["image", "bar-chart", "column-chart", "line-chart", "pie-chart"], readOnly: true, json: { read: false, write: true } })], s$1y.prototype, "type", void 0), s$1y = e$1W([n$2f("esri.popup.content.mixins.MediaInfo")], s$1y);
const p$2G = s$1y;
var s$1x;
let p$2F = s$1x = class extends m$1L {
  constructor(o2) {
    super(o2), this.fieldName = null, this.tooltip = null, this.value = null;
  }
  clone() {
    return new s$1x({ fieldName: this.fieldName, tooltip: this.tooltip, value: this.value });
  }
};
e$1W([y$1o()], p$2F.prototype, "fieldName", void 0), e$1W([y$1o()], p$2F.prototype, "tooltip", void 0), e$1W([y$1o()], p$2F.prototype, "value", void 0), p$2F = s$1x = e$1W([n$2f("esri.popup.content.support.ChartMediaInfoValueSeries")], p$2F);
const i$1$ = p$2F;
var p$2E;
let l$1M = p$2E = class extends l$1_ {
  constructor(o2) {
    super(o2), this.fields = [], this.normalizeField = null, this.series = [], this.tooltipField = null;
  }
  clone() {
    return new p$2E({ fields: y$1r(this.fields), normalizeField: this.normalizeField, tooltipField: this.tooltipField });
  }
};
e$1W([y$1o({ type: [String], json: { write: true } })], l$1M.prototype, "fields", void 0), e$1W([y$1o({ type: String, json: { write: true } })], l$1M.prototype, "normalizeField", void 0), e$1W([y$1o({ type: [i$1$], json: { read: false } })], l$1M.prototype, "series", void 0), e$1W([y$1o({ type: String, json: { write: true } })], l$1M.prototype, "tooltipField", void 0), l$1M = p$2E = e$1W([n$2f("esri.popup.content.support.ChartMediaInfoValue")], l$1M);
const n$1_ = l$1M;
let p$2D = class extends p$2G {
  constructor(r2) {
    super(r2), this.type = null, this.value = null;
  }
};
e$1W([y$1o({ type: ["bar-chart", "column-chart", "line-chart", "pie-chart"], readOnly: true, json: { read: false, write: true } })], p$2D.prototype, "type", void 0), e$1W([y$1o({ type: n$1_, json: { write: true } })], p$2D.prototype, "value", void 0), p$2D = e$1W([n$2f("esri.popup.content.mixins.ChartMediaInfo")], p$2D);
const a$2e = p$2D;
const c$2o = o$1w()({ barchart: "bar-chart", columnchart: "column-chart", linechart: "line-chart", piechart: "pie-chart" });
var a$2d;
let p$2C = a$2d = class extends a$2e {
  constructor(t2) {
    super(t2), this.type = "bar-chart";
  }
  clone() {
    return new a$2d({ altText: this.altText, title: this.title, caption: this.caption, value: this.value ? this.value.clone() : null });
  }
};
e$1W([y$1o({ type: ["bar-chart"], readOnly: true, json: { type: ["barchart"], read: false, write: c$2o.write } })], p$2C.prototype, "type", void 0), p$2C = a$2d = e$1W([n$2f("esri.popup.content.BarChartMediaInfo")], p$2C);
const i$1_ = p$2C;
var a$2c;
let p$2B = a$2c = class extends a$2e {
  constructor(t2) {
    super(t2), this.type = "column-chart";
  }
  clone() {
    return new a$2c({ altText: this.altText, title: this.title, caption: this.caption, value: this.value ? this.value.clone() : null });
  }
};
e$1W([y$1o({ type: ["column-chart"], readOnly: true, json: { type: ["columnchart"], read: false, write: c$2o.write } })], p$2B.prototype, "type", void 0), p$2B = a$2c = e$1W([n$2f("esri.popup.content.ColumnChartMediaInfo")], p$2B);
const c$2n = p$2B;
var e$1p;
let p$2A = e$1p = class extends l$1_ {
  constructor(r2) {
    super(r2), this.linkURL = null, this.sourceURL = null;
  }
  clone() {
    return new e$1p({ linkURL: this.linkURL, sourceURL: this.sourceURL });
  }
};
e$1W([y$1o({ type: String, json: { write: true } })], p$2A.prototype, "linkURL", void 0), e$1W([y$1o({ type: String, json: { write: true } })], p$2A.prototype, "sourceURL", void 0), p$2A = e$1p = e$1W([n$2f("esri.popup.content.support.ImageMediaInfoValue")], p$2A);
const c$2m = p$2A;
var a$2b;
let i$1Z = a$2b = class extends p$2G {
  constructor(e2) {
    super(e2), this.refreshInterval = null, this.type = "image", this.value = null;
  }
  clone() {
    return new a$2b({ altText: this.altText, title: this.title, caption: this.caption, refreshInterval: this.refreshInterval, value: this.value ? this.value.clone() : null });
  }
};
e$1W([y$1o({ type: Number, json: { write: true } })], i$1Z.prototype, "refreshInterval", void 0), e$1W([y$1o({ type: ["image"], readOnly: true, json: { read: false, write: true } })], i$1Z.prototype, "type", void 0), e$1W([y$1o({ type: c$2m, json: { write: true } })], i$1Z.prototype, "value", void 0), i$1Z = a$2b = e$1W([n$2f("esri.popup.content.ImageMediaInfo")], i$1Z);
const p$2z = i$1Z;
var i$1Y;
let a$2a = i$1Y = class extends a$2e {
  constructor(t2) {
    super(t2), this.type = "line-chart";
  }
  clone() {
    return new i$1Y({ altText: this.altText, title: this.title, caption: this.caption, value: this.value ? this.value.clone() : null });
  }
};
e$1W([y$1o({ type: ["line-chart"], readOnly: true, json: { type: ["linechart"], read: false, write: c$2o.write } })], a$2a.prototype, "type", void 0), a$2a = i$1Y = e$1W([n$2f("esri.popup.content.LineChartMediaInfo")], a$2a);
const p$2y = a$2a;
var p$2x;
let i$1X = p$2x = class extends a$2e {
  constructor(t2) {
    super(t2), this.type = "pie-chart";
  }
  clone() {
    return new p$2x({ altText: this.altText, title: this.title, caption: this.caption, value: this.value ? this.value.clone() : null });
  }
};
e$1W([y$1o({ type: ["pie-chart"], readOnly: true, json: { type: ["piechart"], read: false, write: c$2o.write } })], i$1X.prototype, "type", void 0), i$1X = p$2x = e$1W([n$2f("esri.popup.content.PieChartMediaInfo")], i$1X);
const a$29 = i$1X;
const m$1z = { base: p$2G, key: "type", defaultKeyValue: "image", typeMap: { "bar-chart": i$1_, "column-chart": c$2n, "line-chart": p$2y, "pie-chart": a$29, image: p$2z } };
var l$1L;
let u$1w = l$1L = class extends p$2L {
  constructor(t2) {
    super(t2), this.activeMediaInfoIndex = null, this.attributes = null, this.description = null, this.mediaInfos = null, this.title = null, this.type = "media";
  }
  readMediaInfos(t2) {
    return t2 && t2.map((t3) => t3.type === "image" ? p$2z.fromJSON(t3) : t3.type === "barchart" ? i$1_.fromJSON(t3) : t3.type === "columnchart" ? c$2n.fromJSON(t3) : t3.type === "linechart" ? p$2y.fromJSON(t3) : t3.type === "piechart" ? a$29.fromJSON(t3) : void 0).filter(Boolean);
  }
  writeMediaInfos(t2, o2) {
    o2.mediaInfos = t2 && t2.map((t3) => t3.toJSON());
  }
  clone() {
    return new l$1L(y$1r({ activeMediaInfoIndex: this.activeMediaInfoIndex, attributes: this.attributes, description: this.description, mediaInfos: this.mediaInfos, title: this.title }));
  }
};
e$1W([y$1o()], u$1w.prototype, "activeMediaInfoIndex", void 0), e$1W([y$1o({ type: Object, json: { write: true } })], u$1w.prototype, "attributes", void 0), e$1W([y$1o({ type: String, json: { write: true } })], u$1w.prototype, "description", void 0), e$1W([y$1o({ types: [m$1z] })], u$1w.prototype, "mediaInfos", void 0), e$1W([o$1H("mediaInfos")], u$1w.prototype, "readMediaInfos", null), e$1W([r$1h("mediaInfos")], u$1w.prototype, "writeMediaInfos", null), e$1W([y$1o({ type: String, json: { write: true } })], u$1w.prototype, "title", void 0), e$1W([y$1o({ type: ["media"], readOnly: true, json: { read: false, write: true } })], u$1w.prototype, "type", void 0), u$1w = l$1L = e$1W([n$2f("esri.popup.content.MediaContent")], u$1w);
const I$t = u$1w;
var t$1s;
let p$2w = t$1s = class extends l$1_ {
  constructor(r2) {
    super(r2), this.field = null, this.order = null;
  }
  clone() {
    return new t$1s({ field: this.field, order: this.order });
  }
};
e$1W([y$1o({ type: String, json: { write: true } })], p$2w.prototype, "field", void 0), e$1W([y$1o({ type: ["asc", "desc"], json: { write: true } })], p$2w.prototype, "order", void 0), p$2w = t$1s = e$1W([n$2f("esri.popup.support.RelatedRecordsInfoFieldOrder")], p$2w);
const c$2l = p$2w;
let n$1Z = class extends i$28(p$2L) {
  constructor(t2) {
    super(t2), this.description = null, this.displayCount = null, this.displayType = "list", this.orderByFields = null, this.relationshipId = null, this.title = null, this.type = "relationship";
  }
};
e$1W([y$1o({ type: String, json: { write: true } })], n$1Z.prototype, "description", void 0), e$1W([y$1o({ type: Number, json: { type: T$r, write: true } })], n$1Z.prototype, "displayCount", void 0), e$1W([y$1o({ type: ["list"], json: { write: true } })], n$1Z.prototype, "displayType", void 0), e$1W([y$1o({ type: [c$2l], json: { write: true } })], n$1Z.prototype, "orderByFields", void 0), e$1W([y$1o({ type: Number, json: { type: T$r, write: true } })], n$1Z.prototype, "relationshipId", void 0), e$1W([y$1o({ type: String, json: { write: true } })], n$1Z.prototype, "title", void 0), e$1W([y$1o({ type: ["relationship"], readOnly: true, json: { read: false, write: true } })], n$1Z.prototype, "type", void 0), n$1Z = e$1W([n$2f("esri.popup.content.RelationshipContent")], n$1Z);
const l$1K = n$1Z;
var s$1w;
let p$2v = s$1w = class extends p$2L {
  constructor(t2) {
    super(t2), this.text = null, this.type = "text";
  }
  clone() {
    return new s$1w({ text: this.text });
  }
};
e$1W([y$1o({ type: String, json: { write: true } })], p$2v.prototype, "text", void 0), e$1W([y$1o({ type: ["text"], readOnly: true, json: { read: false, write: true } })], p$2v.prototype, "type", void 0), p$2v = s$1w = e$1W([n$2f("esri.popup.content.TextContent")], p$2v);
const c$2k = p$2v;
const m$1y = { base: null, key: "type", typeMap: { attachment: i$25, media: I$t, text: c$2k, expression: i$22, field: c$2p, relationship: l$1K } };
var s$1v;
let p$2u = s$1v = class extends l$1_ {
  constructor(r2) {
    super(r2), this.name = null, this.title = null, this.expression = null, this.returnType = null;
  }
  clone() {
    return new s$1v({ name: this.name, title: this.title, expression: this.expression, returnType: this.returnType });
  }
};
e$1W([y$1o({ type: String, json: { write: true } })], p$2u.prototype, "name", void 0), e$1W([y$1o({ type: String, json: { write: true } })], p$2u.prototype, "title", void 0), e$1W([y$1o({ type: String, json: { write: true } })], p$2u.prototype, "expression", void 0), e$1W([y$1o({ type: ["string", "number"], json: { write: true } })], p$2u.prototype, "returnType", void 0), p$2u = s$1v = e$1W([n$2f("esri.popup.ExpressionInfo")], p$2u);
const i$1W = p$2u;
var e$1o;
let p$2t = e$1o = class extends l$1_ {
  constructor(o2) {
    super(o2), this.returnTopmostRaster = null, this.showNoDataRecords = null;
  }
  clone() {
    return new e$1o({ showNoDataRecords: this.showNoDataRecords, returnTopmostRaster: this.returnTopmostRaster });
  }
};
e$1W([y$1o({ type: Boolean, json: { write: true } })], p$2t.prototype, "returnTopmostRaster", void 0), e$1W([y$1o({ type: Boolean, json: { write: true } })], p$2t.prototype, "showNoDataRecords", void 0), p$2t = e$1o = e$1W([n$2f("esri.popup.LayerOptions")], p$2t);
const a$28 = p$2t;
var d$1l;
let c$2j = d$1l = class extends l$1_ {
  constructor(o2) {
    super(o2), this.showRelatedRecords = null, this.orderByFields = null;
  }
  clone() {
    return new d$1l({ showRelatedRecords: this.showRelatedRecords, orderByFields: this.orderByFields ? y$1r(this.orderByFields) : null });
  }
};
e$1W([y$1o({ type: Boolean, json: { write: true } })], c$2j.prototype, "showRelatedRecords", void 0), e$1W([y$1o({ type: [c$2l], json: { write: true } })], c$2j.prototype, "orderByFields", void 0), c$2j = d$1l = e$1W([n$2f("esri.popup.RelatedRecordsInfo")], c$2j);
const l$1J = c$2j;
let t$1r = 0;
const s$1u = (s2) => {
  let i2 = class extends s2 {
    constructor(...e2) {
      super(...e2), Object.defineProperty(this, "uid", { writable: false, configurable: false, value: Date.now().toString(16) + "-object-" + t$1r++ });
    }
  };
  return i2 = e$1W([n$2f("esri.core.Identifiable")], i2), i2;
}, i$1V = (s2) => {
  let i2 = class extends s2 {
    constructor(...e2) {
      super(...e2), Object.defineProperty(this, "uid", { writable: false, configurable: false, value: t$1r++ });
    }
  };
  return i2 = e$1W([n$2f("esri.core.NumericIdentifiable")], i2), i2;
};
let o$1s = class extends s$1u(class {
}) {
};
o$1s = e$1W([n$2f("esri.core.Identifiable")], o$1s);
var r$18;
let p$2s = r$18 = class extends s$1u(m$1L) {
  constructor(t2) {
    super(t2), this.active = false, this.className = null, this.disabled = false, this.id = null, this.indicator = false, this.title = null, this.type = null, this.visible = true;
  }
  clone() {
    return new r$18({ active: this.active, className: this.className, disabled: this.disabled, id: this.id, indicator: this.indicator, title: this.title, visible: this.visible });
  }
};
e$1W([y$1o()], p$2s.prototype, "active", void 0), e$1W([y$1o()], p$2s.prototype, "className", void 0), e$1W([y$1o()], p$2s.prototype, "disabled", void 0), e$1W([y$1o()], p$2s.prototype, "id", void 0), e$1W([y$1o()], p$2s.prototype, "indicator", void 0), e$1W([y$1o()], p$2s.prototype, "title", void 0), e$1W([y$1o()], p$2s.prototype, "type", void 0), e$1W([y$1o()], p$2s.prototype, "visible", void 0), p$2s = r$18 = e$1W([n$2f("esri.support.actions.ActionBase")], p$2s);
const c$2i = p$2s;
var o$1r;
let r$17 = o$1r = class extends c$2i {
  constructor(s2) {
    super(s2), this.image = null, this.type = "button";
  }
  clone() {
    return new o$1r({ active: this.active, className: this.className, disabled: this.disabled, id: this.id, indicator: this.indicator, title: this.title, visible: this.visible, image: this.image });
  }
};
e$1W([y$1o()], r$17.prototype, "image", void 0), r$17 = o$1r = e$1W([n$2f("esri.support.Action.ActionButton")], r$17);
const a$27 = r$17;
var o$1q;
let r$16 = o$1q = class extends c$2i {
  constructor(s2) {
    super(s2), this.image = null, this.type = "toggle", this.value = false;
  }
  clone() {
    return new o$1q({ active: this.active, className: this.className, disabled: this.disabled, id: this.id, indicator: this.indicator, title: this.title, visible: this.visible, image: this.image, value: this.value });
  }
};
e$1W([y$1o()], r$16.prototype, "image", void 0), e$1W([y$1o()], r$16.prototype, "value", void 0), r$16 = o$1q = e$1W([n$2f("esri.support.Action.ActionToggle")], r$16);
const a$26 = r$16;
const T$l = "esri.PopupTemplate", b$O = s$22.getLogger(T$l), J$b = "relationships/", L$o = "expression/", B$j = j$F.ofType({ key: "type", defaultKeyValue: "button", base: c$2i, typeMap: { button: a$27, toggle: a$26 } }), M$n = { base: p$2L, key: "type", typeMap: { media: I$t, custom: i$24, text: c$2k, attachments: i$25, fields: c$2p, expression: i$22, relationship: l$1K } }, P$n = ["attachments", "fields", "media", "text", "expression", "relationship"];
let $$d = class extends i$28(l$1_) {
  constructor() {
    super(...arguments), this.actions = null, this.content = "", this.expressionInfos = null, this.fieldInfos = null, this.layerOptions = null, this.lastEditInfoEnabled = true, this.outFields = null, this.overwriteActions = false, this.returnGeometry = false, this.title = "";
  }
  castContent(t2) {
    return Array.isArray(t2) ? t2.map((t3) => S$H(M$n, t3)) : typeof t2 == "string" || typeof t2 == "function" || t2 instanceof HTMLElement || C$q(t2) ? t2 : (b$O.error("content error", "unsupported content value", { value: t2 }), null);
  }
  readContent(t2, e2) {
    const { popupElements: o2 } = e2;
    return Array.isArray(o2) && o2.length > 0 ? this._readPopupInfoElements(e2.description, e2.mediaInfos, o2) : this._readPopupInfo(e2);
  }
  writeContent(t2, e2, o2, s2) {
    typeof t2 != "string" ? Array.isArray(t2) && (e2.popupElements = t2.filter((t3) => P$n.includes(t3.type)).map((t3) => t3 && t3.toJSON(s2)), e2.popupElements.forEach((t3) => {
      t3.type === "attachments" ? this._writeAttachmentContent(e2) : t3.type === "media" ? this._writeMediaContent(t3, e2) : t3.type === "text" ? this._writeTextContent(t3, e2) : t3.type === "relationship" && this._writeRelationshipContent(t3, e2);
    })) : e2.description = t2;
  }
  writeFieldInfos(t2, e2, o2, s2) {
    const { content: r2 } = this, i2 = Array.isArray(r2) ? r2 : null;
    if (t2) {
      const o3 = i2 ? i2.filter((t3) => t3.type === "fields") : [], r3 = o3.length && o3.every((t3) => {
        var _a2;
        return (_a2 = t3.fieldInfos) == null ? void 0 : _a2.length;
      });
      e2.fieldInfos = t2.filter(Boolean).map((t3) => {
        const e3 = t3.toJSON(s2);
        return r3 && (e3.visible = false), e3;
      });
    }
    if (i2)
      for (const n2 of i2)
        n2.type === "fields" && this._writeFieldsContent(n2, e2);
  }
  writeLayerOptions(t2, e2, o2, s2) {
    e2[o2] = !t2 || t2.showNoDataRecords === null && t2.returnTopmostRaster === null ? null : t2.toJSON(s2);
  }
  writeTitle(t2, e2) {
    e2.title = t2 || "";
  }
  async collectRequiredFields(t2, e2) {
    const o2 = this.expressionInfos || [];
    await this._collectExpressionInfoFields(t2, e2, [...o2, ...this._getContentExpressionInfos(this.content, o2)]), h$1c(t2, e2, [...this.outFields || [], ...this._getActionsFields(this.actions), ...this._getTitleFields(this.title), ...this._getContentFields(this.content)]);
  }
  async getRequiredFields(t2) {
    const e2 = new Set();
    return await this.collectRequiredFields(e2, t2), [...e2].sort();
  }
  _writeFieldsContent(t2, e2) {
    if (!Array.isArray(t2.fieldInfos) || !t2.fieldInfos.length)
      return;
    const o2 = y$1r(t2.fieldInfos);
    Array.isArray(e2.fieldInfos) ? o2.forEach((t3) => {
      const o3 = e2.fieldInfos.find((e3) => e3.fieldName.toLowerCase() === t3.fieldName.toLowerCase());
      o3 ? o3.visible = true : e2.fieldInfos.push(t3);
    }) : e2.fieldInfos = o2;
  }
  _writeAttachmentContent(t2) {
    t2.showAttachments || (t2.showAttachments = true);
  }
  _writeRelationshipContent(t2, e2) {
    var _a2, _b2;
    const o2 = ((_a2 = t2.orderByFields) == null ? void 0 : _a2.map((e3) => this._toFieldOrderJSON(e3, t2.relationshipId))) || [], s2 = [...((_b2 = e2.relatedRecordsInfo) == null ? void 0 : _b2.orderByFields) || [], ...o2];
    e2.relatedRecordsInfo = __spreadValues({ showRelatedRecords: true }, (s2 == null ? void 0 : s2.length) && { orderByFields: s2 });
  }
  _writeTextContent(t2, e2) {
    !e2.description && t2.text && (e2.description = t2.text);
  }
  _writeMediaContent(t2, e2) {
    if (!Array.isArray(t2.mediaInfos) || !t2.mediaInfos.length)
      return;
    const o2 = y$1r(t2.mediaInfos);
    Array.isArray(e2.mediaInfos) ? e2.mediaInfos = [...e2.mediaInfos, ...o2] : e2.mediaInfos = o2;
  }
  _readPopupInfoElements(t2, e2, o2) {
    const s2 = { description: false, mediaInfos: false };
    return o2.map((o3) => o3.type === "media" ? (o3.mediaInfos || !e2 || s2.mediaInfos || (o3.mediaInfos = e2, s2.mediaInfos = true), I$t.fromJSON(o3)) : o3.type === "text" ? (o3.text || !t2 || s2.description || (o3.text = t2, s2.description = true), c$2k.fromJSON(o3)) : o3.type === "attachments" ? i$25.fromJSON(o3) : o3.type === "fields" ? c$2p.fromJSON(o3) : o3.type === "expression" ? i$22.fromJSON(o3) : o3.type === "relationship" ? l$1K.fromJSON(o3) : void 0).filter(Boolean);
  }
  _toRelationshipContent(t2) {
    const { field: e2, order: o2 } = t2;
    if (!(e2 == null ? void 0 : e2.startsWith(J$b)))
      return null;
    const s2 = e2.replace(J$b, "").split("/");
    if (s2.length !== 2)
      return null;
    const r2 = parseInt(s2[0], 10), i2 = s2[1];
    return typeof r2 == "number" && i2 ? l$1K.fromJSON({ relationshipId: r2, orderByFields: [{ field: i2, order: o2 }] }) : null;
  }
  _toFieldOrderJSON(t2, e2) {
    const { order: o2, field: s2 } = t2;
    return { field: `${J$b}${e2}/${s2}`, order: o2 };
  }
  _readPopupInfo({ description: t2, mediaInfos: e2, showAttachments: o2, relatedRecordsInfo: s2 = { showRelatedRecords: false } }) {
    const r2 = [];
    t2 ? r2.push(new c$2k({ text: t2 })) : r2.push(new c$2p()), Array.isArray(e2) && e2.length && r2.push(I$t.fromJSON({ mediaInfos: e2 })), o2 && r2.push(i$25.fromJSON({ displayType: "auto" }));
    const { showRelatedRecords: i2, orderByFields: n2 } = s2;
    return i2 && (n2 == null ? void 0 : n2.length) && n2.forEach((t3) => {
      const e3 = this._toRelationshipContent(t3);
      e3 && r2.push(e3);
    }), r2.length ? r2 : t2;
  }
  _getContentElementFields(t2) {
    var _a2;
    const e2 = t2 == null ? void 0 : t2.type;
    if (e2 === "attachments")
      return [...this._extractFieldNames(t2.title), ...this._extractFieldNames(t2.description)];
    if (e2 === "custom")
      return t2.outFields || [];
    if (e2 === "fields")
      return [...this._extractFieldNames(t2.title), ...this._extractFieldNames(t2.description), ...this._getFieldInfoFields((_a2 = t2.fieldInfos) != null ? _a2 : this.fieldInfos)];
    if (e2 === "media") {
      const e3 = t2.mediaInfos || [];
      return [...this._extractFieldNames(t2.title), ...this._extractFieldNames(t2.description), ...e3.reduce((t3, e4) => [...t3, ...this._getMediaInfoFields(e4)], [])];
    }
    return e2 === "text" ? this._extractFieldNames(t2.text) : [];
  }
  _getMediaInfoFields(t2) {
    const { caption: e2, title: o2, value: s2 } = t2, r2 = s2 || {}, { fields: i2, normalizeField: n2, tooltipField: p2, sourceURL: l2, linkURL: a2 } = r2, d2 = [...this._extractFieldNames(o2), ...this._extractFieldNames(e2), ...this._extractFieldNames(l2), ...this._extractFieldNames(a2), ...i2 != null ? i2 : []];
    return n2 && d2.push(n2), p2 && d2.push(p2), d2;
  }
  _getContentExpressionInfos(t2, e2) {
    return Array.isArray(t2) ? t2.reduce((t3, e3) => [...t3, ...e3.type === "expression" && e3.expressionInfo ? [e3.expressionInfo] : []], e2) : [];
  }
  _getContentFields(t2) {
    return typeof t2 == "string" ? this._extractFieldNames(t2) : Array.isArray(t2) ? t2.reduce((t3, e2) => [...t3, ...this._getContentElementFields(e2)], []) : [];
  }
  async _collectExpressionInfoFields(t2, e2, o2) {
    o2 && await Promise.all(o2.map((o3) => S$C(t2, e2, o3.expression)));
  }
  _getFieldInfoFields(t2) {
    return t2 ? t2.filter((t3) => t3.visible === void 0 || !!t3.visible).map((t3) => t3.fieldName).filter((t3) => !t3.startsWith(J$b) && !t3.startsWith(L$o)) : [];
  }
  _getActionsFields(t2) {
    return t2 ? t2.toArray().reduce((t3, e2) => [...t3, ...this._getActionFields(e2)], []) : [];
  }
  _getActionFields(t2) {
    const { className: e2, title: o2, type: s2 } = t2, r2 = s2 === "button" || s2 === "toggle" ? t2.image : "";
    return [...this._extractFieldNames(o2), ...this._extractFieldNames(e2), ...this._extractFieldNames(r2)];
  }
  _getTitleFields(t2) {
    return typeof t2 == "string" ? this._extractFieldNames(t2) : [];
  }
  _extractFieldNames(t2) {
    if (!t2 || typeof t2 != "string")
      return [];
    const e2 = /{[^}]*}/g, o2 = t2.match(e2);
    if (!o2)
      return [];
    const s2 = /\{(\w+):.+\}/, r2 = o2.filter((t3) => !(t3.indexOf(`{${J$b}`) === 0 || t3.indexOf(`{${L$o}`) === 0)).map((t3) => t3.replace(s2, "{$1}"));
    return r2 ? r2.map((t3) => t3.slice(1, -1)) : [];
  }
};
e$1W([y$1o({ type: B$j })], $$d.prototype, "actions", void 0), e$1W([y$1o()], $$d.prototype, "content", void 0), e$1W([s$1N("content")], $$d.prototype, "castContent", null), e$1W([o$1H("content", ["description", "fieldInfos", "popupElements", "mediaInfos", "showAttachments", "relatedRecordsInfo"])], $$d.prototype, "readContent", null), e$1W([r$1h("content", { popupElements: { type: j$F.ofType(m$1y) }, showAttachments: { type: Boolean }, mediaInfos: { type: j$F.ofType(m$1z) }, description: { type: String }, relatedRecordsInfo: { type: l$1J } })], $$d.prototype, "writeContent", null), e$1W([y$1o({ type: [i$1W], json: { write: true } })], $$d.prototype, "expressionInfos", void 0), e$1W([y$1o({ type: [c$2q] })], $$d.prototype, "fieldInfos", void 0), e$1W([r$1h("fieldInfos")], $$d.prototype, "writeFieldInfos", null), e$1W([y$1o({ type: a$28 })], $$d.prototype, "layerOptions", void 0), e$1W([r$1h("layerOptions")], $$d.prototype, "writeLayerOptions", null), e$1W([y$1o({ type: Boolean, json: { read: { source: "showLastEditInfo" }, write: { target: "showLastEditInfo" }, default: true } })], $$d.prototype, "lastEditInfoEnabled", void 0), e$1W([y$1o()], $$d.prototype, "outFields", void 0), e$1W([y$1o()], $$d.prototype, "overwriteActions", void 0), e$1W([y$1o()], $$d.prototype, "returnGeometry", void 0), e$1W([y$1o({ json: { type: String } })], $$d.prototype, "title", void 0), e$1W([r$1h("title")], $$d.prototype, "writeTitle", null), $$d = e$1W([n$2f("esri.PopupTemplate")], $$d);
const k$o = $$d;
const e$1n = { transparent: [0, 0, 0, 0], black: [0, 0, 0, 1], silver: [192, 192, 192, 1], gray: [128, 128, 128, 1], white: [255, 255, 255, 1], maroon: [128, 0, 0, 1], red: [255, 0, 0, 1], purple: [128, 0, 128, 1], fuchsia: [255, 0, 255, 1], green: [0, 128, 0, 1], lime: [0, 255, 0, 1], olive: [128, 128, 0, 1], yellow: [255, 255, 0, 1], navy: [0, 0, 128, 1], blue: [0, 0, 255, 1], teal: [0, 128, 128, 1], aqua: [0, 255, 255, 1], aliceblue: [240, 248, 255, 1], antiquewhite: [250, 235, 215, 1], aquamarine: [127, 255, 212, 1], azure: [240, 255, 255, 1], beige: [245, 245, 220, 1], bisque: [255, 228, 196, 1], blanchedalmond: [255, 235, 205, 1], blueviolet: [138, 43, 226, 1], brown: [165, 42, 42, 1], burlywood: [222, 184, 135, 1], cadetblue: [95, 158, 160, 1], chartreuse: [127, 255, 0, 1], chocolate: [210, 105, 30, 1], coral: [255, 127, 80, 1], cornflowerblue: [100, 149, 237, 1], cornsilk: [255, 248, 220, 1], crimson: [220, 20, 60, 1], cyan: [0, 255, 255, 1], darkblue: [0, 0, 139, 1], darkcyan: [0, 139, 139, 1], darkgoldenrod: [184, 134, 11, 1], darkgray: [169, 169, 169, 1], darkgreen: [0, 100, 0, 1], darkgrey: [169, 169, 169, 1], darkkhaki: [189, 183, 107, 1], darkmagenta: [139, 0, 139, 1], darkolivegreen: [85, 107, 47, 1], darkorange: [255, 140, 0, 1], darkorchid: [153, 50, 204, 1], darkred: [139, 0, 0, 1], darksalmon: [233, 150, 122, 1], darkseagreen: [143, 188, 143, 1], darkslateblue: [72, 61, 139, 1], darkslategray: [47, 79, 79, 1], darkslategrey: [47, 79, 79, 1], darkturquoise: [0, 206, 209, 1], darkviolet: [148, 0, 211, 1], deeppink: [255, 20, 147, 1], deepskyblue: [0, 191, 255, 1], dimgray: [105, 105, 105, 1], dimgrey: [105, 105, 105, 1], dodgerblue: [30, 144, 255, 1], firebrick: [178, 34, 34, 1], floralwhite: [255, 250, 240, 1], forestgreen: [34, 139, 34, 1], gainsboro: [220, 220, 220, 1], ghostwhite: [248, 248, 255, 1], gold: [255, 215, 0, 1], goldenrod: [218, 165, 32, 1], greenyellow: [173, 255, 47, 1], grey: [128, 128, 128, 1], honeydew: [240, 255, 240, 1], hotpink: [255, 105, 180, 1], indianred: [205, 92, 92, 1], indigo: [75, 0, 130, 1], ivory: [255, 255, 240, 1], khaki: [240, 230, 140, 1], lavender: [230, 230, 250, 1], lavenderblush: [255, 240, 245, 1], lawngreen: [124, 252, 0, 1], lemonchiffon: [255, 250, 205, 1], lightblue: [173, 216, 230, 1], lightcoral: [240, 128, 128, 1], lightcyan: [224, 255, 255, 1], lightgoldenrodyellow: [250, 250, 210, 1], lightgray: [211, 211, 211, 1], lightgreen: [144, 238, 144, 1], lightgrey: [211, 211, 211, 1], lightpink: [255, 182, 193, 1], lightsalmon: [255, 160, 122, 1], lightseagreen: [32, 178, 170, 1], lightskyblue: [135, 206, 250, 1], lightslategray: [119, 136, 153, 1], lightslategrey: [119, 136, 153, 1], lightsteelblue: [176, 196, 222, 1], lightyellow: [255, 255, 224, 1], limegreen: [50, 205, 50, 1], linen: [250, 240, 230, 1], magenta: [255, 0, 255, 1], mediumaquamarine: [102, 205, 170, 1], mediumblue: [0, 0, 205, 1], mediumorchid: [186, 85, 211, 1], mediumpurple: [147, 112, 219, 1], mediumseagreen: [60, 179, 113, 1], mediumslateblue: [123, 104, 238, 1], mediumspringgreen: [0, 250, 154, 1], mediumturquoise: [72, 209, 204, 1], mediumvioletred: [199, 21, 133, 1], midnightblue: [25, 25, 112, 1], mintcream: [245, 255, 250, 1], mistyrose: [255, 228, 225, 1], moccasin: [255, 228, 181, 1], navajowhite: [255, 222, 173, 1], oldlace: [253, 245, 230, 1], olivedrab: [107, 142, 35, 1], orange: [255, 165, 0, 1], orangered: [255, 69, 0, 1], orchid: [218, 112, 214, 1], palegoldenrod: [238, 232, 170, 1], palegreen: [152, 251, 152, 1], paleturquoise: [175, 238, 238, 1], palevioletred: [219, 112, 147, 1], papayawhip: [255, 239, 213, 1], peachpuff: [255, 218, 185, 1], peru: [205, 133, 63, 1], pink: [255, 192, 203, 1], plum: [221, 160, 221, 1], powderblue: [176, 224, 230, 1], rebeccapurple: [102, 51, 153, 1], rosybrown: [188, 143, 143, 1], royalblue: [65, 105, 225, 1], saddlebrown: [139, 69, 19, 1], salmon: [250, 128, 114, 1], sandybrown: [244, 164, 96, 1], seagreen: [46, 139, 87, 1], seashell: [255, 245, 238, 1], sienna: [160, 82, 45, 1], skyblue: [135, 206, 235, 1], slateblue: [106, 90, 205, 1], slategray: [112, 128, 144, 1], slategrey: [112, 128, 144, 1], snow: [255, 250, 250, 1], springgreen: [0, 255, 127, 1], steelblue: [70, 130, 180, 1], tan: [210, 180, 140, 1], thistle: [216, 191, 216, 1], tomato: [255, 99, 71, 1], turquoise: [64, 224, 208, 1], violet: [238, 130, 238, 1], wheat: [245, 222, 179, 1], whitesmoke: [245, 245, 245, 1], yellowgreen: [154, 205, 50, 1] };
function r$15(r2) {
  return e$1n[r2] || e$1n[r2.toLowerCase()];
}
function l$1I(r2) {
  var _a2;
  return (_a2 = e$1n[r2]) != null ? _a2 : e$1n[r2.toLowerCase()];
}
function a$25(e2) {
  return [...l$1I(e2)];
}
function n$1Y(e2, r2, l2) {
  l2 < 0 && ++l2, l2 > 1 && --l2;
  const a2 = 6 * l2;
  return a2 < 1 ? e2 + (r2 - e2) * a2 : 2 * l2 < 1 ? r2 : 3 * l2 < 2 ? e2 + (r2 - e2) * (2 / 3 - l2) * 6 : e2;
}
function o$1p(e2, r2, l2, a2 = 1) {
  const o2 = (e2 % 360 + 360) % 360 / 360, i2 = l2 <= 0.5 ? l2 * (r2 + 1) : l2 + r2 - l2 * r2, t2 = 2 * l2 - i2;
  return [Math.round(255 * n$1Y(t2, i2, o2 + 1 / 3)), Math.round(255 * n$1Y(t2, i2, o2)), Math.round(255 * n$1Y(t2, i2, o2 - 1 / 3)), a2];
}
function i$1U(e2) {
  const r2 = e2.length > 5, l2 = r2 ? 8 : 4, a2 = (1 << l2) - 1, n2 = r2 ? 1 : 17, o2 = r2 ? e2.length === 9 : e2.length === 5;
  let i2 = Number("0x" + e2.substr(1));
  if (isNaN(i2))
    return null;
  const t2 = [0, 0, 0, 1];
  let u2;
  return o2 && (u2 = i2 & a2, i2 >>= l2, t2[3] = n2 * u2 / 255), u2 = i2 & a2, i2 >>= l2, t2[2] = n2 * u2, u2 = i2 & a2, i2 >>= l2, t2[1] = n2 * u2, u2 = i2 & a2, i2 >>= l2, t2[0] = n2 * u2, t2;
}
function n$1X() {
  return [0, 0, 0];
}
function t$1q(n2) {
  return [n2[0], n2[1], n2[2]];
}
function r$14(n2, t2, r2) {
  return [n2, t2, r2];
}
function e$1m(t2) {
  const r2 = n$1X(), e2 = Math.min(3, t2.length);
  for (let n2 = 0; n2 < e2; ++n2)
    r2[n2] = t2[n2];
  return r2;
}
function u$1v(n2, t2) {
  return new Float64Array(n2, t2, 3);
}
function o$1o() {
  return n$1X();
}
function a$24() {
  return r$14(1, 1, 1);
}
function s$1t() {
  return r$14(1, 0, 0);
}
function c$2h() {
  return r$14(0, 1, 0);
}
function i$1T() {
  return r$14(0, 0, 1);
}
const f$1g = o$1o(), l$1H = a$24(), _$y = s$1t(), O$k = c$2h(), b$N = i$1T();
Object.freeze(Object.defineProperty({ __proto__: null, create: n$1X, clone: t$1q, fromValues: r$14, fromArray: e$1m, createView: u$1v, zeros: o$1o, ones: a$24, unitX: s$1t, unitY: c$2h, unitZ: i$1T, ZEROS: f$1g, ONES: l$1H, UNIT_X: _$y, UNIT_Y: O$k, UNIT_Z: b$N }, Symbol.toStringTag, { value: "Module" }));
let t$1p = 1e-6;
function a$23() {
  return t$1p;
}
function e$1l(a2) {
  t$1p = a2;
}
const n$1W = Math.random, o$1n = Math.PI / 180, s$1s = 180 / Math.PI;
function r$13(t2) {
  return t2 * o$1n;
}
function u$1u(t2) {
  return t2 * s$1s;
}
function c$2g(a2, e2) {
  return Math.abs(a2 - e2) <= t$1p * Math.max(1, Math.abs(a2), Math.abs(e2));
}
Object.freeze(Object.defineProperty({ __proto__: null, getEpsilon: a$23, setEpsilon: e$1l, RANDOM: n$1W, toRadian: r$13, toDegree: u$1u, equals: c$2g }, Symbol.toStringTag, { value: "Module" }));
function s$1r(t2) {
  const n2 = t2[0], a2 = t2[1], s2 = t2[2];
  return Math.sqrt(n2 * n2 + a2 * a2 + s2 * s2);
}
function r$12(t2, n2) {
  return t2[0] = n2[0], t2[1] = n2[1], t2[2] = n2[2], t2;
}
function o$1m(t2, n2, a2, s2) {
  return t2[0] = n2, t2[1] = a2, t2[2] = s2, t2;
}
function u$1t(t2, n2, a2) {
  return t2[0] = n2[0] + a2[0], t2[1] = n2[1] + a2[1], t2[2] = n2[2] + a2[2], t2;
}
function e$1k(t2, n2, a2) {
  return t2[0] = n2[0] - a2[0], t2[1] = n2[1] - a2[1], t2[2] = n2[2] - a2[2], t2;
}
function c$2f(t2, n2, a2) {
  return t2[0] = n2[0] * a2[0], t2[1] = n2[1] * a2[1], t2[2] = n2[2] * a2[2], t2;
}
function i$1S(t2, n2, a2) {
  return t2[0] = n2[0] / a2[0], t2[1] = n2[1] / a2[1], t2[2] = n2[2] / a2[2], t2;
}
function h$19(t2, n2) {
  return t2[0] = Math.ceil(n2[0]), t2[1] = Math.ceil(n2[1]), t2[2] = Math.ceil(n2[2]), t2;
}
function M$m(t2, n2) {
  return t2[0] = Math.floor(n2[0]), t2[1] = Math.floor(n2[1]), t2[2] = Math.floor(n2[2]), t2;
}
function f$1f(t2, n2) {
  return t2[0] = Math.abs(n2[0]), t2[1] = Math.abs(n2[1]), t2[2] = Math.abs(n2[2]), t2;
}
function l$1G(t2, n2) {
  return t2[0] = Math.sign(n2[0]), t2[1] = Math.sign(n2[1]), t2[2] = Math.sign(n2[2]), t2;
}
function m$1x(t2, n2, a2) {
  return t2[0] = Math.min(n2[0], a2[0]), t2[1] = Math.min(n2[1], a2[1]), t2[2] = Math.min(n2[2], a2[2]), t2;
}
function d$1k(t2, n2, a2) {
  return t2[0] = Math.max(n2[0], a2[0]), t2[1] = Math.max(n2[1], a2[1]), t2[2] = Math.max(n2[2], a2[2]), t2;
}
function b$M(t2, n2) {
  return t2[0] = Math.round(n2[0]), t2[1] = Math.round(n2[1]), t2[2] = Math.round(n2[2]), t2;
}
function g$R(t2, n2, a2) {
  return t2[0] = n2[0] * a2, t2[1] = n2[1] * a2, t2[2] = n2[2] * a2, t2;
}
function q$e(t2, n2, a2, s2) {
  return t2[0] = n2[0] + a2[0] * s2, t2[1] = n2[1] + a2[1] * s2, t2[2] = n2[2] + a2[2] * s2, t2;
}
function x$A(t2, n2) {
  const a2 = n2[0] - t2[0], s2 = n2[1] - t2[1], r2 = n2[2] - t2[2];
  return Math.sqrt(a2 * a2 + s2 * s2 + r2 * r2);
}
function p$2r(t2, n2) {
  const a2 = n2[0] - t2[0], s2 = n2[1] - t2[1], r2 = n2[2] - t2[2];
  return a2 * a2 + s2 * s2 + r2 * r2;
}
function v$K(t2) {
  const n2 = t2[0], a2 = t2[1], s2 = t2[2];
  return n2 * n2 + a2 * a2 + s2 * s2;
}
function j$D(t2, n2) {
  return t2[0] = -n2[0], t2[1] = -n2[1], t2[2] = -n2[2], t2;
}
function y$17(t2, n2) {
  return t2[0] = 1 / n2[0], t2[1] = 1 / n2[1], t2[2] = 1 / n2[2], t2;
}
function z$o(t2, n2) {
  const a2 = n2[0], s2 = n2[1], r2 = n2[2];
  let o2 = a2 * a2 + s2 * s2 + r2 * r2;
  return o2 > 0 && (o2 = 1 / Math.sqrt(o2), t2[0] = n2[0] * o2, t2[1] = n2[1] * o2, t2[2] = n2[2] * o2), t2;
}
function P$m(t2, n2) {
  return t2[0] * n2[0] + t2[1] * n2[1] + t2[2] * n2[2];
}
function _$x(t2, n2, a2) {
  const s2 = n2[0], r2 = n2[1], o2 = n2[2], u2 = a2[0], e2 = a2[1], c2 = a2[2];
  return t2[0] = r2 * c2 - o2 * e2, t2[1] = o2 * u2 - s2 * c2, t2[2] = s2 * e2 - r2 * u2, t2;
}
function A$l(t2, n2, a2, s2) {
  const r2 = n2[0], o2 = n2[1], u2 = n2[2];
  return t2[0] = r2 + s2 * (a2[0] - r2), t2[1] = o2 + s2 * (a2[1] - o2), t2[2] = u2 + s2 * (a2[2] - u2), t2;
}
function D$m(t2, n2, a2, s2, r2, o2) {
  const u2 = o2 * o2, e2 = u2 * (2 * o2 - 3) + 1, c2 = u2 * (o2 - 2) + o2, i2 = u2 * (o2 - 1), h2 = u2 * (3 - 2 * o2);
  return t2[0] = n2[0] * e2 + a2[0] * c2 + s2[0] * i2 + r2[0] * h2, t2[1] = n2[1] * e2 + a2[1] * c2 + s2[1] * i2 + r2[1] * h2, t2[2] = n2[2] * e2 + a2[2] * c2 + s2[2] * i2 + r2[2] * h2, t2;
}
function I$s(t2, n2, a2, s2, r2, o2) {
  const u2 = 1 - o2, e2 = u2 * u2, c2 = o2 * o2, i2 = e2 * u2, h2 = 3 * o2 * e2, M2 = 3 * c2 * u2, f2 = c2 * o2;
  return t2[0] = n2[0] * i2 + a2[0] * h2 + s2[0] * M2 + r2[0] * f2, t2[1] = n2[1] * i2 + a2[1] * h2 + s2[1] * M2 + r2[1] * f2, t2[2] = n2[2] * i2 + a2[2] * h2 + s2[2] * M2 + r2[2] * f2, t2;
}
function L$n(t2, n2) {
  n2 = n2 || 1;
  const s2 = n$1W, r2 = 2 * s2() * Math.PI, o2 = 2 * s2() - 1, u2 = Math.sqrt(1 - o2 * o2) * n2;
  return t2[0] = Math.cos(r2) * u2, t2[1] = Math.sin(r2) * u2, t2[2] = o2 * n2, t2;
}
function O$j(t2, n2, a2) {
  const s2 = n2[0], r2 = n2[1], o2 = n2[2];
  return t2[0] = a2[0] * s2 + a2[4] * r2 + a2[8] * o2 + a2[12], t2[1] = a2[1] * s2 + a2[5] * r2 + a2[9] * o2 + a2[13], t2[2] = a2[2] * s2 + a2[6] * r2 + a2[10] * o2 + a2[14], t2;
}
function S$A(t2, n2, a2) {
  const s2 = n2[0], r2 = n2[1], o2 = n2[2];
  return t2[0] = s2 * a2[0] + r2 * a2[3] + o2 * a2[6], t2[1] = s2 * a2[1] + r2 * a2[4] + o2 * a2[7], t2[2] = s2 * a2[2] + r2 * a2[5] + o2 * a2[8], t2;
}
function E$q(t2, n2, a2) {
  const s2 = a2[0], r2 = a2[1], o2 = a2[2], u2 = a2[3], e2 = n2[0], c2 = n2[1], i2 = n2[2];
  let h2 = r2 * i2 - o2 * c2, M2 = o2 * e2 - s2 * i2, f2 = s2 * c2 - r2 * e2, l2 = r2 * f2 - o2 * M2, m2 = o2 * h2 - s2 * f2, d2 = s2 * M2 - r2 * h2;
  const b2 = 2 * u2;
  return h2 *= b2, M2 *= b2, f2 *= b2, l2 *= 2, m2 *= 2, d2 *= 2, t2[0] = e2 + h2 + l2, t2[1] = c2 + M2 + m2, t2[2] = i2 + f2 + d2, t2;
}
function Q$a(t2, n2, a2, s2) {
  const r2 = [], o2 = [];
  return r2[0] = n2[0] - a2[0], r2[1] = n2[1] - a2[1], r2[2] = n2[2] - a2[2], o2[0] = r2[0], o2[1] = r2[1] * Math.cos(s2) - r2[2] * Math.sin(s2), o2[2] = r2[1] * Math.sin(s2) + r2[2] * Math.cos(s2), t2[0] = o2[0] + a2[0], t2[1] = o2[1] + a2[1], t2[2] = o2[2] + a2[2], t2;
}
function R$l(t2, n2, a2, s2) {
  const r2 = [], o2 = [];
  return r2[0] = n2[0] - a2[0], r2[1] = n2[1] - a2[1], r2[2] = n2[2] - a2[2], o2[0] = r2[2] * Math.sin(s2) + r2[0] * Math.cos(s2), o2[1] = r2[1], o2[2] = r2[2] * Math.cos(s2) - r2[0] * Math.sin(s2), t2[0] = o2[0] + a2[0], t2[1] = o2[1] + a2[1], t2[2] = o2[2] + a2[2], t2;
}
function T$k(t2, n2, a2, s2) {
  const r2 = [], o2 = [];
  return r2[0] = n2[0] - a2[0], r2[1] = n2[1] - a2[1], r2[2] = n2[2] - a2[2], o2[0] = r2[0] * Math.cos(s2) - r2[1] * Math.sin(s2), o2[1] = r2[0] * Math.sin(s2) + r2[1] * Math.cos(s2), o2[2] = r2[2], t2[0] = o2[0] + a2[0], t2[1] = o2[1] + a2[1], t2[2] = o2[2] + a2[2], t2;
}
function k$n(t2, n2) {
  r$12(w$G, t2), r$12(B$i, n2), z$o(w$G, w$G), z$o(B$i, B$i);
  const a2 = P$m(w$G, B$i);
  return a2 > 1 ? 0 : a2 < -1 ? Math.PI : Math.acos(a2);
}
const w$G = n$1X(), B$i = n$1X();
function C$m(t2) {
  return "vec3(" + t2[0] + ", " + t2[1] + ", " + t2[2] + ")";
}
function F$j(t2, n2) {
  return t2[0] === n2[0] && t2[1] === n2[1] && t2[2] === n2[2];
}
function G$f(t2, a2) {
  if (t2 === a2)
    return true;
  const s2 = t2[0], r2 = t2[1], o2 = t2[2], u2 = a2[0], e2 = a2[1], c2 = a2[2], i2 = a$23();
  return Math.abs(s2 - u2) <= i2 * Math.max(1, Math.abs(s2), Math.abs(u2)) && Math.abs(r2 - e2) <= i2 * Math.max(1, Math.abs(r2), Math.abs(e2)) && Math.abs(o2 - c2) <= i2 * Math.max(1, Math.abs(o2), Math.abs(c2));
}
function H$c(t2, n2, a2) {
  const s2 = a2[0] - n2[0], r2 = a2[1] - n2[1], o2 = a2[2] - n2[2];
  let u2 = s2 * s2 + r2 * r2 + o2 * o2;
  return u2 > 0 ? (u2 = 1 / Math.sqrt(u2), t2[0] = s2 * u2, t2[1] = r2 * u2, t2[2] = o2 * u2, t2) : (t2[0] = 0, t2[1] = 0, t2[2] = 0, t2);
}
const J$a = e$1k, K$9 = c$2f, N$f = i$1S, U$n = x$A, X$7 = p$2r, Y$8 = s$1r, Z$5 = v$K;
Object.freeze(Object.defineProperty({ __proto__: null, length: s$1r, copy: r$12, set: o$1m, add: u$1t, subtract: e$1k, multiply: c$2f, divide: i$1S, ceil: h$19, floor: M$m, abs: f$1f, sign: l$1G, min: m$1x, max: d$1k, round: b$M, scale: g$R, scaleAndAdd: q$e, distance: x$A, squaredDistance: p$2r, squaredLength: v$K, negate: j$D, inverse: y$17, normalize: z$o, dot: P$m, cross: _$x, lerp: A$l, hermite: D$m, bezier: I$s, random: L$n, transformMat4: O$j, transformMat3: S$A, transformQuat: E$q, rotateX: Q$a, rotateY: R$l, rotateZ: T$k, angle: k$n, str: C$m, exactEquals: F$j, equals: G$f, direction: H$c, sub: J$a, mul: K$9, div: N$f, dist: U$n, sqrDist: X$7, len: Y$8, sqrLen: Z$5 }, Symbol.toStringTag, { value: "Module" }));
function a$22(t2, n2) {
  return t2[0] = n2[0], t2[1] = n2[1], t2[2] = n2[2], t2[3] = n2[3], t2;
}
function r$11(t2, n2, a2, r2, s2) {
  return t2[0] = n2, t2[1] = a2, t2[2] = r2, t2[3] = s2, t2;
}
function s$1q(t2, n2, a2) {
  return t2[0] = n2[0] + a2[0], t2[1] = n2[1] + a2[1], t2[2] = n2[2] + a2[2], t2[3] = n2[3] + a2[3], t2;
}
function o$1l(t2, n2, a2) {
  return t2[0] = n2[0] - a2[0], t2[1] = n2[1] - a2[1], t2[2] = n2[2] - a2[2], t2[3] = n2[3] - a2[3], t2;
}
function u$1s(t2, n2, a2) {
  return t2[0] = n2[0] * a2[0], t2[1] = n2[1] * a2[1], t2[2] = n2[2] * a2[2], t2[3] = n2[3] * a2[3], t2;
}
function e$1j(t2, n2, a2) {
  return t2[0] = n2[0] / a2[0], t2[1] = n2[1] / a2[1], t2[2] = n2[2] / a2[2], t2[3] = n2[3] / a2[3], t2;
}
function c$2e(t2, n2) {
  return t2[0] = Math.ceil(n2[0]), t2[1] = Math.ceil(n2[1]), t2[2] = Math.ceil(n2[2]), t2[3] = Math.ceil(n2[3]), t2;
}
function i$1R(t2, n2) {
  return t2[0] = Math.floor(n2[0]), t2[1] = Math.floor(n2[1]), t2[2] = Math.floor(n2[2]), t2[3] = Math.floor(n2[3]), t2;
}
function h$18(t2, n2, a2) {
  return t2[0] = Math.min(n2[0], a2[0]), t2[1] = Math.min(n2[1], a2[1]), t2[2] = Math.min(n2[2], a2[2]), t2[3] = Math.min(n2[3], a2[3]), t2;
}
function M$l(t2, n2, a2) {
  return t2[0] = Math.max(n2[0], a2[0]), t2[1] = Math.max(n2[1], a2[1]), t2[2] = Math.max(n2[2], a2[2]), t2[3] = Math.max(n2[3], a2[3]), t2;
}
function f$1e(t2, n2) {
  return t2[0] = Math.round(n2[0]), t2[1] = Math.round(n2[1]), t2[2] = Math.round(n2[2]), t2[3] = Math.round(n2[3]), t2;
}
function l$1F(t2, n2, a2) {
  return t2[0] = n2[0] * a2, t2[1] = n2[1] * a2, t2[2] = n2[2] * a2, t2[3] = n2[3] * a2, t2;
}
function m$1w(t2, n2, a2, r2) {
  return t2[0] = n2[0] + a2[0] * r2, t2[1] = n2[1] + a2[1] * r2, t2[2] = n2[2] + a2[2] * r2, t2[3] = n2[3] + a2[3] * r2, t2;
}
function d$1j(t2, n2) {
  const a2 = n2[0] - t2[0], r2 = n2[1] - t2[1], s2 = n2[2] - t2[2], o2 = n2[3] - t2[3];
  return Math.sqrt(a2 * a2 + r2 * r2 + s2 * s2 + o2 * o2);
}
function b$L(t2, n2) {
  const a2 = n2[0] - t2[0], r2 = n2[1] - t2[1], s2 = n2[2] - t2[2], o2 = n2[3] - t2[3];
  return a2 * a2 + r2 * r2 + s2 * s2 + o2 * o2;
}
function x$z(t2) {
  const n2 = t2[0], a2 = t2[1], r2 = t2[2], s2 = t2[3];
  return Math.sqrt(n2 * n2 + a2 * a2 + r2 * r2 + s2 * s2);
}
function q$d(t2) {
  const n2 = t2[0], a2 = t2[1], r2 = t2[2], s2 = t2[3];
  return n2 * n2 + a2 * a2 + r2 * r2 + s2 * s2;
}
function p$2q(t2, n2) {
  return t2[0] = -n2[0], t2[1] = -n2[1], t2[2] = -n2[2], t2[3] = -n2[3], t2;
}
function g$Q(t2, n2) {
  return t2[0] = 1 / n2[0], t2[1] = 1 / n2[1], t2[2] = 1 / n2[2], t2[3] = 1 / n2[3], t2;
}
function v$J(t2, n2) {
  const a2 = n2[0], r2 = n2[1], s2 = n2[2], o2 = n2[3];
  let u2 = a2 * a2 + r2 * r2 + s2 * s2 + o2 * o2;
  return u2 > 0 && (u2 = 1 / Math.sqrt(u2), t2[0] = a2 * u2, t2[1] = r2 * u2, t2[2] = s2 * u2, t2[3] = o2 * u2), t2;
}
function y$16(t2, n2) {
  return t2[0] * n2[0] + t2[1] * n2[1] + t2[2] * n2[2] + t2[3] * n2[3];
}
function j$C(t2, n2, a2, r2) {
  const s2 = n2[0], o2 = n2[1], u2 = n2[2], e2 = n2[3];
  return t2[0] = s2 + r2 * (a2[0] - s2), t2[1] = o2 + r2 * (a2[1] - o2), t2[2] = u2 + r2 * (a2[2] - u2), t2[3] = e2 + r2 * (a2[3] - e2), t2;
}
function _$w(t2, a2) {
  const r2 = n$1W;
  let s2, o2, u2, e2, c2, i2;
  a2 = a2 || 1;
  do {
    s2 = 2 * r2() - 1, o2 = 2 * r2() - 1, c2 = s2 * s2 + o2 * o2;
  } while (c2 >= 1);
  do {
    u2 = 2 * r2() - 1, e2 = 2 * r2() - 1, i2 = u2 * u2 + e2 * e2;
  } while (i2 >= 1);
  const h2 = Math.sqrt((1 - c2) / i2);
  return t2[0] = a2 * s2, t2[1] = a2 * o2, t2[2] = a2 * u2 * h2, t2[3] = a2 * e2 * h2, t2;
}
function w$F(t2, n2, a2) {
  const r2 = n2[0], s2 = n2[1], o2 = n2[2], u2 = n2[3];
  return t2[0] = a2[0] * r2 + a2[4] * s2 + a2[8] * o2 + a2[12] * u2, t2[1] = a2[1] * r2 + a2[5] * s2 + a2[9] * o2 + a2[13] * u2, t2[2] = a2[2] * r2 + a2[6] * s2 + a2[10] * o2 + a2[14] * u2, t2[3] = a2[3] * r2 + a2[7] * s2 + a2[11] * o2 + a2[15] * u2, t2;
}
function z$n(t2, n2, a2) {
  const r2 = n2[0], s2 = n2[1], o2 = n2[2], u2 = a2[0], e2 = a2[1], c2 = a2[2], i2 = a2[3], h2 = i2 * r2 + e2 * o2 - c2 * s2, M2 = i2 * s2 + c2 * r2 - u2 * o2, f2 = i2 * o2 + u2 * s2 - e2 * r2, l2 = -u2 * r2 - e2 * s2 - c2 * o2;
  return t2[0] = h2 * i2 + l2 * -u2 + M2 * -c2 - f2 * -e2, t2[1] = M2 * i2 + l2 * -e2 + f2 * -u2 - h2 * -c2, t2[2] = f2 * i2 + l2 * -c2 + h2 * -e2 - M2 * -u2, t2[3] = n2[3], t2;
}
function A$k(t2) {
  return "vec4(" + t2[0] + ", " + t2[1] + ", " + t2[2] + ", " + t2[3] + ")";
}
function D$l(t2, n2) {
  return t2[0] === n2[0] && t2[1] === n2[1] && t2[2] === n2[2] && t2[3] === n2[3];
}
function E$p(n2, a2) {
  const r2 = n2[0], s2 = n2[1], o2 = n2[2], u2 = n2[3], e2 = a2[0], c2 = a2[1], i2 = a2[2], h2 = a2[3], M2 = a$23();
  return Math.abs(r2 - e2) <= M2 * Math.max(1, Math.abs(r2), Math.abs(e2)) && Math.abs(s2 - c2) <= M2 * Math.max(1, Math.abs(s2), Math.abs(c2)) && Math.abs(o2 - i2) <= M2 * Math.max(1, Math.abs(o2), Math.abs(i2)) && Math.abs(u2 - h2) <= M2 * Math.max(1, Math.abs(u2), Math.abs(h2));
}
const L$m = o$1l, O$i = u$1s, S$z = e$1j, k$m = d$1j, B$h = b$L, C$l = x$z, F$i = q$d;
Object.freeze(Object.defineProperty({ __proto__: null, copy: a$22, set: r$11, add: s$1q, subtract: o$1l, multiply: u$1s, divide: e$1j, ceil: c$2e, floor: i$1R, min: h$18, max: M$l, round: f$1e, scale: l$1F, scaleAndAdd: m$1w, distance: d$1j, squaredDistance: b$L, length: x$z, squaredLength: q$d, negate: p$2q, inverse: g$Q, normalize: v$J, dot: y$16, lerp: j$C, random: _$w, transformMat4: w$F, transformQuat: z$n, str: A$k, exactEquals: D$l, equals: E$p, sub: L$m, mul: O$i, div: S$z, dist: k$m, sqrDist: B$h, len: C$l, sqrLen: F$i }, Symbol.toStringTag, { value: "Module" }));
const e$1i = new Float32Array(1);
function i$1Q(t2) {
  --t2;
  for (let n2 = 1; n2 < 32; n2 <<= 1)
    t2 |= t2 >> n2;
  return t2 + 1;
}
function a$21(t2, n2, r2) {
  return Math.min(Math.max(t2, n2), r2);
}
function c$2d(t2) {
  return (t2 & t2 - 1) == 0;
}
function f$1d(t2) {
  return t2--, t2 |= t2 >> 1, t2 |= t2 >> 2, t2 |= t2 >> 4, t2 |= t2 >> 8, t2 |= t2 >> 16, ++t2;
}
function h$17(t2, n2, r2) {
  return t2 + (n2 - t2) * r2;
}
function m$1v(t2) {
  return t2 * Math.PI / 180;
}
function b$K(t2) {
  return 180 * t2 / Math.PI;
}
function l$1E(t2) {
  return Math.acos(a$21(t2, -1, 1));
}
function N$e(t2) {
  return Math.asin(a$21(t2, -1, 1));
}
function g$P(t2, n2, r2 = 1e-6) {
  if (t2 === n2)
    return true;
  if (!Number.isFinite(t2) || !Number.isFinite(n2))
    return false;
  return (t2 > n2 ? t2 - n2 : n2 - t2) <= r2;
}
const E$o = new DataView(new ArrayBuffer(Float64Array.BYTES_PER_ELEMENT));
function B$g(t2) {
  return E$o.setFloat64(0, t2), E$o.getBigInt64(0);
}
function I$r(t2) {
  return E$o.setBigInt64(0, t2), E$o.getFloat64(0);
}
const p$2p = BigInt("1000000");
x$y(1);
function x$y(t2) {
  const n2 = B$g(t2 = Math.abs(t2)), r2 = I$r(n2 <= p$2p ? p$2p : n2 - p$2p);
  return Math.abs(t2 - r2);
}
function A$j(t2) {
  return P$l(Math.max(-D$k, Math.min(t2, D$k)));
}
function P$l(t2) {
  return e$1i[0] = t2, e$1i[0];
}
function L$l(t2, u2) {
  const e2 = s$1r(t2), i2 = N$e(t2[2] / e2), a2 = Math.atan2(t2[1] / e2, t2[0] / e2);
  return o$1m(u2, e2, i2, a2), u2;
}
function d$1i(t2) {
  const n2 = t2[0] * t2[0] + t2[1] * t2[1] + t2[2] * t2[2], r2 = t2[3] * t2[3] + t2[4] * t2[4] + t2[5] * t2[5], u2 = t2[6] * t2[6] + t2[7] * t2[7] + t2[8] * t2[8];
  return !(g$P(n2, 1) && g$P(r2, 1) && g$P(u2, 1));
}
const D$k = P$l(34028234663852886e22);
function n$1V(t2) {
  return a$21(s$21(t2), 0, 255);
}
function o$1k(t2, r2, s2) {
  return t2 = Number(t2), isNaN(t2) ? s2 : t2 < r2 ? r2 : t2 > s2 ? s2 : t2;
}
class h$16 {
  constructor(t2) {
    this.r = 255, this.g = 255, this.b = 255, this.a = 1, t2 && this.setColor(t2);
  }
  static blendColors(t2, r2, s2, i2 = new h$16()) {
    return i2.r = Math.round(t2.r + (r2.r - t2.r) * s2), i2.g = Math.round(t2.g + (r2.g - t2.g) * s2), i2.b = Math.round(t2.b + (r2.b - t2.b) * s2), i2.a = t2.a + (r2.a - t2.a) * s2, i2._sanitize();
  }
  static fromRgb(r2, s2) {
    const i2 = r2.toLowerCase().match(/^(rgba?|hsla?)\(([\s\.\-,%0-9]+)\)/);
    if (i2) {
      const r3 = i2[2].split(/\s*,\s*/), e2 = i2[1];
      if (e2 === "rgb" && r3.length === 3 || e2 === "rgba" && r3.length === 4) {
        const t2 = r3[0];
        if (t2.charAt(t2.length - 1) === "%") {
          const t3 = r3.map((t4) => 2.56 * parseFloat(t4));
          return r3.length === 4 && (t3[3] = parseFloat(r3[3])), h$16.fromArray(t3, s2);
        }
        return h$16.fromArray(r3.map((t3) => parseFloat(t3)), s2);
      }
      if (e2 === "hsl" && r3.length === 3 || e2 === "hsla" && r3.length === 4)
        return h$16.fromArray(o$1p(parseFloat(r3[0]), parseFloat(r3[1]) / 100, parseFloat(r3[2]) / 100, parseFloat(r3[3])), s2);
    }
    return null;
  }
  static fromHex(t2, r2 = new h$16()) {
    if (t2.length !== 4 && t2.length !== 7 || t2[0] !== "#")
      return null;
    const s2 = t2.length === 4 ? 4 : 8, i2 = (1 << s2) - 1;
    let e2 = Number("0x" + t2.substr(1));
    return isNaN(e2) ? null : (["b", "g", "r"].forEach((t3) => {
      const a2 = e2 & i2;
      e2 >>= s2, r2[t3] = s2 === 4 ? 17 * a2 : a2;
    }), r2.a = 1, r2);
  }
  static fromArray(t2, r2 = new h$16()) {
    return r2._set(Number(t2[0]), Number(t2[1]), Number(t2[2]), Number(t2[3])), isNaN(r2.a) && (r2.a = 1), r2._sanitize();
  }
  static fromString(t2, i2) {
    const e2 = r$15(t2) ? l$1I(t2) : null;
    return e2 && h$16.fromArray(e2, i2) || h$16.fromRgb(t2, i2) || h$16.fromHex(t2, i2);
  }
  static fromJSON(t2) {
    return t2 && new h$16([t2[0], t2[1], t2[2], t2[3] / 255]);
  }
  static toUnitRGB(t2) {
    return r$1t(t2) ? [t2.r / 255, t2.g / 255, t2.b / 255] : null;
  }
  static toUnitRGBA(t2) {
    return r$1t(t2) ? [t2.r / 255, t2.g / 255, t2.b / 255, t2.a != null ? t2.a : 1] : null;
  }
  get isBright() {
    return 0.299 * this.r + 0.587 * this.g + 0.114 * this.b >= 127;
  }
  setColor(t2) {
    var _a2, _b2, _c2, _d2;
    return typeof t2 == "string" ? h$16.fromString(t2, this) : Array.isArray(t2) ? h$16.fromArray(t2, this) : (this._set((_a2 = t2.r) != null ? _a2 : 0, (_b2 = t2.g) != null ? _b2 : 0, (_c2 = t2.b) != null ? _c2 : 0, (_d2 = t2.a) != null ? _d2 : 1), t2 instanceof h$16 || this._sanitize()), this;
  }
  toRgb() {
    return [this.r, this.g, this.b];
  }
  toRgba() {
    return [this.r, this.g, this.b, this.a];
  }
  toHex() {
    const t2 = this.r.toString(16), r2 = this.g.toString(16), s2 = this.b.toString(16);
    return `#${t2.length < 2 ? "0" + t2 : t2}${r2.length < 2 ? "0" + r2 : r2}${s2.length < 2 ? "0" + s2 : s2}`;
  }
  toCss(t2 = false) {
    const r2 = this.r + ", " + this.g + ", " + this.b;
    return t2 ? `rgba(${r2}, ${this.a})` : `rgb(${r2})`;
  }
  toString() {
    return this.toCss(true);
  }
  toJSON() {
    return this.toArray();
  }
  toArray(t2 = h$16.AlphaMode.ALWAYS) {
    const r2 = n$1V(this.r), s2 = n$1V(this.g), i2 = n$1V(this.b);
    return t2 === h$16.AlphaMode.ALWAYS || this.a !== 1 ? [r2, s2, i2, n$1V(255 * this.a)] : [r2, s2, i2];
  }
  clone() {
    return new h$16(this.toRgba());
  }
  hash() {
    return this.r << 24 | this.g << 16 | this.b << 8 | 255 * this.a;
  }
  equals(t2) {
    return r$1t(t2) && t2.r === this.r && t2.g === this.g && t2.b === this.b && t2.a === this.a;
  }
  _sanitize() {
    return this.r = Math.round(o$1k(this.r, 0, 255)), this.g = Math.round(o$1k(this.g, 0, 255)), this.b = Math.round(o$1k(this.b, 0, 255)), this.a = o$1k(this.a, 0, 1), this;
  }
  _set(t2, r2, s2, i2) {
    this.r = t2, this.g = r2, this.b = s2, this.a = i2;
  }
}
h$16.prototype.declaredClass = "esri.Color", function(t2) {
  var r2;
  (r2 = t2.AlphaMode || (t2.AlphaMode = {}))[r2.ALWAYS = 0] = "ALWAYS", r2[r2.UNLESS_OPAQUE = 1] = "UNLESS_OPAQUE";
}(h$16 || (h$16 = {}));
const l$1D = h$16;
const p$2o = new s$1F({ esriSMS: "simple-marker", esriPMS: "picture-marker", esriSLS: "simple-line", esriSFS: "simple-fill", esriPFS: "picture-fill", esriTS: "text", esriSHD: "shield-label-symbol", PointSymbol3D: "point-3d", LineSymbol3D: "line-3d", PolygonSymbol3D: "polygon-3d", WebStyleSymbol: "web-style", MeshSymbol3D: "mesh-3d", LabelSymbol3D: "label-3d", CIMSymbolReference: "cim" });
let c$2c = 0, m$1u = class extends l$1_ {
  constructor(r2) {
    super(r2), this.id = "sym" + c$2c++, this.type = null, this.color = new l$1D([0, 0, 0, 1]);
  }
  readColor(r2) {
    return r2 && r2[0] != null ? [r2[0], r2[1], r2[2], r2[3] / 255] : r2;
  }
  async collectRequiredFields(r2, o2) {
  }
  hash() {
    return JSON.stringify(this.toJSON());
  }
  clone() {
  }
};
e$1W([y$1o({ type: p$2o.apiValues, readOnly: true, json: { read: false, write: { ignoreOrigin: true, writer: p$2o.write } } })], m$1u.prototype, "type", void 0), e$1W([y$1o({ type: l$1D, json: { write: { allowNull: true } } })], m$1u.prototype, "color", void 0), e$1W([o$1H("color")], m$1u.prototype, "readColor", null), m$1u = e$1W([n$2f("esri.symbols.Symbol")], m$1u);
const a$20 = m$1u;
var m$1t;
let l$1C = m$1t = class extends a$20 {
  constructor(r2) {
    super(r2), this.data = null, this.type = "cim";
  }
  readData(r2, o2) {
    return o2;
  }
  writeData(r2, o2) {
    if (r2)
      for (const t2 in r2)
        o2[t2] = r2[t2];
  }
  async collectRequiredFields(r2, o2) {
    var _a2;
    if (((_a2 = this.data) == null ? void 0 : _a2.type) === "CIMSymbolReference") {
      const t2 = this.data.primitiveOverrides;
      if (t2) {
        const e2 = t2.map((t3) => {
          const e3 = t3.valueExpressionInfo;
          return S$C(r2, o2, e3.expression);
        });
        await Promise.all(e2);
      }
    }
  }
  clone() {
    return new m$1t({ data: y$1r(this.data) });
  }
  hash() {
    return c$2T(JSON.stringify(this.data)).toString();
  }
};
e$1W([y$1o({ json: { write: false } })], l$1C.prototype, "color", void 0), e$1W([y$1o({ json: { write: true } })], l$1C.prototype, "data", void 0), e$1W([o$1H("data", ["symbol"])], l$1C.prototype, "readData", null), e$1W([r$1h("data", {})], l$1C.prototype, "writeData", null), e$1W([r$1a({ CIMSymbolReference: "cim" }, { readOnly: true })], l$1C.prototype, "type", void 0), l$1C = m$1t = e$1W([n$2f("esri.symbols.CIMSymbol")], l$1C);
const d$1h = l$1C;
let p$2n = class extends l$1_ {
  constructor(e2) {
    super(e2), this.enabled = true, this.type = null;
  }
  writeEnabled(e2, r2, o2) {
    e2 || (r2[o2] = e2);
  }
};
e$1W([y$1o({ type: Boolean, json: { read: { source: "enable" }, write: { target: "enable" } } })], p$2n.prototype, "enabled", void 0), e$1W([r$1h("enabled")], p$2n.prototype, "writeEnabled", null), e$1W([y$1o({ type: ["icon", "object", "line", "path", "fill", "water", "extrude", "text"], readOnly: true })], p$2n.prototype, "type", void 0), p$2n = e$1W([n$2f("esri.symbols.Symbol3DLayer")], p$2n);
const a$1$ = p$2n;
const n$1U = /^-?(\d+(\.\d+)?)\s*((px)|(pt))?$/i, t$1o = "screenUtils.toPt: input not recognized!", r$10 = 96;
function u$1r(n2) {
  return n2 ? n2 / 72 * r$10 : 0;
}
function e$1h(n2) {
  return n2 ? 72 * n2 / r$10 : 0;
}
function o$1j(r2) {
  if (typeof r2 == "string") {
    const u2 = r2.match(n$1U);
    if (u2) {
      const n2 = Number(u2[1]), t2 = u2[3] && u2[3].toLowerCase(), o2 = r2.charAt(0) === "-", c2 = t2 === "px" ? e$1h(n2) : n2;
      return o2 ? -c2 : c2;
    }
    return console.warn(t$1o), null;
  }
  return r2;
}
function c$2b(n2 = 0, t2 = 0) {
  return { x: n2, y: t2 };
}
function i$1P(n2 = 0, t2 = 0) {
  return [n2, t2];
}
function n$1T(n2) {
  const r2 = s$21(100 * (1 - n2));
  return Math.max(0, Math.min(r2, 100));
}
function r$$(t2) {
  const n2 = 1 - t2 / 100;
  return Math.max(0, Math.min(n2, 1));
}
function s$1p(o2, t2) {
  const n2 = t2.transparency != null ? r$$(t2.transparency) : 1, s2 = t2.color;
  return s2 && Array.isArray(s2) ? new l$1D([s2[0] || 0, s2[1] || 0, s2[2] || 0, n2]) : null;
}
function c$2a(r2, o2) {
  o2.color = r2.toJSON().slice(0, 3);
  const t2 = n$1T(r2.a);
  t2 !== 0 && (o2.transparency = t2);
}
const p$2m = { type: l$1D, json: { type: [T$r], default: null, read: { source: ["color", "transparency"], reader: s$1p }, write: { target: { color: { type: [T$r] }, transparency: { type: T$r } }, writer: c$2a } } }, a$1_ = { type: Number, cast: o$1j, json: { write: true } };
let l$1B = class extends l$1_ {
  constructor(o2) {
    super(o2), this.color = new l$1D([0, 0, 0, 1]), this.extensionLength = 0, this.size = e$1h(1);
  }
  clone() {
  }
  cloneProperties() {
    return { color: y$1r(this.color), size: this.size, extensionLength: this.extensionLength };
  }
};
e$1W([y$1o({ type: ["solid", "sketch"], readOnly: true, json: { read: true, write: { ignoreOrigin: true } } })], l$1B.prototype, "type", void 0), e$1W([y$1o(p$2m)], l$1B.prototype, "color", void 0), e$1W([y$1o(__spreadProps(__spreadValues({}, a$1_), { json: { write: { overridePolicy: (o2) => ({ enabled: !!o2 }) } } }))], l$1B.prototype, "extensionLength", void 0), e$1W([y$1o(a$1_)], l$1B.prototype, "size", void 0), l$1B = e$1W([n$2f("esri.symbols.edges.Edges3D")], l$1B);
const m$1s = l$1B;
var t$1n;
let c$29 = t$1n = class extends m$1s {
  constructor(r2) {
    super(r2), this.type = "sketch";
  }
  clone() {
    return new t$1n(this.cloneProperties());
  }
};
e$1W([r$1a({ sketch: "sketch" }, { readOnly: true })], c$29.prototype, "type", void 0), c$29 = t$1n = e$1W([n$2f("esri.symbols.edges.SketchEdges3D")], c$29);
const p$2l = c$29;
var t$1m;
let p$2k = t$1m = class extends m$1s {
  constructor(r2) {
    super(r2), this.type = "solid";
  }
  clone() {
    return new t$1m(this.cloneProperties());
  }
};
e$1W([r$1a({ solid: "solid" }, { readOnly: true })], p$2k.prototype, "type", void 0), p$2k = t$1m = e$1W([n$2f("esri.symbols.support.SolidEdges3D")], p$2k);
const c$28 = p$2k;
const t$1l = { types: { key: "type", base: m$1s, typeMap: { solid: c$28, sketch: p$2l } }, json: { write: true } };
var p$2j;
let l$1A = p$2j = class extends l$1_ {
  constructor(o2) {
    super(o2), this.color = null;
  }
  clone() {
    const o2 = { color: r$1t(this.color) ? this.color.clone() : null };
    return new p$2j(o2);
  }
};
e$1W([y$1o(p$2m)], l$1A.prototype, "color", void 0), l$1A = p$2j = e$1W([n$2f("esri.symbols.support.Symbol3DMaterial")], l$1A);
var l$1z;
let c$27 = l$1z = class extends a$1$ {
  constructor(e2) {
    super(e2), this.type = "extrude", this.size = 1, this.material = null, this.castShadows = true, this.edges = null;
  }
  clone() {
    return new l$1z({ edges: this.edges && this.edges.clone(), enabled: this.enabled, material: r$1t(this.material) ? this.material.clone() : null, castShadows: this.castShadows, size: this.size });
  }
};
e$1W([r$1a({ Extrude: "extrude" }, { readOnly: true })], c$27.prototype, "type", void 0), e$1W([y$1o({ type: Number, json: { write: { enabled: true, isRequired: true } }, nonNullable: true })], c$27.prototype, "size", void 0), e$1W([y$1o({ type: l$1A, json: { write: true } })], c$27.prototype, "material", void 0), e$1W([y$1o({ type: Boolean, nonNullable: true, json: { write: true, default: true } })], c$27.prototype, "castShadows", void 0), e$1W([y$1o(t$1l)], c$27.prototype, "edges", void 0), c$27 = l$1z = e$1W([n$2f("esri.symbols.ExtrudeSymbol3DLayer")], c$27);
const d$1g = c$27;
let i$1O = class extends a$20 {
  constructor(r2) {
    super(r2), this.type = "simple-line", this.width = 0.75;
  }
  hash() {
    return `${this.type}.${this.width}`;
  }
};
e$1W([r$1a({ esriSLS: "simple-line" }, { readOnly: true })], i$1O.prototype, "type", void 0), e$1W([y$1o({ type: Number, cast: o$1j, json: { write: true } })], i$1O.prototype, "width", void 0), i$1O = e$1W([n$2f("esri.symbols.LineSymbol")], i$1O);
const c$26 = i$1O;
const e$1g = ["begin", "end", "begin-end"], n$1S = ["arrow", "circle", "square", "diamond", "cross", "x"];
var n$1R;
let m$1r = n$1R = class extends l$1_ {
  constructor(r2) {
    super(r2), this.placement = "begin-end", this.type = "line-marker", this.style = "arrow";
  }
  writeStyle(r2, o2, e2, t2) {
    o2[e2] = (t2 == null ? void 0 : t2.origin) === "web-map" ? "arrow" : r2;
  }
  set color(r2) {
    this._set("color", r2);
  }
  readColor(r2) {
    return r2 && r2[0] != null ? [r2[0], r2[1], r2[2], r2[3] / 255] : r2;
  }
  writeColor(r2, o2, e2, t2) {
    (t2 == null ? void 0 : t2.origin) === "web-map" || (o2[e2] = r2);
  }
  clone() {
    return new n$1R({ color: y$1r(this.color), placement: this.placement, style: this.style });
  }
  hash() {
    var _a2;
    return `${this.placement}.${(_a2 = this.color) == null ? void 0 : _a2.hash()}.${this.style}`;
  }
};
e$1W([y$1o({ type: ["begin", "end", "begin-end"], json: { write: true } })], m$1r.prototype, "placement", void 0), e$1W([r$1a({ "line-marker": "line-marker" }, { readOnly: true }), y$1o({ json: { origins: { "web-map": { write: false } } } })], m$1r.prototype, "type", void 0), e$1W([y$1o({ type: n$1S })], m$1r.prototype, "style", void 0), e$1W([r$1h("style")], m$1r.prototype, "writeStyle", null), e$1W([y$1o({ type: l$1D, value: null, json: { write: { allowNull: true } } })], m$1r.prototype, "color", null), e$1W([o$1H("color")], m$1r.prototype, "readColor", null), e$1W([r$1h("color")], m$1r.prototype, "writeColor", null), m$1r = n$1R = e$1W([n$2f("esri.symbols.LineSymbolMarker")], m$1r);
const u$1q = m$1r;
var p$2i;
const h$15 = new s$1F({ esriSLSSolid: "solid", esriSLSDash: "dash", esriSLSDot: "dot", esriSLSDashDot: "dash-dot", esriSLSDashDotDot: "long-dash-dot-dot", esriSLSNull: "none", esriSLSInsideFrame: "inside-frame", esriSLSShortDash: "short-dash", esriSLSShortDot: "short-dot", esriSLSShortDashDot: "short-dash-dot", esriSLSShortDashDotDot: "short-dash-dot-dot", esriSLSLongDash: "long-dash", esriSLSLongDashDot: "long-dash-dot" });
let d$1f = p$2i = class extends c$26 {
  constructor(...r2) {
    super(...r2), this.type = "simple-line", this.style = "solid", this.cap = "round", this.join = "round", this.marker = null, this.miterLimit = 2;
  }
  normalizeCtorArgs(r2, o2, e2, s2, i2, n2) {
    if (r2 && typeof r2 != "string")
      return r2;
    const l2 = {};
    return r2 != null && (l2.style = r2), o2 != null && (l2.color = o2), e2 != null && (l2.width = o$1j(e2)), s2 != null && (l2.cap = s2), i2 != null && (l2.join = i2), n2 != null && (l2.miterLimit = o$1j(n2)), l2;
  }
  clone() {
    var _a2;
    return new p$2i({ color: y$1r(this.color), style: this.style, width: this.width, cap: this.cap, join: this.join, miterLimit: this.miterLimit, marker: (_a2 = this.marker) == null ? void 0 : _a2.clone() });
  }
  hash() {
    var _a2, _b2;
    return `${super.hash()}.${(_a2 = this.color) == null ? void 0 : _a2.hash()}.${this.style}.${this.cap}.${this.join}.${this.miterLimit}.${(_b2 = this.marker) == null ? void 0 : _b2.hash()}`;
  }
};
e$1W([r$1a({ esriSLS: "simple-line" }, { readOnly: true })], d$1f.prototype, "type", void 0), e$1W([y$1o({ type: h$15.apiValues, json: { read: h$15.read, write: h$15.write } })], d$1f.prototype, "style", void 0), e$1W([y$1o({ type: ["butt", "round", "square"], json: { write: { overridePolicy: (r2, o2, e2) => ({ enabled: r2 !== "round" && (e2 == null || e2.origin == null) }) } } })], d$1f.prototype, "cap", void 0), e$1W([y$1o({ type: ["miter", "round", "bevel"], json: { write: { overridePolicy: (r2, o2, e2) => ({ enabled: r2 !== "round" && (e2 == null || e2.origin == null) }) } } })], d$1f.prototype, "join", void 0), e$1W([y$1o({ types: { key: "type", base: null, defaultKeyValue: "line-marker", typeMap: { "line-marker": u$1q } }, json: { write: true, origins: { "web-scene": { write: false } } } })], d$1f.prototype, "marker", void 0), e$1W([y$1o({ type: Number, json: { read: false, write: false } })], d$1f.prototype, "miterLimit", void 0), d$1f = p$2i = e$1W([n$2f("esri.symbols.SimpleLineSymbol")], d$1f);
const m$1q = d$1f;
let l$1y = class extends a$20 {
  constructor(e2) {
    super(e2), this.outline = null, this.type = null;
  }
  hash() {
    return `${this.type}.${this.outline && this.outline.hash()}`;
  }
};
e$1W([y$1o({ types: { key: "type", base: null, defaultKeyValue: "simple-line", typeMap: { "simple-line": m$1q } }, json: { default: null, write: true } })], l$1y.prototype, "outline", void 0), e$1W([y$1o({ type: ["simple-fill", "picture-fill"], readOnly: true })], l$1y.prototype, "type", void 0), l$1y = e$1W([n$2f("esri.symbols.FillSymbol")], l$1y);
const p$2h = l$1y;
let t$1k = class extends l$1_ {
  constructor(r2) {
    super(r2);
  }
  clone() {
  }
};
e$1W([y$1o({ type: ["style"], readOnly: true, json: { read: true, write: { ignoreOrigin: true } } })], t$1k.prototype, "type", void 0), t$1k = e$1W([n$2f("esri.symbols.patterns.LinePattern3D")], t$1k);
const p$2g = t$1k;
const o$1i = ["dash", "dash-dot", "dot", "long-dash", "long-dash-dot", "long-dash-dot-dot", "none", "short-dash", "short-dash-dot", "short-dash-dot-dot", "short-dot", "solid"];
var p$2f;
const h$14 = o$1w()({ dash: "dash", "dash-dot": "dash-dot", "dash-dot-dot": "long-dash-dot-dot", dot: "dot", "long-dash": "long-dash", "long-dash-dot": "long-dash-dot", null: "none", "short-dash": "short-dash", "short-dash-dot": "short-dash-dot", "short-dash-dot-dot": "short-dash-dot-dot", "short-dot": "short-dot", solid: "solid" });
let l$1x = p$2f = class extends p$2g {
  constructor(o2) {
    super(o2), this.type = "style", this.style = "solid";
  }
  clone() {
    const o2 = { style: this.style };
    return new p$2f(o2);
  }
};
e$1W([y$1o({ type: ["style"] })], l$1x.prototype, "type", void 0), e$1W([r$1a(h$14), y$1o({ type: o$1i })], l$1x.prototype, "style", void 0), l$1x = p$2f = e$1W([n$2f("esri.symbols.patterns.LineStylePattern3D")], l$1x);
const n$1Q = l$1x;
let t$1j = class extends l$1_ {
  constructor(r2) {
    super(r2);
  }
  clone() {
  }
};
e$1W([y$1o({ type: ["style"], readOnly: true, json: { read: true, write: { ignoreOrigin: true } } })], t$1j.prototype, "type", void 0), t$1j = e$1W([n$2f("esri.symbols.patterns.Pattern3D")], t$1j);
const p$2e = t$1j;
const a$1Z = ["backward-diagonal", "cross", "diagonal-cross", "forward-diagonal", "horizontal", "none", "solid", "vertical"];
var p$2d;
let c$25 = p$2d = class extends p$2e {
  constructor(t2) {
    super(t2), this.type = "style", this.style = "solid";
  }
  clone() {
    const t2 = { style: this.style };
    return new p$2d(t2);
  }
};
e$1W([y$1o({ type: ["style"] })], c$25.prototype, "type", void 0), e$1W([y$1o({ type: a$1Z, json: { read: true, write: true } })], c$25.prototype, "style", void 0), c$25 = p$2d = e$1W([n$2f("esri.symbols.patterns.StylePattern3D")], c$25);
const y$15 = c$25;
const s$1o = { types: { key: "type", base: p$2e, typeMap: { style: y$15 } }, json: { write: true } }, o$1h = { types: { key: "type", base: p$2g, typeMap: { style: n$1Q } }, json: { write: true } };
const o$1g = new l$1D("white");
new l$1D("black");
const e$1f = new l$1D([255, 255, 255, 0]);
function t$1i(n2) {
  return n2.r === 0 && n2.g === 0 && n2.b === 0;
}
var c$24;
let l$1w = c$24 = class extends l$1A {
  constructor(o2) {
    super(o2), this.colorMixMode = null;
  }
  clone() {
    const o2 = { color: r$1t(this.color) ? this.color.clone() : null, colorMixMode: this.colorMixMode };
    return new c$24(o2);
  }
};
e$1W([r$1a({ multiply: "multiply", replace: "replace", tint: "tint" })], l$1w.prototype, "colorMixMode", void 0), l$1w = c$24 = e$1W([n$2f("esri.symbols.support.Symbol3DFillMaterial")], l$1w);
function i$1N(n2) {
  return n2;
}
function u$1p(n2 = L$k) {
  return i$1N([n2[0], n2[1], n2[2], n2[3]]);
}
function e$1e(n2) {
  return i$1N([n2[0], n2[1], n2[2], n2[3]]);
}
function a$1Y(n2, t2) {
  return n2 !== t2 && (n2[0] = t2[0], n2[1] = t2[1], n2[2] = t2[2], n2[3] = t2[3]), n2;
}
function o$1f(n2, t2, r2, i2, e2 = u$1p()) {
  return e2[0] = n2, e2[1] = t2, e2[2] = r2, e2[3] = i2, e2;
}
function c$23(n2, t2 = u$1p()) {
  return t2[0] = n2.xmin, t2[1] = n2.ymin, t2[2] = n2.xmax, t2[3] = n2.ymax, t2;
}
function f$1c(n2, t2) {
  return new w$J({ xmin: n2[0], ymin: n2[1], xmax: n2[2], ymax: n2[3], spatialReference: t2 });
}
function m$1p(n2, t2) {
  t2[0] < n2[0] && (n2[0] = t2[0]), t2[0] > n2[2] && (n2[2] = t2[0]), t2[1] < n2[1] && (n2[1] = t2[1]), t2[1] > n2[3] && (n2[3] = t2[1]);
}
function h$13(n2, r2, i2) {
  if (t$1W(r2))
    a$1Y(i2, n2);
  else if ("length" in r2)
    G$e(r2) ? (i2[0] = Math.min(n2[0], r2[0]), i2[1] = Math.min(n2[1], r2[1]), i2[2] = Math.max(n2[2], r2[2]), i2[3] = Math.max(n2[3], r2[3])) : r2.length !== 2 && r2.length !== 3 || (i2[0] = Math.min(n2[0], r2[0]), i2[1] = Math.min(n2[1], r2[1]), i2[2] = Math.max(n2[2], r2[0]), i2[3] = Math.max(n2[3], r2[1]));
  else
    switch (r2.type) {
      case "extent":
        i2[0] = Math.min(n2[0], r2.xmin), i2[1] = Math.min(n2[1], r2.ymin), i2[2] = Math.max(n2[2], r2.xmax), i2[3] = Math.max(n2[3], r2.ymax);
        break;
      case "point":
        i2[0] = Math.min(n2[0], r2.x), i2[1] = Math.min(n2[1], r2.y), i2[2] = Math.max(n2[2], r2.x), i2[3] = Math.max(n2[3], r2.y);
    }
}
function s$1n(n2) {
  return t$1W(n2) || n2[0] >= n2[2] ? 0 : n2[2] - n2[0];
}
function l$1v(n2) {
  return n2[1] >= n2[3] ? 0 : n2[3] - n2[1];
}
function y$14(n2) {
  return s$1n(n2) * l$1v(n2);
}
function w$E(n2, t2, r2) {
  return t2 >= n2[0] && r2 >= n2[1] && t2 <= n2[2] && r2 <= n2[3];
}
function q$c(n2, t2, r2) {
  return t2[0] >= n2[0] - r2 && t2[1] >= n2[1] - r2 && t2[0] <= n2[2] + r2 && t2[1] <= n2[3] + r2;
}
function E$n(n2, t2) {
  return Math.max(t2[0], n2[0]) <= Math.min(t2[2], n2[2]) && Math.max(t2[1], n2[1]) <= Math.min(t2[3], n2[3]);
}
function R$k(n2, t2) {
  return t2[0] >= n2[0] && t2[2] <= n2[2] && t2[1] >= n2[1] && t2[3] <= n2[3];
}
function D$j(n2) {
  return n2 ? a$1Y(n2, K$8) : u$1p(K$8);
}
function G$e(n2) {
  return n2 != null && n2.length === 4;
}
function I$q(n2, t2) {
  return G$e(n2) && G$e(t2) ? n2[0] === t2[0] && n2[1] === t2[1] && n2[2] === t2[2] && n2[3] === t2[3] : n2 === t2;
}
const K$8 = i$1N([1 / 0, 1 / 0, -1 / 0, -1 / 0]), L$k = i$1N([0, 0, 0, 0]);
function i$1M(n2) {
  return n2;
}
function a$1X(n2 = D$i) {
  return i$1M([n2[0], n2[1], n2[2], n2[3], n2[4], n2[5]]);
}
function u$1o(n2, t2, r2, i2, u2, e2, m2 = a$1X()) {
  return m2[0] = n2, m2[1] = t2, m2[2] = r2, m2[3] = i2, m2[4] = u2, m2[5] = e2, m2;
}
function m$1o(n2, r2) {
  const i2 = isFinite(n2[2]) || isFinite(n2[5]);
  return new w$J(i2 ? { xmin: n2[0], xmax: n2[3], ymin: n2[1], ymax: n2[4], zmin: n2[2], zmax: n2[5], spatialReference: r2 } : { xmin: n2[0], xmax: n2[3], ymin: n2[1], ymax: n2[4], spatialReference: r2 });
}
function f$1b(n2, t2) {
  n2[0] = Math.min(n2[0], t2[0]), n2[1] = Math.min(n2[1], t2[1]), n2[2] = Math.min(n2[2], t2[2]), n2[3] = Math.max(n2[3], t2[3]), n2[4] = Math.max(n2[4], t2[4]), n2[5] = Math.max(n2[5], t2[5]);
}
function c$22(n2, t2) {
  n2[0] = Math.min(n2[0], t2[0]), n2[1] = Math.min(n2[1], t2[1]), n2[2] = Math.min(n2[2], t2[2]), n2[3] = Math.max(n2[3], t2[0]), n2[4] = Math.max(n2[4], t2[1]), n2[5] = Math.max(n2[5], t2[2]);
}
function I$p(n2) {
  return n2[0] >= n2[3] ? 0 : n2[3] - n2[0];
}
function y$13(n2) {
  return n2[1] >= n2[4] ? 0 : n2[4] - n2[1];
}
function N$d(n2) {
  return n2[2] >= n2[5] ? 0 : n2[5] - n2[2];
}
function F$h(n2, t2 = [0, 0, 0]) {
  return t2[0] = I$p(n2), t2[1] = y$13(n2), t2[2] = N$d(n2), t2;
}
function d$1e(n2, t2, r2 = n2) {
  return r2[0] = t2[0], r2[1] = t2[1], r2[2] = t2[2], r2 !== n2 && (r2[3] = n2[3], r2[4] = n2[4], r2[5] = n2[5]), r2;
}
function q$b(n2, t2, r2 = n2) {
  return r2[3] = t2[0], r2[4] = t2[1], r2[5] = t2[2], r2 !== n2 && (r2[0] = n2[0], r2[1] = n2[1], r2[2] = n2[2]), n2;
}
function w$D(n2, t2) {
  return n2[0] = t2[0], n2[1] = t2[1], n2[2] = t2[2], n2[3] = t2[3], n2[4] = t2[4], n2[5] = t2[5], n2;
}
function A$i(n2) {
  return n2 ? w$D(n2, C$k) : a$1X(C$k);
}
function G$d(n2, t2) {
  return n2[0] = t2[0], n2[1] = t2[1], n2[2] = Number.NEGATIVE_INFINITY, n2[3] = t2[2], n2[4] = t2[3], n2[5] = Number.POSITIVE_INFINITY, n2;
}
function O$h(n2) {
  return n2.length === 6;
}
function S$y(t2, r2, i2) {
  if (t$1W(t2) || t$1W(r2))
    return t2 === r2;
  if (!O$h(t2) || !O$h(r2))
    return false;
  if (i2) {
    for (let n2 = 0; n2 < t2.length; n2++)
      if (!i2(t2[n2], r2[n2]))
        return false;
  } else
    for (let n2 = 0; n2 < t2.length; n2++)
      if (t2[n2] !== r2[n2])
        return false;
  return true;
}
const C$k = i$1M([1 / 0, 1 / 0, 1 / 0, -1 / 0, -1 / 0, -1 / 0]), D$i = i$1M([0, 0, 0, 0, 0, 0]);
a$1X();
function t$1h(r2, { isPrimitive: t2, width: n2, depth: o2, height: s2 }) {
  const c2 = t2 ? 10 : 1;
  if (n2 == null && s2 == null && o2 == null)
    return [c2 * r2[0], c2 * r2[1], c2 * r2[2]];
  const u2 = r$14(n2, o2, s2);
  let i2;
  for (let e2 = 0; e2 < 3; e2++) {
    const t3 = u2[e2];
    if (t3 != null) {
      i2 = t3 / r2[e2];
      break;
    }
  }
  for (let e2 = 0; e2 < 3; e2++)
    u2[e2] == null && (u2[e2] = r2[e2] * i2);
  return u2;
}
const n$1P = u$1o(-0.5, -0.5, -0.5, 0.5, 0.5, 0.5), o$1e = u$1o(-0.5, -0.5, 0, 0.5, 0.5, 1), s$1m = u$1o(-0.5, -0.5, 0, 0.5, 0.5, 0.5);
function c$21(e2) {
  switch (e2) {
    case "sphere":
    case "cube":
    case "diamond":
      return n$1P;
    case "cylinder":
    case "cone":
    case "inverted-cone":
      return o$1e;
    case "tetrahedron":
      return s$1m;
    default:
      return;
  }
}
const u$1n = ["butt", "square", "round"], i$1L = [...u$1n, "none"], a$1W = ["miter", "bevel", "round"];
var m$1n;
let u$1m = m$1n = class extends l$1_ {
  constructor(t2) {
    super(t2), this.color = new l$1D([0, 0, 0, 1]), this.size = e$1h(1), this.pattern = null, this.patternCap = "butt";
  }
  clone() {
    const t2 = { color: r$1t(this.color) ? this.color.clone() : null, size: this.size, pattern: r$1t(this.pattern) ? this.pattern.clone() : null, patternCap: this.patternCap };
    return new m$1n(t2);
  }
};
e$1W([y$1o(p$2m)], u$1m.prototype, "color", void 0), e$1W([y$1o(a$1_)], u$1m.prototype, "size", void 0), e$1W([y$1o(o$1h)], u$1m.prototype, "pattern", void 0), e$1W([y$1o({ type: u$1n, json: { default: "butt", write: { overridePolicy() {
  return { enabled: r$1t(this.pattern) };
} } } })], u$1m.prototype, "patternCap", void 0), u$1m = m$1n = e$1W([n$2f("esri.symbols.support.Symbol3DOutline")], u$1m);
var d$1d;
let h$12 = d$1d = class extends a$1$ {
  constructor(t2) {
    super(t2), this.type = "fill", this.material = null, this.pattern = null, this.castShadows = true, this.outline = null, this.edges = null;
  }
  clone() {
    const t2 = { edges: r$1t(this.edges) ? this.edges.clone() : null, enabled: this.enabled, material: r$1t(this.material) ? this.material.clone() : null, pattern: r$1t(this.pattern) ? this.pattern.clone() : null, castShadows: this.castShadows, outline: r$1t(this.outline) ? this.outline.clone() : null };
    return new d$1d(t2);
  }
  static fromSimpleFillSymbol(t2) {
    var _a2, _b2, _c2, _d2, _e3, _f2;
    const e2 = t2.outline && t2.outline.style && t2.outline.style !== "inside-frame" && t2.outline.style !== "solid" ? new n$1Q({ style: t2.outline.style }) : null, o2 = { size: (_b2 = (_a2 = t2.outline) == null ? void 0 : _a2.width) != null ? _b2 : 0, color: ((_d2 = (_c2 = t2.outline) == null ? void 0 : _c2.color) != null ? _d2 : o$1g).clone(), pattern: e2 };
    return e2 && ((_e3 = t2.outline) == null ? void 0 : _e3.cap) && (o2.patternCap = t2.outline.cap), new d$1d({ material: new l$1w({ color: ((_f2 = t2.color) != null ? _f2 : e$1f).clone() }), pattern: t2.style && t2.style !== "solid" ? new y$15({ style: t2.style }) : null, outline: o2 });
  }
};
e$1W([r$1a({ Fill: "fill" }, { readOnly: true })], h$12.prototype, "type", void 0), e$1W([y$1o({ type: l$1w, json: { write: true } })], h$12.prototype, "material", void 0), e$1W([y$1o(s$1o)], h$12.prototype, "pattern", void 0), e$1W([y$1o({ type: Boolean, nonNullable: true, json: { write: true, default: true } })], h$12.prototype, "castShadows", void 0), e$1W([y$1o({ type: u$1m, json: { write: true } })], h$12.prototype, "outline", void 0), e$1W([y$1o(t$1l)], h$12.prototype, "edges", void 0), h$12 = d$1d = e$1W([n$2f("esri.symbols.FillSymbol3DLayer")], h$12);
const f$1a = h$12;
const l$1u = ["none", "underline", "line-through"], t$1g = ["normal", "italic", "oblique"], r$_ = ["normal", "lighter", "bold", "bolder"], n$1O = { type: Number, cast: (l2) => {
  const t2 = a$2w(l2);
  return t2 === 0 ? 1 : a$21(t2, 0.1, 4);
}, nonNullable: true }, i$1K = ["left", "right", "center"], a$1V = ["baseline", "top", "middle", "bottom"], m$1m = { type: i$1K, nonNullable: true }, p$2c = { type: a$1V, nonNullable: true };
var c$20;
let l$1t = c$20 = class extends l$1_ {
  constructor(t2) {
    super(t2), this.decoration = "none", this.family = "sans-serif", this.size = 9, this.style = "normal", this.weight = "normal";
  }
  castSize(t2) {
    return o$1j(t2);
  }
  clone() {
    return new c$20({ decoration: this.decoration, family: this.family, size: this.size, style: this.style, weight: this.weight });
  }
  hash() {
    return `${this.decoration}.${this.family}.${this.size}.${this.style}.${this.weight}`;
  }
};
e$1W([y$1o({ type: l$1u, json: { default: "none", write: true } })], l$1t.prototype, "decoration", void 0), e$1W([y$1o({ type: String, json: { write: true } })], l$1t.prototype, "family", void 0), e$1W([y$1o({ type: Number, json: { write: { overridePolicy: (t2, o2, e2) => ({ enabled: !e2 || !e2.textSymbol3D }) } } })], l$1t.prototype, "size", void 0), e$1W([s$1N("size")], l$1t.prototype, "castSize", null), e$1W([y$1o({ type: t$1g, json: { default: "normal", write: true } })], l$1t.prototype, "style", void 0), e$1W([y$1o({ type: r$_, json: { default: "normal", write: true } })], l$1t.prototype, "weight", void 0), l$1t = c$20 = e$1W([n$2f("esri.symbols.Font")], l$1t);
const m$1l = l$1t;
const s$1l = s$22.getLogger("esri.core.urlUtils"), u$1l = s$23.request, l$1s = "esri/config: esriConfig.request.proxyUrl is not set.", c$1$ = /^\s*[a-z][a-z0-9-+.]*:(?![0-9])/i, f$19 = /^\s*http:/i, a$1U = /^\s*https:/i, h$11 = /^\s*file:/i, p$2b = /:\d+$/, d$1c = /^https?:\/\/[^/]+\.arcgis.com\/sharing(\/|$)/i, g$O = new RegExp("^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?$"), m$1k = new RegExp("^((([^\\[:]+):)?([^@]+)@)?(\\[([^\\]]+)\\]|([^\\[:]*))(:([0-9]+))?$");
class y$12 {
  constructor(t2 = "") {
    this.uri = t2, this.scheme = null, this.authority = null, this.path = null, this.query = null, this.fragment = null, this.user = null, this.password = null, this.host = null, this.port = null;
    let n2 = x$N(this.uri.match(g$O));
    this.scheme = n2[2] || (n2[1] ? "" : null), this.authority = n2[4] || (n2[3] ? "" : null), this.path = n2[5], this.query = n2[7] || (n2[6] ? "" : null), this.fragment = n2[9] || (n2[8] ? "" : null), this.authority != null && (n2 = x$N(this.authority.match(m$1k)), this.user = n2[3] || null, this.password = n2[4] || null, this.host = n2[6] || n2[7], this.port = n2[9] || null);
  }
  toString() {
    return this.uri;
  }
}
const $$c = {}, x$x = new y$12(s$23.applicationUrl);
let w$C = x$x;
const O$g = q$a();
let U$m = O$g;
const b$J = () => w$C, C$j = () => U$m;
function q$a() {
  const t2 = x$N(w$C.path), n2 = t2.substring(0, t2.lastIndexOf(t2.split("/")[t2.split("/").length - 1]));
  return `${`${w$C.scheme}://${w$C.host}${w$C.port != null ? `:${w$C.port}` : ""}`}${n2}`;
}
function j$B(t2) {
  if (!t2)
    return null;
  const n2 = { path: null, query: null }, e2 = new y$12(t2), r2 = t2.indexOf("?");
  return e2.query === null ? n2.path = t2 : (n2.path = t2.substring(0, r2), n2.query = L$j(e2.query)), e2.fragment && (n2.hash = e2.fragment, e2.query === null && (n2.path = n2.path.substring(0, n2.path.length - (e2.fragment.length + 1)))), n2;
}
function L$j(t2) {
  const n2 = t2.split("&"), e2 = {};
  for (const r2 of n2) {
    if (!r2)
      continue;
    const t3 = r2.indexOf("=");
    let n3, o2;
    t3 < 0 ? (n3 = decodeURIComponent(r2), o2 = "") : (n3 = decodeURIComponent(r2.slice(0, t3)), o2 = decodeURIComponent(r2.slice(t3 + 1)));
    let i2 = e2[n3];
    typeof i2 == "string" && (i2 = e2[n3] = [i2]), Array.isArray(i2) ? i2.push(o2) : e2[n3] = o2;
  }
  return e2;
}
function v$I(t2) {
  return t2 && typeof t2 == "object" && "toJSON" in t2 && typeof t2.toJSON == "function";
}
function I$o(t2, n2) {
  return t2 ? n2 && typeof n2 == "function" ? Object.keys(t2).map((e2) => encodeURIComponent(e2) + "=" + encodeURIComponent(n2(e2, t2[e2]))).join("&") : Object.keys(t2).map((e2) => {
    const r2 = t2[e2];
    if (r2 == null)
      return "";
    const o2 = encodeURIComponent(e2) + "=", i2 = n2 && n2[e2];
    return i2 ? o2 + encodeURIComponent(i2(r2)) : Array.isArray(r2) ? r2.map((t3) => v$I(t3) ? o2 + encodeURIComponent(JSON.stringify(t3)) : o2 + encodeURIComponent(t3)).join("&") : v$I(r2) ? o2 + encodeURIComponent(JSON.stringify(r2)) : o2 + encodeURIComponent(r2);
  }).filter((t3) => t3).join("&") : "";
}
function A$h(t2 = false) {
  let e2, r2 = u$1l.proxyUrl;
  if (typeof t2 == "string") {
    e2 = ht$2(t2);
    const n2 = J$9(t2);
    n2 && (r2 = n2.proxyUrl);
  } else
    e2 = !!t2;
  if (!r2)
    throw s$1l.warn(l$1s), new s$1Z("urlutils:proxy-not-set", l$1s);
  e2 && $t() && (r2 = mt$2(r2));
  return j$B(r2);
}
function S$x(t2) {
  const n2 = J$9(t2);
  let e2, r2;
  if (n2) {
    const t3 = P$k(n2.proxyUrl);
    e2 = t3.path, r2 = t3.query ? L$j(t3.query) : null;
  }
  if (e2) {
    const n3 = j$B(t2);
    t2 = e2 + "?" + n3.path;
    const o2 = I$o(__spreadValues(__spreadValues({}, r2), n3.query));
    o2 && (t2 = `${t2}?${o2}`);
  }
  return t2;
}
const B$f = { path: "", query: "" };
function P$k(t2) {
  const n2 = t2.indexOf("?");
  return n2 !== -1 ? (B$f.path = t2.slice(0, n2), B$f.query = t2.slice(n2 + 1)) : (B$f.path = t2, B$f.query = null), B$f;
}
function k$l(t2) {
  return t2 = (t2 = xt$1(t2 = bt$1(t2 = P$k(t2).path), true)).toLowerCase();
}
function E$m(t2) {
  const n2 = { proxyUrl: t2.proxyUrl, urlPrefix: k$l(t2.urlPrefix) }, e2 = u$1l.proxyRules, r2 = n2.urlPrefix;
  let o2 = e2.length;
  for (let i2 = 0; i2 < e2.length; i2++) {
    const t3 = e2[i2].urlPrefix;
    if (r2.indexOf(t3) === 0) {
      if (r2.length === t3.length)
        return -1;
      o2 = i2;
      break;
    }
    t3.indexOf(r2) === 0 && (o2 = i2 + 1);
  }
  return e2.splice(o2, 0, n2), o2;
}
function J$9(t2) {
  const n2 = u$1l.proxyRules, e2 = k$l(t2);
  for (let r2 = 0; r2 < n2.length; r2++)
    if (e2.indexOf(n2[r2].urlPrefix) === 0)
      return n2[r2];
}
function N$c(t2, n2) {
  return t2 = T$j(t2), n2 = T$j(n2), xt$1(t2) === xt$1(n2);
}
function T$j(t2) {
  const n2 = (t2 = F$g(t2)).indexOf("/sharing");
  return n2 > 0 ? t2.substring(0, n2) : t2.replace(/\/+$/, "");
}
function W$9(t2) {
  const n2 = (n3) => n3 == null || n3 instanceof RegExp && n3.test(t2) || typeof n3 == "string" && t2.startsWith(n3), e2 = u$1l.interceptors;
  if (e2) {
    for (const r2 of e2)
      if (Array.isArray(r2.urls)) {
        if (r2.urls.some(n2))
          return r2;
      } else if (n2(r2.urls))
        return r2;
  }
  return null;
}
function z$m(t2, n2, e2 = false) {
  if (!t2 || !n2)
    return false;
  const r2 = vt(t2), o2 = vt(n2);
  return !(!e2 && r2.scheme !== o2.scheme) && (r2.host != null && o2.host != null && (r2.host.toLowerCase() === o2.host.toLowerCase() && r2.port === o2.port));
}
function D$h(t2) {
  if (typeof t2 == "string") {
    if (!K$7(t2))
      return true;
    t2 = vt(t2);
  }
  if (z$m(t2, w$C))
    return true;
  const n2 = u$1l.trustedServers || [];
  for (let e2 = 0; e2 < n2.length; e2++) {
    const r2 = M$k(n2[e2]);
    for (let n3 = 0; n3 < r2.length; n3++)
      if (z$m(t2, r2[n3]))
        return true;
  }
  return false;
}
function M$k(t2) {
  return $$c[t2] || (at$2(t2) || ft$2(t2) ? $$c[t2] = [new y$12(Q$9(t2))] : $$c[t2] = [new y$12(`http://${t2}`), new y$12(`https://${t2}`)]), $$c[t2];
}
function Q$9(t2, n2 = U$m, e2) {
  return ft$2(t2) ? e2 && e2.preserveProtocolRelative ? t2 : w$C.scheme === "http" && w$C.authority === H$b(t2).slice(2) ? `http:${t2}` : `https:${t2}` : at$2(t2) ? t2 : x$N(G$c(t2[0] === "/" ? wt$2(n2) : n2, t2));
}
function _$v(t2, n2 = U$m, e2) {
  if (t2 == null || !K$7(t2))
    return t2;
  const r2 = F$g(t2), o2 = r2.toLowerCase(), i2 = F$g(n2).toLowerCase().replace(/\/+$/, ""), s2 = e2 ? F$g(e2).toLowerCase().replace(/\/+$/, "") : null;
  if (s2 && i2.indexOf(s2) !== 0)
    return t2;
  const u2 = (t3, n3, e3) => (e3 = t3.indexOf(n3, e3)) === -1 ? t3.length : e3;
  let l2 = u2(o2, "/", o2.indexOf("//") + 2), c2 = -1;
  for (; o2.slice(0, l2 + 1) === i2.slice(0, l2) + "/" && (c2 = l2 + 1, l2 !== o2.length); )
    l2 = u2(o2, "/", l2 + 1);
  if (c2 === -1)
    return t2;
  if (s2 && c2 < s2.length)
    return t2;
  t2 = r2.slice(c2);
  const f2 = i2.slice(c2 - 1).replace(/[^/]+/g, "").length;
  if (f2 > 0)
    for (let a2 = 0; a2 < f2; a2++)
      t2 = `../${t2}`;
  else
    t2 = `./${t2}`;
  return t2;
}
function F$g(t2) {
  return t2 = jt$1(t2 = Rt$1(t2 = qt(t2 = Q$9(t2 = t2.trim()))));
}
function G$c(...t2) {
  const n2 = t2.filter(r$1t);
  if (!n2 || !n2.length)
    return;
  const e2 = [];
  if (K$7(n2[0])) {
    const t3 = n2[0], r3 = t3.indexOf("//");
    r3 !== -1 && (e2.push(t3.slice(0, r3 + 1)), dt$2(n2[0]) && (e2[0] += "/"), n2[0] = t3.slice(r3 + 2));
  } else
    n2[0][0] === "/" && e2.push("");
  const r2 = n2.reduce((t3, n3) => n3 ? t3.concat(n3.split("/")) : t3, []);
  for (let o2 = 0; o2 < r2.length; o2++) {
    const t3 = r2[o2];
    t3 === ".." && e2.length > 0 && e2[e2.length - 1] !== ".." ? e2.pop() : (!t3 && o2 === r2.length - 1 || t3 && (t3 !== "." || e2.length === 0)) && e2.push(t3);
  }
  return e2.join("/");
}
function H$b(t2, n2 = false) {
  if (t2 == null || V$a(t2) || X$6(t2))
    return null;
  let e2 = t2.indexOf("://");
  if (e2 === -1 && ft$2(t2))
    e2 = 2;
  else {
    if (e2 === -1)
      return null;
    e2 += 3;
  }
  const r2 = t2.indexOf("/", e2);
  return r2 !== -1 && (t2 = t2.slice(0, r2)), n2 && (t2 = xt$1(t2, true)), t2;
}
function K$7(t2) {
  return ft$2(t2) || at$2(t2);
}
function V$a(t2) {
  return t2 != null && t2.slice(0, 5) === "blob:";
}
function X$6(t2) {
  return t2 != null && t2.slice(0, 5) === "data:";
}
function Y$7(t2) {
  const n2 = nt$2(t2);
  if (!n2 || !n2.isBase64)
    return null;
  const e2 = atob(n2.data), r2 = new Uint8Array(e2.length);
  for (let o2 = 0; o2 < e2.length; o2++)
    r2[o2] = e2.charCodeAt(o2);
  return r2.buffer;
}
function Z$4(t2) {
  return btoa(String.fromCharCode.apply(null, t2)).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
}
const tt$2 = /^data:(.*?)(;base64)?,(.*)$/;
function nt$2(t2) {
  const n2 = t2.match(tt$2);
  if (!n2)
    return null;
  const [, e2, r2, o2] = n2;
  return { mediaType: e2, isBase64: !!r2, data: o2 };
}
function et$2(t2) {
  return t2.isBase64 ? `data:${t2.mediaType};base64,${t2.data}` : `data:${t2.mediaType},${t2.data}`;
}
function it$2(t2, n2) {
  ut$2(t2, n2) || ct$2(t2, n2);
}
function ut$2(t2, n2) {
  if (!t2)
    return false;
  const e2 = document.createElement("a");
  if (!("download" in e2))
    return false;
  const r2 = URL.createObjectURL(t2);
  return e2.download = n2, e2.href = r2, e2.style.display = "none", document.body.appendChild(e2), e2.click(), document.body.removeChild(e2), URL.revokeObjectURL(r2), true;
}
function ct$2(t2, n2) {
  return !!window.navigator.msSaveOrOpenBlob && window.navigator.msSaveOrOpenBlob(t2, n2);
}
function ft$2(t2) {
  return t2 != null && t2[0] === "/" && t2[1] === "/";
}
function at$2(t2) {
  return t2 != null && c$1$.test(t2);
}
function ht$2(t2) {
  return t2 != null && a$1U.test(t2) || w$C.scheme === "https" && ft$2(t2);
}
function pt$2(t2) {
  return t2 != null && f$19.test(t2) || w$C.scheme === "http" && ft$2(t2);
}
function dt$2(t2) {
  return t2 != null && h$11.test(t2);
}
function mt$2(t2) {
  return ft$2(t2) ? `https:${t2}` : t2.replace(f$19, "https:");
}
function yt$1() {
  return w$C.scheme === "http";
}
function $t() {
  return w$C.scheme === "https";
}
function xt$1(t2, n2 = false) {
  return ft$2(t2) ? t2.slice(2) : (t2 = t2.replace(c$1$, ""), n2 && t2.length > 1 && t2[0] === "/" && t2[1] === "/" && (t2 = t2.slice(2)), t2);
}
function wt$2(t2) {
  const n2 = t2.indexOf("//"), e2 = t2.indexOf("/", n2 + 2);
  return e2 === -1 ? t2 : t2.slice(0, e2);
}
function Ot(t2) {
  let n2 = 0;
  if (K$7(t2)) {
    const e3 = t2.indexOf("//");
    e3 !== -1 && (n2 = e3 + 2);
  }
  const e2 = t2.lastIndexOf("/");
  return e2 < n2 ? t2 : t2.slice(0, e2 + 1);
}
function Ut(t2, n2) {
  if (!t2)
    return "";
  const e2 = j$B(t2).path.replace(/\/+$/, ""), r2 = e2.substring(e2.lastIndexOf("/") + 1);
  if (!(n2 == null ? void 0 : n2.length))
    return r2;
  const o2 = new RegExp(`.(${n2.join("|")})$`, "ig");
  return r2.replace(o2, "");
}
function bt$1(t2) {
  return t2 && t2[t2.length - 1] === "/" ? t2 : `${t2}/`;
}
function Ct(t2) {
  return t2.replace(/\/+$/, "");
}
function qt(t2) {
  if (/^https?:\/\//i.test(t2)) {
    const n2 = P$k(t2);
    t2 = (t2 = n2.path.replace(/\/{2,}/g, "/")).replace("/", "//"), n2.query && (t2 += `?${n2.query}`);
  }
  return t2;
}
function Rt$1(t2) {
  return t2.replace(/^(https?:\/\/)(arcgis\.com)/i, "$1www.$2");
}
function jt$1(t2) {
  const n2 = u$1l.httpsDomains;
  if (!pt$2(t2))
    return t2;
  const e2 = t2.indexOf("/", 7);
  let r2;
  if (r2 = e2 === -1 ? t2 : t2.slice(0, e2), r2 = r2.toLowerCase().slice(7), p$2b.test(r2)) {
    if (!r2.endsWith(":80"))
      return t2;
    r2 = r2.slice(0, -3), t2 = t2.replace(":80", "");
  }
  return yt$1() && r2 === w$C.authority && !d$1c.test(t2) || ($t() && r2 === w$C.authority || n2 && n2.some((t3) => r2 === t3 || r2.endsWith(`.${t3}`)) || $t() && !J$9(t2)) && (t2 = mt$2(t2)), t2;
}
function Lt(t2, n2, e2) {
  if (!(n2 && e2 && t2 && K$7(t2)))
    return t2;
  const r2 = t2.indexOf("//"), o2 = t2.indexOf("/", r2 + 2), i2 = t2.indexOf(":", r2 + 2), s2 = Math.min(o2 < 0 ? t2.length : o2, i2 < 0 ? t2.length : i2);
  if (t2.slice(r2 + 2, s2).toLowerCase() !== n2.toLowerCase())
    return t2;
  return `${t2.slice(0, r2 + 2)}${e2}${t2.slice(s2)}`;
}
function vt(t2) {
  return typeof t2 == "string" ? new y$12(Q$9(t2)) : (t2.scheme || (t2.scheme = w$C.scheme), t2);
}
function It$1(t2) {
  return Nt.test(t2);
}
function At$1(t2, n2) {
  const e2 = j$B(t2), r2 = Object.keys(e2.query || {});
  return r2.length > 0 && n2 && n2.warn("removeQueryParameters()", `Url query parameters are not supported, the following parameters have been removed: ${r2.join(", ")}.`), e2.path;
}
function St$1(t2, n2, e2) {
  const r2 = j$B(t2), o2 = r2.query || {};
  return o2[n2] = String(e2), `${r2.path}?${I$o(o2)}`;
}
function Bt(t2, n2) {
  const e2 = j$B(t2), r2 = e2.query || {};
  for (const i2 in n2)
    r2[i2] = n2[i2];
  const o2 = I$o(r2);
  return o2 ? `${e2.path}?${o2}` : e2.path;
}
function kt$1(t2) {
  if (t$1W(t2))
    return null;
  const n2 = t2.match(Jt);
  return n2 ? n2[2] : null;
}
function Et(t2) {
  if (t$1W(t2))
    return null;
  const n2 = t2.match(Jt);
  return n2 ? { path: n2[1], extension: n2[2] } : { path: t2, extension: null };
}
const Jt = /([^.]*)\.([^\/]*)$/, Nt = /(^data:image\/svg|\.svg$)/i;
function c$1_(e2, o2) {
  const l2 = o2 && o2.url && o2.url.path;
  if (e2 && l2 && (e2 = Q$9(e2, l2, { preserveProtocolRelative: true }), o2.portalItem && o2.readResourcePaths)) {
    const r2 = _$v(e2, o2.portalItem.itemUrl);
    r2 != null && v$H.test(r2) && o2.readResourcePaths.push(o2.portalItem.resourceFromPath(r2).path);
  }
  return I$n(e2, o2 && o2.portal);
}
function m$1j(e2, n2, a2 = R$j.YES) {
  if (e2 == null)
    return e2;
  !K$7(e2) && n2 && n2.blockedRelativeUrls && n2.blockedRelativeUrls.push(e2);
  let u2 = Q$9(e2);
  if (n2) {
    const r2 = n2.verifyItemRelativeUrls && n2.verifyItemRelativeUrls.rootPath || n2.url && n2.url.path;
    if (r2) {
      const o2 = I$n(r2, n2.portal);
      u2 = _$v(I$n(u2, n2.portal), o2, o2), u2 != null && u2 !== e2 && n2.verifyItemRelativeUrls && n2.verifyItemRelativeUrls.writtenUrls.push(u2);
    }
  }
  return u2 = y$11(u2, n2 == null ? void 0 : n2.portal), K$7(u2) && (u2 = F$g(u2)), (n2 == null ? void 0 : n2.resources) && (n2 == null ? void 0 : n2.portalItem) && !K$7(u2) && !X$6(u2) && a2 === R$j.YES && n2.resources.toKeep.push({ resource: n2.portalItem.resourceFromPath(u2), compress: false }), u2;
}
function p$2a(e2, r2, t2) {
  return c$1_(e2, t2);
}
function f$18(e2, r2, t2, o2) {
  const l2 = m$1j(e2, o2);
  l2 !== void 0 && (r2[t2] = l2);
}
const h$10 = /\/items\/([^\/]+)\/resources\/(.*)/, v$H = /^\.\/resources\//;
function U$l(e2) {
  var _a2, _b2, _c2;
  return (_c2 = (_b2 = (_a2 = e2 == null ? void 0 : e2.match(h$10)) != null ? _a2 : null) == null ? void 0 : _b2[1]) != null ? _c2 : null;
}
function d$1b(r2) {
  var _a2;
  const t2 = (_a2 = r2 == null ? void 0 : r2.match(h$10)) != null ? _a2 : null;
  if (t2 == null)
    return null;
  const o2 = t2[2], l2 = o2.lastIndexOf("/");
  if (l2 === -1) {
    const { path: r3, extension: t3 } = Et(o2);
    return { prefix: null, filename: r3, extension: e$1U(t3) };
  }
  const { path: s2, extension: a2 } = Et(o2.slice(l2 + 1));
  return { prefix: o2.slice(0, l2), filename: s2, extension: e$1U(a2) };
}
function y$11(e2, r2) {
  return r2 && !r2.isPortal && r2.urlKey && r2.customBaseUrl ? Lt(e2, `${r2.urlKey}.${r2.customBaseUrl}`, r2.portalHostname) : e2;
}
function I$n(e2, r2) {
  if (!r2 || r2.isPortal || !r2.urlKey || !r2.customBaseUrl)
    return e2;
  const t2 = `${r2.urlKey}.${r2.customBaseUrl}`, o2 = b$J();
  return z$m(o2, `${o2.scheme}://${t2}`) ? Lt(e2, r2.portalHostname, t2) : Lt(e2, t2, r2.portalHostname);
}
var R$j;
!function(e2) {
  e2[e2.YES = 0] = "YES", e2[e2.NO = 1] = "NO";
}(R$j || (R$j = {}));
const x$w = Object.freeze(Object.defineProperty({ __proto__: null, fromJSON: c$1_, toJSON: m$1j, read: p$2a, write: f$18, itemIdFromResourceUrl: U$l, prefixAndFilenameFromResourceUrl: d$1b, ensureMainOnlineDomain: y$11, get MarkKeep() {
  return R$j;
} }, Symbol.toStringTag, { value: "Module" }));
var l$1r;
const d$1a = o$1w()({ circle: "circle", square: "square", cross: "cross", x: "x", kite: "kite", triangle: "triangle" });
let h$$ = l$1r = class extends l$1_ {
  constructor(r2) {
    super(r2);
  }
  readHref(r2, e2, o2) {
    return r2 ? c$1_(r2, o2) : e2.dataURI;
  }
  writeHref(r2, e2, o2, c2) {
    r2 && (X$6(r2) ? e2.dataURI = r2 : (e2.href = m$1j(r2, c2), K$7(e2.href) && (e2.href = F$g(e2.href))));
  }
  clone() {
    return new l$1r({ href: this.href, primitive: this.primitive });
  }
};
e$1W([y$1o({ type: String, json: { write: true, read: { source: ["href", "dataURI"] } } })], h$$.prototype, "href", void 0), e$1W([o$1H("href")], h$$.prototype, "readHref", null), e$1W([r$1h("href", { href: { type: String }, dataURI: { type: String } })], h$$.prototype, "writeHref", null), e$1W([r$1a(d$1a)], h$$.prototype, "primitive", void 0), h$$ = l$1r = e$1W([n$2f("esri.symbols.support.IconSymbol3DLayerResource")], h$$);
var e$1d;
let p$29 = e$1d = class extends m$1L {
  constructor() {
    super(...arguments), this.x = 0, this.y = 0;
  }
  clone() {
    return new e$1d({ x: this.x, y: this.y });
  }
};
e$1W([y$1o({ type: Number })], p$29.prototype, "x", void 0), e$1W([y$1o({ type: Number })], p$29.prototype, "y", void 0), p$29 = e$1d = e$1W([n$2f("esri.symbols.support.Symbol3DAnchorPosition2D")], p$29);
var l$1q;
let a$1T = l$1q = class extends l$1_ {
  constructor(o2) {
    super(o2), this.color = new l$1D([0, 0, 0, 1]), this.size = e$1h(1);
  }
  clone() {
    const o2 = { color: r$1t(this.color) ? this.color.clone() : null, size: this.size };
    return new l$1q(o2);
  }
};
e$1W([y$1o(p$2m)], a$1T.prototype, "color", void 0), e$1W([y$1o(a$1_)], a$1T.prototype, "size", void 0), a$1T = l$1q = e$1W([n$2f("esri.symbols.support.Symbol3DIconOutline")], a$1T);
var f$17;
const d$19 = "esri.symbols.IconSymbol3DLayer";
let b$I = f$17 = class extends a$1$ {
  constructor(o2) {
    super(o2), this.material = null, this.resource = null, this.type = "icon", this.size = 12, this.anchor = "center", this.anchorPosition = null, this.outline = null;
  }
  clone() {
    return new f$17({ anchor: this.anchor, anchorPosition: this.anchorPosition && this.anchorPosition.clone(), enabled: this.enabled, material: r$1t(this.material) ? this.material.clone() : null, outline: r$1t(this.outline) ? this.outline.clone() : null, resource: this.resource && this.resource.clone(), size: this.size });
  }
  static fromSimpleMarkerSymbol(o2) {
    const t2 = o2.color || o$1g, r2 = j$A(o2), e2 = o2.outline && o2.outline.width > 0 ? { size: o2.outline.width, color: (o2.outline.color || o$1g).clone() } : null;
    return new f$17({ size: o2.size, resource: { primitive: w$B(o2.style) }, material: { color: t2 }, outline: e2, anchor: r2 ? "relative" : void 0, anchorPosition: r2 });
  }
  static fromPictureMarkerSymbol(o2) {
    const t2 = !o2.color || t$1i(o2.color) ? o$1g : o2.color, r2 = j$A(o2);
    return new f$17({ size: o2.width <= o2.height ? o2.height : o2.width, resource: { href: o2.url }, material: { color: t2.clone() }, anchor: r2 ? "relative" : void 0, anchorPosition: r2 });
  }
  static fromCIMSymbol(o2) {
    return new f$17({ resource: { href: et$2({ mediaType: "application/json", data: JSON.stringify(o2.data) }) } });
  }
};
function j$A(o2) {
  const t2 = "width" in o2 ? o2.width : o2.size, r2 = "height" in o2 ? o2.height : o2.size, e2 = g$N(o2.xoffset), i2 = g$N(o2.yoffset);
  return (e2 || i2) && t2 && r2 ? { x: -e2 / t2, y: i2 / r2 } : null;
}
function g$N(o2) {
  return isFinite(o2) ? o2 : 0;
}
e$1W([y$1o({ type: l$1A, json: { write: true } })], b$I.prototype, "material", void 0), e$1W([y$1o({ type: h$$, json: { write: true } })], b$I.prototype, "resource", void 0), e$1W([r$1a({ Icon: "icon" }, { readOnly: true })], b$I.prototype, "type", void 0), e$1W([y$1o(a$1_)], b$I.prototype, "size", void 0), e$1W([r$1a({ center: "center", left: "left", right: "right", top: "top", bottom: "bottom", topLeft: "top-left", topRight: "top-right", bottomLeft: "bottom-left", bottomRight: "bottom-right", relative: "relative" }), y$1o({ json: { default: "center" } })], b$I.prototype, "anchor", void 0), e$1W([y$1o({ type: p$29, json: { type: [Number], read: { reader: (o2) => new p$29({ x: o2[0], y: o2[1] }) }, write: { writer: (o2, t2) => {
  t2.anchorPosition = [o2.x, o2.y];
}, overridePolicy() {
  return { enabled: this.anchor === "relative" };
} } } })], b$I.prototype, "anchorPosition", void 0), e$1W([y$1o({ type: a$1T, json: { write: true } })], b$I.prototype, "outline", void 0), b$I = f$17 = e$1W([n$2f(d$19)], b$I);
const v$G = { circle: "circle", cross: "cross", diamond: "kite", square: "square", x: "x", triangle: "triangle", path: null };
function w$B(o2) {
  const r2 = v$G[o2];
  return r2 || (s$22.getLogger(d$19).warn(`${o2} cannot be mapped to Icon symbol. Fallback to "circle"`), "circle");
}
const S$w = b$I;
function n$1N(n2, t2, i2 = j$F) {
  return t2 || (t2 = new i2()), t2 === n2 || (t2.removeAll(), e$1c(n2) ? t2.addMany(n2) : n2 && t2.add(n2)), t2;
}
function t$1f(r2) {
  return r2;
}
function e$1c(r2) {
  return r2 && (Array.isArray(r2) || "items" in r2 && Array.isArray(r2.items));
}
const e$1b = "20221121", f$16 = "f520630575ed53cf8b49e5f1492799065ee366e5";
const a$1S = "4.25", r$Z = { async request(t2, a2) {
  var _a2, _b2;
  const { default: r2 } = await Promise.resolve().then(function() {
    return request;
  }), s2 = t2.options, n2 = s2.responseType;
  s2.signal = a2 == null ? void 0 : a2.signal, s2.responseType = n2 === "native" || n2 === "native-request-init" ? "native-request-init" : n2 && ["blob", "json", "text"].includes(n2) && ((_a2 = W$9(t2.url)) == null ? void 0 : _a2.after) ? n2 : "array-buffer";
  const o2 = await r2(t2.url, s2), i2 = { data: o2.data, ssl: o2.ssl };
  switch ((_b2 = o2.requestOptions) == null ? void 0 : _b2.responseType) {
    case "native-request-init":
      return delete i2.data.signal, i2;
    case "blob":
      i2.data = await i2.data.arrayBuffer();
      break;
    case "json":
      i2.data = new TextEncoder().encode(JSON.stringify(i2.data)).buffer;
      break;
    case "text":
      i2.data = new TextEncoder().encode(i2.data).buffer;
  }
  return { result: i2, transferList: [i2.data] };
} };
let s$1k;
function n$1M(e2) {
  s$1k = e2;
}
function o$1d(e2) {
  const a2 = s$1k && s$1k.findCredential(e2);
  return a2 && a2.token ? St$1(e2, "token", a2.token) : e2;
}
has("host-webworker");
const e$1a = /^https:\/\/([a-z\d-]+)(\.maps([^.]*))?\.arcgis\.com/i, s$1j = { devext: { customBaseUrl: "mapsdevext.arcgis.com", portalHostname: "devext.arcgis.com" }, qaext: { customBaseUrl: "mapsqa.arcgis.com", portalHostname: "qaext.arcgis.com" }, www: { customBaseUrl: "maps.arcgis.com", portalHostname: "www.arcgis.com" } };
function a$1R(a2) {
  const t2 = a2 == null ? void 0 : a2.match(e$1a);
  if (!t2)
    return null;
  const [, r2, o2, l2] = t2;
  if (!r2)
    return null;
  let c2 = null, m2 = null, n2 = null;
  const { devext: u2, qaext: i2, www: p2 } = s$1j;
  if (o2)
    if (c2 = r2, l2)
      switch (l2.toLowerCase()) {
        case "devext":
          ({ customBaseUrl: m2, portalHostname: n2 } = u2);
          break;
        case "qa":
          ({ customBaseUrl: m2, portalHostname: n2 } = i2);
          break;
        default:
          return null;
      }
    else
      ({ customBaseUrl: m2, portalHostname: n2 } = p2);
  else
    switch (r2.toLowerCase()) {
      case "devext":
        ({ customBaseUrl: m2, portalHostname: n2 } = u2);
        break;
      case "qaext":
        ({ customBaseUrl: m2, portalHostname: n2 } = i2);
        break;
      case "www":
        ({ customBaseUrl: m2, portalHostname: n2 } = p2);
        break;
      default:
        return null;
    }
  return { customBaseUrl: m2, isPortal: false, portalHostname: n2, urlKey: c2 };
}
function t$1e(e2) {
  return /\/(sharing|usrsvcs)\/(appservices|servers)\//i.test(e2);
}
const t$1d = ["elevation3d.arcgis.com", "js.arcgis.com", "jsdev.arcgis.com", "jsqa.arcgis.com", "static.arcgis.com"];
function r$Y(c2) {
  const r2 = H$b(c2, true);
  return !!r2 && (r2.endsWith(".arcgis.com") && !t$1d.includes(r2) && !c2.endsWith("/sharing/rest/generateToken"));
}
function c$1Z(r2, t2, n2 = false, s2) {
  return new Promise((i2, c2) => {
    if (p$2W(s2))
      return void c2(a$1Q());
    let m2 = () => {
      f2(), c2(new Error(`Unable to load ${t2}`));
    }, u2 = () => {
      const e2 = r2;
      f2(), i2(e2);
    }, d2 = () => {
      if (!r2)
        return;
      const e2 = r2;
      f2(), e2.src = "", c2(a$1Q());
    };
    const f2 = () => {
      has("esri-image-decode") || (r2.removeEventListener("error", m2), r2.removeEventListener("load", u2)), m2 = null, u2 = null, r2 = null, r$1t(s2) && s2.removeEventListener("abort", d2), d2 = null, n2 && URL.revokeObjectURL(t2);
    };
    r$1t(s2) && s2.addEventListener("abort", d2), has("esri-image-decode") ? r2.decode().then(u2, m2) : (r2.addEventListener("error", m2), r2.addEventListener("load", u2));
  });
}
function a$1Q() {
  try {
    return new DOMException("Aborted", "AbortError");
  } catch {
    const r2 = new Error();
    return r2.name = "AbortError", r2;
  }
}
function m$1i(e2) {
  var _a2, _b2, _c2;
  s$23.request.crossOriginNoCorsDomains || (s$23.request.crossOriginNoCorsDomains = {});
  const o2 = s$23.request.crossOriginNoCorsDomains;
  for (let r2 of e2)
    r2 = r2.toLowerCase(), /^https?:\/\//.test(r2) ? o2[(_a2 = H$b(r2)) != null ? _a2 : ""] = 0 : (o2[(_b2 = H$b("http://" + r2)) != null ? _b2 : ""] = 0, o2[(_c2 = H$b("https://" + r2)) != null ? _c2 : ""] = 0);
}
function u$1k(e2) {
  const o2 = s$23.request.crossOriginNoCorsDomains;
  if (o2) {
    let r2 = H$b(e2);
    if (r2)
      return r2 = r2.toLowerCase(), !z$m(r2, b$J()) && o2[r2] < Date.now() - 36e5;
  }
  return false;
}
async function d$18(e2) {
  var _a2;
  const o2 = s$23.request.crossOriginNoCorsDomains, n2 = H$b(e2);
  o2 && n2 && (o2[n2.toLowerCase()] = Date.now());
  const s2 = j$B(e2);
  e2 = s2.path, ((_a2 = s2.query) == null ? void 0 : _a2.f) === "json" && (e2 += "?f=json");
  try {
    await fetch(e2, { mode: "no-cors", credentials: "include" });
  } catch {
  }
}
async function U$k(e2, r2) {
  var _a2;
  const t2 = X$6(e2), s2 = V$a(e2);
  s2 || t2 || (e2 = F$g(e2));
  const n2 = { url: e2, requestOptions: __spreadValues({}, e$1U(r2)) };
  let i2 = W$9(e2);
  if (i2) {
    const e3 = await G$b(i2, n2);
    if (e3 != null)
      return { data: e3, getHeader: M$j, requestOptions: n2.requestOptions, url: n2.url };
    i2.after || i2.error || (i2 = null);
  }
  if (e2 = n2.url, (r2 = n2.requestOptions).responseType === "image") {
    if (has("host-webworker") || has("host-node"))
      throw N$b("request:invalid-parameters", new Error("responseType 'image' is not supported in Web Workers or Node environment"), n2);
  } else if (t2)
    throw N$b("request:invalid-parameters", new Error("Data URLs are not supported for responseType = " + r2.responseType), n2);
  if (r2.method === "head") {
    if (r2.body)
      throw N$b("request:invalid-parameters", new Error("body parameter cannot be set when method is 'head'"), n2);
    if (t2 || s2)
      throw N$b("request:invalid-parameters", new Error("data and blob URLs are not supported for method 'head'"), n2);
  }
  if (await B$e(), j$z)
    return j$z.execute(e2, r2);
  const l2 = new AbortController();
  v$S(r2, () => l2.abort());
  const m2 = { controller: l2, credential: void 0, credentialToken: void 0, fetchOptions: void 0, hasToken: false, interceptor: i2, params: n2, redoRequest: false, useIdentity: P$j.useIdentity, useProxy: false, useSSL: false, withCredentials: false }, h2 = await Q$8(m2);
  return (_a2 = i2 == null ? void 0 : i2.after) == null ? void 0 : _a2.call(i2, h2), h2;
}
let j$z;
const P$j = s$23.request, D$g = "FormData" in globalThis, _$u = [499, 498, 403, 401], F$f = ["COM_0056", "COM_0057", "SB_0008"], I$m = [/\/arcgis\/tokens/i, /\/sharing(\/rest)?\/generatetoken/i, /\/rest\/info/i], M$j = () => null, R$i = Symbol();
function A$g(e2) {
  const r2 = H$b(e2);
  r2 && !U$k._corsServers.includes(r2) && U$k._corsServers.push(r2);
}
function H$a(e2) {
  const r2 = H$b(e2);
  return !r2 || r2.endsWith(".arcgis.com") || U$k._corsServers.includes(r2) || D$h(r2);
}
function N$b(e2, r2, o2, a2) {
  let l2 = "Error";
  const u2 = { url: o2.url, requestOptions: o2.requestOptions, getHeader: M$j, ssl: false };
  if (r2 instanceof s$1Z)
    return r2.details ? (r2.details = y$1r(r2.details), r2.details.url = o2.url, r2.details.requestOptions = o2.requestOptions) : r2.details = u2, r2;
  if (r2) {
    const e3 = a2 && ((e4) => a2.headers.get(e4)), t2 = a2 && a2.status, s2 = r2.message;
    s2 && (l2 = s2), e3 && (u2.getHeader = e3), u2.httpStatus = (r2.httpCode != null ? r2.httpCode : r2.code) || t2 || 0, u2.subCode = r2.subcode, u2.messageCode = r2.messageCode, typeof r2.details == "string" ? u2.messages = [r2.details] : u2.messages = r2.details, u2.raw = R$i in r2 ? r2[R$i] : r2;
  }
  return j$K(r2) ? a$2p() : new s$1Z(e2, l2, u2);
}
async function B$e() {
  has("host-webworker") ? j$z || (j$z = await import("./request.js")) : U$k._abortableFetch || (U$k._abortableFetch = globalThis.fetch.bind(globalThis));
}
async function $$b() {
  s$1k || await import("./IdentityManager.js");
}
async function z$l(t2) {
  var _a2;
  const s2 = t2.params.url, o2 = t2.params.requestOptions, a2 = t2.controller.signal, n2 = o2.body;
  let i2 = null, u2 = null;
  if (D$g && "HTMLFormElement" in globalThis && (n2 instanceof FormData ? i2 = n2 : n2 instanceof HTMLFormElement && (i2 = new FormData(n2))), typeof n2 == "string" && (u2 = n2), t2.fetchOptions = { cache: o2.cacheBust && !U$k._abortableFetch.polyfill ? "no-cache" : "default", credentials: "same-origin", headers: o2.headers || {}, method: o2.method === "head" ? "HEAD" : "GET", mode: "cors", priority: P$j.priority, redirect: "follow", signal: a2 }, (i2 || u2) && (t2.fetchOptions.body = i2 || u2), o2.authMode === "anonymous" && (t2.useIdentity = false), t2.hasToken = !!(/token=/i.test(s2) || ((_a2 = o2.query) == null ? void 0 : _a2.token) || (i2 == null ? void 0 : i2.get("token"))), !t2.hasToken && s$23.apiKey && r$Y(s2) && (o2.query || (o2.query = {}), o2.query.token = s$23.apiKey, t2.hasToken = true), t2.useIdentity && !t2.hasToken && !t2.credentialToken && !K$6(s2) && !p$2W(a2)) {
    let e2;
    o2.authMode === "immediate" ? (await $$b(), e2 = await s$1k.getCredential(s2, { signal: a2 }), t2.credential = e2) : o2.authMode === "no-prompt" ? (await $$b(), e2 = await s$1k.getCredential(s2, { prompt: false, signal: a2 }).catch(() => {
    }), t2.credential = e2) : s$1k && (e2 = s$1k.findCredential(s2)), e2 && (t2.credentialToken = e2.token, t2.useSSL = !!e2.ssl);
  }
}
function K$6(e2) {
  return I$m.some((r2) => r2.test(e2));
}
async function W$8(e2) {
  var _a2, _b2;
  let t2 = e2.params.url;
  const s2 = e2.params.requestOptions, o2 = (_a2 = e2.fetchOptions) != null ? _a2 : {}, a2 = V$a(t2) || X$6(t2), n2 = s2.responseType || "json", l2 = a2 ? 0 : s2.timeout != null ? s2.timeout : P$j.timeout;
  let d2 = false;
  if (!a2) {
    e2.useSSL && (t2 = mt$2(t2)), s2.cacheBust && o2.cache === "default" && (t2 = St$1(t2, "request.preventCache", Date.now()));
    let a3 = __spreadValues({}, s2.query);
    e2.credentialToken && (a3.token = e2.credentialToken);
    let n3 = I$o(a3);
    has("esri-url-encodes-apostrophe") && (n3 = n3.replace(/'/g, "%27"));
    const i2 = t2.length + 1 + n3.length;
    let l3;
    d2 = s2.method === "delete" || s2.method === "post" || s2.method === "put" || !!s2.body || i2 > P$j.maxUrlLength;
    const u2 = s2.useProxy || !!J$9(t2);
    if (u2) {
      const e3 = A$h(t2);
      l3 = e3.path, !d2 && l3.length + 1 + i2 > P$j.maxUrlLength && (d2 = true), e3.query && (a3 = __spreadValues(__spreadValues({}, e3.query), a3));
    }
    if (o2.method === "HEAD" && (d2 || u2)) {
      if (d2) {
        if (i2 > P$j.maxUrlLength)
          throw N$b("request:invalid-parameters", new Error("URL exceeds maximum length"), e2.params);
        throw N$b("request:invalid-parameters", new Error("cannot use POST request when method is 'head'"), e2.params);
      }
      if (u2)
        throw N$b("request:invalid-parameters", new Error("cannot use proxy when method is 'head'"), e2.params);
    }
    if (d2 ? (o2.method = s2.method === "delete" ? "DELETE" : s2.method === "put" ? "PUT" : "POST", s2.body ? t2 = Bt(t2, a3) : (o2.body = I$o(a3), o2.headers || (o2.headers = {}), o2.headers["Content-Type"] = "application/x-www-form-urlencoded")) : t2 = Bt(t2, a3), u2 && (e2.useProxy = true, t2 = `${l3}?${t2}`), a3.token && D$g && o2.body instanceof FormData && !t$1e(t2) && o2.body.set("token", a3.token), s2.hasOwnProperty("withCredentials"))
      e2.withCredentials = s2.withCredentials;
    else if (!z$m(t2, b$J())) {
      if (D$h(t2))
        e2.withCredentials = true;
      else if (s$1k) {
        const s3 = s$1k.findServerInfo(t2);
        s3 && s3.webTierAuth && (e2.withCredentials = true);
      }
    }
    e2.withCredentials && (o2.credentials = "include", u$1k(t2) && await d$18(d2 ? Bt(t2, a3) : t2));
  }
  let p2, v2, C2 = 0, L2 = false;
  l2 > 0 && (C2 = setTimeout(() => {
    L2 = true, e2.controller.abort();
  }, l2));
  try {
    if (s2.responseType === "native-request-init")
      v2 = o2, v2.url = t2;
    else if (s2.responseType !== "image" || o2.cache !== "default" || o2.method !== "GET" || d2 || J$8(s2.headers) || !a2 && !e2.useProxy && P$j.proxyUrl && !H$a(t2)) {
      if (p2 = await U$k._abortableFetch(t2, o2), e2.useProxy || A$g(t2), s2.responseType === "native")
        v2 = p2;
      else if (o2.method !== "HEAD")
        if (p2.ok) {
          switch (n2) {
            case "array-buffer":
              v2 = await p2.arrayBuffer();
              break;
            case "blob":
            case "image":
              v2 = await p2.blob();
              break;
            default:
              v2 = await p2.text();
          }
          if (C2 && (clearTimeout(C2), C2 = 0), n2 === "json" || n2 === "xml" || n2 === "document")
            if (v2)
              switch (n2) {
                case "json":
                  v2 = JSON.parse(v2);
                  break;
                case "xml":
                  v2 = X$5(v2, "application/xml");
                  break;
                case "document":
                  v2 = X$5(v2, "text/html");
              }
            else
              v2 = null;
          if (v2) {
            if (n2 === "array-buffer" || n2 === "blob") {
              const e3 = p2.headers.get("Content-Type");
              if (e3 && /application\/json|text\/plain/i.test(e3) && v2[n2 === "blob" ? "size" : "byteLength"] <= 750)
                try {
                  const e4 = await new Response(v2).json();
                  e4.error && (v2 = e4);
                } catch {
                }
            }
            n2 === "image" && v2 instanceof Blob && (v2 = await Y$6(URL.createObjectURL(v2), e2, true));
          }
        } else
          v2 = await p2.text();
    } else
      v2 = await Y$6(t2, e2);
  } catch (j2) {
    if (j2.name === "AbortError") {
      if (L2)
        throw new Error("Timeout exceeded");
      throw a$2p("Request canceled");
    }
    if (!(!p2 && j2 instanceof TypeError && P$j.proxyUrl) || s2.body || s2.method === "delete" || s2.method === "head" || s2.method === "post" || s2.method === "put" || e2.useProxy || H$a(t2))
      throw j2;
    e2.redoRequest = true, E$m({ proxyUrl: P$j.proxyUrl, urlPrefix: (_b2 = H$b(t2)) != null ? _b2 : "" });
  } finally {
    C2 && clearTimeout(C2);
  }
  return [p2, v2];
}
async function G$b(e2, r2) {
  if (e2.responseData != null)
    return e2.responseData;
  if (e2.headers && (r2.requestOptions.headers = __spreadValues(__spreadValues({}, r2.requestOptions.headers), e2.headers)), e2.query && (r2.requestOptions.query = __spreadValues(__spreadValues({}, r2.requestOptions.query), e2.query)), e2.before) {
    let o2, a2;
    try {
      a2 = await e2.before(r2);
    } catch (s2) {
      o2 = N$b("request:interceptor", s2, r2);
    }
    if ((a2 instanceof Error || a2 instanceof s$1Z) && (o2 = N$b("request:interceptor", a2, r2)), o2)
      throw e2.error && e2.error(o2), o2;
    return a2;
  }
}
function J$8(e2) {
  if (e2) {
    for (const r2 of Object.getOwnPropertyNames(e2))
      if (e2[r2])
        return true;
  }
  return false;
}
function X$5(e2, r2) {
  let t2;
  try {
    t2 = new DOMParser().parseFromString(e2, r2);
  } catch {
  }
  if (!t2 || t2.getElementsByTagName("parsererror").length)
    throw new SyntaxError("XML Parse error");
  return t2;
}
async function Q$8(e2) {
  var _a2;
  let t2, s2;
  await z$l(e2);
  try {
    do {
      [t2, s2] = await W$8(e2);
    } while (!await V$9(e2, t2, s2));
  } catch (n2) {
    const r2 = N$b("request:server", n2, e2.params, t2);
    throw r2.details.ssl = e2.useSSL, e2.interceptor && e2.interceptor.error && e2.interceptor.error(r2), r2;
  }
  const o2 = e2.params.url;
  if (s2 && /\/sharing\/rest\/(accounts|portals)\/self/i.test(o2)) {
    if (!e2.hasToken && !e2.credentialToken && ((_a2 = s2.user) == null ? void 0 : _a2.username) && !D$h(o2)) {
      const e3 = H$b(o2, true);
      e3 && P$j.trustedServers.push(e3);
    }
    Array.isArray(s2.authorizedCrossOriginNoCorsDomains) && m$1i(s2.authorizedCrossOriginNoCorsDomains);
  }
  const a2 = e2.credential;
  if (a2 && s$1k) {
    const e3 = s$1k.findServerInfo(a2.server);
    let t3 = e3 && e3.owningSystemUrl;
    if (t3) {
      t3 = t3.replace(/\/?$/, "/sharing");
      const e4 = s$1k.findCredential(t3, a2.userId);
      e4 && s$1k._getIdenticalSvcIdx(t3, e4) === -1 && e4.resources.unshift(t3);
    }
  }
  return { data: s2, getHeader: t2 ? (e3) => t2 == null ? void 0 : t2.headers.get(e3) : M$j, requestOptions: e2.params.requestOptions, ssl: e2.useSSL, url: e2.params.url };
}
async function V$9(e2, t2, s2) {
  if (e2.redoRequest)
    return e2.redoRequest = false, false;
  const o2 = e2.params.requestOptions;
  if (!t2 || o2.responseType === "native" || o2.responseType === "native-request-init")
    return true;
  let a2, n2;
  if (!t2.ok)
    throw a2 = new Error(`Unable to load ${t2.url} status: ${t2.status}`), a2[R$i] = s2, a2;
  s2 && (s2.error ? a2 = s2.error : s2.status === "error" && Array.isArray(s2.messages) && (a2 = __spreadValues({}, s2), a2[R$i] = s2, a2.details = s2.messages));
  let i2, l2 = null;
  a2 && (n2 = Number(a2.code), l2 = a2.hasOwnProperty("subcode") ? Number(a2.subcode) : null, i2 = a2.messageCode, i2 = i2 && i2.toUpperCase());
  const u2 = o2.authMode;
  if (n2 === 403 && (l2 === 4 || a2.message && a2.message.toLowerCase().includes("ssl") && !a2.message.toLowerCase().includes("permission"))) {
    if (!e2.useSSL)
      return e2.useSSL = true, false;
  } else if (!e2.hasToken && e2.useIdentity && (u2 !== "no-prompt" || n2 === 498) && n2 !== void 0 && _$u.includes(n2) && !K$6(e2.params.url) && (n2 !== 403 || i2 && !F$f.includes(i2) && (l2 == null || l2 === 2 && e2.credentialToken))) {
    await $$b();
    try {
      const t3 = await s$1k.getCredential(e2.params.url, { error: N$b("request:server", a2, e2.params), prompt: u2 !== "no-prompt", signal: e2.controller.signal, token: e2.credentialToken });
      return e2.credential = t3, e2.credentialToken = t3.token, e2.useSSL = e2.useSSL || t3.ssl, false;
    } catch (c2) {
      if (u2 === "no-prompt")
        return e2.credential = void 0, e2.credentialToken = void 0, false;
      a2 = c2;
    }
  }
  if (a2)
    throw a2;
  return true;
}
function Y$6(e2, r2, t2 = false) {
  const s2 = r2.controller.signal, o2 = new Image();
  return r2.withCredentials ? o2.crossOrigin = "use-credentials" : o2.crossOrigin = "anonymous", o2.alt = "", o2.fetchPriority = P$j.priority, o2.src = e2, c$1Z(o2, e2, t2, s2);
}
U$k._abortableFetch = null, U$k._corsServers = ["https://server.arcgisonline.com", "https://services.arcgisonline.com"];
var request = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": U$k
});
var h$_;
!function(s2) {
  s2[s2.PENDING = 0] = "PENDING", s2[s2.RESOLVED = 1] = "RESOLVED", s2[s2.REJECTED = 2] = "REJECTED";
}(h$_ || (h$_ = {}));
class n$1L {
  constructor(s2) {
    this.instance = s2, this._resolver = A$p(), this._status = h$_.PENDING, this._resolvingPromises = [], this._resolver.promise.then(() => {
      this._status = h$_.RESOLVED, this._cleanUp();
    }, () => {
      this._status = h$_.REJECTED, this._cleanUp();
    });
  }
  addResolvingPromise(s2) {
    this._resolvingPromises.push(s2), this._tryResolve();
  }
  isResolved() {
    return this._status === h$_.RESOLVED;
  }
  isRejected() {
    return this._status === h$_.REJECTED;
  }
  isFulfilled() {
    return this._status !== h$_.PENDING;
  }
  abort() {
    this._resolver.reject(a$2p());
  }
  when(s2, e2) {
    return this._resolver.promise.then(s2, e2);
  }
  _cleanUp() {
    this._allPromise = this._resolvingPromises = this._allPromise = null;
  }
  _tryResolve() {
    if (this.isFulfilled())
      return;
    const s2 = A$p(), e2 = [...this._resolvingPromises, x$N(s2.promise)], t2 = this._allPromise = Promise.all(e2);
    t2.then(() => {
      this.isFulfilled() || this._allPromise !== t2 || this._resolver.resolve(this.instance);
    }, (s3) => {
      this.isFulfilled() || this._allPromise !== t2 || j$K(s3) || this._resolver.reject(s3);
    }), s2.resolve();
  }
}
const m$1h = (e2) => {
  let i2 = class extends e2 {
    constructor(...s2) {
      super(...s2), this._promiseProps = new n$1L(this), this.addResolvingPromise(Promise.resolve());
    }
    isResolved() {
      return this._promiseProps.isResolved();
    }
    isRejected() {
      return this._promiseProps.isRejected();
    }
    isFulfilled() {
      return this._promiseProps.isFulfilled();
    }
    when(s2, e3) {
      return new Promise((s3, e4) => {
        this._promiseProps.when(s3, e4);
      }).then(s2, e3);
    }
    catch(s2) {
      return this.when(null, s2);
    }
    addResolvingPromise(s2) {
      s2 && !this._promiseProps.isFulfilled() && this._promiseProps.addResolvingPromise("_promiseProps" in s2 ? s2.when() : s2);
    }
  };
  return i2 = e$1W([n$2f("esri.core.Promise")], i2), i2;
};
let _$t = class extends m$1h(m$1L) {
};
_$t = e$1W([n$2f("esri.core.Promise")], _$t);
const i$1J = "not-loaded", d$17 = "loading", c$1Y = "failed", h$Z = "loaded", u$1j = (s2) => {
  let u2 = class extends s2 {
    constructor(...o2) {
      super(...o2), this._loadController = null, this.loadError = null, this.loadStatus = "not-loaded", this._set("loadWarnings", []), this.addResolvingPromise(new Promise((o3) => {
        const s3 = this.load.bind(this);
        this.load = (l2) => {
          const a2 = new Promise((o4, s4) => {
            const e2 = d$1x(l2, s4);
            this.destroyed && s4(new s$1Z("load:instance-destroyed", `Instance of '${this.declaredClass || this.constructor.name}' is already destroyed`, { instance: this })), this._promiseProps.when(o4, s4).finally(() => {
              e2 && e2.remove();
            });
          });
          if (this.loadStatus === i$1J) {
            this._set("loadStatus", d$17);
            const o4 = this._loadController = new AbortController();
            s3({ signal: o4.signal }), v$S(o4.signal, () => {
              this._promiseProps.abort();
            });
          }
          return o3(), a2;
        };
      })), this.when(() => {
        this._set("loadStatus", h$Z), this._loadController = null;
      }, (o3) => {
        this._set("loadStatus", c$1Y), this._set("loadError", o3), this._loadController = null;
      });
    }
    get loaded() {
      return this.loadStatus === h$Z;
    }
    get loadWarnings() {
      return this._get("loadWarnings");
    }
    load() {
      return null;
    }
    cancelLoad() {
      var _a2;
      return this.isFulfilled() || (this._set("loadError", new s$1Z("load:cancelled", "Cancelled")), (_a2 = this._loadController) == null ? void 0 : _a2.abort()), this;
    }
  };
  return e$1W([y$1o({ readOnly: true })], u2.prototype, "loaded", null), e$1W([y$1o({ readOnly: true })], u2.prototype, "loadError", void 0), e$1W([y$1o({ clonable: false })], u2.prototype, "loadStatus", void 0), e$1W([y$1o({ type: [t$1Q], readOnly: true })], u2.prototype, "loadWarnings", null), u2 = e$1W([n$2f("esri.core.Loadable")], u2), u2;
};
let p$28 = class extends u$1j(_$t) {
};
p$28 = e$1W([n$2f("esri.core.Loadable")], p$28), function(o2) {
  function t2(o3) {
    return !(!o3 || !o3.load);
  }
  o2.LoadableMixin = u$1j, o2.isLoadable = t2;
}(p$28 || (p$28 = {}));
const m$1g = p$28;
var u$1i;
const m$1f = new s$1F({ avgRating: "avg-rating", numRatings: "num-ratings", numComments: "num-comments", numViews: "num-views" });
let c$1X = u$1i = class extends m$1L {
  constructor(t2) {
    super(t2), this.categories = null, this.disableExtraQuery = false, this.extent = null, this.filter = null, this.num = 10, this.query = null, this.sortField = null, this.start = 1;
  }
  get sortOrder() {
    return this._get("sortOrder") || "asc";
  }
  set sortOrder(t2) {
    t2 !== "asc" && t2 !== "desc" || this._set("sortOrder", t2);
  }
  clone() {
    return new u$1i({ categories: this.categories ? y$1r(this.categories) : null, disableExtraQuery: this.disableExtraQuery, extent: this.extent ? this.extent.clone() : null, filter: this.filter, num: this.num, query: this.query, sortField: this.sortField, sortOrder: this.sortOrder, start: this.start });
  }
  toRequestOptions(t2, r2) {
    let e2, s2;
    if (this.categories && (e2 = this.categories.map((t3) => Array.isArray(t3) ? JSON.stringify(t3) : t3)), this.extent) {
      const t3 = M$s(this.extent, k$p.WGS84);
      r$1t(t3) && (s2 = `${t3.xmin},${t3.ymin},${t3.xmax},${t3.ymax}`);
    }
    let i2 = this.query;
    !this.disableExtraQuery && t2.extraQuery && (i2 = "(" + i2 + ")" + t2.extraQuery);
    const a2 = { categories: e2, bbox: s2, q: i2, filter: this.filter, num: this.num, sortField: null, sortOrder: null, start: this.start };
    return this.sortField && (a2.sortField = this.sortField.split(",").map((t3) => m$1f.toJSON(t3.trim())).join(","), a2.sortOrder = this.sortOrder), { query: __spreadValues(__spreadValues({}, r2), a2) };
  }
};
e$1W([y$1o()], c$1X.prototype, "categories", void 0), e$1W([y$1o()], c$1X.prototype, "disableExtraQuery", void 0), e$1W([y$1o({ type: w$J })], c$1X.prototype, "extent", void 0), e$1W([y$1o()], c$1X.prototype, "filter", void 0), e$1W([y$1o()], c$1X.prototype, "num", void 0), e$1W([y$1o()], c$1X.prototype, "query", void 0), e$1W([y$1o()], c$1X.prototype, "sortField", void 0), e$1W([y$1o()], c$1X.prototype, "sortOrder", null), e$1W([y$1o()], c$1X.prototype, "start", void 0), c$1X = u$1i = e$1W([n$2f("esri.portal.PortalQueryParams")], c$1X);
const d$16 = c$1X;
let e$19 = class extends m$1L {
  constructor(r2) {
    super(r2), this.nextQueryParams = null, this.queryParams = null, this.results = null, this.total = null;
  }
};
e$1W([y$1o()], e$19.prototype, "nextQueryParams", void 0), e$1W([y$1o()], e$19.prototype, "queryParams", void 0), e$1W([y$1o()], e$19.prototype, "results", void 0), e$1W([y$1o()], e$19.prototype, "total", void 0), e$19 = e$1W([n$2f("esri.portal.PortalQueryResult")], e$19);
const p$27 = e$19;
let p$26 = class extends l$1_ {
  constructor(t2) {
    super(t2), this.created = null, this.id = null, this.portal = null, this.title = null, this.username = null;
  }
  get url() {
    const t2 = this.get("portal.restUrl");
    return t2 ? `${t2}/content/users/${this.username}/${this.id}` : null;
  }
  toJSON() {
    throw new s$1Z("internal:not-yet-implemented", "PortalFolder.toJSON is not yet implemented");
  }
};
e$1W([y$1o({ type: Date })], p$26.prototype, "created", void 0), e$1W([y$1o()], p$26.prototype, "id", void 0), e$1W([y$1o()], p$26.prototype, "portal", void 0), e$1W([y$1o()], p$26.prototype, "title", void 0), e$1W([y$1o({ readOnly: true })], p$26.prototype, "url", null), e$1W([y$1o()], p$26.prototype, "username", void 0), p$26 = e$1W([n$2f("esri.portal.PortalFolder")], p$26);
const l$1p = p$26;
let u$1h = class extends l$1_ {
  constructor(t2) {
    super(t2), this.access = null, this.created = null, this.description = null, this.id = null, this.isInvitationOnly = false, this.modified = null, this.owner = null, this.portal = null, this.snippet = null, this.sortField = null, this.sortOrder = null, this.tags = null, this.title = null;
  }
  get thumbnailUrl() {
    var _a2;
    const t2 = this.url, r2 = this.thumbnail;
    return t2 && r2 && this.portal ? (_a2 = this.portal) == null ? void 0 : _a2._normalizeUrl(`${t2}/info/${r2}?f=json`) : null;
  }
  get url() {
    const t2 = this.get("portal.restUrl");
    return t2 ? t2 + "/community/groups/" + this.id : null;
  }
  fetchCategorySchema(t2) {
    return f$1F(this.portal)._request(this.url + "/categorySchema", t2).then((r2) => {
      const e2 = r2.categorySchema || [];
      return e2.some((t3) => t3.source === "contentCategorySetsGroupQuery.LivingAtlas") ? this._fetchCategorySchemaSet("LivingAtlas", t2) : e2;
    });
  }
  fetchMembers(t2) {
    return f$1F(this.portal)._request(this.url + "/users", t2);
  }
  getThumbnailUrl(t2) {
    let r2 = this.thumbnailUrl;
    return r2 && t2 && (r2 += `&w=${t2}`), r2;
  }
  toJSON() {
    throw new s$1Z("internal:not-yet-implemented", "PortalGroup.toJSON is not yet implemented");
  }
  queryItems(t2, r2) {
    let e2 = b$U(d$16, t2);
    const s2 = f$1F(this.portal);
    return parseFloat(s2.currentVersion) > 5 ? (e2 = e2 || new d$16(), s2._queryPortal(`/content/groups/${this.id}/search`, e2, "PortalItem", r2)) : (e2 = e2 ? e2.clone() : new d$16(), e2.query = "group:" + this.id + (e2.query ? " " + e2.query : ""), s2.queryItems(e2, r2));
  }
  _fetchCategorySchemaSet(t2, e2) {
    const s2 = f$1F(this.portal);
    return s2._fetchSelf(s2.authMode, true, e2).then((t3) => {
      const o2 = t3.contentCategorySetsGroupQuery;
      if (o2) {
        const t4 = new d$16();
        return t4.disableExtraQuery = true, t4.num = 1, t4.query = o2, s2.queryGroups(t4, e2);
      }
      throw new s$1Z("portal-group:fetchCategorySchema", "contentCategorySetsGroupQuery value not found");
    }).then((o2) => {
      if (o2.total) {
        const r2 = o2.results[0], s3 = new d$16();
        return s3.num = 1, s3.query = `typekeywords:"${t2}"`, r2.queryItems(s3, e2);
      }
      throw new s$1Z("portal-group:fetchCategorySchema", "contentCategorySetsGroupQuery group not found");
    }).then((t3) => {
      if (t3.total) {
        return t3.results[0].fetchData("json", e2).then((t4) => {
          const r2 = t4 && t4.categorySchema;
          return r2 && r2.length ? r2 : [];
        });
      }
      return [];
    });
  }
};
e$1W([y$1o()], u$1h.prototype, "access", void 0), e$1W([y$1o({ type: Date })], u$1h.prototype, "created", void 0), e$1W([y$1o()], u$1h.prototype, "description", void 0), e$1W([y$1o()], u$1h.prototype, "id", void 0), e$1W([y$1o()], u$1h.prototype, "isInvitationOnly", void 0), e$1W([y$1o({ type: Date })], u$1h.prototype, "modified", void 0), e$1W([y$1o()], u$1h.prototype, "owner", void 0), e$1W([y$1o()], u$1h.prototype, "portal", void 0), e$1W([y$1o()], u$1h.prototype, "snippet", void 0), e$1W([y$1o()], u$1h.prototype, "sortField", void 0), e$1W([y$1o()], u$1h.prototype, "sortOrder", void 0), e$1W([y$1o()], u$1h.prototype, "tags", void 0), e$1W([y$1o()], u$1h.prototype, "thumbnail", void 0), e$1W([y$1o({ readOnly: true })], u$1h.prototype, "thumbnailUrl", null), e$1W([y$1o()], u$1h.prototype, "title", void 0), e$1W([y$1o({ readOnly: true })], u$1h.prototype, "url", null), u$1h = e$1W([n$2f("esri.portal.PortalGroup")], u$1h);
const p$25 = u$1h;
var PortalGroup = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": p$25
});
var i$1I;
let u$1g = i$1I = class extends l$1_ {
  constructor(...t2) {
    super(...t2), this.access = null, this.created = null, this.culture = null, this.description = null, this.email = null, this.fullName = null, this.modified = null, this.orgId = null, this.portal = null, this.preferredView = null, this.privileges = null, this.region = null, this.role = null, this.roleId = null, this.sourceJSON = null, this.units = null, this.username = null, this.userType = null;
  }
  get thumbnailUrl() {
    const t2 = this.url, r2 = this.thumbnail;
    return t2 && r2 ? this.portal._normalizeUrl(`${t2}/info/${r2}?f=json`) : null;
  }
  get userContentUrl() {
    const t2 = this.get("portal.restUrl");
    return t2 ? `${t2}/content/users/${this.username}` : null;
  }
  get url() {
    const t2 = this.get("portal.restUrl");
    return t2 ? `${t2}/community/users/${this.username}` : null;
  }
  addItem(t2) {
    const r2 = t2 && t2.item, e2 = t2 && t2.data, o2 = t2 && t2.folder, l2 = { method: "post" };
    r2 && (l2.query = r2.createPostQuery(), e2 != null && (typeof e2 == "string" ? l2.query.text = e2 : typeof e2 == "object" && (l2.query.text = JSON.stringify(e2))));
    let s2 = this.userContentUrl;
    return o2 && (s2 += "/" + (typeof o2 == "string" ? o2 : o2.id)), this.portal._request(s2 + "/addItem", l2).then((t3) => (r2.id = t3.id, r2.portal = this.portal, r2.loaded ? r2.reload() : r2.load()));
  }
  deleteItem(t2) {
    let r2 = this.userContentUrl;
    return t2.ownerFolder && (r2 += "/" + t2.ownerFolder), this.portal._request(r2 + `/items/${t2.id}/delete`, { method: "post" }).then(() => {
      t2.id = null, t2.portal = null;
    });
  }
  deleteItems(t2) {
    const r2 = this.userContentUrl + "/deleteItems", e2 = t2.map((t3) => t3.id);
    if (e2.length) {
      const o2 = { method: "post", query: { items: e2.join(",") } };
      return this.portal._request(r2, o2).then(() => {
        t2.forEach((t3) => {
          t3.id = null, t3.portal = null;
        });
      });
    }
    return Promise.resolve(void 0);
  }
  fetchFolders() {
    var _a2;
    const t2 = { query: { num: 1 } };
    return this.portal._request((_a2 = this.userContentUrl) != null ? _a2 : "", t2).then((t3) => {
      let r2;
      return r2 = t3 && t3.folders ? t3.folders.map((t4) => {
        const r3 = l$1p.fromJSON(t4);
        return r3.portal = this.portal, r3;
      }) : [], r2;
    });
  }
  fetchGroups() {
    var _a2;
    return this.portal._request((_a2 = this.url) != null ? _a2 : "").then((t2) => {
      let r2;
      return r2 = t2 && t2.groups ? t2.groups.map((t3) => {
        const r3 = p$25.fromJSON(t3);
        return r3.portal = this.portal, r3;
      }) : [], r2;
    });
  }
  fetchItems(t2) {
    var _a2;
    const r2 = t2 != null ? t2 : {};
    let e2, o2 = (_a2 = this.userContentUrl) != null ? _a2 : "";
    return r2.folder && (o2 += "/" + r2.folder.id), Promise.resolve().then(function() {
      return PortalItem;
    }).then(({ default: t3 }) => {
      e2 = t3;
      const l2 = { folders: false, num: r2.num || 10, start: r2.start || 1, sortField: r2.sortField || "created", sortOrder: r2.sortOrder || "asc" };
      return this.portal._request(o2, { query: l2 });
    }).then((t3) => {
      let r3;
      return t3 && t3.items ? (r3 = t3.items.map((t4) => {
        const r4 = e2.fromJSON(t4);
        return r4.portal = this.portal, r4;
      }), Promise.all(r3.map((t4) => t4.load())).catch((t4) => t4).then(() => ({ items: r3, nextStart: t3.nextStart, total: t3.total }))) : { items: [], nextStart: -1, total: 0 };
    });
  }
  fetchTags() {
    return this.portal._request(this.url + "/tags").then((t2) => t2.tags);
  }
  getThumbnailUrl(t2) {
    let r2 = this.thumbnailUrl;
    return r2 && t2 && (r2 += `&w=${t2}`), r2;
  }
  queryFavorites(t2) {
    return this.favGroupId ? (this._favGroup || (this._favGroup = new p$25({ id: this.favGroupId, portal: this.portal })), this._favGroup.queryItems(t2)) : Promise.reject(new s$1Z("internal:unknown", "Unknown internal error", { internalError: "Unknown favGroupId" }));
  }
  toJSON() {
    throw new s$1Z("internal:not-yet-implemented", "PortalGroup.toJSON is not yet implemented");
  }
  static fromJSON(t2) {
    if (!t2)
      return null;
    if (t2.declaredClass)
      throw new Error("JSON object is already hydrated");
    const r2 = new i$1I();
    return r2.sourceJSON = t2, r2.read(t2), r2;
  }
};
e$1W([y$1o()], u$1g.prototype, "access", void 0), e$1W([y$1o({ type: Date })], u$1g.prototype, "created", void 0), e$1W([y$1o()], u$1g.prototype, "culture", void 0), e$1W([y$1o()], u$1g.prototype, "description", void 0), e$1W([y$1o()], u$1g.prototype, "email", void 0), e$1W([y$1o()], u$1g.prototype, "favGroupId", void 0), e$1W([y$1o()], u$1g.prototype, "fullName", void 0), e$1W([y$1o({ type: Date })], u$1g.prototype, "modified", void 0), e$1W([y$1o()], u$1g.prototype, "orgId", void 0), e$1W([y$1o()], u$1g.prototype, "portal", void 0), e$1W([y$1o()], u$1g.prototype, "preferredView", void 0), e$1W([y$1o()], u$1g.prototype, "privileges", void 0), e$1W([y$1o()], u$1g.prototype, "region", void 0), e$1W([y$1o()], u$1g.prototype, "role", void 0), e$1W([y$1o()], u$1g.prototype, "roleId", void 0), e$1W([y$1o()], u$1g.prototype, "sourceJSON", void 0), e$1W([y$1o()], u$1g.prototype, "thumbnail", void 0), e$1W([y$1o({ readOnly: true })], u$1g.prototype, "thumbnailUrl", null), e$1W([y$1o()], u$1g.prototype, "units", void 0), e$1W([y$1o({ readOnly: true })], u$1g.prototype, "userContentUrl", null), e$1W([y$1o({ readOnly: true })], u$1g.prototype, "url", null), e$1W([y$1o()], u$1g.prototype, "username", void 0), e$1W([y$1o()], u$1g.prototype, "userType", void 0), u$1g = i$1I = e$1W([n$2f("esri.portal.PortalUser")], u$1g);
const p$24 = u$1g;
var PortalUser = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": p$24
});
var G$a;
let U$j;
const B$d = { PortalGroup: () => Promise.resolve().then(function() {
  return PortalGroup;
}), PortalItem: () => Promise.resolve().then(function() {
  return PortalItem;
}), PortalUser: () => Promise.resolve().then(function() {
  return PortalUser;
}) };
let D$f = G$a = class extends u$1N(m$1g) {
  constructor(e2) {
    super(e2), this._esriIdCredentialCreateHandle = null, this.access = null, this.allSSL = false, this.authMode = "auto", this.authorizedCrossOriginDomains = null, this.basemapGalleryGroupQuery = null, this.bingKey = null, this.canListApps = false, this.canListData = false, this.canListPreProvisionedItems = false, this.canProvisionDirectPurchase = false, this.canSearchPublic = true, this.canShareBingPublic = false, this.canSharePublic = false, this.canSignInArcGIS = false, this.canSignInIDP = false, this.colorSetsGroupQuery = null, this.commentsEnabled = false, this.created = null, this.culture = null, this.customBaseUrl = null, this.defaultBasemap = null, this.defaultDevBasemap = null, this.defaultExtent = null, this.defaultVectorBasemap = null, this.description = null, this.devBasemapGalleryGroupQuery = null, this.eueiEnabled = null, this.featuredGroups = null, this.featuredItemsGroupQuery = null, this.galleryTemplatesGroupQuery = null, this.livingAtlasGroupQuery = null, this.hasCategorySchema = false, this.helperServices = null, this.homePageFeaturedContent = null, this.homePageFeaturedContentCount = null, this.httpPort = null, this.httpsPort = null, this.id = null, this.ipCntryCode = null, this.isPortal = false, this.isReadOnly = false, this.layerTemplatesGroupQuery = null, this.maxTokenExpirationMinutes = null, this.modified = null, this.name = null, this.portalHostname = null, this.portalMode = null, this.portalProperties = null, this.region = null, this.rotatorPanels = null, this.showHomePageDescription = false, this.sourceJSON = null, this.supportsHostedServices = false, this.symbolSetsGroupQuery = null, this.templatesGroupQuery = null, this.units = null, this.url = s$23.portalUrl, this.urlKey = null, this.user = null, this.useStandardizedQuery = false, this.useVectorBasemaps = false, this.vectorBasemapGalleryGroupQuery = null;
  }
  normalizeCtorArgs(e2) {
    return typeof e2 == "string" ? { url: e2 } : e2;
  }
  destroy() {
    this._esriIdCredentialCreateHandle = h$1s(this._esriIdCredentialCreateHandle);
  }
  readAuthorizedCrossOriginDomains(e2) {
    if (e2)
      for (const r2 of e2)
        s$23.request.trustedServers.includes(r2) || s$23.request.trustedServers.push(r2);
    return e2;
  }
  readDefaultBasemap(e2) {
    return this._readBasemap(e2);
  }
  readDefaultDevBasemap(e2) {
    return this._readBasemap(e2);
  }
  readDefaultVectorBasemap(e2) {
    return this._readBasemap(e2);
  }
  get extraQuery() {
    const e2 = !(this.user && this.user.orgId) || this.canSearchPublic;
    return this.id && !e2 ? ` AND orgid:${this.id}` : null;
  }
  get isOrganization() {
    return !!this.access;
  }
  get itemPageUrl() {
    return this.url ? `${this.url}/home/item.html` : null;
  }
  get restUrl() {
    let e2 = this.url;
    if (e2) {
      const t2 = e2.indexOf("/sharing");
      e2 = t2 > 0 ? e2.substring(0, t2) : this.url.replace(/\/+$/, ""), e2 += "/sharing/rest";
    }
    return e2;
  }
  get thumbnailUrl() {
    const e2 = this.restUrl, t2 = this.thumbnail;
    return e2 && t2 ? this._normalizeSSL(e2 + "/portals/self/resources/" + t2) : null;
  }
  readUrlKey(e2) {
    return e2 ? e2.toLowerCase() : e2;
  }
  readUser(e2) {
    let t2 = null;
    return e2 && (t2 = p$24.fromJSON(e2), t2.portal = this), t2;
  }
  load(e2) {
    const t2 = Promise.resolve().then(function() {
      return Basemap;
    }).then(({ default: t3 }) => {
      f$1x(e2), U$j = t3;
    }).then(() => this.sourceJSON ? this.sourceJSON : this._fetchSelf(this.authMode, false, e2)).then((e3) => {
      if (s$1k) {
        const e4 = s$1k;
        this.credential = e4.findCredential(this.restUrl), this.credential || this.authMode !== G$a.AUTH_MODE_AUTO || (this._esriIdCredentialCreateHandle = e4.on("credential-create", () => {
          e4.findCredential(this.restUrl) && this._signIn().catch(() => {
          });
        }));
      }
      this.sourceJSON = e3, this.read(e3);
    });
    return this.addResolvingPromise(t2), Promise.resolve(this);
  }
  async createElevationLayers() {
    await this.load();
    const e2 = this._getHelperService("defaultElevationLayers"), t2 = (await import("./ElevationLayer.js")).default;
    return e2 ? e2.map((e3) => new t2({ id: e3.id, url: e3.url })) : [];
  }
  fetchBasemaps(e2, r2) {
    const o2 = new d$16();
    return o2.query = e2 || (s$23.apiKey && r$Y(this.url) ? this.devBasemapGalleryGroupQuery : this.useVectorBasemaps ? this.vectorBasemapGalleryGroupQuery : this.basemapGalleryGroupQuery), o2.disableExtraQuery = true, this.queryGroups(o2, r2).then((e3) => {
      if (o2.num = 100, o2.query = 'type:"Web Map" -type:"Web Application"', e3.total) {
        const t2 = e3.results[0];
        return o2.sortField = t2.sortField || "name", o2.sortOrder = t2.sortOrder || "desc", t2.queryItems(o2, r2);
      }
      return null;
    }).then((e3) => {
      let t2;
      return t2 = e3 && e3.total ? e3.results.filter((e4) => e4.type === "Web Map").map((e4) => new U$j({ portalItem: e4 })) : [], t2;
    });
  }
  fetchCategorySchema(e2) {
    return this.hasCategorySchema ? this._request(this.restUrl + "/portals/self/categorySchema", e2).then((e3) => e3.categorySchema) : p$2W(e2) ? Promise.reject(a$2p()) : Promise.resolve([]);
  }
  fetchFeaturedGroups(e2) {
    const t2 = this.featuredGroups, r2 = new d$16();
    if (r2.num = 100, r2.sortField = "title", t2 && t2.length) {
      const o2 = [];
      for (const e3 of t2)
        o2.push(`(title:"${e3.title}" AND owner:${e3.owner})`);
      return r2.query = o2.join(" OR "), this.queryGroups(r2, e2).then((e3) => e3.results);
    }
    return p$2W(e2) ? Promise.reject(a$2p()) : Promise.resolve([]);
  }
  fetchRegions(e2) {
    var _a2;
    const t2 = ((_a2 = this.user) == null ? void 0 : _a2.culture) || this.culture || l$1Q();
    return this._request(this.restUrl + "/portals/regions", __spreadProps(__spreadValues({}, e2), { query: { culture: t2 } }));
  }
  fetchSettings(e2) {
    var _a2;
    const t2 = ((_a2 = this.user) == null ? void 0 : _a2.culture) || this.culture || l$1Q();
    return this._request(this.restUrl + "/portals/self/settings", __spreadProps(__spreadValues({}, e2), { query: { culture: t2 } }));
  }
  static getDefault() {
    return G$a._default && !G$a._default.destroyed || (G$a._default = new G$a()), G$a._default;
  }
  queryGroups(e2, t2) {
    return this._queryPortal("/community/groups", e2, "PortalGroup", t2);
  }
  queryItems(e2, t2) {
    return this._queryPortal("/search", e2, "PortalItem", t2);
  }
  queryUsers(e2, t2) {
    return e2.sortField || (e2.sortField = "username"), this._queryPortal("/community/users", e2, "PortalUser", t2);
  }
  toJSON() {
    throw new s$1Z("internal:not-yet-implemented", "Portal.toJSON is not yet implemented");
  }
  static fromJSON(e2) {
    if (!e2)
      return null;
    if (e2.declaredClass)
      throw new Error("JSON object is already hydrated");
    return new G$a({ sourceJSON: e2 });
  }
  _getHelperService(e2) {
    const t2 = this.helperServices && this.helperServices[e2];
    if (!t2)
      throw new s$1Z("portal:service-not-found", `The \`helperServices\` do not include an entry named "${e2}"`);
    return t2;
  }
  _getHelperServiceUrl(e2) {
    const t2 = this._getHelperService(e2);
    if (!(t2 == null ? void 0 : t2.url))
      throw new s$1Z("portal:service-url-not-found", `The \`helperServices\` entry "${e2}" does not include a \`url\` value`);
    return t2.url;
  }
  _fetchSelf(e2 = this.authMode, t2 = false, r2) {
    const o2 = this.restUrl + "/portals/self", s2 = __spreadValues({ authMode: e2, query: { culture: l$1Q().toLowerCase() } }, r2);
    return s2.authMode === "auto" && (s2.authMode = "no-prompt"), t2 && (s2.query.default = true), this._request(o2, s2);
  }
  _queryPortal(e2, t2, r2, o2) {
    const s2 = b$U(d$16, t2), i2 = (t3) => this._request(this.restUrl + e2, __spreadValues(__spreadValues({}, s2.toRequestOptions(this)), o2)).then((e3) => {
      const r3 = s2.clone();
      return r3.start = e3.nextStart, new p$27({ nextQueryParams: r3, queryParams: s2, total: e3.total, results: G$a._resultsToTypedArray(t3, { portal: this }, e3, o2) });
    }).then((e3) => Promise.all(e3.results.map((t4) => typeof t4.when == "function" ? t4.when() : e3)).then(() => e3, (t4) => (w$O(t4), e3)));
    return r2 && B$d[r2] ? B$d[r2]().then(({ default: e3 }) => (f$1x(o2), i2(e3))) : i2();
  }
  _signIn() {
    if (this.authMode === G$a.AUTH_MODE_ANONYMOUS)
      return Promise.reject(new s$1Z("portal:invalid-auth-mode", `Current "authMode"' is "${this.authMode}"`));
    if (this.loadStatus === "failed")
      return Promise.reject(this.loadError);
    const e2 = (e3) => Promise.resolve().then(() => this.loadStatus === "not-loaded" ? (e3 || (this.authMode = "immediate"), this.load().then(() => null)) : this.loadStatus === "loading" ? this.load().then(() => this.credential ? null : (this.credential = e3, this._fetchSelf("immediate"))) : this.user && this.credential === e3 ? null : (this.credential = e3, this._fetchSelf("immediate"))).then((e4) => {
      e4 && (this.sourceJSON = e4, this.read(e4));
    });
    return s$1k ? s$1k.getCredential(this.restUrl).then((t2) => e2(t2)) : e2(this.credential);
  }
  _normalizeSSL(e2) {
    return e2.replace(/^http:/i, "https:").replace(":7080", ":7443");
  }
  _normalizeUrl(e2) {
    const t2 = this.credential && this.credential.token;
    return this._normalizeSSL(t2 ? e2 + (e2.includes("?") ? "&" : "?") + "token=" + t2 : e2);
  }
  _requestToTypedArray(e2, t2, r2) {
    return this._request(e2, t2).then((e3) => {
      const t3 = G$a._resultsToTypedArray(r2, { portal: this }, e3);
      return Promise.all(t3.map((t4) => typeof t4.when == "function" ? t4.when() : e3)).then(() => t3, () => t3);
    });
  }
  _readBasemap(e2) {
    if (e2) {
      const t2 = U$j.fromJSON(e2);
      return t2.portalItem = { portal: this }, t2;
    }
    return null;
  }
  _request(e2, t2 = {}) {
    const r2 = __spreadValues({ f: "json" }, t2.query), { authMode: s2 = this.authMode === G$a.AUTH_MODE_ANONYMOUS ? "anonymous" : "auto", body: i2 = null, cacheBust: a2 = false, method: l2 = "auto", responseType: u2 = "json", signal: n2 } = t2, p2 = { authMode: s2, body: i2, cacheBust: a2, method: l2, query: r2, responseType: u2, timeout: 0, signal: n2 };
    return U$k(this._normalizeSSL(e2), p2).then((e3) => e3.data);
  }
  static _resultsToTypedArray(e2, t2, r2, o2) {
    let s2;
    if (r2) {
      const i2 = r$1t(o2) ? o2.signal : null;
      s2 = r2.listings || r2.notifications || r2.userInvitations || r2.tags || r2.items || r2.groups || r2.comments || r2.provisions || r2.results || r2.relatedItems || r2, (e2 || t2) && (s2 = s2.map((r3) => {
        const o3 = Object.assign(e2 ? e2.fromJSON(r3) : r3, t2);
        return typeof o3.load == "function" && o3.load(i2), o3;
      }));
    } else
      s2 = [];
    return s2;
  }
};
D$f.AUTH_MODE_ANONYMOUS = "anonymous", D$f.AUTH_MODE_AUTO = "auto", D$f.AUTH_MODE_IMMEDIATE = "immediate", e$1W([y$1o()], D$f.prototype, "access", void 0), e$1W([y$1o()], D$f.prototype, "allSSL", void 0), e$1W([y$1o()], D$f.prototype, "authMode", void 0), e$1W([y$1o()], D$f.prototype, "authorizedCrossOriginDomains", void 0), e$1W([o$1H("authorizedCrossOriginDomains")], D$f.prototype, "readAuthorizedCrossOriginDomains", null), e$1W([y$1o()], D$f.prototype, "basemapGalleryGroupQuery", void 0), e$1W([y$1o()], D$f.prototype, "bingKey", void 0), e$1W([y$1o()], D$f.prototype, "canListApps", void 0), e$1W([y$1o()], D$f.prototype, "canListData", void 0), e$1W([y$1o()], D$f.prototype, "canListPreProvisionedItems", void 0), e$1W([y$1o()], D$f.prototype, "canProvisionDirectPurchase", void 0), e$1W([y$1o()], D$f.prototype, "canSearchPublic", void 0), e$1W([y$1o()], D$f.prototype, "canShareBingPublic", void 0), e$1W([y$1o()], D$f.prototype, "canSharePublic", void 0), e$1W([y$1o()], D$f.prototype, "canSignInArcGIS", void 0), e$1W([y$1o()], D$f.prototype, "canSignInIDP", void 0), e$1W([y$1o()], D$f.prototype, "colorSetsGroupQuery", void 0), e$1W([y$1o()], D$f.prototype, "commentsEnabled", void 0), e$1W([y$1o({ type: Date })], D$f.prototype, "created", void 0), e$1W([y$1o()], D$f.prototype, "credential", void 0), e$1W([y$1o()], D$f.prototype, "culture", void 0), e$1W([y$1o()], D$f.prototype, "currentVersion", void 0), e$1W([y$1o()], D$f.prototype, "customBaseUrl", void 0), e$1W([y$1o()], D$f.prototype, "defaultBasemap", void 0), e$1W([o$1H("defaultBasemap")], D$f.prototype, "readDefaultBasemap", null), e$1W([y$1o()], D$f.prototype, "defaultDevBasemap", void 0), e$1W([o$1H("defaultDevBasemap")], D$f.prototype, "readDefaultDevBasemap", null), e$1W([y$1o({ type: w$J })], D$f.prototype, "defaultExtent", void 0), e$1W([y$1o()], D$f.prototype, "defaultVectorBasemap", void 0), e$1W([o$1H("defaultVectorBasemap")], D$f.prototype, "readDefaultVectorBasemap", null), e$1W([y$1o()], D$f.prototype, "description", void 0), e$1W([y$1o()], D$f.prototype, "devBasemapGalleryGroupQuery", void 0), e$1W([y$1o()], D$f.prototype, "eueiEnabled", void 0), e$1W([y$1o({ readOnly: true })], D$f.prototype, "extraQuery", null), e$1W([y$1o()], D$f.prototype, "featuredGroups", void 0), e$1W([y$1o()], D$f.prototype, "featuredItemsGroupQuery", void 0), e$1W([y$1o()], D$f.prototype, "galleryTemplatesGroupQuery", void 0), e$1W([y$1o()], D$f.prototype, "livingAtlasGroupQuery", void 0), e$1W([y$1o()], D$f.prototype, "hasCategorySchema", void 0), e$1W([y$1o()], D$f.prototype, "helpBase", void 0), e$1W([y$1o()], D$f.prototype, "helperServices", void 0), e$1W([y$1o()], D$f.prototype, "helpMap", void 0), e$1W([y$1o()], D$f.prototype, "homePageFeaturedContent", void 0), e$1W([y$1o()], D$f.prototype, "homePageFeaturedContentCount", void 0), e$1W([y$1o()], D$f.prototype, "httpPort", void 0), e$1W([y$1o()], D$f.prototype, "httpsPort", void 0), e$1W([y$1o()], D$f.prototype, "id", void 0), e$1W([y$1o()], D$f.prototype, "ipCntryCode", void 0), e$1W([y$1o({ readOnly: true })], D$f.prototype, "isOrganization", null), e$1W([y$1o()], D$f.prototype, "isPortal", void 0), e$1W([y$1o()], D$f.prototype, "isReadOnly", void 0), e$1W([y$1o({ readOnly: true })], D$f.prototype, "itemPageUrl", null), e$1W([y$1o()], D$f.prototype, "layerTemplatesGroupQuery", void 0), e$1W([y$1o()], D$f.prototype, "maxTokenExpirationMinutes", void 0), e$1W([y$1o({ type: Date })], D$f.prototype, "modified", void 0), e$1W([y$1o()], D$f.prototype, "name", void 0), e$1W([y$1o()], D$f.prototype, "portalHostname", void 0), e$1W([y$1o()], D$f.prototype, "portalMode", void 0), e$1W([y$1o()], D$f.prototype, "portalProperties", void 0), e$1W([y$1o()], D$f.prototype, "region", void 0), e$1W([y$1o({ readOnly: true })], D$f.prototype, "restUrl", null), e$1W([y$1o()], D$f.prototype, "rotatorPanels", void 0), e$1W([y$1o()], D$f.prototype, "showHomePageDescription", void 0), e$1W([y$1o()], D$f.prototype, "sourceJSON", void 0), e$1W([y$1o()], D$f.prototype, "staticImagesUrl", void 0), e$1W([y$1o({ json: { name: "2DStylesGroupQuery" } })], D$f.prototype, "stylesGroupQuery2d", void 0), e$1W([y$1o({ json: { name: "stylesGroupQuery" } })], D$f.prototype, "stylesGroupQuery3d", void 0), e$1W([y$1o()], D$f.prototype, "supportsHostedServices", void 0), e$1W([y$1o()], D$f.prototype, "symbolSetsGroupQuery", void 0), e$1W([y$1o()], D$f.prototype, "templatesGroupQuery", void 0), e$1W([y$1o()], D$f.prototype, "thumbnail", void 0), e$1W([y$1o({ readOnly: true })], D$f.prototype, "thumbnailUrl", null), e$1W([y$1o()], D$f.prototype, "units", void 0), e$1W([y$1o()], D$f.prototype, "url", void 0), e$1W([y$1o()], D$f.prototype, "urlKey", void 0), e$1W([o$1H("urlKey")], D$f.prototype, "readUrlKey", null), e$1W([y$1o()], D$f.prototype, "user", void 0), e$1W([o$1H("user")], D$f.prototype, "readUser", null), e$1W([y$1o()], D$f.prototype, "useStandardizedQuery", void 0), e$1W([y$1o()], D$f.prototype, "useVectorBasemaps", void 0), e$1W([y$1o()], D$f.prototype, "vectorBasemapGalleryGroupQuery", void 0), D$f = G$a = e$1W([n$2f("esri.portal.Portal")], D$f);
const j$y = D$f;
let m$1e = class extends i$28(l$1_) {
  constructor(o2) {
    super(o2), this.type = "style", this.placement = "begin-end", this.style = "arrow", this.color = null;
  }
  equals(o2) {
    return r$1t(o2) && o2.placement === this.placement && o2.style === this.style && (t$1W(this.color) && t$1W(o2.color) || r$1t(this.color) && r$1t(o2.color) && this.color.toJSON() === o2.color.toJSON());
  }
};
e$1W([y$1o({ type: ["style"], readOnly: true, json: { read: true, write: { ignoreOrigin: true } } })], m$1e.prototype, "type", void 0), e$1W([y$1o({ type: e$1g, json: { default: "begin-end", write: true } })], m$1e.prototype, "placement", void 0), e$1W([y$1o({ type: n$1S, json: { default: "arrow", write: true } })], m$1e.prototype, "style", void 0), e$1W([y$1o({ type: l$1D, json: { type: [T$r], default: null, write: true } })], m$1e.prototype, "color", void 0), m$1e = e$1W([n$2f("esri.symbols.LineStyleMarker3D")], m$1e);
const y$10 = m$1e;
var d$15;
let f$15 = d$15 = class extends a$1$ {
  constructor(t2) {
    super(t2), this.material = null, this.type = "line", this.join = "miter", this.cap = "butt", this.size = e$1h(1), this.pattern = null, this.marker = null;
  }
  clone() {
    const t2 = { enabled: this.enabled, material: r$1t(this.material) ? this.material.clone() : null, size: this.size, join: this.join, cap: this.cap, pattern: r$1t(this.pattern) ? this.pattern.clone() : null, marker: r$1t(this.marker) ? this.marker.clone() : null };
    return new d$15(t2);
  }
  static fromSimpleLineSymbol(t2) {
    var _a2, _b2, _c2;
    const e2 = { enabled: true, size: (_a2 = t2.width) != null ? _a2 : e$1h(1), cap: t2.cap || "butt", join: t2.join || "miter", pattern: t2.style && t2.style !== "inside-frame" ? new n$1Q({ style: t2.style }) : null, material: new l$1A({ color: (t2.color || o$1g).clone() }), marker: t2.marker ? new y$10({ placement: t2.marker.placement, style: t2.marker.style, color: (_c2 = (_b2 = t2.marker.color) == null ? void 0 : _b2.clone()) != null ? _c2 : null }) : null };
    return new d$15(e2);
  }
};
e$1W([y$1o({ type: l$1A, json: { write: true } })], f$15.prototype, "material", void 0), e$1W([r$1a({ Line: "line" }, { readOnly: true })], f$15.prototype, "type", void 0), e$1W([y$1o({ type: a$1W, json: { write: true, default: "miter" } })], f$15.prototype, "join", void 0), e$1W([y$1o({ type: u$1n, json: { write: true, default: "butt" } })], f$15.prototype, "cap", void 0), e$1W([y$1o(a$1_)], f$15.prototype, "size", void 0), e$1W([y$1o(o$1h)], f$15.prototype, "pattern", void 0), e$1W([y$1o({ types: { key: "type", base: y$10, typeMap: { style: y$10 } }, json: { write: true } })], f$15.prototype, "marker", void 0), f$15 = d$15 = e$1W([n$2f("esri.symbols.LineSymbol3DLayer")], f$15);
const h$Y = f$15;
var n$1K;
const a$1P = o$1w()({ sphere: "sphere", cylinder: "cylinder", cube: "cube", cone: "cone", diamond: "diamond", tetrahedron: "tetrahedron", invertedCone: "inverted-cone" });
let m$1d = n$1K = class extends l$1_ {
  clone() {
    return new n$1K({ href: this.href, primitive: this.primitive });
  }
};
e$1W([y$1o({ type: String, json: { read: p$2a, write: f$18 } })], m$1d.prototype, "href", void 0), e$1W([r$1a(a$1P)], m$1d.prototype, "primitive", void 0), m$1d = n$1K = e$1W([n$2f("esri.symbols.support.ObjectSymbol3DLayerResource")], m$1d);
var e$18;
let p$23 = e$18 = class extends m$1L {
  constructor() {
    super(...arguments), this.x = 0, this.y = 0, this.z = 0;
  }
  clone() {
    return new e$18({ x: this.x, y: this.y, z: this.z });
  }
};
e$1W([y$1o({ type: Number })], p$23.prototype, "x", void 0), e$1W([y$1o({ type: Number })], p$23.prototype, "y", void 0), e$1W([y$1o({ type: Number })], p$23.prototype, "z", void 0), p$23 = e$18 = e$1W([n$2f("esri.symbols.support.Symbol3DAnchorPosition3D")], p$23);
var n$1J;
let c$1W = n$1J = class extends a$1$ {
  constructor(o2) {
    super(o2), this.material = null, this.castShadows = true, this.resource = null, this.type = "object", this.width = void 0, this.height = void 0, this.depth = void 0, this.anchor = void 0, this.anchorPosition = void 0, this.heading = void 0, this.tilt = void 0, this.roll = void 0;
  }
  clone() {
    return new n$1J({ heading: this.heading, tilt: this.tilt, roll: this.roll, anchor: this.anchor, anchorPosition: this.anchorPosition && this.anchorPosition.clone(), depth: this.depth, enabled: this.enabled, height: this.height, material: r$1t(this.material) ? this.material.clone() : null, castShadows: this.castShadows, resource: this.resource && this.resource.clone(), width: this.width });
  }
  get isPrimitive() {
    return !this.resource || typeof this.resource.href != "string";
  }
};
e$1W([y$1o({ type: l$1A, json: { write: true } })], c$1W.prototype, "material", void 0), e$1W([y$1o({ type: Boolean, nonNullable: true, json: { write: true, default: true } })], c$1W.prototype, "castShadows", void 0), e$1W([y$1o({ type: m$1d, json: { write: true } })], c$1W.prototype, "resource", void 0), e$1W([r$1a({ Object: "object" }, { readOnly: true })], c$1W.prototype, "type", void 0), e$1W([y$1o({ type: Number, json: { write: true } })], c$1W.prototype, "width", void 0), e$1W([y$1o({ type: Number, json: { write: true } })], c$1W.prototype, "height", void 0), e$1W([y$1o({ type: Number, json: { write: true } })], c$1W.prototype, "depth", void 0), e$1W([r$1a({ center: "center", top: "top", bottom: "bottom", origin: "origin", relative: "relative" }), y$1o({ json: { default: "origin" } })], c$1W.prototype, "anchor", void 0), e$1W([y$1o({ type: p$23, json: { type: [Number], read: { reader: (o2) => new p$23({ x: o2[0], y: o2[1], z: o2[2] }) }, write: { writer: (o2, t2) => {
  t2.anchorPosition = [o2.x, o2.y, o2.z];
}, overridePolicy() {
  return { enabled: this.anchor === "relative" };
} } } })], c$1W.prototype, "anchorPosition", void 0), e$1W([y$1o({ type: Number, json: { write: true } })], c$1W.prototype, "heading", void 0), e$1W([y$1o({ type: Number, json: { write: true } })], c$1W.prototype, "tilt", void 0), e$1W([y$1o({ type: Number, json: { write: true } })], c$1W.prototype, "roll", void 0), e$1W([y$1o({ readOnly: true })], c$1W.prototype, "isPrimitive", null), c$1W = n$1J = e$1W([n$2f("esri.symbols.ObjectSymbol3DLayer")], c$1W);
const l$1o = c$1W;
var n$1I;
let d$14 = n$1I = class extends a$1$ {
  constructor(t2) {
    super(t2), this.material = null, this.castShadows = true, this.type = "path", this.profile = "circle", this.join = "miter", this.cap = "butt", this.width = void 0, this.height = void 0, this.anchor = "center", this.profileRotation = "all";
  }
  readWidth(t2, e2) {
    return t2 != null ? t2 : e2.height == null && e2.size != null ? e2.size : void 0;
  }
  readHeight(t2, e2) {
    return t2 != null ? t2 : e2.width == null && e2.size != null ? e2.size : void 0;
  }
  clone() {
    return new n$1I({ enabled: this.enabled, material: r$1t(this.material) ? this.material.clone() : null, castShadows: this.castShadows, profile: this.profile, join: this.join, cap: this.cap, width: this.width, height: this.height, profileRotation: this.profileRotation, anchor: this.anchor });
  }
};
e$1W([y$1o({ type: l$1A, json: { write: true } })], d$14.prototype, "material", void 0), e$1W([y$1o({ type: Boolean, nonNullable: true, json: { write: true, default: true } })], d$14.prototype, "castShadows", void 0), e$1W([r$1a({ Path: "path" }, { readOnly: true })], d$14.prototype, "type", void 0), e$1W([y$1o({ type: ["circle", "quad"], json: { write: true, default: "circle" } })], d$14.prototype, "profile", void 0), e$1W([y$1o({ type: a$1W, json: { write: true, default: "miter" } })], d$14.prototype, "join", void 0), e$1W([y$1o({ type: i$1L, json: { write: true, default: "butt" } })], d$14.prototype, "cap", void 0), e$1W([y$1o({ type: Number, json: { write: { enabled: true, target: { width: { type: Number }, size: { type: Number } } } } })], d$14.prototype, "width", void 0), e$1W([o$1H("width", ["width", "size", "height"])], d$14.prototype, "readWidth", null), e$1W([y$1o({ type: Number, json: { write: true } })], d$14.prototype, "height", void 0), e$1W([o$1H("height", ["height", "size", "width"])], d$14.prototype, "readHeight", null), e$1W([y$1o({ type: ["center", "bottom", "top"], json: { write: true, default: "center" } })], d$14.prototype, "anchor", void 0), e$1W([y$1o({ type: ["heading", "all"], json: { write: true, default: "all" } })], d$14.prototype, "profileRotation", void 0), d$14 = n$1I = e$1W([n$2f("esri.symbols.PathSymbol3DLayer")], d$14);
const c$1V = d$14;
var m$1c;
let l$1n = m$1c = class extends l$1_ {
  constructor() {
    super(...arguments), this.color = new l$1D([0, 0, 0, 1]), this.size = 0;
  }
  clone() {
    const o2 = { color: y$1r(this.color), size: this.size };
    return new m$1c(o2);
  }
};
e$1W([y$1o(p$2m)], l$1n.prototype, "color", void 0), e$1W([y$1o(a$1_)], l$1n.prototype, "size", void 0), l$1n = m$1c = e$1W([n$2f("esri.symbols.support.Symbol3DHalo")], l$1n);
let c$1U = class extends i$28(l$1_) {
  constructor(o2) {
    super(o2), this.color = null;
  }
};
e$1W([y$1o(p$2m)], c$1U.prototype, "color", void 0), c$1U = e$1W([n$2f("esri.symbols.support.Symbol3DTextBackground")], c$1U);
var g$M;
let d$13 = g$M = class extends a$1$ {
  constructor(t2) {
    super(t2), this._userSize = void 0, this.halo = null, this.horizontalAlignment = "center", this.lineHeight = 1, this.material = null, this.background = null, this.text = null, this.type = "text", this.verticalAlignment = "baseline";
  }
  get font() {
    return this._get("font") || null;
  }
  set font(t2) {
    r$1t(t2) && r$1t(this._userSize) && (t2.size = this._userSize), this._set("font", t2);
  }
  writeFont(t2, o2, e2, r2) {
    const i2 = __spreadProps(__spreadValues({}, r2), { textSymbol3D: true });
    o2.font = t2.write({}, i2), delete o2.font.size;
  }
  get size() {
    return r$1t(this._userSize) ? this._userSize : r$1t(this.font) && this.font.size != null ? this.font.size : 9;
  }
  set size(t2) {
    this._userSize = t2, r$1t(this.font) && (this.font.size = this._userSize), this.notifyChange("size");
  }
  clone() {
    const t2 = new g$M({ enabled: this.enabled, font: this.font && y$1r(this.font), halo: this.halo && y$1r(this.halo), horizontalAlignment: this.horizontalAlignment, lineHeight: this.lineHeight, material: r$1t(this.material) ? this.material.clone() : null, text: this.text, verticalAlignment: this.verticalAlignment, background: y$1r(this.background) });
    return t2._userSize = this._userSize, t2;
  }
  static fromTextSymbol(t2) {
    return new g$M({ font: r$1t(t2.font) ? t2.font.clone() : new m$1l(), halo: z$k(t2.haloColor, t2.haloSize), horizontalAlignment: t2.horizontalAlignment, lineHeight: t2.lineHeight, material: t2.color ? new l$1A({ color: t2.color.clone() }) : null, text: t2.text, verticalAlignment: t2.verticalAlignment, background: t2.backgroundColor ? new c$1U({ color: t2.backgroundColor.clone() }) : null });
  }
};
function z$k(t2, e2) {
  return t2 && e2 != null && e2 > 0 ? new l$1n({ color: y$1r(t2), size: e2 }) : null;
}
e$1W([y$1o({ type: m$1l, json: { write: true } })], d$13.prototype, "font", null), e$1W([r$1h("font")], d$13.prototype, "writeFont", null), e$1W([y$1o({ type: l$1n, json: { write: true } })], d$13.prototype, "halo", void 0), e$1W([y$1o(__spreadProps(__spreadValues({}, m$1m), { json: { default: "center", write: true } }))], d$13.prototype, "horizontalAlignment", void 0), e$1W([y$1o(__spreadProps(__spreadValues({}, n$1O), { json: { default: 1, write: true } }))], d$13.prototype, "lineHeight", void 0), e$1W([y$1o({ type: l$1A, json: { write: true } })], d$13.prototype, "material", void 0), e$1W([y$1o({ type: c$1U, json: { write: true } })], d$13.prototype, "background", void 0), e$1W([y$1o(a$1_)], d$13.prototype, "size", null), e$1W([y$1o({ type: String, json: { write: true } })], d$13.prototype, "text", void 0), e$1W([r$1a({ Text: "text" }, { readOnly: true })], d$13.prototype, "type", void 0), e$1W([y$1o(__spreadProps(__spreadValues({}, p$2c), { json: { default: "baseline", write: true } }))], d$13.prototype, "verticalAlignment", void 0), d$13 = g$M = e$1W([n$2f("esri.symbols.TextSymbol3DLayer")], d$13);
const j$x = d$13;
var l$1m;
let c$1T = l$1m = class extends a$1$ {
  constructor(e2) {
    super(e2), this.color = m$1b.clone(), this.type = "water", this.waterbodySize = "medium", this.waveDirection = null, this.waveStrength = "moderate";
  }
  clone() {
    return new l$1m({ color: y$1r(this.color), waterbodySize: this.waterbodySize, waveDirection: this.waveDirection, waveStrength: this.waveStrength });
  }
};
e$1W([y$1o({ type: l$1D, nonNullable: true, json: { type: [T$r], write: (e2, r2, t2) => r2[t2] = e2.toArray(l$1D.AlphaMode.UNLESS_OPAQUE), default: () => m$1b.clone(), defaultEquals: (e2) => e2.toCss(true) === m$1b.toCss(true) } })], c$1T.prototype, "color", void 0), e$1W([r$1a({ Water: "water" }, { readOnly: true })], c$1T.prototype, "type", void 0), e$1W([y$1o({ type: ["small", "medium", "large"], json: { write: true, default: "medium" } })], c$1T.prototype, "waterbodySize", void 0), e$1W([y$1o({ type: Number, json: { write: true, default: null } })], c$1T.prototype, "waveDirection", void 0), e$1W([y$1o({ type: ["calm", "rippled", "slight", "moderate"], json: { write: true, default: "moderate" } })], c$1T.prototype, "waveStrength", void 0), c$1T = l$1m = e$1W([n$2f("esri.symbols.WaterSymbol3DLayer")], c$1T);
const m$1b = new l$1D([0, 119, 190]), n$1H = c$1T;
var p$22;
let l$1l = p$22 = class extends m$1L {
  constructor(t2) {
    super(t2), this.name = null, this.styleUrl = null, this.styleName = null, this.portal = null;
  }
  clone() {
    return new p$22({ name: this.name, styleUrl: this.styleUrl, styleName: this.styleName, portal: this.portal });
  }
};
e$1W([y$1o({ type: String })], l$1l.prototype, "name", void 0), e$1W([y$1o({ type: String })], l$1l.prototype, "styleUrl", void 0), e$1W([y$1o({ type: String })], l$1l.prototype, "styleName", void 0), e$1W([y$1o({ type: j$y })], l$1l.prototype, "portal", void 0), l$1l = p$22 = e$1W([n$2f("esri.symbols.support.StyleOrigin")], l$1l);
const a$1O = l$1l;
var t$1c;
let p$21 = t$1c = class extends m$1L {
  constructor() {
    super(...arguments), this.url = "";
  }
  clone() {
    return new t$1c({ url: this.url });
  }
};
e$1W([y$1o({ type: String })], p$21.prototype, "url", void 0), p$21 = t$1c = e$1W([n$2f("esri.symbols.support.Thumbnail")], p$21);
const v$F = { icon: S$w, object: l$1o, line: h$Y, path: c$1V, fill: f$1a, extrude: d$1g, text: j$x, water: n$1H }, C$i = j$F.ofType({ base: a$1$, key: "type", typeMap: v$F, errorContext: "symbol-layer" });
let T$i = class extends a$20 {
  constructor(e2) {
    super(e2), this.styleOrigin = null, this.thumbnail = null, this.type = null;
    const t2 = this.__accessor__ && this.__accessor__.metadatas && this.__accessor__.metadatas.symbolLayers, o2 = t2 && t2.type || j$F;
    this._set("symbolLayers", new o2());
  }
  get color() {
    return null;
  }
  set color(e2) {
    this.constructed && s$22.getLogger(this.declaredClass).error("Symbol3D does not support colors on the symbol level. Colors may be set on individual symbol layer materials instead.");
  }
  set symbolLayers(e2) {
    n$1N(e2, this._get("symbolLayers"));
  }
  readStyleOrigin(e2, r2, t2) {
    if (e2.styleUrl && e2.name) {
      const r3 = c$1_(e2.styleUrl, t2);
      return new a$1O({ styleUrl: r3, name: e2.name });
    }
    if (e2.styleName && e2.name)
      return new a$1O({ portal: t2 && t2.portal || j$y.getDefault(), styleName: e2.styleName, name: e2.name });
    t2 && t2.messages && t2.messages.push(new t$1Q("symbol3d:incomplete-style-origin", "Style origin requires either a 'styleUrl' or 'styleName' and a 'name' property", { context: t2, definition: e2 }));
  }
  writeStyleOrigin(e2, r2, t2, o2) {
    if (e2.styleUrl && e2.name) {
      let t3 = m$1j(e2.styleUrl, o2);
      K$7(t3) && (t3 = F$g(t3)), r2.styleOrigin = { styleUrl: t3, name: e2.name };
    } else
      e2.styleName && e2.name && (e2.portal && o2 && o2.portal && !N$c(e2.portal.restUrl, o2.portal.restUrl) ? o2 && o2.messages && o2.messages.push(new t$1Q("symbol:cross-portal", "The symbol style origin cannot be persisted because it refers to an item on a different portal than the one being saved to.", { symbol: this })) : r2.styleOrigin = { styleName: e2.styleName, name: e2.name });
  }
  normalizeCtorArgs(e2) {
    return e2 instanceof a$1$ || e2 && v$F[e2.type] ? { symbolLayers: [e2] } : Array.isArray(e2) ? { symbolLayers: e2 } : e2;
  }
};
e$1W([y$1o({ json: { read: false, write: false } })], T$i.prototype, "color", null), e$1W([y$1o({ type: C$i, nonNullable: true, json: { write: true } }), s$1N(t$1f)], T$i.prototype, "symbolLayers", null), e$1W([y$1o({ type: a$1O })], T$i.prototype, "styleOrigin", void 0), e$1W([o$1H("styleOrigin")], T$i.prototype, "readStyleOrigin", null), e$1W([r$1h("styleOrigin", { "styleOrigin.styleUrl": { type: String }, "styleOrigin.styleName": { type: String }, "styleOrigin.name": { type: String } })], T$i.prototype, "writeStyleOrigin", null), e$1W([y$1o({ type: p$21, json: { read: false } })], T$i.prototype, "thumbnail", void 0), e$1W([y$1o({ type: ["point-3d", "line-3d", "polygon-3d", "mesh-3d", "label-3d"], readOnly: true })], T$i.prototype, "type", void 0), T$i = e$1W([n$2f("esri.symbols.Symbol3D")], T$i);
const k$k = T$i;
let t$1b = class extends l$1_ {
  constructor(r2) {
    super(r2), this.visible = true;
  }
  clone() {
  }
};
e$1W([y$1o({ type: ["line"], readOnly: true, json: { read: false, write: { ignoreOrigin: true } } })], t$1b.prototype, "type", void 0), e$1W([y$1o({ readOnly: true })], t$1b.prototype, "visible", void 0), t$1b = e$1W([n$2f("esri.symbols.callouts.Callout3D")], t$1b);
const p$20 = t$1b;
var l$1k;
let a$1N = l$1k = class extends l$1_ {
  constructor() {
    super(...arguments), this.color = new l$1D("white");
  }
  clone() {
    return new l$1k({ color: y$1r(this.color) });
  }
};
e$1W([y$1o(p$2m)], a$1N.prototype, "color", void 0), a$1N = l$1k = e$1W([n$2f("esri.symbols.callouts.LineCallout3DBorder")], a$1N);
const i$1H = a$1N;
Object.freeze(Object.defineProperty({ __proto__: null, default: i$1H }, Symbol.toStringTag, { value: "Module" }));
var u$1f;
let d$12 = u$1f = class extends p$20 {
  constructor(o2) {
    super(o2), this.type = "line", this.color = new l$1D([0, 0, 0, 1]), this.size = e$1h(1), this.border = null;
  }
  get visible() {
    return this.size > 0 && r$1t(this.color) && this.color.a > 0;
  }
  clone() {
    return new u$1f({ color: y$1r(this.color), size: this.size, border: y$1r(this.border) });
  }
};
e$1W([r$1a({ line: "line" }, { readOnly: true })], d$12.prototype, "type", void 0), e$1W([y$1o(p$2m)], d$12.prototype, "color", void 0), e$1W([y$1o(a$1_)], d$12.prototype, "size", void 0), e$1W([y$1o({ type: i$1H, json: { write: true } })], d$12.prototype, "border", void 0), e$1W([y$1o({ readOnly: true })], d$12.prototype, "visible", null), d$12 = u$1f = e$1W([n$2f("esri.symbols.callouts.LineCallout3D")], d$12);
const y$$ = d$12;
function n$1G(e2) {
  if (!e2)
    return false;
  const r2 = e2.verticalOffset;
  return !!r2 && !(r2.screenLength <= 0 || r$1t(r2.maxWorldLength) && r2.maxWorldLength <= 0);
}
function o$1c(t2) {
  if (!t2)
    return false;
  if (!t2.supportsCallout || !t2.supportsCallout())
    return false;
  const e2 = t2.callout;
  return !!e2 && (!!e2.visible && !!n$1G(t2));
}
const u$1e = { types: { key: "type", base: p$20, typeMap: { line: y$$ } }, json: { write: true } };
var n$1F;
let p$1$ = n$1F = class extends l$1_ {
  constructor(r2) {
    super(r2), this.screenLength = 0, this.minWorldLength = 0, this.maxWorldLength = null;
  }
  clone() {
    return new n$1F({ screenLength: this.screenLength, minWorldLength: this.minWorldLength, maxWorldLength: this.maxWorldLength });
  }
};
e$1W([y$1o(a$1_)], p$1$.prototype, "screenLength", void 0), e$1W([y$1o({ type: Number, nonNullable: true, json: { write: true, default: 0 } })], p$1$.prototype, "minWorldLength", void 0), e$1W([y$1o({ type: Number, json: { write: true } })], p$1$.prototype, "maxWorldLength", void 0), p$1$ = n$1F = e$1W([n$2f("esri.symbols.support.Symbol3DVerticalOffset")], p$1$);
const i$1G = p$1$;
var n$1E;
const u$1d = j$F.ofType({ base: null, key: "type", typeMap: { text: j$x } });
let f$14 = n$1E = class extends k$k {
  constructor(t2) {
    super(t2), this.verticalOffset = null, this.callout = null, this.styleOrigin = null, this.symbolLayers = new u$1d(), this.type = "label-3d";
  }
  supportsCallout() {
    return true;
  }
  hasVisibleCallout() {
    return o$1c(this);
  }
  hasVisibleVerticalOffset() {
    return n$1G(this);
  }
  clone() {
    return new n$1E({ styleOrigin: y$1r(this.styleOrigin), symbolLayers: y$1r(this.symbolLayers), thumbnail: y$1r(this.thumbnail), callout: y$1r(this.callout), verticalOffset: y$1r(this.verticalOffset) });
  }
  static fromTextSymbol(t2) {
    return new n$1E({ symbolLayers: [j$x.fromTextSymbol(t2)] });
  }
};
e$1W([y$1o({ type: i$1G, json: { write: true } })], f$14.prototype, "verticalOffset", void 0), e$1W([y$1o(u$1e)], f$14.prototype, "callout", void 0), e$1W([y$1o({ json: { read: false, write: false } })], f$14.prototype, "styleOrigin", void 0), e$1W([y$1o({ type: u$1d })], f$14.prototype, "symbolLayers", void 0), e$1W([r$1a({ LabelSymbol3D: "label-3d" }, { readOnly: true })], f$14.prototype, "type", void 0), f$14 = n$1E = e$1W([n$2f("esri.symbols.LabelSymbol3D")], f$14);
const b$H = f$14;
var l$1j;
const a$1M = j$F.ofType({ base: null, key: "type", typeMap: { line: h$Y, path: c$1V } }), n$1D = j$F.ofType({ base: null, key: "type", typeMap: { line: h$Y, path: c$1V } });
let c$1S = l$1j = class extends k$k {
  constructor(o2) {
    super(o2), this.symbolLayers = new a$1M(), this.type = "line-3d";
  }
  clone() {
    return new l$1j({ styleOrigin: y$1r(this.styleOrigin), symbolLayers: y$1r(this.symbolLayers), thumbnail: y$1r(this.thumbnail) });
  }
  static fromSimpleLineSymbol(o2) {
    return new l$1j({ symbolLayers: [h$Y.fromSimpleLineSymbol(o2)] });
  }
};
e$1W([y$1o({ type: a$1M, json: { type: n$1D } })], c$1S.prototype, "symbolLayers", void 0), e$1W([r$1a({ LineSymbol3D: "line-3d" }, { readOnly: true })], c$1S.prototype, "type", void 0), c$1S = l$1j = e$1W([n$2f("esri.symbols.LineSymbol3D")], c$1S);
const b$G = c$1S;
let p$1_ = class extends a$20 {
  constructor(t2) {
    super(t2), this.angle = 0, this.type = null, this.xoffset = 0, this.yoffset = 0, this.size = 9;
  }
  hash() {
    return `${this.type}.${this.angle}.${this.size}.${this.xoffset}.${this.yoffset}`;
  }
};
e$1W([y$1o({ type: Number, json: { read: (t2) => t2 && -1 * t2, write: (t2, e2) => e2.angle = t2 && -1 * t2 } })], p$1_.prototype, "angle", void 0), e$1W([y$1o({ type: ["simple-marker", "picture-marker"], readOnly: true })], p$1_.prototype, "type", void 0), e$1W([y$1o({ type: Number, cast: o$1j, json: { write: true } })], p$1_.prototype, "xoffset", void 0), e$1W([y$1o({ type: Number, cast: o$1j, json: { write: true } })], p$1_.prototype, "yoffset", void 0), e$1W([y$1o({ type: Number, cast: (t2) => t2 === "auto" ? t2 : o$1j(t2), json: { write: true } })], p$1_.prototype, "size", void 0), p$1_ = e$1W([n$2f("esri.symbols.MarkerSymbol")], p$1_);
const i$1F = p$1_;
var i$1E;
const y$_ = j$F.ofType({ base: null, key: "type", typeMap: { fill: f$1a } });
let a$1L = i$1E = class extends k$k {
  constructor(o2) {
    super(o2), this.symbolLayers = new y$_(), this.type = "mesh-3d";
  }
  clone() {
    return new i$1E({ styleOrigin: y$1r(this.styleOrigin), symbolLayers: y$1r(this.symbolLayers), thumbnail: y$1r(this.thumbnail) });
  }
  static fromSimpleFillSymbol(o2) {
    return new i$1E({ symbolLayers: [f$1a.fromSimpleFillSymbol(o2)] });
  }
};
e$1W([y$1o({ type: y$_ })], a$1L.prototype, "symbolLayers", void 0), e$1W([r$1a({ MeshSymbol3D: "mesh-3d" }, { readOnly: true })], a$1L.prototype, "type", void 0), a$1L = i$1E = e$1W([n$2f("esri.symbols.MeshSymbol3D")], a$1L);
const c$1R = a$1L;
function o$1b(a2, r2, t2) {
  return r2.imageData ? et$2({ mediaType: r2.contentType || "image/png", isBase64: true, data: r2.imageData }) : s$1i(r2.url, t2);
}
function s$1i(e2, t2) {
  var _a2;
  return p$1Z(t2) && !K$7(e2) && ((_a2 = t2 == null ? void 0 : t2.layer) == null ? void 0 : _a2.parsedUrl) ? G$c(t2.layer.parsedUrl.path, "images", e2) : c$1_(e2, t2);
}
function u$1c(e2, a2, r2, n2) {
  if (X$6(e2)) {
    const t2 = nt$2(e2);
    if (!t2)
      return;
    a2.contentType = t2.mediaType, a2.imageData = t2.data, r2 && r2.imageData === a2.imageData && r2.url && f$18(r2.url, a2, "url", n2);
  } else
    f$18(e2, a2, "url", n2);
}
const m$1a = { json: { read: { source: ["imageData", "url"], reader: o$1b }, write: { writer(e2, a2, r2, t2) {
  u$1c(e2, a2, this.source, t2);
} } } }, c$1Q = { readOnly: true, json: { read: { source: ["imageData", "url"], reader(e2, a2, r2) {
  const t2 = {};
  return a2.imageData && (t2.imageData = a2.imageData), a2.contentType && (t2.contentType = a2.contentType), a2.url && (t2.url = s$1i(a2.url, r2)), t2;
} } } };
function p$1Z(e2) {
  var _a2, _b2;
  return !(e2 == null || e2.origin !== "service" && e2.origin !== "portal-item" || ((_a2 = e2.layer) == null ? void 0 : _a2.type) !== "feature" && ((_b2 = e2.layer) == null ? void 0 : _b2.type) !== "stream");
}
var c$1P;
let u$1b = c$1P = class extends p$2h {
  constructor(...t2) {
    super(...t2), this.type = "picture-fill", this.url = null, this.xscale = 1, this.yscale = 1, this.width = 12, this.height = 12, this.xoffset = 0, this.yoffset = 0, this.source = null;
  }
  normalizeCtorArgs(t2, s2, e2, r2) {
    if (t2 && typeof t2 != "string" && t2.imageData == null)
      return t2;
    const i2 = {};
    return t2 && (i2.url = t2), s2 && (i2.outline = s2), e2 != null && (i2.width = o$1j(e2)), r2 != null && (i2.height = o$1j(r2)), i2;
  }
  clone() {
    const t2 = new c$1P({ color: y$1r(this.color), height: this.height, outline: this.outline && this.outline.clone(), url: this.url, width: this.width, xoffset: this.xoffset, xscale: this.xscale, yoffset: this.yoffset, yscale: this.yscale });
    return t2._set("source", y$1r(this.source)), t2;
  }
  hash() {
    var _a2;
    return `${super.hash()}.${(_a2 = this.color) == null ? void 0 : _a2.hash()}.${this.height}.${this.url}.${this.width}.${this.xoffset}.${this.xscale}.${this.yoffset}.${this.yscale}`;
  }
};
e$1W([r$1a({ esriPFS: "picture-fill" }, { readOnly: true })], u$1b.prototype, "type", void 0), e$1W([y$1o(m$1a)], u$1b.prototype, "url", void 0), e$1W([y$1o({ type: Number, json: { write: true } })], u$1b.prototype, "xscale", void 0), e$1W([y$1o({ type: Number, json: { write: true } })], u$1b.prototype, "yscale", void 0), e$1W([y$1o({ type: Number, cast: o$1j, json: { write: true } })], u$1b.prototype, "width", void 0), e$1W([y$1o({ type: Number, cast: o$1j, json: { write: true } })], u$1b.prototype, "height", void 0), e$1W([y$1o({ type: Number, cast: o$1j, json: { write: true } })], u$1b.prototype, "xoffset", void 0), e$1W([y$1o({ type: Number, cast: o$1j, json: { write: true } })], u$1b.prototype, "yoffset", void 0), e$1W([y$1o(c$1Q)], u$1b.prototype, "source", void 0), u$1b = c$1P = e$1W([n$2f("esri.symbols.PictureFillSymbol")], u$1b);
const a$1K = u$1b;
var l$1i;
let a$1J = l$1i = class extends i$1F {
  constructor(...r2) {
    super(...r2), this.color = null, this.type = "picture-marker", this.url = null, this.source = null, this.height = 12, this.width = 12, this.size = null;
  }
  normalizeCtorArgs(r2, t2, o2) {
    if (r2 && typeof r2 != "string" && r2.imageData == null)
      return r2;
    const s2 = {};
    return r2 && (s2.url = r2), t2 != null && (s2.width = o$1j(t2)), o2 != null && (s2.height = o$1j(o2)), s2;
  }
  readHeight(r2, t2) {
    return t2.size || r2;
  }
  readWidth(r2, t2) {
    return t2.size || r2;
  }
  clone() {
    const r2 = new l$1i({ angle: this.angle, height: this.height, url: this.url, width: this.width, xoffset: this.xoffset, yoffset: this.yoffset });
    return r2._set("source", y$1r(this.source)), r2;
  }
  hash() {
    return `${super.hash()}.${this.height}.${this.url}.${this.width}`;
  }
};
e$1W([y$1o({ json: { write: false } })], a$1J.prototype, "color", void 0), e$1W([r$1a({ esriPMS: "picture-marker" }, { readOnly: true })], a$1J.prototype, "type", void 0), e$1W([y$1o(m$1a)], a$1J.prototype, "url", void 0), e$1W([y$1o(c$1Q)], a$1J.prototype, "source", void 0), e$1W([y$1o({ type: Number, cast: o$1j, json: { write: true } })], a$1J.prototype, "height", void 0), e$1W([o$1H("height", ["height", "size"])], a$1J.prototype, "readHeight", null), e$1W([y$1o({ type: Number, cast: o$1j, json: { write: true } })], a$1J.prototype, "width", void 0), e$1W([y$1o({ json: { write: false } })], a$1J.prototype, "size", void 0), a$1J = l$1i = e$1W([n$2f("esri.symbols.PictureMarkerSymbol")], a$1J);
const n$1C = a$1J;
var b$F;
const f$13 = j$F.ofType({ base: null, key: "type", typeMap: { icon: S$w, object: l$1o, text: j$x } });
let S$v = b$F = class extends k$k {
  constructor(t2) {
    super(t2), this.verticalOffset = null, this.callout = null, this.symbolLayers = new f$13(), this.type = "point-3d";
  }
  supportsCallout() {
    if ((this.symbolLayers ? this.symbolLayers.length : 0) < 1)
      return false;
    for (const t2 of this.symbolLayers.items)
      switch (t2.type) {
        case "icon":
        case "text":
        case "object":
          continue;
        default:
          return false;
      }
    return true;
  }
  hasVisibleCallout() {
    return o$1c(this);
  }
  hasVisibleVerticalOffset() {
    return n$1G(this);
  }
  clone() {
    return new b$F({ verticalOffset: y$1r(this.verticalOffset), callout: y$1r(this.callout), styleOrigin: y$1r(this.styleOrigin), symbolLayers: y$1r(this.symbolLayers), thumbnail: y$1r(this.thumbnail) });
  }
  static fromSimpleMarkerSymbol(t2) {
    return new b$F({ symbolLayers: [S$w.fromSimpleMarkerSymbol(t2)] });
  }
  static fromPictureMarkerSymbol(t2) {
    return new b$F({ symbolLayers: [S$w.fromPictureMarkerSymbol(t2)] });
  }
  static fromCIMSymbol(t2) {
    var _a2, _b2;
    const o2 = (_b2 = (_a2 = t2.data) == null ? void 0 : _a2.symbol) == null ? void 0 : _b2.type;
    if (o2 !== "CIMPointSymbol")
      return null;
    const r2 = t2.data.symbol;
    return new b$F((r2 == null ? void 0 : r2.callout) ? { symbolLayers: [S$w.fromCIMSymbol(t2)], callout: { type: "line", size: 0.5, color: [0, 0, 0] }, verticalOffset: { screenLength: 40 } } : { symbolLayers: [S$w.fromCIMSymbol(t2)] });
  }
  static fromTextSymbol(t2) {
    return new b$F({ symbolLayers: [j$x.fromTextSymbol(t2)] });
  }
};
e$1W([y$1o({ type: i$1G, json: { write: true } })], S$v.prototype, "verticalOffset", void 0), e$1W([y$1o(u$1e)], S$v.prototype, "callout", void 0), e$1W([y$1o({ type: f$13, json: { origins: { "web-scene": { write: true } } } })], S$v.prototype, "symbolLayers", void 0), e$1W([r$1a({ PointSymbol3D: "point-3d" }, { readOnly: true })], S$v.prototype, "type", void 0), S$v = b$F = e$1W([n$2f("esri.symbols.PointSymbol3D")], S$v);
const h$X = S$v;
var L$i;
const u$1a = j$F.ofType({ base: null, key: "type", typeMap: { extrude: d$1g, fill: f$1a, icon: S$w, line: h$Y, object: l$1o, text: j$x, water: n$1H } });
let j$w = L$i = class extends k$k {
  constructor(o2) {
    super(o2), this.symbolLayers = new u$1a(), this.type = "polygon-3d";
  }
  clone() {
    return new L$i({ styleOrigin: y$1r(this.styleOrigin), symbolLayers: y$1r(this.symbolLayers), thumbnail: y$1r(this.thumbnail) });
  }
  static fromJSON(o2) {
    const e2 = new L$i();
    if (e2.read(o2), e2.symbolLayers.length === 2 && e2.symbolLayers.getItemAt(0).type === "fill" && e2.symbolLayers.getItemAt(1).type === "line") {
      const r2 = e2.symbolLayers.getItemAt(0), s2 = e2.symbolLayers.getItemAt(1);
      !s2.enabled || o2.symbolLayers && o2.symbolLayers[1] && o2.symbolLayers[1].enable === false || (r2.outline = { size: s2.size, color: r$1t(s2.material) ? s2.material.color : null }), e2.symbolLayers.removeAt(1);
    }
    return e2;
  }
  static fromSimpleFillSymbol(o2) {
    return new L$i({ symbolLayers: [f$1a.fromSimpleFillSymbol(o2)] });
  }
};
e$1W([y$1o({ type: u$1a, json: { write: true } })], j$w.prototype, "symbolLayers", void 0), e$1W([r$1a({ PolygonSymbol3D: "polygon-3d" }, { readOnly: true })], j$w.prototype, "type", void 0), j$w = L$i = e$1W([n$2f("esri.symbols.PolygonSymbol3D")], j$w);
const S$u = j$w;
var p$1Y;
const c$1O = new s$1F({ esriSFSSolid: "solid", esriSFSNull: "none", esriSFSHorizontal: "horizontal", esriSFSVertical: "vertical", esriSFSForwardDiagonal: "forward-diagonal", esriSFSBackwardDiagonal: "backward-diagonal", esriSFSCross: "cross", esriSFSDiagonalCross: "diagonal-cross" });
let m$19 = p$1Y = class extends p$2h {
  constructor(...o2) {
    super(...o2), this.color = new l$1D([0, 0, 0, 0.25]), this.outline = new m$1q(), this.type = "simple-fill", this.style = "solid";
  }
  normalizeCtorArgs(o2, r2, s2) {
    if (o2 && typeof o2 != "string")
      return o2;
    const e2 = {};
    return o2 && (e2.style = o2), r2 && (e2.outline = r2), s2 && (e2.color = s2), e2;
  }
  clone() {
    return new p$1Y({ color: y$1r(this.color), outline: this.outline && this.outline.clone(), style: this.style });
  }
  hash() {
    return `${super.hash()}${this.style}.${this.color && this.color.hash()}`;
  }
};
e$1W([y$1o()], m$19.prototype, "color", void 0), e$1W([y$1o()], m$19.prototype, "outline", void 0), e$1W([r$1a({ esriSFS: "simple-fill" }, { readOnly: true })], m$19.prototype, "type", void 0), e$1W([y$1o({ type: c$1O.apiValues, json: { read: c$1O.read, write: c$1O.write } })], m$19.prototype, "style", void 0), m$19 = p$1Y = e$1W([n$2f("esri.symbols.SimpleFillSymbol")], m$19);
const S$t = m$19;
var h$W;
const m$18 = new s$1F({ esriSMSCircle: "circle", esriSMSSquare: "square", esriSMSCross: "cross", esriSMSX: "x", esriSMSDiamond: "diamond", esriSMSTriangle: "triangle", esriSMSPath: "path" });
let u$19 = h$W = class extends i$1F {
  constructor(...e2) {
    super(...e2), this.color = new l$1D([255, 255, 255, 0.25]), this.type = "simple-marker", this.size = 12, this.style = "circle", this.outline = new m$1q();
  }
  normalizeCtorArgs(e2, o2, r2, t2) {
    if (e2 && typeof e2 != "string")
      return e2;
    const i2 = {};
    return e2 && (i2.style = e2), o2 != null && (i2.size = o$1j(o2)), r2 && (i2.outline = r2), t2 && (i2.color = t2), i2;
  }
  writeColor(e2, o2) {
    e2 && this.style !== "x" && this.style !== "cross" && (o2.color = e2.toJSON()), e2 === null && (o2.color = null);
  }
  set path(e2) {
    this.style = "path", this._set("path", e2);
  }
  clone() {
    return new h$W({ angle: this.angle, color: y$1r(this.color), outline: this.outline && this.outline.clone(), path: this.path, size: this.size, style: this.style, xoffset: this.xoffset, yoffset: this.yoffset });
  }
  hash() {
    var _a2;
    return `${super.hash()}.${this.color && this.color.hash()}.${this.path}.${this.style}.${(_a2 = this.outline) == null ? void 0 : _a2.hash()}`;
  }
};
e$1W([y$1o()], u$19.prototype, "color", void 0), e$1W([r$1h("color")], u$19.prototype, "writeColor", null), e$1W([r$1a({ esriSMS: "simple-marker" }, { readOnly: true })], u$19.prototype, "type", void 0), e$1W([y$1o()], u$19.prototype, "size", void 0), e$1W([y$1o({ type: m$18.apiValues, json: { read: m$18.read, write: m$18.write } })], u$19.prototype, "style", void 0), e$1W([y$1o({ type: String, json: { write: true } })], u$19.prototype, "path", null), e$1W([y$1o({ types: { key: "type", base: null, defaultKeyValue: "simple-line", typeMap: { "simple-line": m$1q } }, json: { default: null, write: true } })], u$19.prototype, "outline", void 0), u$19 = h$W = e$1W([n$2f("esri.symbols.SimpleMarkerSymbol")], u$19);
const y$Z = u$19;
var f$12;
let g$L = f$12 = class extends a$20 {
  constructor(...t2) {
    super(...t2), this.backgroundColor = null, this.borderLineColor = null, this.borderLineSize = null, this.font = new m$1l(), this.horizontalAlignment = "center", this.kerning = true, this.haloColor = null, this.haloSize = null, this.rightToLeft = null, this.rotated = false, this.text = "", this.type = "text", this.verticalAlignment = "baseline", this.xoffset = 0, this.yoffset = 0, this.angle = 0, this.width = null, this.lineWidth = 192, this.lineHeight = 1;
  }
  normalizeCtorArgs(t2, o2, e2) {
    if (t2 && typeof t2 != "string")
      return t2;
    const i2 = {};
    return t2 && (i2.text = t2), o2 && (i2.font = o2), e2 && (i2.color = e2), i2;
  }
  writeLineWidth(t2, o2, e2, i2) {
    i2 && typeof i2 != "string" ? i2.origin : o2[e2] = t2;
  }
  castLineWidth(t2) {
    return o$1j(t2);
  }
  writeLineHeight(t2, o2, e2, i2) {
    i2 && typeof i2 != "string" ? i2.origin : o2[e2] = t2;
  }
  clone() {
    return new f$12({ angle: this.angle, backgroundColor: y$1r(this.backgroundColor), borderLineColor: y$1r(this.borderLineColor), borderLineSize: this.borderLineSize, color: y$1r(this.color), font: this.font && this.font.clone(), haloColor: y$1r(this.haloColor), haloSize: this.haloSize, horizontalAlignment: this.horizontalAlignment, kerning: this.kerning, lineHeight: this.lineHeight, lineWidth: this.lineWidth, rightToLeft: this.rightToLeft, rotated: this.rotated, text: this.text, verticalAlignment: this.verticalAlignment, width: this.width, xoffset: this.xoffset, yoffset: this.yoffset });
  }
  hash() {
    var _a2;
    return `${this.backgroundColor && this.backgroundColor.hash()}.${this.borderLineColor}.${this.borderLineSize}.${(_a2 = this.color) == null ? void 0 : _a2.hash()}.${this.font && this.font.hash()}.${this.haloColor && this.haloColor.hash()}.${this.haloSize}.${this.horizontalAlignment}.${this.kerning}.${this.rightToLeft}.${this.rotated}.${this.text}.${this.verticalAlignment}.${this.width}.${this.xoffset}.${this.yoffset}.${this.lineHeight}.${this.lineWidth}.${this.angle}`;
  }
};
e$1W([y$1o({ type: l$1D, json: { write: true } })], g$L.prototype, "backgroundColor", void 0), e$1W([y$1o({ type: l$1D, json: { write: true } })], g$L.prototype, "borderLineColor", void 0), e$1W([y$1o({ type: Number, json: { write: true } })], g$L.prototype, "borderLineSize", void 0), e$1W([y$1o({ type: m$1l, json: { write: true } })], g$L.prototype, "font", void 0), e$1W([y$1o(__spreadProps(__spreadValues({}, m$1m), { json: { write: true } }))], g$L.prototype, "horizontalAlignment", void 0), e$1W([y$1o({ type: Boolean, json: { write: true } })], g$L.prototype, "kerning", void 0), e$1W([y$1o({ type: l$1D, json: { write: true } })], g$L.prototype, "haloColor", void 0), e$1W([y$1o({ type: Number, cast: o$1j, json: { write: true } })], g$L.prototype, "haloSize", void 0), e$1W([y$1o({ type: Boolean, json: { write: true } })], g$L.prototype, "rightToLeft", void 0), e$1W([y$1o({ type: Boolean, json: { write: true } })], g$L.prototype, "rotated", void 0), e$1W([y$1o({ type: String, json: { write: true } })], g$L.prototype, "text", void 0), e$1W([r$1a({ esriTS: "text" }, { readOnly: true })], g$L.prototype, "type", void 0), e$1W([y$1o(__spreadProps(__spreadValues({}, p$2c), { json: { write: true } }))], g$L.prototype, "verticalAlignment", void 0), e$1W([y$1o({ type: Number, cast: o$1j, json: { write: true } })], g$L.prototype, "xoffset", void 0), e$1W([y$1o({ type: Number, cast: o$1j, json: { write: true } })], g$L.prototype, "yoffset", void 0), e$1W([y$1o({ type: Number, json: { read: (t2) => t2 && -1 * t2, write: (t2, o2) => o2.angle = t2 && -1 * t2 } })], g$L.prototype, "angle", void 0), e$1W([y$1o({ type: Number, json: { write: true } })], g$L.prototype, "width", void 0), e$1W([y$1o({ type: Number })], g$L.prototype, "lineWidth", void 0), e$1W([r$1h("lineWidth")], g$L.prototype, "writeLineWidth", null), e$1W([s$1N("lineWidth")], g$L.prototype, "castLineWidth", null), e$1W([y$1o(n$1O)], g$L.prototype, "lineHeight", void 0), e$1W([r$1h("lineHeight")], g$L.prototype, "writeLineHeight", null), g$L = f$12 = e$1W([n$2f("esri.symbols.TextSymbol")], g$L);
const m$17 = g$L;
var y$Y;
let h$V = y$Y = class extends a$20 {
  constructor(t2) {
    super(t2), this.styleName = null, this.portal = null, this.styleUrl = null, this.thumbnail = null, this.name = null, this.type = "web-style";
  }
  get _fetchCacheKey() {
    const t2 = r$1t(this.portal) ? this.portal : j$y.getDefault(), e2 = t2.user ? t2.user.username : null;
    return `${this.styleName}:${this.styleUrl}:${this.name}:${e2}:${t2.url}`;
  }
  read(t2, e2) {
    this.portal = e2 ? e2.portal : void 0, super.read(t2, e2);
  }
  clone() {
    return new y$Y({ name: this.name, styleUrl: this.styleUrl, styleName: this.styleName, portal: this.portal });
  }
  fetchSymbol(t2) {
    return this._fetchSymbol("webRef", t2);
  }
  fetchCIMSymbol(t2) {
    return this._fetchSymbol("cimRef", t2);
  }
  async _fetchSymbol(t2, s2) {
    const l2 = r$1t(s2) ? s2.cache : null, i2 = l2 ? this._fetchCacheKey : null;
    if (r$1t(l2)) {
      const t3 = i2 && l2.get(i2);
      if (t3)
        return t3.clone();
    }
    const p2 = await u$18();
    f$1x(s2);
    const a2 = p2.resolveWebStyleSymbol(this, { portal: this.portal }, t2, s2);
    a2.catch((t3) => {
      s$22.getLogger(this.declaredClass).error("#fetchSymbol()", "Failed to create symbol from style", t3);
    });
    const c2 = await a2;
    return t2 === "webRef" && c2.type === "point-3d" || t2 === "cimRef" && c2.type === "cim" ? (r$1t(l2) && l2.set(i2, c2.clone()), c2) : null;
  }
};
function u$18() {
  return import("./webStyleSymbolUtils.js");
}
e$1W([y$1o({ json: { write: false } })], h$V.prototype, "color", void 0), e$1W([y$1o({ type: String, json: { write: true } })], h$V.prototype, "styleName", void 0), e$1W([y$1o({ type: j$y, json: { write: false } })], h$V.prototype, "portal", void 0), e$1W([y$1o({ type: String, json: { read: p$2a, write: f$18 } })], h$V.prototype, "styleUrl", void 0), e$1W([y$1o({ type: p$21, json: { read: false } })], h$V.prototype, "thumbnail", void 0), e$1W([y$1o({ type: String, json: { write: true } })], h$V.prototype, "name", void 0), e$1W([r$1a({ styleSymbolReference: "web-style" }, { readOnly: true })], h$V.prototype, "type", void 0), e$1W([y$1o()], h$V.prototype, "_fetchCacheKey", null), h$V = y$Y = e$1W([n$2f("esri.symbols.WebStyleSymbol")], h$V);
const f$11 = h$V;
function x$v(e2) {
  if (!e2)
    return false;
  switch (e2.type) {
    case "picture-fill":
    case "picture-marker":
    case "simple-fill":
    case "simple-line":
    case "simple-marker":
    case "text":
    case "cim":
      return true;
    default:
      return false;
  }
}
function c$1N(e2) {
  if (!e2)
    return false;
  switch (e2.type) {
    case "label-3d":
    case "line-3d":
    case "mesh-3d":
    case "point-3d":
    case "polygon-3d":
      return true;
    default:
      return false;
  }
}
const j$v = { base: a$20, key: "type", typeMap: { "simple-fill": S$t, "picture-fill": a$1K, "picture-marker": n$1C, "simple-line": m$1q, "simple-marker": y$Z, text: m$17, "label-3d": b$H, "line-3d": b$G, "mesh-3d": c$1R, "point-3d": h$X, "polygon-3d": S$u, "web-style": f$11, cim: d$1h }, errorContext: "symbol" }, D$e = { base: a$20, key: "type", typeMap: { "picture-marker": n$1C, "simple-marker": y$Z, text: m$17, "web-style": f$11, cim: d$1h }, errorContext: "symbol" }, k$j = s$1W({ types: j$v }), M$i = { base: a$20, key: "type", typeMap: { "simple-fill": S$t, "picture-fill": a$1K, "picture-marker": n$1C, "simple-line": m$1q, "simple-marker": y$Z, text: m$17, "line-3d": b$G, "mesh-3d": c$1R, "point-3d": h$X, "polygon-3d": S$u, "web-style": f$11, cim: d$1h }, errorContext: "symbol" }, P$i = { base: a$20, key: "type", typeMap: { text: m$17, "label-3d": b$H }, errorContext: "symbol" }, h$U = { base: a$20, key: "type", typeMap: { "line-3d": b$G, "mesh-3d": c$1R, "point-3d": h$X, "polygon-3d": S$u, "web-style": f$11, cim: d$1h }, errorContext: "symbol" }, F$e = { base: a$20, key: "type", typeMap: { "label-3d": b$H }, errorContext: "symbol" }, g$K = S$H(j$v);
function y$X(t2) {
  if (!t2)
    return null;
  const e2 = {};
  for (const r2 in t2) {
    const o2 = v$N(t2[r2]);
    o2 && (e2[r2] = o2);
  }
  return Object.keys(e2).length !== 0 ? e2 : null;
}
function m$16(t2) {
  if (!r$1t(t2))
    return null;
  const e2 = {};
  for (const r2 in t2) {
    const o2 = t2[r2];
    o2 && (e2[r2] = o2.toJSON());
  }
  return Object.keys(e2).length !== 0 ? e2 : null;
}
let h$T = class extends i$28(l$1_) {
  constructor(...t2) {
    super(...t2), this.isAggregate = false, this.layer = null, this.popupTemplate = null, this.sourceLayer = null, Object.defineProperty(this, "uid", { value: e$1E(), configurable: true });
  }
  normalizeCtorArgs(t2, e2, r2, o2) {
    return t2 && !t2.declaredClass ? t2 : { geometry: t2, symbol: e2, attributes: r2, popupTemplate: o2 };
  }
  set aggregateGeometries(t2) {
    const e2 = this._get("aggregateGeometries");
    JSON.stringify(e2) !== JSON.stringify(t2) && this._set("aggregateGeometries", t2);
  }
  set attributes(t2) {
    const e2 = this._get("attributes");
    e2 !== t2 && (this._set("attributes", t2), this._notifyLayer("attributes", e2, t2));
  }
  set geometry(t2) {
    const e2 = this._get("geometry");
    e2 !== t2 && (this._set("geometry", t2), this._notifyLayer("geometry", e2, t2));
  }
  set symbol(t2) {
    const e2 = this._get("symbol");
    e2 !== t2 && (this._set("symbol", t2), this._notifyLayer("symbol", e2, t2));
  }
  set visible(t2) {
    const e2 = this._get("visible");
    e2 !== t2 && (this._set("visible", t2), this._notifyLayer("visible", e2, t2));
  }
  getEffectivePopupTemplate(t2 = false) {
    if (this.popupTemplate)
      return this.popupTemplate;
    for (const e2 of [this.sourceLayer, this.layer])
      if (e2) {
        if ("popupTemplate" in e2 && e2.popupTemplate)
          return e2.popupTemplate;
        if (t2 && "defaultPopupTemplate" in e2 && r$1t(e2.defaultPopupTemplate))
          return e2.defaultPopupTemplate;
      }
    return null;
  }
  getAttribute(t2) {
    var _a2;
    return (_a2 = this.attributes) == null ? void 0 : _a2[t2];
  }
  setAttribute(t2, e2) {
    if (this.attributes) {
      const r2 = this.getAttribute(t2);
      this.attributes[t2] = e2, this._notifyLayer("attributes", r2, e2, t2);
    } else
      this.attributes = { [t2]: e2 }, this._notifyLayer("attributes", void 0, e2, t2);
  }
  getObjectId() {
    return this.sourceLayer && "objectIdField" in this.sourceLayer && this.sourceLayer.objectIdField ? this.getAttribute(this.sourceLayer.objectIdField) : null;
  }
  toJSON() {
    return { aggregateGeometries: m$16(this.aggregateGeometries), geometry: r$1t(this.geometry) ? this.geometry.toJSON() : null, symbol: r$1t(this.symbol) ? this.symbol.toJSON() : null, attributes: __spreadValues({}, this.attributes), popupTemplate: this.popupTemplate && this.popupTemplate.toJSON() };
  }
  notifyGeometryChanged() {
    this._notifyLayer("geometry", this.geometry, this.geometry);
  }
  notifyMeshTransformChanged() {
    r$1t(this.geometry) && this.geometry.type === "mesh" && this._notifyLayer("transform", this.geometry.transform, this.geometry.transform);
  }
  _notifyLayer(t2, e2, r2, o2) {
    if (!this.layer || !("graphicChanged" in this.layer))
      return;
    const s2 = { graphic: this, property: t2, oldValue: e2, newValue: r2 };
    t2 === "attributes" && (s2.attributeName = o2), this.layer.graphicChanged(s2);
  }
};
e$1W([y$1o({ value: null, json: { read: y$X } })], h$T.prototype, "aggregateGeometries", null), e$1W([y$1o({ value: null })], h$T.prototype, "attributes", null), e$1W([y$1o({ value: null, types: i$29, json: { read: v$N } })], h$T.prototype, "geometry", null), e$1W([y$1o({ type: Boolean })], h$T.prototype, "isAggregate", void 0), e$1W([y$1o({ clonable: "reference" })], h$T.prototype, "layer", void 0), e$1W([y$1o({ type: k$o })], h$T.prototype, "popupTemplate", void 0), e$1W([y$1o({ clonable: "reference" })], h$T.prototype, "sourceLayer", void 0), e$1W([y$1o({ value: null, types: j$v })], h$T.prototype, "symbol", null), e$1W([y$1o({ type: Boolean, value: true })], h$T.prototype, "visible", null), h$T = e$1W([n$2f("esri.Graphic")], h$T), function(t2) {
  t2.generateUID = e$1E;
}(h$T || (h$T = {}));
const g$J = h$T;
class i$1D {
  constructor(n2, i2) {
    this.min = n2, this.max = i2, this.range = i2 - n2;
  }
  ndiff(n2, i2 = 0) {
    return Math.ceil((n2 - i2) / this.range) * this.range + i2;
  }
  _normalize(n2, i2, t2, o2 = 0, r2 = false) {
    return (t2 -= o2) < n2 ? t2 += this.ndiff(n2 - t2) : t2 > i2 && (t2 -= this.ndiff(t2 - i2)), r2 && t2 === i2 && (t2 = n2), t2 + o2;
  }
  normalize(n2, i2 = 0, t2 = false) {
    return this._normalize(this.min, this.max, n2, i2, t2);
  }
  clamp(i2, t2 = 0) {
    return a$21(i2 - t2, this.min, this.max) + t2;
  }
  monotonic(n2, i2, t2) {
    return n2 < i2 ? i2 : i2 + this.ndiff(n2 - i2, t2);
  }
  minimalMonotonic(n2, i2, t2) {
    return this._normalize(n2, n2 + this.range, i2, t2);
  }
  center(n2, i2, t2) {
    return i2 = this.monotonic(n2, i2, t2), this.normalize((n2 + i2) / 2, t2);
  }
  diff(n2, i2, t2) {
    return this.monotonic(n2, i2, t2) - n2;
  }
  shortestSignedDiff(n2, i2) {
    n2 = this.normalize(n2);
    const t2 = (i2 = this.normalize(i2)) - n2, o2 = i2 < n2 ? this.minimalMonotonic(n2, i2) - n2 : i2 - this.minimalMonotonic(i2, n2);
    return Math.abs(t2) < Math.abs(o2) ? t2 : o2;
  }
  contains(n2, i2, t2) {
    return i2 = this.minimalMonotonic(n2, i2), (t2 = this.minimalMonotonic(n2, t2)) > n2 && t2 < i2;
  }
}
function t$1a(n2) {
  for (const i2 in n2) {
    const t2 = n2[i2];
    t2 instanceof Function && (n2[i2] = t2.bind(n2));
  }
  return n2;
}
t$1a(new i$1D(0, 2 * Math.PI));
t$1a(new i$1D(-Math.PI, Math.PI));
const s$1h = t$1a(new i$1D(0, 360));
let d$11 = class extends i$28(l$1_) {
  constructor(...o2) {
    super(...o2), this.position = new w$K([0, 0, 0]), this.heading = 0, this.tilt = 0, this.fov = 55;
  }
  normalizeCtorArgs(o2, r2, t2, e2) {
    if (o2 && typeof o2 == "object" && ("x" in o2 || Array.isArray(o2))) {
      const s2 = { position: o2 };
      return r2 != null && (s2.heading = r2), t2 != null && (s2.tilt = t2), e2 != null && (s2.fov = e2), s2;
    }
    return o2;
  }
  writePosition(o2, r2, t2, e2) {
    const s2 = o2.clone();
    s2.x = a$2w(o2.x || 0), s2.y = a$2w(o2.y || 0), s2.z = o2.hasZ ? a$2w(o2.z || 0) : o2.z, r2[t2] = s2.write({}, e2);
  }
  readPosition(o2, r2) {
    const t2 = new w$K();
    return t2.read(o2, r2), t2.x = a$2w(t2.x || 0), t2.y = a$2w(t2.y || 0), t2.z = t2.hasZ ? a$2w(t2.z || 0) : t2.z, t2;
  }
  equals(o2) {
    return !t$1W(o2) && (this.tilt === o2.tilt && this.heading === o2.heading && this.fov === o2.fov && this.position.equals(o2.position));
  }
};
e$1W([y$1o({ type: w$K, json: { write: { isRequired: true } } })], d$11.prototype, "position", void 0), e$1W([r$1h("position")], d$11.prototype, "writePosition", null), e$1W([o$1H("position")], d$11.prototype, "readPosition", null), e$1W([y$1o({ type: Number, nonNullable: true, json: { write: { isRequired: true } } }), s$1N((o2) => s$1h.normalize(a$2w(o2)))], d$11.prototype, "heading", void 0), e$1W([y$1o({ type: Number, nonNullable: true, json: { write: { isRequired: true } } }), s$1N((o2) => a$21(a$2w(o2), -180, 180))], d$11.prototype, "tilt", void 0), e$1W([y$1o({ type: Number, nonNullable: true, json: { read: false, write: false } })], d$11.prototype, "fov", void 0), d$11 = e$1W([n$2f("esri.Camera")], d$11);
const y$W = d$11;
var m$15;
let n$1B = m$15 = class extends l$1_ {
  constructor(r2) {
    super(r2), this.rotation = 0, this.scale = 0, this.targetGeometry = null, this.camera = null;
  }
  castRotation(r2) {
    return (r2 %= 360) < 0 && (r2 += 360), r2;
  }
  clone() {
    return new m$15({ rotation: this.rotation, scale: this.scale, targetGeometry: r$1t(this.targetGeometry) ? this.targetGeometry.clone() : null, camera: r$1t(this.camera) ? this.camera.clone() : null });
  }
};
function l$1h() {
  return { enabled: !this.camera };
}
e$1W([y$1o({ type: Number, json: { write: true, origins: { "web-map": { default: 0, write: true }, "web-scene": { write: { overridePolicy: l$1h } } } } })], n$1B.prototype, "rotation", void 0), e$1W([s$1N("rotation")], n$1B.prototype, "castRotation", null), e$1W([y$1o({ type: Number, json: { write: true, origins: { "web-map": { default: 0, write: true }, "web-scene": { write: { overridePolicy: l$1h } } } } })], n$1B.prototype, "scale", void 0), e$1W([y$1o({ types: i$29, json: { read: v$N, write: true, origins: { "web-scene": { read: v$N, write: { overridePolicy: l$1h } } } } })], n$1B.prototype, "targetGeometry", void 0), e$1W([y$1o({ type: y$W, json: { write: true } })], n$1B.prototype, "camera", void 0), n$1B = m$15 = e$1W([n$2f("esri.Viewpoint")], n$1B);
const u$17 = n$1B;
let c$1M = class extends j$F {
  constructor(t2) {
    super(t2), this.getCollections = null;
  }
  initialize() {
    this.own(l$20(() => this._refresh()));
  }
  destroy() {
    this.getCollections = null;
  }
  _refresh() {
    const t2 = r$1t(this.getCollections) ? this.getCollections() : null;
    if (t$1W(t2))
      return void this.removeAll();
    let o2 = 0;
    for (const r2 of t2)
      r$1t(r2) && (o2 = this._processCollection(o2, r2));
    this.splice(o2, this.length);
  }
  _createNewInstance(t2) {
    return new j$F(t2);
  }
  _processCollection(t2, o2) {
    if (!o2)
      return t2;
    const s2 = this.itemFilterFunction ? this.itemFilterFunction : (t3) => !!t3;
    for (const r2 of o2)
      if (r2) {
        if (s2(r2)) {
          const o3 = this.indexOf(r2, t2);
          o3 >= 0 ? o3 !== t2 && this.reorder(r2, t2) : this.add(r2, t2), ++t2;
        }
        if (this.getChildrenFunction) {
          const o3 = this.getChildrenFunction(r2);
          if (Array.isArray(o3))
            for (const s3 of o3)
              t2 = this._processCollection(t2, s3);
          else
            t2 = this._processCollection(t2, o3);
        }
      }
    return t2;
  }
};
e$1W([y$1o()], c$1M.prototype, "getCollections", void 0), e$1W([y$1o()], c$1M.prototype, "getChildrenFunction", void 0), e$1W([y$1o()], c$1M.prototype, "itemFilterFunction", void 0), c$1M = e$1W([n$2f("esri.core.CollectionFlattener")], c$1M);
const l$1g = c$1M;
function l$1f(n2, t2, r2 = {}) {
  return m$14(n2, t2, r2, y$V);
}
function f$10(n2, t2, r2 = {}) {
  return m$14(n2, t2, r2, d$10);
}
function m$14(n2, t2, r2 = {}, e2) {
  let i2 = null;
  const u2 = r2.once ? (n3, r3) => {
    e2(n3) && (h$1s(i2), t2(n3, r3));
  } : (n3, r3) => {
    e2(n3) && t2(n3, r3);
  };
  if (i2 = P$q(n2, u2, r2.sync, r2.equals), r2.initial) {
    const t3 = n2();
    u2(t3, t3);
  }
  return i2;
}
function a$1I(r2, i2, u2, s2 = {}) {
  let c2 = null, f2 = null, m2 = null;
  function a2() {
    var _a2;
    c2 && f2 && (f2.remove(), (_a2 = s2.onListenerRemove) == null ? void 0 : _a2.call(s2, c2), c2 = null, f2 = null);
  }
  function p2(n2) {
    s2.once && s2.once && h$1s(m2), u2(n2);
  }
  const j2 = l$1f(r2, (r3, e2) => {
    var _a2;
    a2(), e$1F(r3) && (c2 = r3, f2 = r$1j(r3, i2, p2), (_a2 = s2.onListenerAdd) == null ? void 0 : _a2.call(s2, r3));
  }, { sync: s2.sync, initial: true });
  return m2 = n$2k(() => {
    j2.remove(), a2();
  }), m2;
}
function j$u(n2, t2) {
  return v$E(n2, d$10, t2);
}
function v$E(n2, t2, e2) {
  if (p$2W(e2))
    return Promise.reject(a$2p());
  const c2 = n2();
  if (t2 == null ? void 0 : t2(c2))
    return Promise.resolve(c2);
  let l2 = null;
  function f2() {
    l2 = h$1s(l2);
  }
  return new Promise((o2, i2) => {
    l2 = r$1p([v$S(e2, () => {
      f2(), i2(a$2p());
    }), m$14(n2, (n3) => {
      f2(), o2(n3);
    }, { sync: false, once: true }, t2 != null ? t2 : y$V)]);
  });
}
function y$V(n2) {
  return true;
}
function d$10(n2) {
  return !!n2;
}
const U$i = { sync: true }, h$S = { initial: true }, w$A = { sync: true, initial: true };
class e$17 {
  constructor(t2 = (t3) => t3.values().next().value) {
    this._peeker = t2, this._items = new Set();
  }
  get length() {
    return this._items.size;
  }
  clear() {
    this._items.clear();
  }
  last() {
    if (this._items.size === 0)
      return;
    let t2;
    for (t2 of this._items)
      ;
    return t2;
  }
  peek() {
    if (this._items.size !== 0)
      return this._peeker(this._items);
  }
  push(t2) {
    this.contains(t2) || this._items.add(t2);
  }
  contains(t2) {
    return this._items.has(t2);
  }
  pop() {
    if (this.length === 0)
      return;
    const e2 = this.peek();
    return this._items.delete(x$N(e2)), e2;
  }
  popLast() {
    if (this.length === 0)
      return;
    const e2 = this.last();
    return this._items.delete(x$N(e2)), e2;
  }
  remove(t2) {
    this._items.delete(t2);
  }
  filter(t2) {
    return this._items.forEach((e2) => {
      t2(e2) || this._items.delete(e2);
    }), this;
  }
}
var t$19;
!function(t2) {
  t2[t2.HANDSHAKE = 0] = "HANDSHAKE", t2[t2.OPEN = 1] = "OPEN", t2[t2.OPENED = 2] = "OPENED", t2[t2.RESPONSE = 3] = "RESPONSE", t2[t2.INVOKE = 4] = "INVOKE", t2[t2.ABORT = 5] = "ABORT", t2[t2.CLOSE = 6] = "CLOSE", t2[t2.OPEN_PORT = 7] = "OPEN_PORT", t2[t2.ON = 8] = "ON";
}(t$19 || (t$19 = {}));
let e$16 = 0;
function r$X() {
  return e$16++;
}
function n$1A(t2) {
  return t2 && typeof t2 == "object" && ("result" in t2 || "transferList" in t2);
}
function s$1g(t2) {
  return t2 ? typeof t2 == "string" ? JSON.stringify({ name: "message", message: t2 }) : t2.toJSON ? JSON.stringify(t2) : JSON.stringify({ name: t2.name, message: t2.message, details: t2.details || { stack: t2.stack } }) : null;
}
function o$1a(e2, r2, f2, a2) {
  if (r2.type === t$19.OPEN_PORT)
    return void e2.postMessage(r2, [r2.port]);
  if (r2.type !== t$19.INVOKE && r2.type !== t$19.RESPONSE)
    return void e2.postMessage(r2);
  let u2;
  if (n$1A(f2) ? (u2 = i$1C(f2.transferList), r2.data = f2.result) : (u2 = i$1C(a2), r2.data = f2), u2) {
    if (has("ff")) {
      for (const n2 of u2)
        if ("byteLength" in n2 && n2.byteLength > 267386880) {
          const n3 = "Worker call with large ArrayBuffer would crash Firefox";
          switch (r2.type) {
            case t$19.INVOKE:
              throw n3;
            case t$19.RESPONSE:
              return void o$1a(e2, { type: t$19.RESPONSE, jobId: r2.jobId, error: s$1g(n3) });
          }
        }
    }
    e2.postMessage(r2, u2);
  } else
    e2.postMessage(r2);
}
function f$$(t2) {
  if (!t2)
    return null;
  const e2 = t2.data;
  return e2 ? typeof e2 == "string" ? JSON.parse(e2) : e2 : null;
}
function i$1C(t2) {
  if (!t2 || !t2.length)
    return null;
  if (has("esri-workers-arraybuffer-transfer"))
    return t2;
  const e2 = t2.filter((t3) => !a$1H(t3));
  return e2.length ? e2 : null;
}
function a$1H(t2) {
  return t2 instanceof ArrayBuffer || t2 && t2.constructor && t2.constructor.name === "ArrayBuffer";
}
const k$i = { statsWorker: () => import("./statsWorker.js"), geometryEngineWorker: () => import("./geometryEngineWorker.js"), CSVSourceWorker: () => import("./CSVSourceWorker.js"), EdgeProcessingWorker: () => import("./EdgeProcessingWorker.js"), ElevationSamplerWorker: () => import("./ElevationSamplerWorker.js"), FeatureServiceSnappingSourceWorker: () => import("./FeatureServiceSnappingSourceWorker.js"), GeoJSONSourceWorker: () => import("./GeoJSONSourceWorker.js"), LercWorker: () => import("./LercWorker.js"), MemorySourceWorker: () => import("./MemorySourceWorker.js"), PBFDecoderWorker: () => import("./PBFDecoderWorker.js"), Pipeline: () => import("./Pipeline.js"), PointCloudWorker: () => import("./PointCloudWorker.js"), RasterWorker: () => import("./RasterWorker.js"), SceneLayerSnappingSourceWorker: () => import("./SceneLayerSnappingSourceWorker.js"), SceneLayerWorker: () => import("./SceneLayerWorker.js"), WFSSourceWorker: () => import("./WFSSourceWorker.js"), WorkerTileHandler: () => import("./WorkerTileHandler.js") }, { CLOSE: b$E, ABORT: v$D, INVOKE: y$U, RESPONSE: j$t, OPEN_PORT: S$s, ON: f$_ } = t$19, W$7 = 2;
class M$h {
  constructor(e2) {
    this._timer = null, this._cancelledJobIds = new Set(), this._invokeMessages = [], this._invoke = e2, this._timer = null, this._process = this._process.bind(this);
  }
  push(e2) {
    e2.type === t$19.ABORT ? this._cancelledJobIds.add(e2.jobId) : (this._invokeMessages.push(e2), this._timer === null && (this._timer = setTimeout(this._process, 0)));
  }
  clear() {
    this._invokeMessages.length = 0, this._cancelledJobIds.clear(), this._timer = null;
  }
  _process() {
    this._timer = null;
    for (const e2 of this._invokeMessages)
      this._cancelledJobIds.has(e2.jobId) || this._invoke(e2);
    this._cancelledJobIds.clear(), this._invokeMessages.length = 0;
  }
}
class w$z {
  constructor(e2, s2, t2) {
    this._port = e2, this._getNextJob = t2, this._outJobs = new Map(), this._inJobs = new Map(), this._invokeQueue = new M$h((e3) => this._onInvokeMessage(e3)), this._client = s2.client, this._onMessage = this._onMessage.bind(this), this._channel = s2.channel, this._schedule = s2.schedule, this._port.addEventListener("message", this._onMessage), this._port.start();
  }
  static connect(e2) {
    const s2 = new MessageChannel();
    let t2;
    t2 = typeof e2 == "function" ? new e2() : "default" in e2 && typeof e2.default == "function" ? new e2.default() : e2;
    const o2 = new w$z(s2.port1, { channel: s2, client: t2 }, () => null);
    return typeof t2 == "object" && "remoteClient" in t2 && (t2.remoteClient = o2), w$z.clients.set(o2, t2), s2.port2;
  }
  static loadWorker(e2) {
    const s2 = k$i[e2];
    return s2 ? s2() : Promise.resolve(null);
  }
  close() {
    this._post({ type: b$E }), this._close();
  }
  isBusy() {
    return this._outJobs.size > 0;
  }
  invoke(e2, t2, r2) {
    const c2 = r2 && r2.signal, l2 = r2 && r2.transferList;
    if (!this._port)
      return Promise.reject(new s$1Z("worker:port-closed", `Cannot call invoke('${e2}'), port is closed`, { methodName: e2, data: t2 }));
    const h2 = r$X();
    return new Promise((s2, r3) => {
      if (p$2W(c2))
        return this._processWork(), void r3(a$2p());
      const p2 = v$S(c2, () => {
        const e3 = this._outJobs.get(h2);
        e3 && (this._outJobs.delete(h2), this._processWork(), h$1s(e3.abortHandle), this._post({ type: v$D, jobId: h2 }), r3(a$2p()));
      }), u2 = { resolve: s2, reject: r3, abortHandle: p2, debugInfo: e2 };
      this._outJobs.set(h2, u2), this._post({ type: y$U, jobId: h2, methodName: e2, abortable: c2 != null }, t2, l2);
    });
  }
  on(e2, s2) {
    const t2 = new MessageChannel();
    function o2(e3) {
      s2(e3.data);
    }
    return this._port.postMessage({ type: t$19.ON, eventType: e2, port: t2.port2 }, [t2.port2]), t2.port1.addEventListener("message", o2), t2.port1.start(), { remove() {
      t2.port1.postMessage({ type: t$19.CLOSE }), t2.port1.close(), t2.port1.removeEventListener("message", o2);
    } };
  }
  jobAdded() {
    this._processWork();
  }
  openPort() {
    const e2 = new MessageChannel();
    return this._post({ type: S$s, port: e2.port2 }), e2.port1;
  }
  _processWork() {
    if (this._outJobs.size >= W$7)
      return;
    const e2 = this._getNextJob();
    if (!e2)
      return;
    const { methodName: s2, data: t2, invokeOptions: o2, deferred: r2 } = e2;
    this.invoke(s2, t2, o2).then((e3) => r2.resolve(e3)).catch((e3) => r2.reject(e3));
  }
  _close() {
    this._channel && (this._channel = void 0), this._port.removeEventListener("message", this._onMessage), this._port.close(), this._outJobs.forEach((e2) => {
      h$1s(e2.abortHandle), e2.reject(a$2p(`Worker closing, aborting job calling '${e2.debugInfo}'`));
    }), this._inJobs.clear(), this._outJobs.clear(), this._invokeQueue.clear(), this._port = this._client = this._schedule = null;
  }
  _onMessage(e2) {
    r$1t(this._schedule) ? this._schedule(() => this._processMessage(e2)) : this._processMessage(e2);
  }
  _processMessage(e2) {
    const s2 = f$$(e2);
    if (s2)
      switch (s2.type) {
        case j$t:
          this._onResponseMessage(s2);
          break;
        case y$U:
          this._invokeQueue.push(s2);
          break;
        case v$D:
          this._onAbortMessage(s2);
          break;
        case b$E:
          this._onCloseMessage();
          break;
        case S$s:
          this._onOpenPortMessage(s2);
          break;
        case f$_:
          this._onOnMessage(s2);
      }
  }
  _onAbortMessage(e2) {
    const s2 = this._inJobs, t2 = e2.jobId, o2 = s2.get(t2);
    this._invokeQueue.push(e2), o2 && (o2.controller && o2.controller.abort(), s2.delete(t2));
  }
  _onCloseMessage() {
    const e2 = this._client;
    this._close(), e2 && "destroy" in e2 && w$z.clients.get(this) === e2 && e2.destroy(), w$z.clients.delete(this), e2 && e2.remoteClient && (e2.remoteClient = null);
  }
  _onInvokeMessage(e2) {
    const { methodName: s2, jobId: t2, data: o2, abortable: r2 } = e2, i2 = r2 ? new AbortController() : null, n2 = this._inJobs;
    let a2, p2 = this._client, h2 = p2[s2];
    try {
      if (!h2 && s2 && s2.includes(".")) {
        const e3 = s2.split(".");
        for (let s3 = 0; s3 < e3.length - 1; s3++)
          p2 = p2[e3[s3]], h2 = p2[e3[s3 + 1]];
      }
      if (typeof h2 != "function")
        throw new TypeError(`${s2} is not a function`);
      a2 = h2.call(p2, o2, { client: this, signal: i2 ? i2.signal : null });
    } catch (u2) {
      return void this._post({ type: j$t, jobId: t2, error: s$1g(u2) });
    }
    C$q(a2) ? (n2.set(t2, { controller: i2, promise: a2 }), a2.then((e3) => {
      n2.has(t2) && (n2.delete(t2), this._post({ type: j$t, jobId: t2 }, e3));
    }, (e3) => {
      n2.has(t2) && (n2.delete(t2), j$K(e3) || this._post({ type: j$t, jobId: t2, error: s$1g(e3 || { message: `Error encountered at method ${s2}` }) }));
    })) : this._post({ type: j$t, jobId: t2 }, a2);
  }
  _onOpenPortMessage(e2) {
    new w$z(e2.port, { client: this._client }, () => null);
  }
  _onOnMessage(e2) {
    const { port: s2 } = e2, o2 = this._client.on(e2.eventType, (e3) => {
      s2.postMessage(e3);
    }), r2 = r$1j(e2.port, "message", (e3) => {
      var _a2;
      ((_a2 = f$$(e3)) == null ? void 0 : _a2.type) === t$19.CLOSE && (r2.remove(), o2.remove(), s2.close());
    });
  }
  _onResponseMessage(e2) {
    const { jobId: t2, error: r2, data: i2 } = e2, n2 = this._outJobs;
    if (!n2.has(t2))
      return;
    const a2 = n2.get(t2);
    n2.delete(t2), this._processWork(), h$1s(a2.abortHandle), r2 ? a2.reject(s$1Z.fromJSON(JSON.parse(r2))) : a2.resolve(i2);
  }
  _post(e2, s2, t2) {
    return o$1a(this._port, e2, s2, t2);
  }
}
w$z.kernelInfo = { revision: f$16, version: a$1S, buildDate: e$1b }, w$z.clients = new Map();
class h$R {
  constructor() {
    this._inUseClients = new Array(), this._clients = new Array(), this._clientPromises = new Array(), this._ongoingJobsQueue = new e$17();
  }
  destroy() {
    this.close();
  }
  get closed() {
    return !this._clients || !this._clients.length;
  }
  open(e2, t2) {
    return new Promise((n2, i2) => {
      let r2 = true;
      const h2 = (e3) => {
        f$1x(t2.signal), r2 && (r2 = false, e3());
      };
      this._clients.length = e2.length, this._clientPromises.length = e2.length, this._inUseClients.length = e2.length;
      for (let o2 = 0; o2 < e2.length; ++o2) {
        const r3 = e2[o2];
        C$q(r3) ? this._clientPromises[o2] = r3.then((e3) => (this._clients[o2] = new w$z(e3, t2, () => {
          var _a2;
          return (_a2 = this._ongoingJobsQueue.pop()) != null ? _a2 : null;
        }), h2(n2), this._clients[o2]), () => (h2(i2), null)) : (this._clients[o2] = new w$z(r3, t2, () => {
          var _a2;
          return (_a2 = this._ongoingJobsQueue.pop()) != null ? _a2 : null;
        }), this._clientPromises[o2] = Promise.resolve(this._clients[o2]), h2(n2));
      }
    });
  }
  broadcast(e2, t2, s2) {
    const n2 = new Array(this._clientPromises.length);
    for (let i2 = 0; i2 < this._clientPromises.length; ++i2) {
      const o2 = this._clientPromises[i2];
      n2[i2] = o2.then((n3) => n3 == null ? void 0 : n3.invoke(e2, t2, s2));
    }
    return n2;
  }
  close() {
    let e2;
    for (; e2 = this._ongoingJobsQueue.pop(); )
      e2.deferred.reject(a$2p(`Worker closing, aborting job calling '${e2.methodName}'`));
    for (const t2 of this._clientPromises)
      t2.then((e3) => e3 == null ? void 0 : e3.close());
    this._clients.length = 0, this._clientPromises.length = 0;
  }
  invoke(e2, s2, n2) {
    let o2;
    Array.isArray(n2) ? (s$22.getLogger("esri.core.workers.Connection").warn("invoke()", "The transferList parameter is deprecated, use the options object instead"), o2 = { transferList: n2 }) : o2 = n2;
    const r2 = A$p();
    this._ongoingJobsQueue.push({ methodName: e2, data: s2, invokeOptions: o2, deferred: r2 });
    for (let t2 = 0; t2 < this._clientPromises.length; t2++) {
      const e3 = this._clients[t2];
      e3 ? e3.jobAdded() : this._clientPromises[t2].then((e4) => e4 == null ? void 0 : e4.jobAdded());
    }
    return r2.promise;
  }
  on(t2, s2) {
    return Promise.all(this._clientPromises).then(() => r$1p(this._clients.map((e2) => e2.on(t2, s2))));
  }
  openPorts() {
    return new Promise((e2) => {
      const t2 = new Array(this._clientPromises.length);
      let s2 = t2.length;
      for (let n2 = 0; n2 < this._clientPromises.length; ++n2) {
        this._clientPromises[n2].then((i2) => {
          i2 && (t2[n2] = i2.openPort()), --s2 == 0 && e2(t2);
        });
      }
    });
  }
  get test() {
    return { numClients: this._clients.length };
  }
}
const i$1B = s$22.getLogger("esri.assets");
function a$1G(t2) {
  if (!s$23.assetsPath)
    throw i$1B.errorOnce("The API assets location needs to be set using config.assetsPath. More information: https://arcg.is/1OzLe50"), new s$1Z("assets:path-not-set", "config.assetsPath is not set");
  return G$c(s$23.assetsPath, t2);
}
const i$1A = s$22.getLogger("esri.intl.substitute");
function s$1f(t2, r2, n2 = {}) {
  const { format: o2 = {} } = n2;
  return n$2m(t2, (t3) => u$16(t3, r2, o2));
}
function u$16(t2, e2, n2) {
  var _a2;
  let o2, i2;
  const s2 = t2.indexOf(":");
  if (s2 === -1 ? o2 = t2.trim() : (o2 = t2.slice(0, s2).trim(), i2 = t2.slice(s2 + 1).trim()), !o2)
    return "";
  const u2 = t$1T(o2, e2);
  if (u2 == null)
    return "";
  const m2 = (_a2 = i2 ? n2 == null ? void 0 : n2[i2] : null) != null ? _a2 : n2 == null ? void 0 : n2[o2];
  return m2 ? c$1L(u2, m2) : i2 ? a$1F(u2, i2) : f$Z(u2);
}
function c$1L(t2, r2) {
  switch (r2.type) {
    case "date":
      return L$p(t2, r2.intlOptions);
    case "number":
      return m$1A(t2, r2.intlOptions);
    default:
      return i$1A.warn("missing format descriptor for key {key}"), f$Z(t2);
  }
}
function a$1F(t2, r2) {
  switch (r2.toLowerCase()) {
    case "dateformat":
      return L$p(t2);
    case "numberformat":
      return m$1A(t2);
    default:
      return i$1A.warn(`inline format is unsupported since 4.12: ${r2}`), /^(dateformat|datestring)/i.test(r2) ? L$p(t2) : /^numberformat/i.test(r2) ? m$1A(t2) : f$Z(t2);
  }
}
function f$Z(t2) {
  switch (typeof t2) {
    case "string":
      return t2;
    case "number":
      return m$1A(t2);
    case "boolean":
      return "" + t2;
    default:
      return t2 instanceof Date ? L$p(t2) : "";
  }
}
const r$W = /^([a-z]{2})(?:[-_]([A-Za-z]{2}))?$/, o$19 = { ar: true, bg: true, bs: true, ca: true, cs: true, da: true, de: true, el: true, en: true, es: true, et: true, fi: true, fr: true, he: true, hr: true, hu: true, id: true, it: true, ja: true, ko: true, lt: true, lv: true, nb: true, nl: true, pl: true, "pt-BR": true, "pt-PT": true, ro: true, ru: true, sk: true, sl: true, sr: true, sv: true, th: true, tr: true, uk: true, vi: true, "zh-CN": true, "zh-HK": true, "zh-TW": true };
function i$1z(t2) {
  var _a2;
  return (_a2 = o$19[t2]) != null ? _a2 : false;
}
const a$1E = [], c$1K = new Map();
function d$$(t2) {
  for (const e2 of c$1K.keys())
    _$s(t2.pattern, e2) && c$1K.delete(e2);
}
function l$1e(t2) {
  return a$1E.includes(t2) || (d$$(t2), a$1E.unshift(t2)), { remove() {
    const e2 = a$1E.indexOf(t2);
    e2 > -1 && (a$1E.splice(e2, 1), d$$(t2));
  } };
}
async function u$15(t2) {
  const e2 = l$1Q();
  c$1K.has(t2) || c$1K.set(t2, f$Y(t2, e2));
  const n2 = c$1K.get(t2);
  return n2 && await m$13.add(n2), n2;
}
function h$Q(t2) {
  if (!r$W.test(t2))
    return null;
  const e2 = r$W.exec(t2);
  if (e2 === null)
    return null;
  const [, n2, s2] = e2, o2 = n2 + (s2 ? "-" + s2.toUpperCase() : "");
  return i$1z(o2) ? o2 : i$1z(n2) ? n2 : null;
}
async function f$Y(e2, n2) {
  const s2 = [];
  for (const t2 of a$1E)
    if (_$s(t2.pattern, e2))
      try {
        return await t2.fetchMessageBundle(e2, n2);
      } catch (r2) {
        s2.push(r2);
      }
  if (s2.length)
    throw new s$1Z("intl:message-bundle-error", `Errors occurred while loading "${e2}"`, { errors: s2 });
  throw new s$1Z("intl:no-message-bundle-loader", `No loader found for message bundle "${e2}"`);
}
function _$s(t2, e2) {
  return typeof t2 == "string" ? e2.startsWith(t2) : t2.test(e2);
}
g$S(() => {
  c$1K.clear();
});
const m$13 = new class {
  constructor() {
    this._numLoading = 0, this._dfd = null;
  }
  async waitForAll() {
    this._dfd && await this._dfd.promise;
  }
  add(t2) {
    return this._increase(), t2.then(() => this._decrease(), () => this._decrease()), this.waitForAll();
  }
  _increase() {
    this._numLoading++, this._dfd || (this._dfd = A$p());
  }
  _decrease() {
    this._numLoading = Math.max(this._numLoading - 1, 0), this._dfd && this._numLoading === 0 && (this._dfd.resolve(), this._dfd = null);
  }
}();
async function o$18(e2, n2, o2, i2) {
  const a2 = n2.exec(o2);
  if (!a2)
    throw new s$1Z("esri-intl:invalid-bundle", `Bundle id "${o2}" is not compatible with the pattern "${n2}"`);
  const c2 = a2[1] ? `${a2[1]}/` : "", l2 = a2[2], w2 = h$Q(i2), h2 = `${c2}${l2}.json`, u2 = w2 ? `${c2}${l2}_${w2}.json` : h2;
  let f2;
  try {
    f2 = await s$1e(e2(u2));
  } catch (d2) {
    if (u2 === h2)
      throw new s$1Z("intl:unknown-bundle", `Bundle "${o2}" cannot be loaded`, { error: d2 });
    try {
      f2 = await s$1e(e2(h2));
    } catch (d3) {
      throw new s$1Z("intl:unknown-bundle", `Bundle "${o2}" cannot be loaded`, { error: d3 });
    }
  }
  return f2;
}
async function s$1e(t2) {
  if (r$1t(c$1J.fetchBundleAsset))
    return c$1J.fetchBundleAsset(t2);
  const r2 = await U$k(t2, { responseType: "text" });
  return JSON.parse(r2.data);
}
class i$1y {
  constructor({ base: e2 = "", pattern: t2, location: n2 = new URL(window.location.href) }) {
    let r2;
    r2 = typeof n2 == "string" ? (e3) => new URL(e3, new URL(n2, window.location.href)).href : n2 instanceof URL ? (e3) => new URL(e3, n2).href : n2, this.pattern = typeof t2 == "string" ? new RegExp(`^${t2}`) : t2, this.getAssetUrl = r2, e2 = e2 ? e2.endsWith("/") ? e2 : e2 + "/" : "", this.matcher = new RegExp(`^${e2}(?:(.*)/)?(.*)$`);
  }
  fetchMessageBundle(e2, t2) {
    return o$18(this.getAssetUrl, this.matcher, e2, t2);
  }
}
function a$1D(e2) {
  return new i$1y(e2);
}
const c$1J = {};
l$1e(a$1D({ pattern: "esri/", location: a$1G }));
const a$1C = {};
function e$15(s2, a2) {
  for (const e2 of s2)
    if (e2.name === a2.name)
      return;
  s2.push(a2);
}
function r$V(s2) {
  var _a2;
  const r2 = { async: s2.async, isDebug: s2.isDebug, locale: s2.locale, baseUrl: s2.baseUrl, has: __spreadValues({}, s2.has), map: __spreadValues({}, s2.map), packages: s2.packages && s2.packages.concat() || [], paths: __spreadValues({}, s2.paths) };
  return s2.hasOwnProperty("async") || (r2.async = true), s2.hasOwnProperty("isDebug") || (r2.isDebug = false), s2.baseUrl || (r2.baseUrl = a$1C.baseUrl), (_a2 = a$1C.packages) == null ? void 0 : _a2.forEach((s3) => {
    var _a3;
    e$15((_a3 = r2.packages) != null ? _a3 : [], s3);
  }), r2;
}
class n$1z {
  constructor() {
    const e2 = document.createDocumentFragment();
    ["addEventListener", "dispatchEvent", "removeEventListener"].forEach((s2) => {
      this[s2] = (...r2) => e2[s2](...r2);
    });
  }
}
class a$1B {
  constructor() {
    this._dispatcher = new n$1z(), this._workerPostMessage({ type: t$19.HANDSHAKE });
  }
  terminate() {
  }
  get onmessage() {
    return this._onmessageHandler;
  }
  set onmessage(e2) {
    this._onmessageHandler && this.removeEventListener("message", this._onmessageHandler), this._onmessageHandler = e2, e2 && this.addEventListener("message", e2);
  }
  get onmessageerror() {
    return this._onmessageerrorHandler;
  }
  set onmessageerror(e2) {
    this._onmessageerrorHandler && this.removeEventListener("messageerror", this._onmessageerrorHandler), this._onmessageerrorHandler = e2, e2 && this.addEventListener("messageerror", e2);
  }
  get onerror() {
    return this._onerrorHandler;
  }
  set onerror(e2) {
    this._onerrorHandler && this.removeEventListener("error", this._onerrorHandler), this._onerrorHandler = e2, e2 && this.addEventListener("error", e2);
  }
  postMessage(s2) {
    t$1H(() => {
      this._workerMessageHandler(new MessageEvent("message", { data: s2 }));
    });
  }
  dispatchEvent(e2) {
    return this._dispatcher.dispatchEvent(e2);
  }
  addEventListener(e2, s2, r2) {
    this._dispatcher.addEventListener(e2, s2, r2);
  }
  removeEventListener(e2, s2, r2) {
    this._dispatcher.removeEventListener(e2, s2, r2);
  }
  _workerPostMessage(s2) {
    t$1H(() => {
      this.dispatchEvent(new MessageEvent("message", { data: s2 }));
    });
  }
  async _workerMessageHandler(e2) {
    const n2 = f$$(e2);
    if (n2 && n2.type === t$19.OPEN) {
      const { modulePath: e3, jobId: t2 } = n2;
      let a2 = await w$z.loadWorker(e3);
      a2 || (a2 = await import(
        /* @vite-ignore */
        /* webpackIgnore: true */
        e3
      ));
      const o2 = w$z.connect(a2);
      this._workerPostMessage({ type: t$19.OPENED, jobId: t2, data: o2 });
    }
  }
}
const u$14 = s$22.getLogger("esri.core.workers.workerFactory"), { HANDSHAKE: m$12 } = t$19, p$1X = 'let globalId=0;const outgoing=new Map,configuration=JSON.parse("{CONFIGURATION}");self.esriConfig=configuration.esriConfig;const workerPath=self.esriConfig.workers.workerPath,HANDSHAKE=0,OPEN=1,OPENED=2,RESPONSE=3,INVOKE=4,ABORT=5;function createAbortError(){const e=new Error("Aborted");return e.name="AbortError",e}function receiveMessage(e){return e&&e.data?"string"==typeof e.data?JSON.parse(e.data):e.data:null}function invokeStaticMessage(e,o,r){const t=r&&r.signal,n=globalId++;return new Promise(((r,i)=>{if(t){if(t.aborted)return i(createAbortError());t.addEventListener("abort",(()=>{outgoing.get(n)&&(outgoing.delete(n),self.postMessage({type:5,jobId:n}),i(createAbortError()))}))}outgoing.set(n,{resolve:r,reject:i}),self.postMessage({type:4,jobId:n,methodName:e,abortable:null!=t,data:o})}))}let workerRevisionChecked=!1;function checkWorkerRevision(e){if(!workerRevisionChecked&&e.kernelInfo){workerRevisionChecked=!0;const{revision:o,version:r}=configuration.kernelInfo,{revision:t,version:n}=e.kernelInfo;esriConfig.assetsPath!==esriConfig.defaultAssetsPath&&o!==t&&console.warn(`Version mismatch detected between ArcGIS API for JavaScript modules and assets. For more information visit https://bit.ly/3QnsuSo.\\nModules version: ${r}\\nAssets version: ${n}`)}}function messageHandler(e){const o=receiveMessage(e);if(!o)return;const r=o.jobId;switch(o.type){case 1:let n;function t(e){const o=n.connect(e);self.postMessage({type:2,jobId:r,data:o},[o])}"function"==typeof define&&define.amd?require([workerPath],(e=>{n=e.default||e,checkWorkerRevision(n),n.loadWorker(o.modulePath).then((e=>e||new Promise((e=>{require([o.modulePath],e)})))).then(t)})):"System"in self&&"function"==typeof System.import?System.import(workerPath).then((e=>(n=e.default,checkWorkerRevision(n),n.loadWorker(o.modulePath)))).then((e=>e||System.import(o.modulePath))).then(t):esriConfig.workers.useDynamicImport?import(workerPath).then((e=>{n=e.default||e,checkWorkerRevision(n),n.loadWorker(o.modulePath).then((e=>e||import(o.modulePath))).then(t)})):(self.RemoteClient||importScripts(workerPath),n=self.RemoteClient.default||self.RemoteClient,checkWorkerRevision(n),n.loadWorker(o.modulePath).then(t));break;case 3:if(outgoing.has(r)){const i=outgoing.get(r);outgoing.delete(r),o.error?i.reject(JSON.parse(o.error)):i.resolve(o.data)}}}self.dojoConfig=configuration.loaderConfig,esriConfig.workers.loaderUrl&&(self.importScripts(esriConfig.workers.loaderUrl),"function"==typeof require&&"function"==typeof require.config&&require.config(configuration.loaderConfig)),self.addEventListener("message",messageHandler),self.postMessage({type:0});';
let g$I, k$h;
const h$P = "Failed to create Worker. Fallback to execute module in main thread";
async function w$y() {
  if (!has("esri-workers") || (has("mozilla"), 0))
    return y$T(new a$1B());
  if (!g$I && !k$h)
    try {
      const e3 = p$1X.split('"{CONFIGURATION}"').join(`'${b$D()}'`);
      g$I = URL.createObjectURL(new Blob([e3], { type: "text/javascript" }));
    } catch (r2) {
      k$h = r2 || {};
    }
  let e2;
  if (g$I)
    try {
      e2 = new Worker(g$I, { name: "esri-worker-" + v$C++ });
    } catch (r2) {
      u$14.warn(h$P, k$h), e2 = new a$1B();
    }
  else
    u$14.warn(h$P, k$h), e2 = new a$1B();
  return y$T(e2);
}
async function y$T(e2) {
  return new Promise((r2) => {
    function o2(s2) {
      const n2 = f$$(s2);
      n2 && n2.type === m$12 && (e2.removeEventListener("message", o2), e2.removeEventListener("error", t2), r2(e2));
    }
    function t2(r3) {
      r3.preventDefault(), e2.removeEventListener("message", o2), e2.removeEventListener("error", t2), u$14.warn("Failed to create Worker. Fallback to execute module in main thread", r3), (e2 = new a$1B()).addEventListener("message", o2), e2.addEventListener("error", t2);
    }
    e2.addEventListener("message", o2), e2.addEventListener("error", t2);
  });
}
function b$D() {
  let t2;
  if (s$23.default != null) {
    const e2 = __spreadValues({}, s$23);
    delete e2.default, t2 = JSON.parse(JSON.stringify(e2));
  } else
    t2 = JSON.parse(JSON.stringify(s$23));
  t2.assetsPath = Q$9(t2.assetsPath), t2.defaultAssetsPath = t2.defaultAssetsPath ? Q$9(t2.defaultAssetsPath) : void 0, t2.request.interceptors = [], t2.log.interceptors = [], t2.locale = l$1Q(), t2.has = { "esri-csp-restrictions": has("esri-csp-restrictions"), "esri-2d-debug": false, "esri-2d-update-debug": has("esri-2d-update-debug"), "featurelayer-pbf": has("featurelayer-pbf"), "featurelayer-simplify-thresholds": has("featurelayer-simplify-thresholds"), "featurelayer-simplify-payload-size-factors": has("featurelayer-simplify-payload-size-factors"), "featurelayer-simplify-mobile-factor": has("featurelayer-simplify-mobile-factor"), "esri-atomics": has("esri-atomics"), "esri-shared-array-buffer": has("esri-shared-array-buffer"), "esri-tiles-debug": has("esri-tiles-debug"), "esri-workers-arraybuffer-transfer": has("esri-workers-arraybuffer-transfer"), "feature-polyline-generalization-factor": has("feature-polyline-generalization-factor"), "host-webworker": 1, "polylabel-placement-enabled": has("polylabel-placement-enabled") }, t2.workers.loaderUrl && (t2.workers.loaderUrl = Q$9(t2.workers.loaderUrl)), t2.workers.workerPath ? t2.workers.workerPath = Q$9(t2.workers.workerPath) : t2.workers.workerPath = Q$9(a$1G("esri/core/workers/RemoteClient.js")), t2.workers.useDynamicImport = false;
  const i2 = s$23.workers.loaderConfig, a2 = r$V({ baseUrl: i2 == null ? void 0 : i2.baseUrl, locale: l$1Q(), has: __spreadValues({ "csp-restrictions": 1, "dojo-test-sniff": 0, "host-webworker": 1 }, i2 == null ? void 0 : i2.has), map: __spreadValues({}, i2 == null ? void 0 : i2.map), paths: __spreadValues({}, i2 == null ? void 0 : i2.paths), packages: (i2 == null ? void 0 : i2.packages) || [] }), l2 = { version: a$1S, buildDate: e$1b, revision: f$16 };
  return JSON.stringify({ esriConfig: t2, loaderConfig: a2, kernelInfo: l2 });
}
let v$C = 0;
const { ABORT: b$C, INVOKE: m$11, OPEN: _$r, OPENED: g$H, RESPONSE: u$13 } = t$19;
class j$s {
  constructor(e2, t2) {
    this._outJobs = new Map(), this._inJobs = new Map(), this.worker = e2, this.id = t2, e2.addEventListener("message", this._onMessage.bind(this)), e2.addEventListener("error", (e3) => {
      e3.preventDefault(), s$22.getLogger("esri.core.workers.WorkerOwner").error(e3);
    });
  }
  static async create(e2) {
    const t2 = await w$y();
    return new j$s(t2, e2);
  }
  terminate() {
    this.worker.terminate();
  }
  async open(e2, t2 = {}) {
    const { signal: o2 } = t2, s2 = r$X();
    return new Promise((t3, n2) => {
      const a2 = { resolve: t3, reject: n2, abortHandle: d$1x(o2, () => {
        this._outJobs.delete(s2), this._post({ type: b$C, jobId: s2 });
      }) };
      this._outJobs.set(s2, a2), this._post({ type: _$r, jobId: s2, modulePath: e2 });
    });
  }
  _onMessage(e2) {
    const t2 = f$$(e2);
    if (t2)
      switch (t2.type) {
        case g$H:
          this._onOpenedMessage(t2);
          break;
        case u$13:
          this._onResponseMessage(t2);
          break;
        case b$C:
          this._onAbortMessage(t2);
          break;
        case m$11:
          this._onInvokeMessage(t2);
      }
  }
  _onAbortMessage(e2) {
    const t2 = this._inJobs, o2 = e2.jobId, s2 = t2.get(o2);
    s2 && (s2.controller && s2.controller.abort(), t2.delete(o2));
  }
  _onInvokeMessage(t2) {
    const { methodName: o2, jobId: s2, data: r2, abortable: i2 } = t2, l2 = i2 ? new AbortController() : null, h2 = this._inJobs, c2 = r$Z[o2];
    let p2;
    try {
      if (typeof c2 != "function")
        throw new TypeError(`${o2} is not a function`);
      p2 = c2.call(null, r2, { signal: l2 ? l2.signal : null });
    } catch (b2) {
      return void this._post({ type: u$13, jobId: s2, error: s$1g(b2) });
    }
    C$q(p2) ? (h2.set(s2, { controller: l2, promise: p2 }), p2.then((e2) => {
      h2.has(s2) && (h2.delete(s2), this._post({ type: u$13, jobId: s2 }, e2));
    }, (e2) => {
      h2.has(s2) && (h2.delete(s2), e2 || (e2 = { message: "Error encountered at method" + o2 }), j$K(e2) || this._post({ type: u$13, jobId: s2, error: s$1g(e2 || { message: `Error encountered at method ${o2}` }) }));
    })) : this._post({ type: u$13, jobId: s2 }, p2);
  }
  _onOpenedMessage(e2) {
    const { jobId: t2, data: o2 } = e2, r2 = this._outJobs.get(t2);
    r2 && (this._outJobs.delete(t2), h$1s(r2.abortHandle), r2.resolve(o2));
  }
  _onResponseMessage(e2) {
    const { jobId: o2, error: r2, data: n2 } = e2, a2 = this._outJobs.get(o2);
    a2 && (this._outJobs.delete(o2), h$1s(a2.abortHandle), r2 ? a2.reject(s$1Z.fromJSON(JSON.parse(r2))) : a2.resolve(n2));
  }
  _post(e2, t2, o2) {
    return o$1a(this.worker, e2, t2, o2);
  }
}
let i$1x = has("esri-workers-debug") ? 1 : has("esri-mobile") ? Math.min(navigator.hardwareConcurrency - 1, 3) : has("host-browser") ? navigator.hardwareConcurrency - 1 : 0;
i$1x || (i$1x = has("safari") && has("mac") || has("trident") ? 7 : 2);
let a$1A = 0;
const s$1d = [];
function l$1d() {
  d$_();
}
async function m$10(r2, t2) {
  const o2 = new h$R();
  return await o2.open(r2, t2), o2;
}
async function u$12(e2, n2 = {}) {
  if (typeof e2 != "string")
    throw new s$1Z("workers:undefined-module", "modulePath is missing");
  let l2 = n2.strategy || "distributed";
  if (has("host-webworker") && !has("esri-workers") && (l2 = "local"), l2 === "local") {
    let r2 = await w$z.loadWorker(e2);
    r2 || (r2 = await import(
      /* @vite-ignore */
      /* webpackIgnore: true */
      e2
    )), f$1x(n2.signal);
    const i2 = n2.client || r2;
    return m$10([w$z.connect(r2)], __spreadProps(__spreadValues({}, n2), { client: i2 }));
  }
  if (await d$_(), f$1x(n2.signal), l2 === "dedicated") {
    const r2 = a$1A++ % i$1x;
    return m$10([await s$1d[r2].open(e2, n2)], n2);
  }
  if (n2.maxNumWorkers && n2.maxNumWorkers > 0) {
    const r2 = Math.min(n2.maxNumWorkers, i$1x);
    if (r2 < i$1x) {
      const t2 = new Array(r2);
      for (let o2 = 0; o2 < r2; ++o2) {
        const r3 = a$1A++ % i$1x;
        t2[o2] = s$1d[r3].open(e2, n2);
      }
      return m$10(t2, n2);
    }
  }
  return m$10(s$1d.map((r2) => r2.open(e2, n2)), n2);
}
let p$1W = null;
async function d$_() {
  if (p$1W)
    return p$1W;
  new AbortController();
  const r2 = [];
  for (let t2 = 0; t2 < i$1x; t2++) {
    const e2 = j$s.create(t2).then((r3) => (s$1d[t2] = r3, r3));
    r2.push(e2);
  }
  return p$1W = Promise.all(r2), p$1W;
}
function G$9(n2) {
  return new k$p({ wkt: `GEOCCS["Spherical geocentric",
    DATUM["Not specified",
      SPHEROID["Sphere",${n2.radius},0]],
    PRIMEM["Greenwich",0.0,
      AUTHORITY["EPSG","8901"]],
    UNIT["m",1.0],
    AXIS["Geocentric X",OTHER],
    AXIS["Geocentric Y",EAST],
    AXIS["Geocentric Z",NORTH]
  ]` });
}
const I$l = G$9(s$1M), E$l = G$9(t$1y), R$h = G$9(e$1A), p$1V = new k$p({ wkt: `GEOCCS["WGS 84",
  DATUM["WGS_1984",
    SPHEROID["WGS 84",${s$1M.radius},298.257223563,
      AUTHORITY["EPSG","7030"]],
    AUTHORITY["EPSG","6326"]],
  PRIMEM["Greenwich",0,
    AUTHORITY["EPSG","8901"]],
  UNIT["m",1.0,
    AUTHORITY["EPSG","9001"]],
  AXIS["Geocentric X",OTHER],
  AXIS["Geocentric Y",OTHER],
  AXIS["Geocentric Z",NORTH],
  AUTHORITY["EPSG","4978"]
]` });
function O$f(n2) {
  return n2 && (P$p(n2) || n2 === E$l) ? E$l : n2 && (s$1O(n2) || n2 === R$h) ? R$h : I$l;
}
function u$11(e2) {
  return r$1t(e2) && (P$p(e2) || e2 === E$l) ? t$1y : r$1t(e2) && (s$1O(e2) || e2 === R$h) ? e$1A : s$1M;
}
function s$1c(n2) {
  return w$L(n2) ? t$1y : C$p(n2) ? e$1A : s$1M;
}
const f$X = 39.37, d$Z = s$1M.radius * Math.PI / 200, U$h = /UNIT\[([^\]]+)\]\]$/i, q$9 = r$1g, h$O = /UNIT\[([^\]]+)\]/i, B$c = new Set([4261, 4305, 4807, 4810, 4811, 4812, 4816, 4819, 4821, 4901, 4902, 37225, 104139, 104140]), p$1U = o$1w()({ meter: "meters", foot: "feet", foot_us: "us-feet", foot_clarke: "clarke-feet", yard_clarke: "clarke-yards", link_clarke: "clarke-links", yard_sears: "sears-yards", foot_sears: "sears-feet", chain_sears: "sears-chains", chain_benoit_1895_b: "benoit-1895-b-chains", yard_indian: "indian-yards", yard_indian_1937: "indian-1937-yards", foot_gold_coast: "gold-coast-feet", chain_sears_1922_truncated: "sears-1922-truncated-chains", "50_kilometers": "50-kilometers", "150_kilometers": "150-kilometers" }), k$g = (e2) => e2 * e2, b$B = (e2) => e2 * e2 * e2, y$S = { length: { baseUnit: "meters", units: { millimeters: { inBaseUnits: 1e-3 }, centimeters: { inBaseUnits: 0.01 }, decimeters: { inBaseUnits: 0.1 }, meters: { inBaseUnits: 1 }, kilometers: { inBaseUnits: 1e3 }, inches: { inBaseUnits: 0.0254 }, feet: { inBaseUnits: 0.3048 }, yards: { inBaseUnits: 0.9144 }, miles: { inBaseUnits: 1609.344 }, "nautical-miles": { inBaseUnits: 1852 }, "us-feet": { inBaseUnits: 1200 / 3937 } } }, area: { baseUnit: "square-meters", units: { "square-millimeters": { inBaseUnits: k$g(1e-3) }, "square-centimeters": { inBaseUnits: k$g(0.01) }, "square-decimeters": { inBaseUnits: k$g(0.1) }, "square-meters": { inBaseUnits: 1 }, "square-kilometers": { inBaseUnits: k$g(1e3) }, "square-inches": { inBaseUnits: k$g(0.0254) }, "square-feet": { inBaseUnits: k$g(0.3048) }, "square-yards": { inBaseUnits: k$g(0.9144) }, "square-miles": { inBaseUnits: k$g(1609.344) }, "square-us-feet": { inBaseUnits: k$g(1200 / 3937) }, acres: { inBaseUnits: 15625e-7 * k$g(1609.344) }, ares: { inBaseUnits: 100 }, hectares: { inBaseUnits: 1e4 } } }, volume: { baseUnit: "liters", units: { liters: { inBaseUnits: 1 }, "cubic-millimeters": { inBaseUnits: 1e3 * b$B(1e-3) }, "cubic-centimeters": { inBaseUnits: 1e3 * b$B(0.01) }, "cubic-decimeters": { inBaseUnits: 1e3 * b$B(0.1) }, "cubic-meters": { inBaseUnits: 1e3 }, "cubic-kilometers": { inBaseUnits: 1e3 * b$B(1e3) }, "cubic-inches": { inBaseUnits: 1e3 * b$B(0.0254) }, "cubic-feet": { inBaseUnits: 1e3 * b$B(0.3048) }, "cubic-yards": { inBaseUnits: 1e3 * b$B(0.9144) }, "cubic-miles": { inBaseUnits: 1e3 * b$B(1609.344) } } }, angle: { baseUnit: "radians", units: { radians: { inBaseUnits: 1 }, degrees: { inBaseUnits: Math.PI / 180 } } } }, _$q = (() => {
  const e2 = {};
  for (const s2 in y$S)
    for (const t2 in y$S[s2].units)
      e2[t2] = s2;
  return e2;
})();
function M$g(e2, s2, t2) {
  return e2 * y$S[t2].units[s2].inBaseUnits;
}
function g$G(e2, s2, t2) {
  return e2 / y$S[t2].units[s2].inBaseUnits;
}
function P$h(e2) {
  const s2 = _$q[e2];
  if (!s2)
    throw new Error("unknown type");
  return s2;
}
function x$u(e2, s2 = null) {
  return s2 = s2 || P$h(e2), y$S[s2].baseUnit === e2;
}
function E$k(e2, s2, t2) {
  if (s2 === t2)
    return e2;
  const r2 = P$h(s2);
  if (r2 !== P$h(t2))
    throw new Error("incompatible units");
  const i2 = x$u(s2, r2) ? e2 : M$g(e2, s2, r2);
  return x$u(t2, r2) ? i2 : g$G(i2, t2, r2);
}
function Y$5(e2, s2, t2) {
  return E$k(e2, s2, "meters") / (t2 * Math.PI / 180);
}
function G$8(e2) {
  return p$1U.fromJSON(e2.toLowerCase()) || null;
}
function L$h(e2) {
  if (r$1t(e2) && !A$n(e2))
    return 1;
  const t2 = $$a(e2);
  return t2 > 1e5 ? 1 : t2;
}
function W$6(e2) {
  return $$a(e2) >= u$11(e2).metersPerDegree ? "meters" : X$4(e2);
}
function $$a(e2, s2 = s$1M.metersPerDegree) {
  return i$2y(z$j(e2, true), s2);
}
function z$j(e2, t2 = false) {
  const r2 = r$1t(e2) ? e2.wkid : null, i2 = r$1t(e2) ? e2.wkt : null;
  let n2 = null;
  if (r2) {
    if (w$L(r2))
      return t$1y.metersPerDegree;
    if (C$p(r2))
      return e$1A.metersPerDegree;
    n2 = q$9.values[q$9[r2]], !n2 && t2 && B$c.has(r2) && (n2 = d$Z);
  } else
    i2 && (re$2(i2) ? n2 = Q$7(U$h.exec(i2), n2) : te$2(i2) && (n2 = Q$7(h$O.exec(i2), n2)));
  return n2;
}
function Q$7(e2, s2) {
  return e2 && e2[1] ? V$8(e2[1]) : s2;
}
function V$8(e2) {
  return parseFloat(e2.split(",")[1]);
}
function X$4(e2) {
  const t2 = r$1t(e2) ? e2.wkid : null, r2 = r$1t(e2) ? e2.wkt : null;
  let i2 = null;
  if (t2)
    i2 = q$9.units[q$9[t2]];
  else if (r2) {
    const e3 = re$2(r2) ? U$h : te$2(r2) ? h$O : null;
    if (e3) {
      const s2 = e3.exec(r2);
      s2 && s2[1] && (i2 = ne$2(s2[1]));
    }
  }
  return r$1t(i2) ? G$8(i2) : null;
}
function te$2(e2) {
  return /^GEOCCS/i.test(e2);
}
function re$2(e2) {
  return /^PROJCS/i.test(e2);
}
const ie$2 = 1e-7;
function ne$2(e2) {
  const s2 = /[\\"\\']{1}([^\\"\\']+)/.exec(e2);
  let t2 = s2 && s2[1];
  if (!t2 || !q$9.units.includes(t2)) {
    const s3 = V$8(e2);
    t2 = null;
    const r2 = q$9.values;
    for (let e3 = 0; e3 < r2.length; ++e3)
      if (Math.abs(s3 - r2[e3]) < ie$2) {
        t2 = q$9.units[e3];
        break;
      }
  }
  return t2;
}
const ce$3 = { esriAcres: "acres", esriAres: "ares", esriHectares: "hectares", esriSquareCentimeters: "square-centimeters", esriSquareDecimeters: "square-decimeters", esriSquareFeet: "square-feet", esriSquareInches: "square-inches", esriSquareKilometers: "square-kilometers", esriSquareMeters: "square-meters", esriSquareMiles: "square-miles", esriSquareMillimeters: "square-millimeters", esriSquareUsFeet: "square-us-feet", esriSquareYards: "square-yards" }, oe$2 = { esriCentimeters: "centimeters", esriDecimeters: "decimeters", esriFeet: "feet", esriInches: "inches", esriKilometers: "kilometers", esriMeters: "meters", esriMiles: "miles", esriMillimeters: "millimeters", esriNauticalMiles: "nautical-miles", esriYards: "yards" }, le$2 = o$1w()(ce$3), me$3 = o$1w()(oe$2);
o$1w()(__spreadValues(__spreadValues({}, ce$3), oe$2));
function n$1y(t2, a2) {
  return t2[0] = a2[0], t2[1] = a2[1], t2[2] = a2[2], t2[3] = a2[3], t2[4] = a2[4], t2[5] = a2[5], t2[6] = a2[6], t2[7] = a2[7], t2[8] = a2[8], t2[9] = a2[9], t2[10] = a2[10], t2[11] = a2[11], t2[12] = a2[12], t2[13] = a2[13], t2[14] = a2[14], t2[15] = a2[15], t2;
}
function s$1b(t2, a2, n2, s2, r2, o2, h2, e2, M2, u2, c2, i2, f2, b2, l2, m2, x2) {
  return t2[0] = a2, t2[1] = n2, t2[2] = s2, t2[3] = r2, t2[4] = o2, t2[5] = h2, t2[6] = e2, t2[7] = M2, t2[8] = u2, t2[9] = c2, t2[10] = i2, t2[11] = f2, t2[12] = b2, t2[13] = l2, t2[14] = m2, t2[15] = x2, t2;
}
function r$U(t2) {
  return t2[0] = 1, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = 1, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = 1, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
}
function o$17(t2, a2) {
  if (t2 === a2) {
    const n2 = a2[1], s2 = a2[2], r2 = a2[3], o2 = a2[6], h2 = a2[7], e2 = a2[11];
    t2[1] = a2[4], t2[2] = a2[8], t2[3] = a2[12], t2[4] = n2, t2[6] = a2[9], t2[7] = a2[13], t2[8] = s2, t2[9] = o2, t2[11] = a2[14], t2[12] = r2, t2[13] = h2, t2[14] = e2;
  } else
    t2[0] = a2[0], t2[1] = a2[4], t2[2] = a2[8], t2[3] = a2[12], t2[4] = a2[1], t2[5] = a2[5], t2[6] = a2[9], t2[7] = a2[13], t2[8] = a2[2], t2[9] = a2[6], t2[10] = a2[10], t2[11] = a2[14], t2[12] = a2[3], t2[13] = a2[7], t2[14] = a2[11], t2[15] = a2[15];
  return t2;
}
function h$N(t2, a2) {
  const n2 = a2[0], s2 = a2[1], r2 = a2[2], o2 = a2[3], h2 = a2[4], e2 = a2[5], M2 = a2[6], u2 = a2[7], c2 = a2[8], i2 = a2[9], f2 = a2[10], b2 = a2[11], l2 = a2[12], m2 = a2[13], x2 = a2[14], q2 = a2[15], g2 = n2 * e2 - s2 * h2, p2 = n2 * M2 - r2 * h2, d2 = n2 * u2 - o2 * h2, R2 = s2 * M2 - r2 * e2, S2 = s2 * u2 - o2 * e2, y2 = r2 * u2 - o2 * M2, T2 = c2 * m2 - i2 * l2, j2 = c2 * x2 - f2 * l2, v2 = c2 * q2 - b2 * l2, O2 = i2 * x2 - f2 * m2, P2 = i2 * q2 - b2 * m2, D2 = f2 * q2 - b2 * x2;
  let I2 = g2 * D2 - p2 * P2 + d2 * O2 + R2 * v2 - S2 * j2 + y2 * T2;
  return I2 ? (I2 = 1 / I2, t2[0] = (e2 * D2 - M2 * P2 + u2 * O2) * I2, t2[1] = (r2 * P2 - s2 * D2 - o2 * O2) * I2, t2[2] = (m2 * y2 - x2 * S2 + q2 * R2) * I2, t2[3] = (f2 * S2 - i2 * y2 - b2 * R2) * I2, t2[4] = (M2 * v2 - h2 * D2 - u2 * j2) * I2, t2[5] = (n2 * D2 - r2 * v2 + o2 * j2) * I2, t2[6] = (x2 * d2 - l2 * y2 - q2 * p2) * I2, t2[7] = (c2 * y2 - f2 * d2 + b2 * p2) * I2, t2[8] = (h2 * P2 - e2 * v2 + u2 * T2) * I2, t2[9] = (s2 * v2 - n2 * P2 - o2 * T2) * I2, t2[10] = (l2 * S2 - m2 * d2 + q2 * g2) * I2, t2[11] = (i2 * d2 - c2 * S2 - b2 * g2) * I2, t2[12] = (e2 * j2 - h2 * O2 - M2 * T2) * I2, t2[13] = (n2 * O2 - s2 * j2 + r2 * T2) * I2, t2[14] = (m2 * p2 - l2 * R2 - x2 * g2) * I2, t2[15] = (c2 * R2 - i2 * p2 + f2 * g2) * I2, t2) : null;
}
function e$14(t2, a2) {
  const n2 = a2[0], s2 = a2[1], r2 = a2[2], o2 = a2[3], h2 = a2[4], e2 = a2[5], M2 = a2[6], u2 = a2[7], c2 = a2[8], i2 = a2[9], f2 = a2[10], b2 = a2[11], l2 = a2[12], m2 = a2[13], x2 = a2[14], q2 = a2[15];
  return t2[0] = e2 * (f2 * q2 - b2 * x2) - i2 * (M2 * q2 - u2 * x2) + m2 * (M2 * b2 - u2 * f2), t2[1] = -(s2 * (f2 * q2 - b2 * x2) - i2 * (r2 * q2 - o2 * x2) + m2 * (r2 * b2 - o2 * f2)), t2[2] = s2 * (M2 * q2 - u2 * x2) - e2 * (r2 * q2 - o2 * x2) + m2 * (r2 * u2 - o2 * M2), t2[3] = -(s2 * (M2 * b2 - u2 * f2) - e2 * (r2 * b2 - o2 * f2) + i2 * (r2 * u2 - o2 * M2)), t2[4] = -(h2 * (f2 * q2 - b2 * x2) - c2 * (M2 * q2 - u2 * x2) + l2 * (M2 * b2 - u2 * f2)), t2[5] = n2 * (f2 * q2 - b2 * x2) - c2 * (r2 * q2 - o2 * x2) + l2 * (r2 * b2 - o2 * f2), t2[6] = -(n2 * (M2 * q2 - u2 * x2) - h2 * (r2 * q2 - o2 * x2) + l2 * (r2 * u2 - o2 * M2)), t2[7] = n2 * (M2 * b2 - u2 * f2) - h2 * (r2 * b2 - o2 * f2) + c2 * (r2 * u2 - o2 * M2), t2[8] = h2 * (i2 * q2 - b2 * m2) - c2 * (e2 * q2 - u2 * m2) + l2 * (e2 * b2 - u2 * i2), t2[9] = -(n2 * (i2 * q2 - b2 * m2) - c2 * (s2 * q2 - o2 * m2) + l2 * (s2 * b2 - o2 * i2)), t2[10] = n2 * (e2 * q2 - u2 * m2) - h2 * (s2 * q2 - o2 * m2) + l2 * (s2 * u2 - o2 * e2), t2[11] = -(n2 * (e2 * b2 - u2 * i2) - h2 * (s2 * b2 - o2 * i2) + c2 * (s2 * u2 - o2 * e2)), t2[12] = -(h2 * (i2 * x2 - f2 * m2) - c2 * (e2 * x2 - M2 * m2) + l2 * (e2 * f2 - M2 * i2)), t2[13] = n2 * (i2 * x2 - f2 * m2) - c2 * (s2 * x2 - r2 * m2) + l2 * (s2 * f2 - r2 * i2), t2[14] = -(n2 * (e2 * x2 - M2 * m2) - h2 * (s2 * x2 - r2 * m2) + l2 * (s2 * M2 - r2 * e2)), t2[15] = n2 * (e2 * f2 - M2 * i2) - h2 * (s2 * f2 - r2 * i2) + c2 * (s2 * M2 - r2 * e2), t2;
}
function M$f(t2) {
  const a2 = t2[0], n2 = t2[1], s2 = t2[2], r2 = t2[3], o2 = t2[4], h2 = t2[5], e2 = t2[6], M2 = t2[7], u2 = t2[8], c2 = t2[9], i2 = t2[10], f2 = t2[11], b2 = t2[12], l2 = t2[13], m2 = t2[14], x2 = t2[15];
  return (a2 * h2 - n2 * o2) * (i2 * x2 - f2 * m2) - (a2 * e2 - s2 * o2) * (c2 * x2 - f2 * l2) + (a2 * M2 - r2 * o2) * (c2 * m2 - i2 * l2) + (n2 * e2 - s2 * h2) * (u2 * x2 - f2 * b2) - (n2 * M2 - r2 * h2) * (u2 * m2 - i2 * b2) + (s2 * M2 - r2 * e2) * (u2 * l2 - c2 * b2);
}
function u$10(t2, a2, n2) {
  const s2 = a2[0], r2 = a2[1], o2 = a2[2], h2 = a2[3], e2 = a2[4], M2 = a2[5], u2 = a2[6], c2 = a2[7], i2 = a2[8], f2 = a2[9], b2 = a2[10], l2 = a2[11], m2 = a2[12], x2 = a2[13], q2 = a2[14], g2 = a2[15];
  let p2 = n2[0], d2 = n2[1], R2 = n2[2], S2 = n2[3];
  return t2[0] = p2 * s2 + d2 * e2 + R2 * i2 + S2 * m2, t2[1] = p2 * r2 + d2 * M2 + R2 * f2 + S2 * x2, t2[2] = p2 * o2 + d2 * u2 + R2 * b2 + S2 * q2, t2[3] = p2 * h2 + d2 * c2 + R2 * l2 + S2 * g2, p2 = n2[4], d2 = n2[5], R2 = n2[6], S2 = n2[7], t2[4] = p2 * s2 + d2 * e2 + R2 * i2 + S2 * m2, t2[5] = p2 * r2 + d2 * M2 + R2 * f2 + S2 * x2, t2[6] = p2 * o2 + d2 * u2 + R2 * b2 + S2 * q2, t2[7] = p2 * h2 + d2 * c2 + R2 * l2 + S2 * g2, p2 = n2[8], d2 = n2[9], R2 = n2[10], S2 = n2[11], t2[8] = p2 * s2 + d2 * e2 + R2 * i2 + S2 * m2, t2[9] = p2 * r2 + d2 * M2 + R2 * f2 + S2 * x2, t2[10] = p2 * o2 + d2 * u2 + R2 * b2 + S2 * q2, t2[11] = p2 * h2 + d2 * c2 + R2 * l2 + S2 * g2, p2 = n2[12], d2 = n2[13], R2 = n2[14], S2 = n2[15], t2[12] = p2 * s2 + d2 * e2 + R2 * i2 + S2 * m2, t2[13] = p2 * r2 + d2 * M2 + R2 * f2 + S2 * x2, t2[14] = p2 * o2 + d2 * u2 + R2 * b2 + S2 * q2, t2[15] = p2 * h2 + d2 * c2 + R2 * l2 + S2 * g2, t2;
}
function c$1I(t2, a2, n2) {
  const s2 = n2[0], r2 = n2[1], o2 = n2[2];
  if (a2 === t2)
    t2[12] = a2[0] * s2 + a2[4] * r2 + a2[8] * o2 + a2[12], t2[13] = a2[1] * s2 + a2[5] * r2 + a2[9] * o2 + a2[13], t2[14] = a2[2] * s2 + a2[6] * r2 + a2[10] * o2 + a2[14], t2[15] = a2[3] * s2 + a2[7] * r2 + a2[11] * o2 + a2[15];
  else {
    const n3 = a2[0], h2 = a2[1], e2 = a2[2], M2 = a2[3], u2 = a2[4], c2 = a2[5], i2 = a2[6], f2 = a2[7], b2 = a2[8], l2 = a2[9], m2 = a2[10], x2 = a2[11];
    t2[0] = n3, t2[1] = h2, t2[2] = e2, t2[3] = M2, t2[4] = u2, t2[5] = c2, t2[6] = i2, t2[7] = f2, t2[8] = b2, t2[9] = l2, t2[10] = m2, t2[11] = x2, t2[12] = n3 * s2 + u2 * r2 + b2 * o2 + a2[12], t2[13] = h2 * s2 + c2 * r2 + l2 * o2 + a2[13], t2[14] = e2 * s2 + i2 * r2 + m2 * o2 + a2[14], t2[15] = M2 * s2 + f2 * r2 + x2 * o2 + a2[15];
  }
  return t2;
}
function i$1w(t2, a2, n2) {
  const s2 = n2[0], r2 = n2[1], o2 = n2[2];
  return t2[0] = a2[0] * s2, t2[1] = a2[1] * s2, t2[2] = a2[2] * s2, t2[3] = a2[3] * s2, t2[4] = a2[4] * r2, t2[5] = a2[5] * r2, t2[6] = a2[6] * r2, t2[7] = a2[7] * r2, t2[8] = a2[8] * o2, t2[9] = a2[9] * o2, t2[10] = a2[10] * o2, t2[11] = a2[11] * o2, t2[12] = a2[12], t2[13] = a2[13], t2[14] = a2[14], t2[15] = a2[15], t2;
}
function f$W(t2, n2, s2, r2) {
  let o2, h2, e2, M2, u2, c2, i2, f2, b2, l2, m2, x2, q2, g2, p2, d2, R2, S2, y2, T2, j2, v2, O2, P2, D2 = r2[0], I2 = r2[1], A2 = r2[2], _2 = Math.sqrt(D2 * D2 + I2 * I2 + A2 * A2);
  return _2 < a$23() ? null : (_2 = 1 / _2, D2 *= _2, I2 *= _2, A2 *= _2, o2 = Math.sin(s2), h2 = Math.cos(s2), e2 = 1 - h2, M2 = n2[0], u2 = n2[1], c2 = n2[2], i2 = n2[3], f2 = n2[4], b2 = n2[5], l2 = n2[6], m2 = n2[7], x2 = n2[8], q2 = n2[9], g2 = n2[10], p2 = n2[11], d2 = D2 * D2 * e2 + h2, R2 = I2 * D2 * e2 + A2 * o2, S2 = A2 * D2 * e2 - I2 * o2, y2 = D2 * I2 * e2 - A2 * o2, T2 = I2 * I2 * e2 + h2, j2 = A2 * I2 * e2 + D2 * o2, v2 = D2 * A2 * e2 + I2 * o2, O2 = I2 * A2 * e2 - D2 * o2, P2 = A2 * A2 * e2 + h2, t2[0] = M2 * d2 + f2 * R2 + x2 * S2, t2[1] = u2 * d2 + b2 * R2 + q2 * S2, t2[2] = c2 * d2 + l2 * R2 + g2 * S2, t2[3] = i2 * d2 + m2 * R2 + p2 * S2, t2[4] = M2 * y2 + f2 * T2 + x2 * j2, t2[5] = u2 * y2 + b2 * T2 + q2 * j2, t2[6] = c2 * y2 + l2 * T2 + g2 * j2, t2[7] = i2 * y2 + m2 * T2 + p2 * j2, t2[8] = M2 * v2 + f2 * O2 + x2 * P2, t2[9] = u2 * v2 + b2 * O2 + q2 * P2, t2[10] = c2 * v2 + l2 * O2 + g2 * P2, t2[11] = i2 * v2 + m2 * O2 + p2 * P2, n2 !== t2 && (t2[12] = n2[12], t2[13] = n2[13], t2[14] = n2[14], t2[15] = n2[15]), t2);
}
function b$A(t2, a2, n2) {
  const s2 = Math.sin(n2), r2 = Math.cos(n2), o2 = a2[4], h2 = a2[5], e2 = a2[6], M2 = a2[7], u2 = a2[8], c2 = a2[9], i2 = a2[10], f2 = a2[11];
  return a2 !== t2 && (t2[0] = a2[0], t2[1] = a2[1], t2[2] = a2[2], t2[3] = a2[3], t2[12] = a2[12], t2[13] = a2[13], t2[14] = a2[14], t2[15] = a2[15]), t2[4] = o2 * r2 + u2 * s2, t2[5] = h2 * r2 + c2 * s2, t2[6] = e2 * r2 + i2 * s2, t2[7] = M2 * r2 + f2 * s2, t2[8] = u2 * r2 - o2 * s2, t2[9] = c2 * r2 - h2 * s2, t2[10] = i2 * r2 - e2 * s2, t2[11] = f2 * r2 - M2 * s2, t2;
}
function l$1c(t2, a2, n2) {
  const s2 = Math.sin(n2), r2 = Math.cos(n2), o2 = a2[0], h2 = a2[1], e2 = a2[2], M2 = a2[3], u2 = a2[8], c2 = a2[9], i2 = a2[10], f2 = a2[11];
  return a2 !== t2 && (t2[4] = a2[4], t2[5] = a2[5], t2[6] = a2[6], t2[7] = a2[7], t2[12] = a2[12], t2[13] = a2[13], t2[14] = a2[14], t2[15] = a2[15]), t2[0] = o2 * r2 - u2 * s2, t2[1] = h2 * r2 - c2 * s2, t2[2] = e2 * r2 - i2 * s2, t2[3] = M2 * r2 - f2 * s2, t2[8] = o2 * s2 + u2 * r2, t2[9] = h2 * s2 + c2 * r2, t2[10] = e2 * s2 + i2 * r2, t2[11] = M2 * s2 + f2 * r2, t2;
}
function m$$(t2, a2, n2) {
  const s2 = Math.sin(n2), r2 = Math.cos(n2), o2 = a2[0], h2 = a2[1], e2 = a2[2], M2 = a2[3], u2 = a2[4], c2 = a2[5], i2 = a2[6], f2 = a2[7];
  return a2 !== t2 && (t2[8] = a2[8], t2[9] = a2[9], t2[10] = a2[10], t2[11] = a2[11], t2[12] = a2[12], t2[13] = a2[13], t2[14] = a2[14], t2[15] = a2[15]), t2[0] = o2 * r2 + u2 * s2, t2[1] = h2 * r2 + c2 * s2, t2[2] = e2 * r2 + i2 * s2, t2[3] = M2 * r2 + f2 * s2, t2[4] = u2 * r2 - o2 * s2, t2[5] = c2 * r2 - h2 * s2, t2[6] = i2 * r2 - e2 * s2, t2[7] = f2 * r2 - M2 * s2, t2;
}
function x$t(t2, a2) {
  return t2[0] = 1, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = 1, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = 1, t2[11] = 0, t2[12] = a2[0], t2[13] = a2[1], t2[14] = a2[2], t2[15] = 1, t2;
}
function q$8(t2, a2) {
  return t2[0] = a2[0], t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = a2[1], t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = a2[2], t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
}
function g$F(t2, n2, s2) {
  if (n2 === 0)
    return r$U(t2);
  let o2, h2, e2, M2 = s2[0], u2 = s2[1], c2 = s2[2], i2 = Math.sqrt(M2 * M2 + u2 * u2 + c2 * c2);
  return i2 < a$23() ? null : (i2 = 1 / i2, M2 *= i2, u2 *= i2, c2 *= i2, o2 = Math.sin(n2), h2 = Math.cos(n2), e2 = 1 - h2, t2[0] = M2 * M2 * e2 + h2, t2[1] = u2 * M2 * e2 + c2 * o2, t2[2] = c2 * M2 * e2 - u2 * o2, t2[3] = 0, t2[4] = M2 * u2 * e2 - c2 * o2, t2[5] = u2 * u2 * e2 + h2, t2[6] = c2 * u2 * e2 + M2 * o2, t2[7] = 0, t2[8] = M2 * c2 * e2 + u2 * o2, t2[9] = u2 * c2 * e2 - M2 * o2, t2[10] = c2 * c2 * e2 + h2, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2);
}
function p$1T(t2, a2) {
  const n2 = Math.sin(a2), s2 = Math.cos(a2);
  return t2[0] = 1, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = s2, t2[6] = n2, t2[7] = 0, t2[8] = 0, t2[9] = -n2, t2[10] = s2, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
}
function d$Y(t2, a2) {
  const n2 = Math.sin(a2), s2 = Math.cos(a2);
  return t2[0] = s2, t2[1] = 0, t2[2] = -n2, t2[3] = 0, t2[4] = 0, t2[5] = 1, t2[6] = 0, t2[7] = 0, t2[8] = n2, t2[9] = 0, t2[10] = s2, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
}
function R$g(t2, a2) {
  const n2 = Math.sin(a2), s2 = Math.cos(a2);
  return t2[0] = s2, t2[1] = n2, t2[2] = 0, t2[3] = 0, t2[4] = -n2, t2[5] = s2, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = 1, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
}
function S$r(t2, a2, n2) {
  const s2 = a2[0], r2 = a2[1], o2 = a2[2], h2 = a2[3], e2 = s2 + s2, M2 = r2 + r2, u2 = o2 + o2, c2 = s2 * e2, i2 = s2 * M2, f2 = s2 * u2, b2 = r2 * M2, l2 = r2 * u2, m2 = o2 * u2, x2 = h2 * e2, q2 = h2 * M2, g2 = h2 * u2;
  return t2[0] = 1 - (b2 + m2), t2[1] = i2 + g2, t2[2] = f2 - q2, t2[3] = 0, t2[4] = i2 - g2, t2[5] = 1 - (c2 + m2), t2[6] = l2 + x2, t2[7] = 0, t2[8] = f2 + q2, t2[9] = l2 - x2, t2[10] = 1 - (c2 + b2), t2[11] = 0, t2[12] = n2[0], t2[13] = n2[1], t2[14] = n2[2], t2[15] = 1, t2;
}
function y$R(t2, a2) {
  const n2 = T$h, s2 = -a2[0], r2 = -a2[1], o2 = -a2[2], h2 = a2[3], e2 = a2[4], M2 = a2[5], u2 = a2[6], c2 = a2[7], i2 = s2 * s2 + r2 * r2 + o2 * o2 + h2 * h2;
  return i2 > 0 ? (n2[0] = 2 * (e2 * h2 + c2 * s2 + M2 * o2 - u2 * r2) / i2, n2[1] = 2 * (M2 * h2 + c2 * r2 + u2 * s2 - e2 * o2) / i2, n2[2] = 2 * (u2 * h2 + c2 * o2 + e2 * r2 - M2 * s2) / i2) : (n2[0] = 2 * (e2 * h2 + c2 * s2 + M2 * o2 - u2 * r2), n2[1] = 2 * (M2 * h2 + c2 * r2 + u2 * s2 - e2 * o2), n2[2] = 2 * (u2 * h2 + c2 * o2 + e2 * r2 - M2 * s2)), S$r(t2, a2, n2), t2;
}
const T$h = n$1X();
function j$r(t2, a2) {
  return t2[0] = a2[12], t2[1] = a2[13], t2[2] = a2[14], t2;
}
function v$B(t2, a2) {
  const n2 = a2[0], s2 = a2[1], r2 = a2[2], o2 = a2[4], h2 = a2[5], e2 = a2[6], M2 = a2[8], u2 = a2[9], c2 = a2[10];
  return t2[0] = Math.sqrt(n2 * n2 + s2 * s2 + r2 * r2), t2[1] = Math.sqrt(o2 * o2 + h2 * h2 + e2 * e2), t2[2] = Math.sqrt(M2 * M2 + u2 * u2 + c2 * c2), t2;
}
function O$e(t2, a2) {
  const n2 = a2[0] + a2[5] + a2[10];
  let s2 = 0;
  return n2 > 0 ? (s2 = 2 * Math.sqrt(n2 + 1), t2[3] = 0.25 * s2, t2[0] = (a2[6] - a2[9]) / s2, t2[1] = (a2[8] - a2[2]) / s2, t2[2] = (a2[1] - a2[4]) / s2) : a2[0] > a2[5] && a2[0] > a2[10] ? (s2 = 2 * Math.sqrt(1 + a2[0] - a2[5] - a2[10]), t2[3] = (a2[6] - a2[9]) / s2, t2[0] = 0.25 * s2, t2[1] = (a2[1] + a2[4]) / s2, t2[2] = (a2[8] + a2[2]) / s2) : a2[5] > a2[10] ? (s2 = 2 * Math.sqrt(1 + a2[5] - a2[0] - a2[10]), t2[3] = (a2[8] - a2[2]) / s2, t2[0] = (a2[1] + a2[4]) / s2, t2[1] = 0.25 * s2, t2[2] = (a2[6] + a2[9]) / s2) : (s2 = 2 * Math.sqrt(1 + a2[10] - a2[0] - a2[5]), t2[3] = (a2[1] - a2[4]) / s2, t2[0] = (a2[8] + a2[2]) / s2, t2[1] = (a2[6] + a2[9]) / s2, t2[2] = 0.25 * s2), t2;
}
function P$g(t2, a2, n2, s2) {
  const r2 = a2[0], o2 = a2[1], h2 = a2[2], e2 = a2[3], M2 = r2 + r2, u2 = o2 + o2, c2 = h2 + h2, i2 = r2 * M2, f2 = r2 * u2, b2 = r2 * c2, l2 = o2 * u2, m2 = o2 * c2, x2 = h2 * c2, q2 = e2 * M2, g2 = e2 * u2, p2 = e2 * c2, d2 = s2[0], R2 = s2[1], S2 = s2[2];
  return t2[0] = (1 - (l2 + x2)) * d2, t2[1] = (f2 + p2) * d2, t2[2] = (b2 - g2) * d2, t2[3] = 0, t2[4] = (f2 - p2) * R2, t2[5] = (1 - (i2 + x2)) * R2, t2[6] = (m2 + q2) * R2, t2[7] = 0, t2[8] = (b2 + g2) * S2, t2[9] = (m2 - q2) * S2, t2[10] = (1 - (i2 + l2)) * S2, t2[11] = 0, t2[12] = n2[0], t2[13] = n2[1], t2[14] = n2[2], t2[15] = 1, t2;
}
function D$d(t2, a2, n2, s2, r2) {
  const o2 = a2[0], h2 = a2[1], e2 = a2[2], M2 = a2[3], u2 = o2 + o2, c2 = h2 + h2, i2 = e2 + e2, f2 = o2 * u2, b2 = o2 * c2, l2 = o2 * i2, m2 = h2 * c2, x2 = h2 * i2, q2 = e2 * i2, g2 = M2 * u2, p2 = M2 * c2, d2 = M2 * i2, R2 = s2[0], S2 = s2[1], y2 = s2[2], T2 = r2[0], j2 = r2[1], v2 = r2[2], O2 = (1 - (m2 + q2)) * R2, P2 = (b2 + d2) * R2, D2 = (l2 - p2) * R2, I2 = (b2 - d2) * S2, A2 = (1 - (f2 + q2)) * S2, _2 = (x2 + g2) * S2, w2 = (l2 + p2) * y2, F2 = (x2 - g2) * y2, Q2 = (1 - (f2 + m2)) * y2;
  return t2[0] = O2, t2[1] = P2, t2[2] = D2, t2[3] = 0, t2[4] = I2, t2[5] = A2, t2[6] = _2, t2[7] = 0, t2[8] = w2, t2[9] = F2, t2[10] = Q2, t2[11] = 0, t2[12] = n2[0] + T2 - (O2 * T2 + I2 * j2 + w2 * v2), t2[13] = n2[1] + j2 - (P2 * T2 + A2 * j2 + F2 * v2), t2[14] = n2[2] + v2 - (D2 * T2 + _2 * j2 + Q2 * v2), t2[15] = 1, t2;
}
function I$k(t2, a2) {
  const n2 = a2[0], s2 = a2[1], r2 = a2[2], o2 = a2[3], h2 = n2 + n2, e2 = s2 + s2, M2 = r2 + r2, u2 = n2 * h2, c2 = s2 * h2, i2 = s2 * e2, f2 = r2 * h2, b2 = r2 * e2, l2 = r2 * M2, m2 = o2 * h2, x2 = o2 * e2, q2 = o2 * M2;
  return t2[0] = 1 - i2 - l2, t2[1] = c2 + q2, t2[2] = f2 - x2, t2[3] = 0, t2[4] = c2 - q2, t2[5] = 1 - u2 - l2, t2[6] = b2 + m2, t2[7] = 0, t2[8] = f2 + x2, t2[9] = b2 - m2, t2[10] = 1 - u2 - i2, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
}
function A$f(t2, a2, n2, s2, r2, o2, h2) {
  const e2 = 1 / (n2 - a2), M2 = 1 / (r2 - s2), u2 = 1 / (o2 - h2);
  return t2[0] = 2 * o2 * e2, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = 2 * o2 * M2, t2[6] = 0, t2[7] = 0, t2[8] = (n2 + a2) * e2, t2[9] = (r2 + s2) * M2, t2[10] = (h2 + o2) * u2, t2[11] = -1, t2[12] = 0, t2[13] = 0, t2[14] = h2 * o2 * 2 * u2, t2[15] = 0, t2;
}
function _$p(t2, a2, n2, s2, r2) {
  const o2 = 1 / Math.tan(a2 / 2);
  let h2;
  return t2[0] = o2 / n2, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = o2, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[11] = -1, t2[12] = 0, t2[13] = 0, t2[15] = 0, r2 != null && r2 !== 1 / 0 ? (h2 = 1 / (s2 - r2), t2[10] = (r2 + s2) * h2, t2[14] = 2 * r2 * s2 * h2) : (t2[10] = -1, t2[14] = -2 * s2), t2;
}
function w$x(t2, a2, n2, s2) {
  const r2 = Math.tan(a2.upDegrees * Math.PI / 180), o2 = Math.tan(a2.downDegrees * Math.PI / 180), h2 = Math.tan(a2.leftDegrees * Math.PI / 180), e2 = Math.tan(a2.rightDegrees * Math.PI / 180), M2 = 2 / (h2 + e2), u2 = 2 / (r2 + o2);
  return t2[0] = M2, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = u2, t2[6] = 0, t2[7] = 0, t2[8] = -(h2 - e2) * M2 * 0.5, t2[9] = (r2 - o2) * u2 * 0.5, t2[10] = s2 / (n2 - s2), t2[11] = -1, t2[12] = 0, t2[13] = 0, t2[14] = s2 * n2 / (n2 - s2), t2[15] = 0, t2;
}
function F$d(t2, a2, n2, s2, r2, o2, h2) {
  const e2 = 1 / (a2 - n2), M2 = 1 / (s2 - r2), u2 = 1 / (o2 - h2);
  return t2[0] = -2 * e2, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = -2 * M2, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = 2 * u2, t2[11] = 0, t2[12] = (a2 + n2) * e2, t2[13] = (r2 + s2) * M2, t2[14] = (h2 + o2) * u2, t2[15] = 1, t2;
}
function Q$6(t2, n2, s2, o2) {
  let h2, e2, M2, u2, c2, i2, f2, b2, l2, m2;
  const x2 = n2[0], q2 = n2[1], g2 = n2[2], p2 = o2[0], d2 = o2[1], R2 = o2[2], S2 = s2[0], y2 = s2[1], T2 = s2[2], j2 = a$23();
  return Math.abs(x2 - S2) < j2 && Math.abs(q2 - y2) < j2 && Math.abs(g2 - T2) < j2 ? r$U(t2) : (f2 = x2 - S2, b2 = q2 - y2, l2 = g2 - T2, m2 = 1 / Math.sqrt(f2 * f2 + b2 * b2 + l2 * l2), f2 *= m2, b2 *= m2, l2 *= m2, h2 = d2 * l2 - R2 * b2, e2 = R2 * f2 - p2 * l2, M2 = p2 * b2 - d2 * f2, m2 = Math.sqrt(h2 * h2 + e2 * e2 + M2 * M2), m2 ? (m2 = 1 / m2, h2 *= m2, e2 *= m2, M2 *= m2) : (h2 = 0, e2 = 0, M2 = 0), u2 = b2 * M2 - l2 * e2, c2 = l2 * h2 - f2 * M2, i2 = f2 * e2 - b2 * h2, m2 = Math.sqrt(u2 * u2 + c2 * c2 + i2 * i2), m2 ? (m2 = 1 / m2, u2 *= m2, c2 *= m2, i2 *= m2) : (u2 = 0, c2 = 0, i2 = 0), t2[0] = h2, t2[1] = u2, t2[2] = f2, t2[3] = 0, t2[4] = e2, t2[5] = c2, t2[6] = b2, t2[7] = 0, t2[8] = M2, t2[9] = i2, t2[10] = l2, t2[11] = 0, t2[12] = -(h2 * x2 + e2 * q2 + M2 * g2), t2[13] = -(u2 * x2 + c2 * q2 + i2 * g2), t2[14] = -(f2 * x2 + b2 * q2 + l2 * g2), t2[15] = 1, t2);
}
function k$f(t2, a2, n2, s2) {
  const r2 = a2[0], o2 = a2[1], h2 = a2[2], e2 = s2[0], M2 = s2[1], u2 = s2[2];
  let c2 = r2 - n2[0], i2 = o2 - n2[1], f2 = h2 - n2[2], b2 = c2 * c2 + i2 * i2 + f2 * f2;
  b2 > 0 && (b2 = 1 / Math.sqrt(b2), c2 *= b2, i2 *= b2, f2 *= b2);
  let l2 = M2 * f2 - u2 * i2, m2 = u2 * c2 - e2 * f2, x2 = e2 * i2 - M2 * c2;
  return b2 = l2 * l2 + m2 * m2 + x2 * x2, b2 > 0 && (b2 = 1 / Math.sqrt(b2), l2 *= b2, m2 *= b2, x2 *= b2), t2[0] = l2, t2[1] = m2, t2[2] = x2, t2[3] = 0, t2[4] = i2 * x2 - f2 * m2, t2[5] = f2 * l2 - c2 * x2, t2[6] = c2 * m2 - i2 * l2, t2[7] = 0, t2[8] = c2, t2[9] = i2, t2[10] = f2, t2[11] = 0, t2[12] = r2, t2[13] = o2, t2[14] = h2, t2[15] = 1, t2;
}
function z$i(t2) {
  return "mat4(" + t2[0] + ", " + t2[1] + ", " + t2[2] + ", " + t2[3] + ", " + t2[4] + ", " + t2[5] + ", " + t2[6] + ", " + t2[7] + ", " + t2[8] + ", " + t2[9] + ", " + t2[10] + ", " + t2[11] + ", " + t2[12] + ", " + t2[13] + ", " + t2[14] + ", " + t2[15] + ")";
}
function E$j(t2) {
  return Math.sqrt(t2[0] ** 2 + t2[1] ** 2 + t2[2] ** 2 + t2[3] ** 2 + t2[4] ** 2 + t2[5] ** 2 + t2[6] ** 2 + t2[7] ** 2 + t2[8] ** 2 + t2[9] ** 2 + t2[10] ** 2 + t2[11] ** 2 + t2[12] ** 2 + t2[13] ** 2 + t2[14] ** 2 + t2[15] ** 2);
}
function N$a(t2, a2, n2) {
  return t2[0] = a2[0] + n2[0], t2[1] = a2[1] + n2[1], t2[2] = a2[2] + n2[2], t2[3] = a2[3] + n2[3], t2[4] = a2[4] + n2[4], t2[5] = a2[5] + n2[5], t2[6] = a2[6] + n2[6], t2[7] = a2[7] + n2[7], t2[8] = a2[8] + n2[8], t2[9] = a2[9] + n2[9], t2[10] = a2[10] + n2[10], t2[11] = a2[11] + n2[11], t2[12] = a2[12] + n2[12], t2[13] = a2[13] + n2[13], t2[14] = a2[14] + n2[14], t2[15] = a2[15] + n2[15], t2;
}
function X$3(t2, a2, n2) {
  return t2[0] = a2[0] - n2[0], t2[1] = a2[1] - n2[1], t2[2] = a2[2] - n2[2], t2[3] = a2[3] - n2[3], t2[4] = a2[4] - n2[4], t2[5] = a2[5] - n2[5], t2[6] = a2[6] - n2[6], t2[7] = a2[7] - n2[7], t2[8] = a2[8] - n2[8], t2[9] = a2[9] - n2[9], t2[10] = a2[10] - n2[10], t2[11] = a2[11] - n2[11], t2[12] = a2[12] - n2[12], t2[13] = a2[13] - n2[13], t2[14] = a2[14] - n2[14], t2[15] = a2[15] - n2[15], t2;
}
function Y$4(t2, a2, n2) {
  return t2[0] = a2[0] * n2, t2[1] = a2[1] * n2, t2[2] = a2[2] * n2, t2[3] = a2[3] * n2, t2[4] = a2[4] * n2, t2[5] = a2[5] * n2, t2[6] = a2[6] * n2, t2[7] = a2[7] * n2, t2[8] = a2[8] * n2, t2[9] = a2[9] * n2, t2[10] = a2[10] * n2, t2[11] = a2[11] * n2, t2[12] = a2[12] * n2, t2[13] = a2[13] * n2, t2[14] = a2[14] * n2, t2[15] = a2[15] * n2, t2;
}
function Z$3(t2, a2, n2, s2) {
  return t2[0] = a2[0] + n2[0] * s2, t2[1] = a2[1] + n2[1] * s2, t2[2] = a2[2] + n2[2] * s2, t2[3] = a2[3] + n2[3] * s2, t2[4] = a2[4] + n2[4] * s2, t2[5] = a2[5] + n2[5] * s2, t2[6] = a2[6] + n2[6] * s2, t2[7] = a2[7] + n2[7] * s2, t2[8] = a2[8] + n2[8] * s2, t2[9] = a2[9] + n2[9] * s2, t2[10] = a2[10] + n2[10] * s2, t2[11] = a2[11] + n2[11] * s2, t2[12] = a2[12] + n2[12] * s2, t2[13] = a2[13] + n2[13] * s2, t2[14] = a2[14] + n2[14] * s2, t2[15] = a2[15] + n2[15] * s2, t2;
}
function B$b(t2, a2) {
  return t2[0] === a2[0] && t2[1] === a2[1] && t2[2] === a2[2] && t2[3] === a2[3] && t2[4] === a2[4] && t2[5] === a2[5] && t2[6] === a2[6] && t2[7] === a2[7] && t2[8] === a2[8] && t2[9] === a2[9] && t2[10] === a2[10] && t2[11] === a2[11] && t2[12] === a2[12] && t2[13] === a2[13] && t2[14] === a2[14] && t2[15] === a2[15];
}
function C$h(t2, n2) {
  if (t2 === n2)
    return true;
  const s2 = t2[0], r2 = t2[1], o2 = t2[2], h2 = t2[3], e2 = t2[4], M2 = t2[5], u2 = t2[6], c2 = t2[7], i2 = t2[8], f2 = t2[9], b2 = t2[10], l2 = t2[11], m2 = t2[12], x2 = t2[13], q2 = t2[14], g2 = t2[15], p2 = n2[0], d2 = n2[1], R2 = n2[2], S2 = n2[3], y2 = n2[4], T2 = n2[5], j2 = n2[6], v2 = n2[7], O2 = n2[8], P2 = n2[9], D2 = n2[10], I2 = n2[11], A2 = n2[12], _2 = n2[13], w2 = n2[14], F2 = n2[15], Q2 = a$23();
  return Math.abs(s2 - p2) <= Q2 * Math.max(1, Math.abs(s2), Math.abs(p2)) && Math.abs(r2 - d2) <= Q2 * Math.max(1, Math.abs(r2), Math.abs(d2)) && Math.abs(o2 - R2) <= Q2 * Math.max(1, Math.abs(o2), Math.abs(R2)) && Math.abs(h2 - S2) <= Q2 * Math.max(1, Math.abs(h2), Math.abs(S2)) && Math.abs(e2 - y2) <= Q2 * Math.max(1, Math.abs(e2), Math.abs(y2)) && Math.abs(M2 - T2) <= Q2 * Math.max(1, Math.abs(M2), Math.abs(T2)) && Math.abs(u2 - j2) <= Q2 * Math.max(1, Math.abs(u2), Math.abs(j2)) && Math.abs(c2 - v2) <= Q2 * Math.max(1, Math.abs(c2), Math.abs(v2)) && Math.abs(i2 - O2) <= Q2 * Math.max(1, Math.abs(i2), Math.abs(O2)) && Math.abs(f2 - P2) <= Q2 * Math.max(1, Math.abs(f2), Math.abs(P2)) && Math.abs(b2 - D2) <= Q2 * Math.max(1, Math.abs(b2), Math.abs(D2)) && Math.abs(l2 - I2) <= Q2 * Math.max(1, Math.abs(l2), Math.abs(I2)) && Math.abs(m2 - A2) <= Q2 * Math.max(1, Math.abs(m2), Math.abs(A2)) && Math.abs(x2 - _2) <= Q2 * Math.max(1, Math.abs(x2), Math.abs(_2)) && Math.abs(q2 - w2) <= Q2 * Math.max(1, Math.abs(q2), Math.abs(w2)) && Math.abs(g2 - F2) <= Q2 * Math.max(1, Math.abs(g2), Math.abs(F2));
}
function G$7(t2) {
  const n2 = a$23(), s2 = t2[0], r2 = t2[1], o2 = t2[2], h2 = t2[4], e2 = t2[5], M2 = t2[6], u2 = t2[8], c2 = t2[9], i2 = t2[10];
  return Math.abs(1 - (s2 * s2 + h2 * h2 + u2 * u2)) <= n2 && Math.abs(1 - (r2 * r2 + e2 * e2 + c2 * c2)) <= n2 && Math.abs(1 - (o2 * o2 + M2 * M2 + i2 * i2)) <= n2;
}
const H$9 = u$10, J$7 = X$3;
Object.freeze(Object.defineProperty({ __proto__: null, copy: n$1y, set: s$1b, identity: r$U, transpose: o$17, invert: h$N, adjoint: e$14, determinant: M$f, multiply: u$10, translate: c$1I, scale: i$1w, rotate: f$W, rotateX: b$A, rotateY: l$1c, rotateZ: m$$, fromTranslation: x$t, fromScaling: q$8, fromRotation: g$F, fromXRotation: p$1T, fromYRotation: d$Y, fromZRotation: R$g, fromRotationTranslation: S$r, fromQuat2: y$R, getTranslation: j$r, getScaling: v$B, getRotation: O$e, fromRotationTranslationScale: P$g, fromRotationTranslationScaleOrigin: D$d, fromQuat: I$k, frustum: A$f, perspective: _$p, perspectiveFromFieldOfView: w$x, ortho: F$d, lookAt: Q$6, targetTo: k$f, str: z$i, frob: E$j, add: N$a, subtract: X$3, multiplyScalar: Y$4, multiplyScalarAndAdd: Z$3, exactEquals: B$b, equals: C$h, isOrthoNormal: G$7, mul: H$9, sub: J$7 }, Symbol.toStringTag, { value: "Module" }));
let t$18, o$16 = null;
function r$T() {
  return !!o$16;
}
function n$1x() {
  return !!has("esri-wasm");
}
function _$o() {
  return t$18 || (t$18 = import("./pe-wasm.js").then((e2) => e2.p).then(({ default: t2 }) => t2({ locateFile: (t3) => a$1G(`esri/geometry/support/${t3}`) })).then((e2) => {
    S$q(e2);
  }), t$18);
}
var P$f, s$1a, E$i;
!function(e2) {
  function t2(e3, t3, r3) {
    o$16.ensureCache.prepare();
    const n3 = M$e(r3), _3 = r3 === n3, P2 = o$16.ensureFloat64(n3), s2 = o$16._pe_geog_to_proj(o$16.getPointer(e3), t3, P2);
    return s2 && A$e(r3, t3, P2, _3), s2;
  }
  function r2(e3, o2, r3, _3) {
    switch (_3) {
      case s$1a.PE_TRANSFORM_P_TO_G:
        return n2(e3, o2, r3);
      case s$1a.PE_TRANSFORM_G_TO_P:
        return t2(e3, o2, r3);
    }
    return 0;
  }
  function n2(e3, t3, o2) {
    return _2(e3, t3, o2, 0);
  }
  function _2(e3, t3, r3, n3) {
    o$16.ensureCache.prepare();
    const _3 = M$e(r3), P2 = r3 === _3, s2 = o$16.ensureFloat64(_3), E2 = o$16._pe_proj_to_geog_center(o$16.getPointer(e3), t3, s2, n3);
    return E2 && A$e(r3, t3, s2, P2), E2;
  }
  e2.geogToProj = t2, e2.projGeog = r2, e2.projToGeog = n2, e2.projToGeogCenter = _2;
}(P$f || (P$f = {})), function(e2) {
  function t2() {
    e2.PE_BUFFER_MAX = o$16.PeDefs.prototype.PE_BUFFER_MAX, e2.PE_NAME_MAX = o$16.PeDefs.prototype.PE_NAME_MAX, e2.PE_MGRS_MAX = o$16.PeDefs.prototype.PE_MGRS_MAX, e2.PE_USNG_MAX = o$16.PeDefs.prototype.PE_USNG_MAX, e2.PE_DD_MAX = o$16.PeDefs.prototype.PE_DD_MAX, e2.PE_DDM_MAX = o$16.PeDefs.prototype.PE_DDM_MAX, e2.PE_DMS_MAX = o$16.PeDefs.prototype.PE_DMS_MAX, e2.PE_UTM_MAX = o$16.PeDefs.prototype.PE_UTM_MAX, e2.PE_PARM_MAX = o$16.PeDefs.prototype.PE_PARM_MAX, e2.PE_TYPE_NONE = o$16.PeDefs.prototype.PE_TYPE_NONE, e2.PE_TYPE_GEOGCS = o$16.PeDefs.prototype.PE_TYPE_GEOGCS, e2.PE_TYPE_PROJCS = o$16.PeDefs.prototype.PE_TYPE_PROJCS, e2.PE_TYPE_GEOGTRAN = o$16.PeDefs.prototype.PE_TYPE_GEOGTRAN, e2.PE_TYPE_COORDSYS = o$16.PeDefs.prototype.PE_TYPE_COORDSYS, e2.PE_TYPE_UNIT = o$16.PeDefs.prototype.PE_TYPE_UNIT, e2.PE_TYPE_LINUNIT = o$16.PeDefs.prototype.PE_TYPE_LINUNIT, e2.PE_STR_OPTS_NONE = o$16.PeDefs.prototype.PE_STR_OPTS_NONE, e2.PE_STR_AUTH_NONE = o$16.PeDefs.prototype.PE_STR_AUTH_NONE, e2.PE_STR_AUTH_TOP = o$16.PeDefs.prototype.PE_STR_AUTH_TOP, e2.PE_STR_NAME_CANON = o$16.PeDefs.prototype.PE_STR_NAME_CANON, e2.PE_PARM_X0 = o$16.PeDefs.prototype.PE_PARM_X0, e2.PE_PARM_ND = o$16.PeDefs.prototype.PE_PARM_ND, e2.PE_TRANSFORM_1_TO_2 = o$16.PeDefs.prototype.PE_TRANSFORM_1_TO_2, e2.PE_TRANSFORM_2_TO_1 = o$16.PeDefs.prototype.PE_TRANSFORM_2_TO_1, e2.PE_TRANSFORM_P_TO_G = o$16.PeDefs.prototype.PE_TRANSFORM_P_TO_G, e2.PE_TRANSFORM_G_TO_P = o$16.PeDefs.prototype.PE_TRANSFORM_G_TO_P, e2.PE_HORIZON_RECT = o$16.PeDefs.prototype.PE_HORIZON_RECT, e2.PE_HORIZON_POLY = o$16.PeDefs.prototype.PE_HORIZON_POLY, e2.PE_HORIZON_LINE = o$16.PeDefs.prototype.PE_HORIZON_LINE, e2.PE_HORIZON_DELTA = o$16.PeDefs.prototype.PE_HORIZON_DELTA;
  }
  e2.init = t2;
}(s$1a || (s$1a = {})), function(e2) {
  const t2 = {}, r2 = {}, n2 = (e3) => {
    if (e3) {
      const t3 = e3.getType();
      switch (t3) {
        case s$1a.PE_TYPE_GEOGCS:
          e3 = o$16.castObject(e3, o$16.PeGeogcs);
          break;
        case s$1a.PE_TYPE_PROJCS:
          e3 = o$16.castObject(e3, o$16.PeProjcs);
          break;
        case s$1a.PE_TYPE_GEOGTRAN:
          e3 = o$16.castObject(e3, o$16.PeGeogtran);
          break;
        default:
          t3 & s$1a.PE_TYPE_UNIT && (e3 = o$16.castObject(e3, o$16.PeUnit));
      }
    }
    return e3;
  };
  function _2() {
    o$16.PeFactory.prototype.initialize(null);
  }
  function P2(e3) {
    return E2(s$1a.PE_TYPE_COORDSYS, e3);
  }
  function E2(e3, r3) {
    let _3 = null, P3 = t2[e3];
    if (P3 || (P3 = {}, t2[e3] = P3), P3.hasOwnProperty(String(r3)))
      _3 = P3[r3];
    else {
      const t3 = o$16.PeFactory.prototype.factoryByType(e3, r3);
      o$16.compare(t3, o$16.NULL) || (_3 = t3, P3[r3] = _3);
    }
    return _3 = n2(_3), _3;
  }
  function i2(e3, t3) {
    let _3 = null, P3 = r2[e3];
    if (P3 || (P3 = {}, r2[e3] = P3), P3.hasOwnProperty(t3))
      _3 = P3[t3];
    else {
      const r3 = o$16.PeFactory.prototype.fromString(e3, t3);
      o$16.compare(r3, o$16.NULL) || (_3 = r3, P3[t3] = _3);
    }
    return _3 = n2(_3), _3;
  }
  function p2(e3) {
    return E2(s$1a.PE_TYPE_GEOGCS, e3);
  }
  function u2(e3) {
    return E2(s$1a.PE_TYPE_GEOGTRAN, e3);
  }
  function a2(e3) {
    return o$16.PeFactory.prototype.getCode(e3);
  }
  function c2(e3) {
    return E2(s$1a.PE_TYPE_PROJCS, e3);
  }
  function g2(e3) {
    return E2(s$1a.PE_TYPE_UNIT, e3);
  }
  e2.initialize = _2, e2.coordsys = P2, e2.factoryByType = E2, e2.fromString = i2, e2.geogcs = p2, e2.geogtran = u2, e2.getCode = a2, e2.projcs = c2, e2.unit = g2;
}(E$i || (E$i = {}));
let i$1v = null;
var p$1S, u$$, a$1z, c$1H, g$E, T$g, f$V, O$d, l$1b;
function S$q(e2) {
  function t2(e3, t3, o2) {
    e3[t3] = o2(e3[t3]);
  }
  o$16 = e2, s$1a.init(), p$1S.init(), g$E.init(), f$V.init(), O$d.init(), i$1v = class extends o$16.PeGCSExtent {
    destroy() {
      o$16.destroy(this);
    }
  };
  const r2 = [o$16.PeDatum, o$16.PeGeogcs, o$16.PeGeogtran, o$16.PeObject, o$16.PeParameter, o$16.PePrimem, o$16.PeProjcs, o$16.PeSpheroid, o$16.PeUnit];
  for (const o2 of r2)
    t2(o2.prototype, "getName", (e3) => function() {
      return e3.call(this, new Array(s$1a.PE_NAME_MAX));
    });
  for (const P2 of [o$16.PeGeogtran, o$16.PeProjcs])
    t2(P2.prototype, "getParameters", (e3) => function() {
      const t3 = new Array(s$1a.PE_PARM_MAX);
      let r3 = e3.call(this);
      for (let e4 = 0; e4 < t3.length; e4++) {
        const n3 = o$16.getValue(r3, "*");
        t3[e4] = n3 ? o$16.wrapPointer(n3, o$16.PeParameter) : null, r3 += Int32Array.BYTES_PER_ELEMENT;
      }
      return t3;
    });
  t2(o$16.PeHorizon.prototype, "getCoord", (e3) => function() {
    const t3 = this.getSize();
    if (!t3)
      return null;
    const o2 = [];
    return A$e(o2, t3, e3.call(this)), o2;
  }), t2(o$16.PeGTlistExtendedEntry.prototype, "getEntries", (e3) => {
    const t3 = o$16._pe_getPeGTlistExtendedGTsSize();
    return function() {
      let r3 = null;
      const n3 = e3.call(this);
      if (!o$16.compare(n3, o$16.NULL)) {
        r3 = [n3];
        const e4 = this.getSteps();
        if (e4 > 1) {
          const _3 = o$16.getPointer(n3);
          for (let n4 = 1; n4 < e4; n4++)
            r3.push(o$16.wrapPointer(_3 + t3 * n4, o$16.PeGTlistExtendedGTs));
        }
      }
      return r3;
    };
  });
  const n2 = o$16._pe_getPeHorizonSize(), _2 = (e3) => function() {
    let t3 = this._cache;
    if (t3 || (t3 = new Map(), this._cache = t3), t3.has(e3))
      return t3.get(e3);
    let r3 = null;
    const _3 = e3.call(this);
    if (!o$16.compare(_3, o$16.NULL)) {
      r3 = [_3];
      const e4 = _3.getNump();
      if (e4 > 1) {
        const t4 = o$16.getPointer(_3);
        for (let _4 = 1; _4 < e4; _4++)
          r3.push(o$16.wrapPointer(t4 + n2 * _4, o$16.PeHorizon));
      }
    }
    return t3.set(e3, r3), r3;
  };
  t2(o$16.PeProjcs.prototype, "horizonGcsGenerate", _2), t2(o$16.PeProjcs.prototype, "horizonPcsGenerate", _2), o$16.PeObject.prototype.toString = function(e3 = s$1a.PE_STR_OPTS_NONE) {
    o$16.ensureCache.prepare();
    const t3 = o$16.getPointer(this), r3 = o$16.ensureInt8(new Array(s$1a.PE_BUFFER_MAX));
    return o$16.UTF8ToString(o$16._pe_object_to_string_ext(t3, e3, r3));
  };
}
function N$9(e2) {
  if (!e2)
    return;
  const t2 = o$16.getClass(e2);
  if (!t2)
    return;
  const r2 = o$16.getCache(t2);
  if (!r2)
    return;
  const n2 = o$16.getPointer(e2);
  n2 && delete r2[n2];
}
function y$Q(e2, t2) {
  const r2 = [], n2 = new Array(t2);
  for (let _2 = 0; _2 < e2; _2++)
    r2.push(o$16.ensureInt8(n2));
  return r2;
}
function M$e(e2) {
  let t2;
  return Array.isArray(e2[0]) ? (t2 = [], e2.forEach((e3) => {
    t2.push(e3[0], e3[1]);
  })) : t2 = e2, t2;
}
function A$e(e2, t2, r2, n2 = false) {
  if (n2)
    for (let _2 = 0; _2 < 2 * t2; _2++)
      e2[_2] = o$16.getValue(r2 + _2 * Float64Array.BYTES_PER_ELEMENT, "double");
  else {
    const n3 = e2.length === 0;
    for (let _2 = 0; _2 < t2; _2++)
      n3 && (e2[_2] = new Array(2)), e2[_2][0] = o$16.getValue(r2, "double"), e2[_2][1] = o$16.getValue(r2 + Float64Array.BYTES_PER_ELEMENT, "double"), r2 += 2 * Float64Array.BYTES_PER_ELEMENT;
  }
}
!function(e2) {
  let t2;
  function r2() {
    e2.PE_GTLIST_OPTS_COMMON = o$16.PeGTlistExtended.prototype.PE_GTLIST_OPTS_COMMON, t2 = o$16._pe_getPeGTlistExtendedEntrySize();
  }
  function n2(e3, r3, n3, _2, P2, s2) {
    let E2 = null;
    const i2 = new o$16.PeInteger(s2);
    try {
      const p2 = o$16.PeGTlistExtended.prototype.getGTlist(e3, r3, n3, _2, P2, i2);
      if ((s2 = i2.val) && (E2 = [p2], s2 > 1)) {
        const e4 = o$16.getPointer(p2);
        for (let r4 = 1; r4 < s2; r4++)
          E2.push(o$16.wrapPointer(e4 + t2 * r4, o$16.PeGTlistExtendedEntry));
      }
    } finally {
      o$16.destroy(i2);
    }
    return E2;
  }
  e2.init = r2, e2.getGTlist = n2;
}(p$1S || (p$1S = {})), function(e2) {
  function t2(e3) {
    if (e3 && e3.length) {
      for (const t3 of e3)
        N$9(t3), t3.getEntries().forEach((e4) => {
          N$9(e4);
          const t4 = e4.getGeogtran();
          N$9(t4), t4.getParameters().forEach(N$9), [t4.getGeogcs1(), t4.getGeogcs2()].forEach((e5) => {
            N$9(e5);
            const t5 = e5.getDatum();
            N$9(t5), N$9(t5.getSpheroid()), N$9(e5.getPrimem()), N$9(e5.getUnit());
          });
        });
      o$16.PeGTlistExtendedEntry.prototype.Delete(e3[0]);
    }
  }
  e2.destroy = t2;
}(u$$ || (u$$ = {})), function(e2) {
  function t2(e3, t3, r2, n2, _2) {
    o$16.ensureCache.prepare();
    const P2 = M$e(r2), s2 = r2 === P2, E2 = o$16.ensureFloat64(P2);
    let i2 = 0;
    n2 && (i2 = o$16.ensureFloat64(n2));
    const p2 = o$16._pe_geog_to_geog(o$16.getPointer(e3), t3, E2, i2, _2);
    return p2 && A$e(r2, t3, E2, s2), p2;
  }
  e2.geogToGeog = t2;
}(a$1z || (a$1z = {})), function(e2) {
  const t2 = (e3, t3, r3, n3, _3, P3) => {
    let E3, i3;
    switch (o$16.ensureCache.prepare(), e3) {
      case "dd":
        E3 = o$16._pe_geog_to_dd, i3 = s$1a.PE_DD_MAX;
        break;
      case "ddm":
        E3 = o$16._pe_geog_to_ddm, i3 = s$1a.PE_DDM_MAX;
        break;
      case "dms":
        E3 = o$16._pe_geog_to_dms, i3 = s$1a.PE_DMS_MAX;
    }
    let p3 = 0;
    t3 && (p3 = o$16.getPointer(t3));
    const u2 = M$e(n3), a2 = o$16.ensureFloat64(u2), c2 = y$Q(r3, i3), g2 = E3(p3, r3, a2, _3, o$16.ensureInt32(c2));
    if (g2)
      for (let s2 = 0; s2 < r3; s2++)
        P3[s2] = o$16.UTF8ToString(c2[s2]);
    return g2;
  }, r2 = (e3, t3, r3, n3, _3) => {
    let P3;
    switch (o$16.ensureCache.prepare(), e3) {
      case "dd":
        P3 = o$16._pe_dd_to_geog;
        break;
      case "ddm":
        P3 = o$16._pe_ddm_to_geog;
        break;
      case "dms":
        P3 = o$16._pe_dms_to_geog;
    }
    let s2 = 0;
    t3 && (s2 = o$16.getPointer(t3));
    const E3 = n3.map((e4) => o$16.ensureString(e4)), i3 = o$16.ensureInt32(E3), p3 = o$16.ensureFloat64(new Array(2 * r3)), u2 = P3(s2, r3, i3, p3);
    return u2 && A$e(_3, r3, p3), u2;
  };
  function n2(e3, o2, r3, n3, _3) {
    return t2("dms", e3, o2, r3, n3, _3);
  }
  function _2(e3, t3, o2, n3) {
    return r2("dms", e3, t3, o2, n3);
  }
  function P2(e3, o2, r3, n3, _3) {
    return t2("ddm", e3, o2, r3, n3, _3);
  }
  function E2(e3, t3, o2, n3) {
    return r2("ddm", e3, t3, o2, n3);
  }
  function i2(e3, o2, r3, n3, _3) {
    return t2("dd", e3, o2, r3, n3, _3);
  }
  function p2(e3, t3, o2, n3) {
    return r2("dd", e3, t3, o2, n3);
  }
  e2.geogToDms = n2, e2.dmsToGeog = _2, e2.geogToDdm = P2, e2.ddmToGeog = E2, e2.geogToDd = i2, e2.ddToGeog = p2;
}(c$1H || (c$1H = {})), function(e2) {
  function t2() {
    e2.PE_MGRS_STYLE_NEW = o$16.PeNotationMgrs.prototype.PE_MGRS_STYLE_NEW, e2.PE_MGRS_STYLE_OLD = o$16.PeNotationMgrs.prototype.PE_MGRS_STYLE_OLD, e2.PE_MGRS_STYLE_AUTO = o$16.PeNotationMgrs.prototype.PE_MGRS_STYLE_AUTO, e2.PE_MGRS_180_ZONE_1_PLUS = o$16.PeNotationMgrs.prototype.PE_MGRS_180_ZONE_1_PLUS, e2.PE_MGRS_ADD_SPACES = o$16.PeNotationMgrs.prototype.PE_MGRS_ADD_SPACES;
  }
  function r2(e3, t3, r3, n3, _2, P2, E2) {
    o$16.ensureCache.prepare();
    let i2 = 0;
    e3 && (i2 = o$16.getPointer(e3));
    const p2 = M$e(r3), u2 = o$16.ensureFloat64(p2), a2 = y$Q(t3, s$1a.PE_MGRS_MAX), c2 = o$16.ensureInt32(a2), g2 = o$16._pe_geog_to_mgrs_extended(i2, t3, u2, n3, _2, P2, c2);
    if (g2)
      for (let s2 = 0; s2 < t3; s2++)
        E2[s2] = o$16.UTF8ToString(a2[s2]);
    return g2;
  }
  function n2(e3, t3, r3, n3, _2) {
    o$16.ensureCache.prepare();
    let P2 = 0;
    e3 && (P2 = o$16.getPointer(e3));
    const s2 = r3.map((e4) => o$16.ensureString(e4)), E2 = o$16.ensureInt32(s2), i2 = o$16.ensureFloat64(new Array(2 * t3)), p2 = o$16._pe_mgrs_to_geog_extended(P2, t3, E2, n3, i2);
    return p2 && A$e(_2, t3, i2), p2;
  }
  e2.init = t2, e2.geogToMgrsExtended = r2, e2.mgrsToGeogExtended = n2;
}(g$E || (g$E = {})), function(e2) {
  function t2(e3, t3, r3, n2, _2, P2, E2) {
    o$16.ensureCache.prepare();
    let i2 = 0;
    e3 && (i2 = o$16.getPointer(e3));
    const p2 = M$e(r3), u2 = o$16.ensureFloat64(p2), a2 = y$Q(t3, s$1a.PE_MGRS_MAX), c2 = o$16.ensureInt32(a2), g2 = o$16._pe_geog_to_usng(i2, t3, u2, n2, _2, P2, c2);
    if (g2)
      for (let s2 = 0; s2 < t3; s2++)
        E2[s2] = o$16.UTF8ToString(a2[s2]);
    return g2;
  }
  function r2(e3, t3, r3, n2) {
    o$16.ensureCache.prepare();
    let _2 = 0;
    e3 && (_2 = o$16.getPointer(e3));
    const P2 = r3.map((e4) => o$16.ensureString(e4)), s2 = o$16.ensureInt32(P2), E2 = o$16.ensureFloat64(new Array(2 * t3)), i2 = o$16._pe_usng_to_geog(_2, t3, s2, E2);
    return i2 && A$e(n2, t3, E2), i2;
  }
  e2.geogToUsng = t2, e2.usngToGeog = r2;
}(T$g || (T$g = {})), function(e2) {
  function t2() {
    e2.PE_UTM_OPTS_NONE = o$16.PeNotationUtm.prototype.PE_UTM_OPTS_NONE, e2.PE_UTM_OPTS_ADD_SPACES = o$16.PeNotationUtm.prototype.PE_UTM_OPTS_ADD_SPACES, e2.PE_UTM_OPTS_NS = o$16.PeNotationUtm.prototype.PE_UTM_OPTS_NS;
  }
  function r2(e3, t3, r3, n3, _2) {
    o$16.ensureCache.prepare();
    let P2 = 0;
    e3 && (P2 = o$16.getPointer(e3));
    const E2 = M$e(r3), i2 = o$16.ensureFloat64(E2), p2 = y$Q(t3, s$1a.PE_UTM_MAX), u2 = o$16.ensureInt32(p2), a2 = o$16._pe_geog_to_utm(P2, t3, i2, n3, u2);
    if (a2)
      for (let s2 = 0; s2 < t3; s2++)
        _2[s2] = o$16.UTF8ToString(p2[s2]);
    return a2;
  }
  function n2(e3, t3, r3, n3, _2) {
    o$16.ensureCache.prepare();
    let P2 = 0;
    e3 && (P2 = o$16.getPointer(e3));
    const s2 = r3.map((e4) => o$16.ensureString(e4)), E2 = o$16.ensureInt32(s2), i2 = o$16.ensureFloat64(new Array(2 * t3)), p2 = o$16._pe_utm_to_geog(P2, t3, E2, n3, i2);
    return p2 && A$e(_2, t3, i2), p2;
  }
  e2.init = t2, e2.geogToUtm = r2, e2.utmToGeog = n2;
}(f$V || (f$V = {})), function(e2) {
  const t2 = new Map();
  function r2() {
    e2.PE_PCSINFO_OPTION_NONE = o$16.PePCSInfo.prototype.PE_PCSINFO_OPTION_NONE, e2.PE_PCSINFO_OPTION_DOMAIN = o$16.PePCSInfo.prototype.PE_PCSINFO_OPTION_DOMAIN, e2.PE_POLE_OUTSIDE_BOUNDARY = o$16.PePCSInfo.prototype.PE_POLE_OUTSIDE_BOUNDARY, e2.PE_POLE_POINT = o$16.PePCSInfo.prototype.PE_POLE_POINT;
  }
  function n2(r3, n3 = e2.PE_PCSINFO_OPTION_DOMAIN) {
    let _2 = null, P2 = null;
    return t2.has(r3) && (P2 = t2.get(r3), P2[n3] && (_2 = P2[n3])), _2 || (_2 = o$16.PePCSInfo.prototype.generate(r3, n3), P2 || (P2 = [], t2.set(r3, P2)), P2[n3] = _2), _2;
  }
  e2.init = r2, e2.generate = n2;
}(O$d || (O$d = {})), function(e2) {
  function t2() {
    return o$16.PeVersion.prototype.version_string();
  }
  e2.versionString = t2;
}(l$1b || (l$1b = {}));
const d$X = Object.freeze(Object.defineProperty({ __proto__: null, get _pe() {
  return o$16;
}, isLoaded: r$T, isSupported: n$1x, load: _$o, get PeCSTransformations() {
  return P$f;
}, get PeDefs() {
  return s$1a;
}, get PeFactory() {
  return E$i;
}, get PeGCSExtent() {
  return i$1v;
}, get PeGTlistExtended() {
  return p$1S;
}, get PeGTlistExtendedEntry() {
  return u$$;
}, get PeGTTransformations() {
  return a$1z;
}, get PeNotationDms() {
  return c$1H;
}, get PeNotationMgrs() {
  return g$E;
}, get PeNotationUsng() {
  return T$g;
}, get PeNotationUtm() {
  return f$V;
}, get PePCSInfo() {
  return O$d;
}, get PeVersion() {
  return l$1b;
}, _init: S$q }, Symbol.toStringTag, { value: "Module" }));
const r$S = s$1M.radius, n$1w = s$1M.eccentricitySquared, s$19 = { a1: r$S * n$1w, a2: r$S * n$1w * r$S * n$1w, a3: r$S * n$1w * n$1w / 2, a4: r$S * n$1w * r$S * n$1w * 2.5, a5: r$S * n$1w + r$S * n$1w * n$1w / 2, a6: 1 - n$1w };
({ 4267: { a: 63782064e-1, f: 1 / 294.9786982 }, 4269: { a: 6378137, f: 1 / 298.257222101 }, 4326: { a: s$1M.radius, f: s$1M.flattening }, 104900: { a: 2439700, f: 0 }, 104901: { a: 6051e3, f: 0 }, 104902: { a: 6051800, f: 0 }, 104903: { a: e$1A.radius, f: e$1A.flattening }, 104904: { a: 3393400, f: 1 / 192.0430107526882 }, 104905: { a: t$1y.radius, f: t$1y.flattening }, 104906: { a: 6200, f: 0 }, 104907: { a: 11100, f: 0 }, 104908: { a: 71492e3, f: 0.06487439154031222 }, 104909: { a: 8200, f: 0 }, 104910: { a: 83500, f: 0 }, 104911: { a: 1e4, f: 0 }, 104912: { a: 2409300, f: 0 }, 104913: { a: 15e3, f: 0 }, 104914: { a: 4e4, f: 0 }, 104915: { a: 1562090, f: 0 }, 104916: { a: 2632345, f: 0 }, 104917: { a: 85e3, f: 0 }, 104918: { a: 1821460, f: 0 }, 104919: { a: 5e3, f: 0 }, 104920: { a: 12e3, f: 0 }, 104921: { a: 3e4, f: 3 }, 104922: { a: 18e3, f: 0 }, 104923: { a: 14e3, f: 0 }, 104924: { a: 49300, f: 0 }, 104925: { a: 60268e3, f: 1 / 10.2079945799458 }, 104926: { a: 16e3, f: 0 }, 104927: { a: 9500, f: 0 }, 104928: { a: 56e4, f: 0 }, 104929: { a: 249400, f: 0 }, 104930: { a: 59500, f: 0 }, 104931: { a: 16e3, f: 0 }, 104932: { a: 133e3, f: 0 }, 104933: { a: 718e3, f: 0 }, 104934: { a: 888e3, f: 0 }, 104935: { a: 1986300, f: 0 }, 104936: { a: 1e4, f: 0 }, 104937: { a: 41900, f: 0 }, 104938: { a: 11e4, f: 0 }, 104939: { a: 50100, f: 0 }, 104940: { a: 764e3, f: 0 }, 104941: { a: 11e3, f: 0 }, 104942: { a: 529800, f: 0 }, 104943: { a: 2575e3, f: 0 }, 104944: { a: 25559e3, f: 1 / 43.61604095563141 }, 104945: { a: 578900, f: 0 }, 104946: { a: 33e3, f: 0 }, 104947: { a: 21e3, f: 0 }, 104948: { a: 13e3, f: 0 }, 104949: { a: 31e3, f: 0 }, 104950: { a: 27e3, f: 0 }, 104951: { a: 42e3, f: 0 }, 104952: { a: 235800, f: 0 }, 104953: { a: 761400, f: 0 }, 104954: { a: 15e3, f: 0 }, 104955: { a: 54e3, f: 0 }, 104956: { a: 77e3, f: 0 }, 104957: { a: 27e3, f: 0 }, 104958: { a: 788900, f: 0 }, 104959: { a: 584700, f: 0 }, 104960: { a: 24764e3, f: 0.01708124697141011 }, 104961: { a: 74e3, f: 0 }, 104962: { a: 79e3, f: 0 }, 104963: { a: 104e3, f: 0.14423076923076922 }, 104964: { a: 29e3, f: 0 }, 104965: { a: 17e4, f: 0 }, 104966: { a: 208e3, f: 0 }, 104967: { a: 4e4, f: 0 }, 104968: { a: 1352600, f: 0 }, 104969: { a: 1195e3, f: 0 }, 104970: { a: 593e3, f: 0 }, 104971: { a: t$1y.radius, f: 0 }, 104972: { a: 47e4, f: 0 }, 104973: { a: 255e3, f: 0 }, 104974: { a: 2439400, f: 0 } });
let s$18 = 0;
class t$17 {
  constructor(t2) {
    this.uid = s$18++, t2 ? (this._wkt = t2.wkt != null ? t2.wkt : null, this._wkid = t2.wkid != null ? t2.wkid : -1, this._isInverse = t2.isInverse != null && t2.isInverse === true) : (this._wkt = null, this._wkid = -1, this._isInverse = false);
  }
  static fromGE(s2) {
    const i2 = new t$17();
    return i2._wkt = s2.wkt, i2._wkid = s2.wkid, i2._isInverse = s2.isInverse, i2;
  }
  get wkt() {
    return this._wkt;
  }
  set wkt(t2) {
    this._wkt = t2, this.uid = s$18++;
  }
  get wkid() {
    return this._wkid;
  }
  set wkid(t2) {
    this._wkid = t2, this.uid = s$18++;
  }
  get isInverse() {
    return this._isInverse;
  }
  set isInverse(t2) {
    this._isInverse = t2, this.uid = s$18++;
  }
  getInverse() {
    const s2 = new t$17();
    return s2._wkt = this.wkt, s2._wkid = this._wkid, s2._isInverse = !this.isInverse, s2;
  }
}
class s$17 {
  constructor(s2) {
    if (this.steps = [], this._cachedProjection = {}, this._chain = "", this._gtlistentry = null, s2 && s2.steps)
      for (const i2 of s2.steps)
        i2 instanceof t$17 ? this.steps.push(i2) : this.steps.push(new t$17({ wkid: i2.wkid, wkt: i2.wkt, isInverse: i2.isInverse }));
  }
  static cacheKey(t2, s2) {
    return [t2.wkid !== void 0 && t2.wkid !== null ? t2.wkid.toString() : "-1", t2.wkt !== void 0 && t2.wkt !== null ? t2.wkt.toString() : "", s2.wkid !== void 0 && s2.wkid !== null ? s2.wkid.toString() : "-1", s2.wkt !== void 0 && s2.wkt !== null ? s2.wkt.toString() : ""].join(",");
  }
  static fromGE(i2) {
    const e2 = new s$17();
    let n2 = "";
    for (const s2 of i2.steps) {
      const i3 = t$17.fromGE(s2);
      e2.steps.push(i3), n2 += i3.uid.toString() + ",";
    }
    return e2._cachedProjection = {}, e2._gtlistentry = null, e2._chain = n2, e2;
  }
  getInverse() {
    const t2 = new s$17();
    t2.steps = [];
    for (let s2 = this.steps.length - 1; s2 >= 0; s2--) {
      const i2 = this.steps[s2];
      t2.steps.push(i2.getInverse());
    }
    return t2;
  }
  getGTListEntry() {
    let t2 = "";
    for (const s2 of this.steps)
      t2 += s2.uid.toString() + ",";
    return t2 !== this._chain && (this._gtlistentry = null, this._cachedProjection = {}, this._chain = t2), this._gtlistentry;
  }
  assignCachedGe(t2, i2, e2) {
    this._cachedProjection[s$17.cacheKey(t2, i2)] = e2;
  }
  getCachedGeTransformation(t2, i2) {
    let e2 = "";
    for (const s2 of this.steps)
      e2 += s2.uid.toString() + ",";
    e2 !== this._chain && (this._gtlistentry = null, this._cachedProjection = {}, this._chain = e2);
    const n2 = this._cachedProjection[s$17.cacheKey(t2, i2)];
    return n2 === void 0 ? null : n2;
  }
}
function o$15(o2, f2, u2) {
  if (t$1W(f2) || t$1W(u2) || u2.vcsWkid || E$u(f2, u2))
    return null;
  const a2 = L$h(f2) / L$h(u2);
  if (a2 === 1)
    return null;
  switch (o2) {
    case "point":
    case "esriGeometryPoint":
      return (n2) => r$R(n2, a2);
    case "polyline":
    case "esriGeometryPolyline":
      return (n2) => s$16(n2, a2);
    case "polygon":
    case "esriGeometryPolygon":
      return (n2) => i$1u(n2, a2);
    case "multipoint":
    case "esriGeometryMultipoint":
      return (n2) => c$1G(n2, a2);
    case "extent":
    case "esriGeometryExtent":
      return (n2) => l$1a(n2, a2);
    default:
      return null;
  }
}
function r$R(n2, e2) {
  n2 && n2.z != null && (n2.z *= e2);
}
function i$1u(n2, e2) {
  if (n2)
    for (const t2 of n2.rings)
      for (const n3 of t2)
        n3.length > 2 && (n3[2] *= e2);
}
function s$16(n2, e2) {
  if (n2)
    for (const t2 of n2.paths)
      for (const n3 of t2)
        n3.length > 2 && (n3[2] *= e2);
}
function c$1G(n2, e2) {
  if (n2)
    for (const t2 of n2.points)
      t2.length > 2 && (t2[2] *= e2);
}
function l$1a(n2, e2) {
  n2 && n2.zmin != null && n2.zmax != null && (n2.zmin *= e2, n2.zmax *= e2);
}
let J$6 = null, Q$5 = null, Y$3 = null, $$9 = {};
const nn = new e$1u();
function en() {
  return !!J$6 && r$T();
}
function tn(n2) {
  return t$1W(Y$3) && (Y$3 = Promise.all([_$o(), import("./geometryEngineBase.js").then((n3) => n3.g), import("./hydrated.js")])), Y$3.then(([, e2, { hydratedAdapter: t2 }]) => {
    f$1x(n2), Q$5 = t2, J$6 = e2.default, J$6._enableProjection(d$X), nn.notify();
  });
}
function rn(n2, e2, t2 = null, r2 = null) {
  return Array.isArray(n2) ? n2.length === 0 ? [] : ln(Q$5, n2, n2[0].spatialReference, e2, t2, r2) : ln(Q$5, [n2], n2.spatialReference, e2, t2, r2)[0];
}
function ln(n2, e2, t2, r2, l2 = null, i2 = null) {
  if (t$1W(t2) || t$1W(r2))
    return e2;
  if (An(t2, r2, l2))
    return e2.map((n3) => e$1U(Pn(n3, t2, r2)));
  if (t$1W(l2)) {
    const n3 = s$17.cacheKey(t2, r2);
    $$9[n3] !== void 0 ? l2 = $$9[n3] : (l2 = sn(t2, r2, void 0), t$1W(l2) && (l2 = new s$17()), $$9[n3] = l2);
  }
  if (t$1W(J$6) || t$1W(n2))
    throw new cn();
  return r$1t(i2) ? J$6._project(n2, e2, t2, r2, l2, i2) : J$6._project(n2, e2, t2, r2, l2);
}
function un(n2, e2) {
  const t2 = on([n2], e2);
  return r$1t(t2.pending) ? { pending: t2.pending, geometry: null } : r$1t(t2.geometries) ? { pending: null, geometry: t2.geometries[0] } : { pending: null, geometry: null };
}
function on(n2, e2) {
  if (!en()) {
    for (const t2 of n2)
      if (r$1t(t2) && !E$u(t2.spatialReference, e2) && I$v(t2.spatialReference) && I$v(e2) && !An(t2.spatialReference, e2))
        return s$1X(nn), { pending: tn(), geometries: null };
  }
  return { pending: null, geometries: n2.map((n3) => t$1W(n3) ? null : E$u(n3.spatialReference, e2) ? n3 : I$v(n3.spatialReference) && I$v(e2) ? fn(n3, e2) : null) };
}
function sn(n2, e2, t2 = null) {
  if (t$1W(n2) || t$1W(e2))
    return null;
  if (t$1W(J$6) || t$1W(Q$5))
    throw new cn();
  const r2 = J$6._getTransformation(Q$5, n2, e2, t2, t2 == null ? void 0 : t2.spatialReference);
  return r2 !== null ? s$17.fromGE(r2) : null;
}
class cn extends s$1Z {
  constructor() {
    super("projection:not-loaded", "projection engine not fully loaded yet, please call load()");
  }
}
var En;
!function(n2) {
  n2[n2.UNKNOWN = 0] = "UNKNOWN", n2[n2.SPHERICAL_ECEF = 1] = "SPHERICAL_ECEF", n2[n2.WGS84 = 2] = "WGS84", n2[n2.WEB_MERCATOR = 3] = "WEB_MERCATOR", n2[n2.WGS84_ECEF = 4] = "WGS84_ECEF", n2[n2.CGCS2000 = 5] = "CGCS2000", n2[n2.WGS84_COMPARABLE_LON_LAT = 6] = "WGS84_COMPARABLE_LON_LAT", n2[n2.SPHERICAL_MARS_PCPF = 7] = "SPHERICAL_MARS_PCPF", n2[n2.GCSMARS2000 = 8] = "GCSMARS2000", n2[n2.SPHERICAL_MOON_PCPF = 9] = "SPHERICAL_MOON_PCPF", n2[n2.GCSMOON2000 = 10] = "GCSMOON2000", n2[n2.LON_LAT = 11] = "LON_LAT", n2[n2.PLATE_CARREE = 12] = "PLATE_CARREE";
}(En || (En = {}));
function fn(n2, e2) {
  try {
    const t2 = rn(n2, e2);
    if (t2 == null)
      return null;
    "xmin" in n2 && "xmin" in t2 && (t2.zmin = n2.zmin, t2.zmax = n2.zmax);
    const r2 = o$15(t2.type, n2.spatialReference, e2);
    return r$1t(r2) && r2(t2), t2;
  } catch (t2) {
    if (!(t2 instanceof cn))
      throw t2;
    return null;
  }
}
function An(n2, e2, t2) {
  return !t2 && (!!E$u(n2, e2) || I$v(n2) && I$v(e2) && !!de$2(n2, e2, ye$2));
}
async function _n(n2, e2, t2, r2) {
  if (en())
    return O$o(r2);
  if (Array.isArray(n2)) {
    for (const { source: l2, dest: u2, geographicTransformation: o2 } of n2)
      if (!An(l2, u2, o2))
        return tn(r2);
  } else if (!An(n2, e2, t2))
    return tn(r2);
  return O$o(r2);
}
function Pn(n2, e2, t2) {
  return n2 ? "x" in n2 ? Ln(n2, e2, new w$K(), t2, 0) : "xmin" in n2 ? In(n2, e2, new w$J(), t2, 0) : "rings" in n2 ? Tn(n2, e2, new v$O(), t2, 0) : "paths" in n2 ? Gn(n2, e2, new m$1D(), t2, 0) : "points" in n2 ? Mn(n2, e2, new u$1I(), t2, 0) : null : null;
}
function Ln(n2, e2, t2, r2, l2) {
  ze$1[0] = n2.x, ze$1[1] = n2.y;
  const u2 = n2.z;
  return ze$1[2] = u2 !== void 0 ? u2 : l2, xn(ze$1, e2, 0, ze$1, r2, 0, 1) ? (t2.x = ze$1[0], t2.y = ze$1[1], t2.spatialReference = r2, u2 === void 0 ? (t2.z = void 0, t2.hasZ = false) : (t2.z = ze$1[2], t2.hasZ = true), n2.m === void 0 ? (t2.m = void 0, t2.hasM = false) : (t2.m = n2.m, t2.hasM = true), t2) : null;
}
function Mn(n2, e2, t2, r2, l2) {
  const { points: u2, hasZ: o2, hasM: s2 } = n2, i2 = [], a2 = u2.length, c2 = [];
  for (const E2 of u2)
    c2.push(E2[0], E2[1], o2 ? E2[2] : l2);
  if (!xn(c2, e2, 0, c2, r2, 0, a2))
    return null;
  for (let E2 = 0; E2 < a2; ++E2) {
    const n3 = 3 * E2, e3 = c2[n3], t3 = c2[n3 + 1];
    o2 && s2 ? i2.push([e3, t3, c2[n3 + 2], u2[E2][3]]) : o2 ? i2.push([e3, t3, c2[n3 + 2]]) : s2 ? i2.push([e3, t3, u2[E2][2]]) : i2.push([e3, t3]);
  }
  return t2.points = i2, t2.spatialReference = r2, t2.hasZ = o2, t2.hasM = s2, t2;
}
function Gn(n2, e2, t2, r2, l2) {
  const { paths: u2, hasZ: o2, hasM: s2 } = n2, i2 = [];
  return bn(u2, o2 != null ? o2 : false, s2 != null ? s2 : false, e2, i2, r2, l2) ? (t2.paths = i2, t2.spatialReference = r2, t2.hasZ = o2, t2.hasM = s2, t2) : null;
}
function mn(n2, e2, t2 = e2.spatialReference, r2 = 0) {
  return r$1t(n2.spatialReference) && r$1t(t2) && r$1t(Tn(n2, n2.spatialReference, e2, t2, r2));
}
function Tn(n2, e2, t2, r2, l2) {
  const { rings: u2, hasZ: o2, hasM: s2 } = n2, i2 = [];
  return bn(u2, o2 != null ? o2 : false, s2 != null ? s2 : false, e2, i2, r2, l2) ? (t2.rings = i2, t2.spatialReference = r2, t2.hasZ = o2, t2.hasM = s2, t2) : null;
}
function In(n2, e2, t2, r2, l2) {
  const { xmin: u2, ymin: o2, xmax: s2, ymax: i2, hasZ: a2, hasM: c2 } = n2;
  if (!Bn(u2, o2, a2 ? n2.zmin : l2, e2, ze$1, r2))
    return null;
  t2.xmin = ze$1[0], t2.ymin = ze$1[1], a2 && (t2.zmin = ze$1[2]);
  return Bn(s2, i2, a2 ? n2.zmax : l2, e2, ze$1, r2) ? (t2.xmax = ze$1[0], t2.ymax = ze$1[1], a2 && (t2.zmax = ze$1[2]), c2 && (t2.mmin = n2.mmin, t2.mmax = n2.mmax), t2.spatialReference = r2, t2) : null;
}
function gn(n2, e2, t2, r2 = 0) {
  ze$1[0] = n2.x, ze$1[1] = n2.y;
  const l2 = n2.z;
  return ze$1[2] = l2 !== void 0 ? l2 : r2, xn(ze$1, n2.spatialReference, 0, e2, t2, 0, 1);
}
function Bn(n2, e2, t2, r2, l2, u2) {
  return Ke[0] = n2, Ke[1] = e2, Ke[2] = t2, xn(Ke, r2, 0, l2, u2, 0, 1);
}
function xn(n2, e2, t2, r2, l2, o2, s2 = 1) {
  const i2 = de$2(e2, l2, ye$2);
  if (t$1W(i2))
    return false;
  if (i2 === Qn) {
    if (n2 === r2 && t2 === o2)
      return true;
    const e3 = t2 + 3 * s2;
    for (let l3 = t2, u2 = o2; l3 < e3; l3++, u2++)
      r2[u2] = n2[l3];
    return true;
  }
  const a2 = t2 + 3 * s2;
  for (let u2 = t2, c2 = o2; u2 < a2; u2 += 3, c2 += 3)
    i2(n2, u2, r2, c2);
  return true;
}
function bn(n2, e2, t2, r2, l2, u2, o2 = 0) {
  const s2 = new Array();
  for (const a2 of n2)
    for (const n3 of a2)
      s2.push(n3[0], n3[1], e2 ? n3[2] : o2);
  if (!xn(s2, r2, 0, s2, u2, 0, s2.length / 3))
    return false;
  let i2 = 0;
  l2.length = 0;
  for (const a2 of n2) {
    const n3 = new Array();
    for (const r3 of a2)
      e2 && t2 ? n3.push([s2[i2++], s2[i2++], s2[i2++], r3[3]]) : e2 ? n3.push([s2[i2++], s2[i2++], s2[i2++]]) : t2 ? (n3.push([s2[i2++], s2[i2++], r3[2]]), i2++) : (n3.push([s2[i2++], s2[i2++]]), i2++);
    l2.push(n3);
  }
  return true;
}
function Zn(n2, e2, t2, r2) {
  if (t$1W(n2) || t$1W(r2))
    return false;
  const l2 = Jn(n2, Be$1), o2 = Jn(r2, je$1);
  if (l2 === o2 && !Vn(o2) && (l2 !== En.UNKNOWN || E$u(n2, r2)))
    return x$t(t2, e2), true;
  if (Vn(o2)) {
    const n3 = Ie[l2][En.LON_LAT], r3 = Ie[En.LON_LAT][o2];
    return !t$1W(n3) && !t$1W(r3) && (n3(e2, 0, be, 0), r3(be, 0, ke, 0), Xn(Ue * be[0], Ue * be[1], t2), t2[12] = ke[0], t2[13] = ke[1], t2[14] = ke[2], true);
  }
  if ((o2 === En.WEB_MERCATOR || o2 === En.PLATE_CARREE) && (l2 === En.WGS84 || l2 === En.CGCS2000 && o2 === En.PLATE_CARREE || l2 === En.SPHERICAL_ECEF || l2 === En.WEB_MERCATOR)) {
    const n3 = Ie[l2][En.LON_LAT], r3 = Ie[En.LON_LAT][o2];
    return !t$1W(n3) && !t$1W(r3) && (n3(e2, 0, be, 0), r3(be, 0, ke, 0), l2 === En.SPHERICAL_ECEF ? Dn(Ue * be[0], Ue * be[1], t2) : r$U(t2), t2[12] = ke[0], t2[13] = ke[1], t2[14] = ke[2], true);
  }
  return false;
}
function Vn(n2) {
  return n2 === En.SPHERICAL_ECEF || n2 === En.SPHERICAL_MARS_PCPF || n2 === En.SPHERICAL_MOON_PCPF;
}
function Xn(n2, e2, t2) {
  const r2 = Math.sin(n2), l2 = Math.cos(n2), u2 = Math.sin(e2), o2 = Math.cos(e2), s2 = t2;
  return s2[0] = -r2, s2[4] = -u2 * l2, s2[8] = o2 * l2, s2[12] = 0, s2[1] = l2, s2[5] = -u2 * r2, s2[9] = o2 * r2, s2[13] = 0, s2[2] = 0, s2[6] = o2, s2[10] = u2, s2[14] = 0, s2[3] = 0, s2[7] = 0, s2[11] = 0, s2[15] = 1, s2;
}
function Dn(n2, e2, t2) {
  return Xn(n2, e2, t2), o$17(t2, t2), t2;
}
function Jn(n2, e2) {
  return n2 ? e2.spatialReference === n2 ? e2.spatialReferenceId : (e2.spatialReference = n2, "metersPerUnit" in e2 && (e2.metersPerUnit = $$a(n2, 1)), n2.wkt === I$l.wkt ? e2.spatialReferenceId = En.SPHERICAL_ECEF : G$i(n2) ? e2.spatialReferenceId = En.WGS84 : k$q(n2) ? e2.spatialReferenceId = En.WEB_MERCATOR : T$o(n2) ? e2.spatialReferenceId = En.PLATE_CARREE : n2.wkt === p$1V.wkt ? e2.spatialReferenceId = En.WGS84_ECEF : n2.wkid === S$F.CGCS2000 ? e2.spatialReferenceId = En.CGCS2000 : n2.wkt === E$l.wkt ? e2.spatialReferenceId = En.SPHERICAL_MARS_PCPF : n2.wkt === R$h.wkt ? e2.spatialReferenceId = En.SPHERICAL_MOON_PCPF : P$p(n2) ? e2.spatialReferenceId = En.GCSMARS2000 : s$1O(n2) ? e2.spatialReferenceId = En.GCSMOON2000 : e2.spatialReferenceId = En.UNKNOWN) : En.UNKNOWN;
}
function Qn(n2, e2, t2, r2) {
  n2 !== t2 && (t2[r2++] = n2[e2++], t2[r2++] = n2[e2++], t2[r2] = n2[e2]);
}
function Yn(n2, e2, t2, r2) {
  t2[r2++] = xe * (n2[e2++] / s$1M.radius), t2[r2++] = xe * (Math.PI / 2 - 2 * Math.atan(Math.exp(-n2[e2++] / s$1M.radius))), t2[r2] = n2[e2];
}
function $n(n2, e2, t2, r2) {
  Yn(n2, e2, t2, r2), Pe(t2, r2, t2, r2);
}
function ne$1(n2, e2, t2, r2) {
  Yn(n2, e2, t2, r2), We$1(t2, r2, t2, r2);
}
function ee$1(n2, t2, r2, l2, u2) {
  const o2 = 0.4999999 * Math.PI, s2 = a$21(Ue * n2[t2 + 1], -o2, o2), i2 = Math.sin(s2);
  r2[l2++] = Ue * n2[t2] * u2.radius, r2[l2++] = u2.halfSemiMajorAxis * Math.log((1 + i2) / (1 - i2)), r2[l2] = n2[t2 + 2];
}
function te$1(n2, e2, t2, r2) {
  ee$1(n2, e2, t2, r2, s$1M);
}
const re$1 = s$1M.radius * Math.PI / 180, le$1 = 180 / (s$1M.radius * Math.PI);
function ue$2(n2, e2, t2, r2) {
  t2[r2] = n2[e2] * re$1, t2[r2 + 1] = n2[e2 + 1] * re$1, t2[r2 + 2] = n2[e2 + 2];
}
function oe$1(n2, e2, t2, r2) {
  t2[r2] = n2[e2] * le$1, t2[r2 + 1] = n2[e2 + 1] * le$1, t2[r2 + 2] = n2[e2 + 2];
}
function se$1(n2, e2, t2, r2) {
  Yn(n2, e2, t2, r2), ue$2(t2, r2, t2, r2);
}
function ie$1(n2, e2, t2, r2) {
  me$2(n2, e2, t2, r2), ue$2(t2, r2, t2, r2);
}
function ae$1(n2, e2, t2, r2) {
  Me(n2, e2, t2, r2), ue$2(t2, r2, t2, r2);
}
function ce$2(n2, e2, t2, r2) {
  oe$1(n2, e2, t2, r2), Pe(t2, r2, t2, r2);
}
function Ee(n2, e2, t2, r2) {
  oe$1(n2, e2, t2, r2), te$1(t2, r2, t2, r2);
}
function Ce(n2, e2, t2, r2) {
  oe$1(n2, e2, t2, r2), We$1(t2, r2, t2, r2);
}
function Ae(n2, e2, t2, r2, l2) {
  const u2 = l2 + n2[e2 + 2], o2 = Ue * n2[e2 + 1], s2 = Ue * n2[e2], i2 = Math.cos(o2);
  t2[r2++] = Math.cos(s2) * i2 * u2, t2[r2++] = Math.sin(s2) * i2 * u2, t2[r2] = Math.sin(o2) * u2;
}
function _e$1(n2, e2, t2, r2) {
  Ae(n2, e2, t2, r2, e$1A.radius);
}
function Se$1(n2, e2, t2, r2) {
  Ae(n2, e2, t2, r2, t$1y.radius);
}
function Pe(n2, e2, t2, r2) {
  Ae(n2, e2, t2, r2, s$1M.radius);
}
function pe$2(n2, e2, t2, r2, u2) {
  const o2 = n2[e2], s2 = n2[e2 + 1], i2 = n2[e2 + 2], a2 = Math.sqrt(o2 * o2 + s2 * s2 + i2 * i2), c2 = N$e(i2 / (a2 === 0 ? 1 : a2)), E2 = Math.atan2(s2, o2);
  t2[r2++] = xe * E2, t2[r2++] = xe * c2, t2[r2] = a2 - u2;
}
function Le(n2, e2, t2, r2) {
  pe$2(n2, e2, t2, r2, e$1A.radius);
}
function Oe(n2, e2, t2, r2) {
  pe$2(n2, e2, t2, r2, t$1y.radius);
}
function Me(n2, e2, t2, r2) {
  pe$2(n2, e2, t2, r2, s$1M.radius);
}
function Ne$1(n2, e2, t2, r2) {
  Me(n2, e2, t2, r2), te$1(t2, r2, t2, r2);
}
function Ge$1(n2, e2, t2, r2) {
  Me(n2, e2, t2, r2), We$1(t2, r2, t2, r2);
}
function he$1(n2, e2, t2, r2, l2) {
  const u2 = Ue * n2[e2], o2 = Ue * n2[e2 + 1], s2 = n2[e2 + 2], i2 = Math.sin(o2), a2 = Math.cos(o2), c2 = l2.radius / Math.sqrt(1 - l2.eccentricitySquared * i2 * i2);
  t2[r2++] = (c2 + s2) * a2 * Math.cos(u2), t2[r2++] = (c2 + s2) * a2 * Math.sin(u2), t2[r2++] = (c2 * (1 - l2.eccentricitySquared) + s2) * i2;
}
function We$1(n2, e2, t2, r2) {
  he$1(n2, e2, t2, r2, s$1M);
}
function me$2(n2, e2, t2, r2) {
  const l2 = s$19, u2 = n2[e2], o2 = n2[e2 + 1], s2 = n2[e2 + 2];
  let i2, a2, c2, E2, C2, R2, f2, A2, _2, S2, P2, p2, L2, O2, M2, N2, G2, h2, W2, m2, T2;
  i2 = Math.abs(s2), a2 = u2 * u2 + o2 * o2, c2 = Math.sqrt(a2), E2 = a2 + s2 * s2, C2 = Math.sqrt(E2), m2 = Math.atan2(o2, u2), R2 = s2 * s2 / E2, f2 = a2 / E2, O2 = l2.a2 / C2, M2 = l2.a3 - l2.a4 / C2, f2 > 0.3 ? (A2 = i2 / C2 * (1 + f2 * (l2.a1 + O2 + R2 * M2) / C2), W2 = Math.asin(A2), S2 = A2 * A2, _2 = Math.sqrt(1 - S2)) : (_2 = c2 / C2 * (1 - R2 * (l2.a5 - O2 - f2 * M2) / C2), W2 = Math.acos(_2), S2 = 1 - _2 * _2, A2 = Math.sqrt(S2)), P2 = 1 - s$1M.eccentricitySquared * S2, p2 = s$1M.radius / Math.sqrt(P2), L2 = l2.a6 * p2, O2 = c2 - p2 * _2, M2 = i2 - L2 * A2, G2 = _2 * O2 + A2 * M2, N2 = _2 * M2 - A2 * O2, h2 = N2 / (L2 / P2 + G2), W2 += h2, T2 = G2 + N2 * h2 / 2, s2 < 0 && (W2 = -W2), t2[r2++] = xe * m2, t2[r2++] = xe * W2, t2[r2] = T2;
}
function Te(n2, e2, t2, r2) {
  me$2(n2, e2, t2, r2), Pe(t2, r2, t2, r2);
}
function Fe(n2, e2, t2, r2) {
  me$2(n2, e2, t2, r2), te$1(t2, r2, t2, r2);
}
const Ie = { [En.WGS84]: { [En.CGCS2000]: null, [En.GCSMARS2000]: null, [En.GCSMOON2000]: null, [En.LON_LAT]: Qn, [En.WGS84_COMPARABLE_LON_LAT]: Qn, [En.SPHERICAL_ECEF]: Pe, [En.SPHERICAL_MARS_PCPF]: null, [En.SPHERICAL_MOON_PCPF]: null, [En.UNKNOWN]: null, [En.WEB_MERCATOR]: te$1, [En.PLATE_CARREE]: ue$2, [En.WGS84]: Qn, [En.WGS84_ECEF]: We$1 }, [En.CGCS2000]: { [En.CGCS2000]: Qn, [En.GCSMARS2000]: null, [En.GCSMOON2000]: null, [En.LON_LAT]: Qn, [En.WGS84_COMPARABLE_LON_LAT]: Qn, [En.SPHERICAL_ECEF]: Pe, [En.SPHERICAL_MARS_PCPF]: null, [En.SPHERICAL_MOON_PCPF]: null, [En.UNKNOWN]: null, [En.WEB_MERCATOR]: null, [En.PLATE_CARREE]: ue$2, [En.WGS84]: null, [En.WGS84_ECEF]: We$1 }, [En.GCSMARS2000]: { [En.CGCS2000]: null, [En.GCSMARS2000]: Qn, [En.GCSMOON2000]: null, [En.LON_LAT]: Qn, [En.WGS84_COMPARABLE_LON_LAT]: null, [En.SPHERICAL_ECEF]: null, [En.SPHERICAL_MARS_PCPF]: Se$1, [En.SPHERICAL_MOON_PCPF]: null, [En.UNKNOWN]: null, [En.WEB_MERCATOR]: null, [En.PLATE_CARREE]: null, [En.WGS84]: null, [En.WGS84_ECEF]: null }, [En.GCSMOON2000]: { [En.CGCS2000]: null, [En.GCSMARS2000]: null, [En.GCSMOON2000]: Qn, [En.LON_LAT]: Qn, [En.WGS84_COMPARABLE_LON_LAT]: null, [En.SPHERICAL_ECEF]: null, [En.SPHERICAL_MARS_PCPF]: null, [En.SPHERICAL_MOON_PCPF]: _e$1, [En.UNKNOWN]: null, [En.WEB_MERCATOR]: null, [En.PLATE_CARREE]: null, [En.WGS84]: null, [En.WGS84_ECEF]: null }, [En.WEB_MERCATOR]: { [En.CGCS2000]: null, [En.GCSMARS2000]: null, [En.GCSMOON2000]: null, [En.LON_LAT]: Yn, [En.WGS84_COMPARABLE_LON_LAT]: Yn, [En.SPHERICAL_ECEF]: $n, [En.SPHERICAL_MARS_PCPF]: null, [En.SPHERICAL_MOON_PCPF]: null, [En.UNKNOWN]: null, [En.WEB_MERCATOR]: Qn, [En.PLATE_CARREE]: se$1, [En.WGS84]: Yn, [En.WGS84_ECEF]: ne$1 }, [En.WGS84_ECEF]: { [En.CGCS2000]: me$2, [En.GCSMARS2000]: null, [En.GCSMOON2000]: null, [En.LON_LAT]: me$2, [En.WGS84_COMPARABLE_LON_LAT]: me$2, [En.SPHERICAL_ECEF]: Te, [En.SPHERICAL_MARS_PCPF]: null, [En.SPHERICAL_MOON_PCPF]: null, [En.UNKNOWN]: null, [En.WEB_MERCATOR]: Fe, [En.PLATE_CARREE]: ie$1, [En.WGS84]: me$2, [En.WGS84_ECEF]: Qn }, [En.SPHERICAL_ECEF]: { [En.CGCS2000]: Me, [En.GCSMARS2000]: null, [En.GCSMOON2000]: null, [En.LON_LAT]: Me, [En.WGS84_COMPARABLE_LON_LAT]: Me, [En.SPHERICAL_ECEF]: Qn, [En.SPHERICAL_MARS_PCPF]: null, [En.SPHERICAL_MOON_PCPF]: null, [En.UNKNOWN]: null, [En.WEB_MERCATOR]: Ne$1, [En.PLATE_CARREE]: ae$1, [En.WGS84]: Me, [En.WGS84_ECEF]: Ge$1 }, [En.SPHERICAL_MARS_PCPF]: { [En.CGCS2000]: null, [En.GCSMARS2000]: Oe, [En.GCSMOON2000]: null, [En.LON_LAT]: Oe, [En.WGS84_COMPARABLE_LON_LAT]: null, [En.SPHERICAL_ECEF]: null, [En.SPHERICAL_MARS_PCPF]: Qn, [En.SPHERICAL_MOON_PCPF]: null, [En.UNKNOWN]: null, [En.WEB_MERCATOR]: null, [En.PLATE_CARREE]: null, [En.WGS84]: null, [En.WGS84_ECEF]: null }, [En.SPHERICAL_MOON_PCPF]: { [En.CGCS2000]: null, [En.GCSMARS2000]: null, [En.GCSMOON2000]: Le, [En.LON_LAT]: Le, [En.WGS84_COMPARABLE_LON_LAT]: null, [En.SPHERICAL_ECEF]: null, [En.SPHERICAL_MARS_PCPF]: null, [En.SPHERICAL_MOON_PCPF]: Qn, [En.UNKNOWN]: null, [En.WEB_MERCATOR]: null, [En.PLATE_CARREE]: null, [En.WGS84]: null, [En.WGS84_ECEF]: null }, [En.UNKNOWN]: { [En.CGCS2000]: null, [En.GCSMARS2000]: null, [En.GCSMOON2000]: null, [En.LON_LAT]: null, [En.WGS84_COMPARABLE_LON_LAT]: null, [En.SPHERICAL_ECEF]: null, [En.SPHERICAL_MARS_PCPF]: null, [En.SPHERICAL_MOON_PCPF]: null, [En.UNKNOWN]: Qn, [En.WEB_MERCATOR]: null, [En.PLATE_CARREE]: null, [En.WGS84]: null, [En.WGS84_ECEF]: null }, [En.LON_LAT]: { [En.CGCS2000]: Qn, [En.GCSMARS2000]: Qn, [En.GCSMOON2000]: Qn, [En.LON_LAT]: Qn, [En.WGS84_COMPARABLE_LON_LAT]: Qn, [En.SPHERICAL_ECEF]: Pe, [En.SPHERICAL_MARS_PCPF]: Se$1, [En.SPHERICAL_MOON_PCPF]: _e$1, [En.UNKNOWN]: null, [En.WEB_MERCATOR]: te$1, [En.PLATE_CARREE]: ue$2, [En.WGS84]: Qn, [En.WGS84_ECEF]: We$1 }, [En.WGS84_COMPARABLE_LON_LAT]: { [En.CGCS2000]: null, [En.GCSMARS2000]: null, [En.GCSMOON2000]: null, [En.LON_LAT]: Qn, [En.WGS84_COMPARABLE_LON_LAT]: Qn, [En.SPHERICAL_ECEF]: Pe, [En.SPHERICAL_MARS_PCPF]: null, [En.SPHERICAL_MOON_PCPF]: null, [En.UNKNOWN]: null, [En.WEB_MERCATOR]: null, [En.PLATE_CARREE]: ue$2, [En.WGS84]: Qn, [En.WGS84_ECEF]: We$1 }, [En.PLATE_CARREE]: { [En.CGCS2000]: oe$1, [En.GCSMARS2000]: null, [En.GCSMOON2000]: null, [En.LON_LAT]: oe$1, [En.WGS84_COMPARABLE_LON_LAT]: oe$1, [En.SPHERICAL_ECEF]: ce$2, [En.SPHERICAL_MARS_PCPF]: null, [En.SPHERICAL_MOON_PCPF]: null, [En.UNKNOWN]: null, [En.WEB_MERCATOR]: Ee, [En.PLATE_CARREE]: Qn, [En.WGS84]: oe$1, [En.WGS84_ECEF]: Ce } };
function de$2(n2, e2, t2 = ge$2()) {
  return t$1W(n2) || t$1W(e2) ? null : He(n2, e2, t2).projector;
}
function He(n2, e2, t2) {
  if (t$1W(n2) || t$1W(e2) || t2.source.spatialReference === n2 && t2.dest.spatialReference === e2)
    return t2;
  const r2 = Jn(n2, t2.source), l2 = Jn(e2, t2.dest);
  return r2 === En.UNKNOWN && l2 === En.UNKNOWN ? E$u(n2, e2) ? t2.projector = Qn : t2.projector = null : t2.projector = Ie[r2][l2], t2;
}
function ge$2() {
  return { source: { spatialReference: null, spatialReferenceId: En.UNKNOWN, metersPerUnit: 1 }, dest: { spatialReference: null, spatialReferenceId: En.UNKNOWN, metersPerUnit: 1 }, projector: Qn };
}
const Be$1 = { spatialReference: null, spatialReferenceId: En.UNKNOWN }, je$1 = { spatialReference: null, spatialReferenceId: En.UNKNOWN }, ye$2 = ge$2();
ge$2();
const Ue = m$1v(1), xe = b$K(1), Ke = n$1X(), be = n$1X(), ke = n$1X(), ze$1 = n$1X();
var i$1t;
let l$19 = i$1t = class extends l$1_ {
  constructor(e2) {
    super(e2), this.cols = null, this.level = 0, this.levelValue = null, this.origin = null, this.resolution = 0, this.rows = null, this.scale = 0;
  }
  clone() {
    return new i$1t({ cols: this.cols, level: this.level, levelValue: this.levelValue, resolution: this.resolution, rows: this.rows, scale: this.scale });
  }
};
e$1W([y$1o({ json: { write: true, origins: { "web-document": { read: false, write: false }, "portal-item": { read: false, write: false } } } })], l$19.prototype, "cols", void 0), e$1W([y$1o({ type: T$r, json: { write: true } })], l$19.prototype, "level", void 0), e$1W([y$1o({ type: String, json: { write: true } })], l$19.prototype, "levelValue", void 0), e$1W([y$1o({ json: { write: true, origins: { "web-document": { read: false, write: false }, "portal-item": { read: false, write: false } } } })], l$19.prototype, "origin", void 0), e$1W([y$1o({ type: Number, json: { write: true } })], l$19.prototype, "resolution", void 0), e$1W([y$1o({ json: { write: true, origins: { "web-document": { read: false, write: false }, "portal-item": { read: false, write: false } } } })], l$19.prototype, "rows", void 0), e$1W([y$1o({ type: Number, json: { write: true } })], l$19.prototype, "scale", void 0), l$19 = i$1t = e$1W([n$2f("esri.layers.support.LOD")], l$19);
const p$1R = l$19;
class t$16 {
  constructor(t2, s2, i2, e2, h2) {
    this.id = t2, this.level = s2, this.row = i2, this.col = e2, this.extent = h2;
  }
}
var x$s;
const O$c = new s$1F({ PNG: "png", PNG8: "png8", PNG24: "png24", PNG32: "png32", JPEG: "jpg", JPG: "jpg", DIB: "dib", TIFF: "tiff", EMF: "emf", PS: "ps", PDF: "pdf", GIF: "gif", SVG: "svg", SVGZ: "svgz", Mixed: "mixed", MIXED: "mixed", LERC: "lerc", LERC2D: "lerc2d", RAW: "raw", pbf: "pbf" });
let S$p = x$s = class extends l$1_ {
  constructor(e2) {
    super(e2), this.dpi = 96, this.format = null, this.origin = null, this.minScale = 0, this.maxScale = 0, this.size = null, this.spatialReference = null;
  }
  static create(e2 = {}) {
    const { resolutionFactor: t2 = 1, scales: o2, size: r2 = 256, spatialReference: i2 = k$p.WebMercator, numLODs: l2 = 24 } = e2;
    if (!I$v(i2)) {
      const e3 = [];
      if (o2)
        for (let t3 = 0; t3 < o2.length; t3++) {
          const r3 = o2[t3];
          e3.push({ level: t3, scale: r3, resolution: r3 });
        }
      else {
        let t3 = 5e-4;
        for (let o3 = l2 - 1; o3 >= 0; o3--)
          e3.unshift({ level: o3, scale: t3, resolution: t3 }), t3 *= 2;
      }
      return new x$s({ dpi: 96, lods: e3, origin: new w$K(0, 0, i2), size: [r2, r2], spatialReference: i2 });
    }
    const n2 = R$n(i2), a2 = e2.origin ? new w$K({ x: e2.origin.x, y: e2.origin.y, spatialReference: i2 }) : new w$K(n2 ? { x: n2.origin[0], y: n2.origin[1], spatialReference: i2 } : { x: 0, y: 0, spatialReference: i2 }), p2 = 96, f2 = 1 / ($$a(i2) * 39.37 * p2), y2 = [];
    if (o2)
      for (let s2 = 0; s2 < o2.length; s2++) {
        const e3 = o2[s2], t3 = e3 * f2;
        y2.push({ level: s2, scale: e3, resolution: t3 });
      }
    else {
      let e3 = o$1F(i2) ? 512 / r2 * 5916575275917094e-7 : 256 / r2 * 591657527591555e-6;
      const o3 = Math.ceil(l2 / t2);
      y2.push({ level: 0, scale: e3, resolution: e3 * f2 });
      for (let r3 = 1; r3 < o3; r3++) {
        const o4 = e3 / 2 ** t2, s2 = o4 * f2;
        y2.push({ level: r3, scale: o4, resolution: s2 }), e3 = o4;
      }
    }
    return new x$s({ dpi: p2, lods: y2, origin: a2, size: [r2, r2], spatialReference: i2 });
  }
  get isWrappable() {
    const { spatialReference: e2, origin: t2 } = this;
    if (e2 && t2) {
      const o2 = R$n(e2);
      return e2.isWrappable && !!o2 && Math.abs(o2.origin[0] - t2.x) <= o2.dx;
    }
    return false;
  }
  readOrigin(e2, t2) {
    return w$K.fromJSON(__spreadValues({ spatialReference: t2.spatialReference }, e2));
  }
  set lods(e2) {
    let t2 = 0, o2 = 0;
    const r2 = [], s2 = this._levelToLOD = {};
    e2 && (t2 = -1 / 0, o2 = 1 / 0, e2.forEach((e3) => {
      r2.push(e3.scale), t2 = e3.scale > t2 ? e3.scale : t2, o2 = e3.scale < o2 ? e3.scale : o2, s2[e3.level] = e3;
    })), this._set("scales", r2), this._set("minScale", t2), this._set("maxScale", o2), this._set("lods", e2), this._initializeUpsampleLevels();
  }
  readSize(e2, t2) {
    return [t2.cols, t2.rows];
  }
  writeSize(e2, t2) {
    t2.cols = e2[0], t2.rows = e2[1];
  }
  zoomToScale(e2) {
    const t2 = this.scales;
    if (e2 <= 0)
      return t2[0];
    if (e2 >= t2.length - 1)
      return t2[t2.length - 1];
    const o2 = Math.floor(e2), r2 = o2 + 1;
    return t2[o2] / (t2[o2] / t2[r2]) ** (e2 - o2);
  }
  scaleToZoom(e2) {
    const t2 = this.scales, o2 = t2.length - 1;
    let r2 = 0;
    for (; r2 < o2; r2++) {
      const o3 = t2[r2], s2 = t2[r2 + 1];
      if (o3 <= e2)
        return r2;
      if (s2 === e2)
        return r2 + 1;
      if (o3 > e2 && s2 < e2)
        return r2 + Math.log(o3 / e2) / Math.log(o3 / s2);
    }
    return r2;
  }
  snapScale(e2, t2 = 0.95) {
    const o2 = this.scaleToZoom(e2);
    return o2 % Math.floor(o2) >= t2 ? this.zoomToScale(Math.ceil(o2)) : this.zoomToScale(Math.floor(o2));
  }
  tileAt(e2, t2, o2, s2) {
    const i2 = this.lodAt(e2);
    if (!i2)
      return null;
    let l2, n2;
    if (typeof t2 == "number")
      l2 = t2, n2 = o2;
    else if (E$u(t2.spatialReference, this.spatialReference))
      l2 = t2.x, n2 = t2.y, s2 = o2;
    else {
      const e3 = M$s(t2, this.spatialReference);
      if (t$1W(e3))
        return null;
      l2 = e3.x, n2 = e3.y, s2 = o2;
    }
    const a2 = i2.resolution * this.size[0], p2 = i2.resolution * this.size[1];
    return s2 || (s2 = new t$16(null, 0, 0, 0, u$1p())), s2.level = e2, s2.row = Math.floor((this.origin.y - n2) / p2 + 1e-3), s2.col = Math.floor((l2 - this.origin.x) / a2 + 1e-3), this.updateTileInfo(s2), s2;
  }
  updateTileInfo(e2, t2 = x$s.ExtrapolateOptions.NONE) {
    let o2 = this.lodAt(e2.level);
    if (!o2 && t2 === x$s.ExtrapolateOptions.POWER_OF_TWO) {
      const t3 = this.lods[this.lods.length - 1];
      t3.level < e2.level && (o2 = t3);
    }
    if (!o2)
      return;
    const r2 = e2.level - o2.level, s2 = o2.resolution * this.size[0] / 2 ** r2, i2 = o2.resolution * this.size[1] / 2 ** r2;
    e2.id = `${e2.level}/${e2.row}/${e2.col}`, e2.extent || (e2.extent = u$1p()), e2.extent[0] = this.origin.x + e2.col * s2, e2.extent[1] = this.origin.y - (e2.row + 1) * i2, e2.extent[2] = e2.extent[0] + s2, e2.extent[3] = e2.extent[1] + i2;
  }
  upsampleTile(e2) {
    const t2 = this._upsampleLevels[e2.level];
    return !(!t2 || t2.parentLevel === -1) && (e2.level = t2.parentLevel, e2.row = Math.floor(e2.row / t2.factor + 1e-3), e2.col = Math.floor(e2.col / t2.factor + 1e-3), this.updateTileInfo(e2), true);
  }
  getTileBounds(e2, t2) {
    const o2 = this.lodAt(t2.level);
    if (o2 == null)
      return null;
    const { resolution: r2 } = o2, s2 = r2 * this.size[0], i2 = r2 * this.size[1];
    return e2[0] = this.origin.x + t2.col * s2, e2[1] = this.origin.y - (t2.row + 1) * i2, e2[2] = e2[0] + s2, e2[3] = e2[1] + i2, e2;
  }
  lodAt(e2) {
    var _a2, _b2;
    return (_b2 = (_a2 = this._levelToLOD) == null ? void 0 : _a2[e2]) != null ? _b2 : null;
  }
  clone() {
    return x$s.fromJSON(this.write({}));
  }
  getOrCreateCompatible(e2, t2) {
    if (this.size[0] === 256 && this.size[1] === 256)
      return e2 === 256 ? this : null;
    const o2 = [], r2 = this.lods.length;
    for (let s2 = 0; s2 < r2; s2++) {
      const e3 = this.lods[s2], r3 = e3.resolution * t2;
      o2.push(new p$1R({ level: e3.level, scale: e3.scale, resolution: r3 }));
    }
    return new x$s({ size: [e2, e2], dpi: this.dpi, format: this.format, compressionQuality: this.compressionQuality, origin: this.origin, spatialReference: this.spatialReference, lods: o2 });
  }
  _initializeUpsampleLevels() {
    const e2 = this.lods;
    this._upsampleLevels = [];
    let t2 = null;
    for (let o2 = 0; o2 < e2.length; o2++) {
      const r2 = e2[o2];
      this._upsampleLevels[r2.level] = { parentLevel: t2 ? t2.level : -1, factor: t2 ? t2.resolution / r2.resolution : 0 }, t2 = r2;
    }
  }
};
e$1W([y$1o({ type: Number, json: { write: true } })], S$p.prototype, "compressionQuality", void 0), e$1W([y$1o({ type: Number, json: { write: true } })], S$p.prototype, "dpi", void 0), e$1W([y$1o({ type: String, json: { read: O$c.read, write: O$c.write, origins: { "web-scene": { read: false, write: false } } } })], S$p.prototype, "format", void 0), e$1W([y$1o({ readOnly: true })], S$p.prototype, "isWrappable", null), e$1W([y$1o({ type: w$K, json: { write: true } })], S$p.prototype, "origin", void 0), e$1W([o$1H("origin")], S$p.prototype, "readOrigin", null), e$1W([y$1o({ type: [p$1R], value: null, json: { write: true } })], S$p.prototype, "lods", null), e$1W([y$1o({ readOnly: true })], S$p.prototype, "minScale", void 0), e$1W([y$1o({ readOnly: true })], S$p.prototype, "maxScale", void 0), e$1W([y$1o({ readOnly: true })], S$p.prototype, "scales", void 0), e$1W([y$1o({ cast: (e2) => Array.isArray(e2) ? e2 : typeof e2 == "number" ? [e2, e2] : [256, 256] })], S$p.prototype, "size", void 0), e$1W([o$1H("size", ["rows", "cols"])], S$p.prototype, "readSize", null), e$1W([r$1h("size", { cols: { type: T$r }, rows: { type: T$r } })], S$p.prototype, "writeSize", null), e$1W([y$1o({ type: k$p, json: { write: true } })], S$p.prototype, "spatialReference", void 0), S$p = x$s = e$1W([n$2f("esri.layers.support.TileInfo")], S$p), function(e2) {
  var t2;
  (t2 = e2.ExtrapolateOptions || (e2.ExtrapolateOptions = {}))[t2.NONE = 0] = "NONE", t2[t2.POWER_OF_TWO = 1] = "POWER_OF_TWO";
}(S$p || (S$p = {}));
const j$q = S$p;
const n$1v = { widthBreakpoint: { getValue(e2) {
  const i2 = e2.viewSize[0], s2 = e2.breakpoints, a2 = this.values;
  return i2 <= s2.xsmall ? a2.xsmall : i2 <= s2.small ? a2.small : i2 <= s2.medium ? a2.medium : i2 <= s2.large ? a2.large : a2.xlarge;
}, values: { xsmall: "xsmall", small: "small", medium: "medium", large: "large", xlarge: "xlarge" }, valueToClassName: { xsmall: "esri-view-width-xsmall esri-view-width-less-than-small esri-view-width-less-than-medium esri-view-width-less-than-large esri-view-width-less-than-xlarge", small: "esri-view-width-small esri-view-width-greater-than-xsmall esri-view-width-less-than-medium esri-view-width-less-than-large esri-view-width-less-than-xlarge", medium: "esri-view-width-medium esri-view-width-greater-than-xsmall esri-view-width-greater-than-small esri-view-width-less-than-large esri-view-width-less-than-xlarge", large: "esri-view-width-large esri-view-width-greater-than-xsmall esri-view-width-greater-than-small esri-view-width-greater-than-medium esri-view-width-less-than-xlarge", xlarge: "esri-view-width-xlarge esri-view-width-greater-than-xsmall esri-view-width-greater-than-small esri-view-width-greater-than-medium esri-view-width-greater-than-large" } }, heightBreakpoint: { getValue(e2) {
  const i2 = e2.viewSize[1], s2 = e2.breakpoints, a2 = this.values;
  return i2 <= s2.xsmall ? a2.xsmall : i2 <= s2.small ? a2.small : i2 <= s2.medium ? a2.medium : i2 <= s2.large ? a2.large : a2.xlarge;
}, values: { xsmall: "xsmall", small: "small", medium: "medium", large: "large", xlarge: "xlarge" }, valueToClassName: { xsmall: "esri-view-height-xsmall esri-view-height-less-than-small esri-view-height-less-than-medium esri-view-height-less-than-large esri-view-height-less-than-xlarge", small: "esri-view-height-small esri-view-height-greater-than-xsmall esri-view-height-less-than-medium esri-view-height-less-than-large esri-view-height-less-than-xlarge", medium: "esri-view-height-medium esri-view-height-greater-than-xsmall esri-view-height-greater-than-small esri-view-height-less-than-large esri-view-height-less-than-xlarge", large: "esri-view-height-large esri-view-height-greater-than-xsmall esri-view-height-greater-than-small esri-view-height-greater-than-medium esri-view-height-less-than-xlarge", xlarge: "esri-view-height-xlarge esri-view-height-greater-than-xsmall esri-view-height-greater-than-small esri-view-height-greater-than-medium esri-view-height-greater-than-large" } }, orientation: { getValue(e2) {
  const i2 = e2.viewSize, s2 = i2[0], a2 = i2[1], t2 = this.values;
  return a2 >= s2 ? t2.portrait : t2.landscape;
}, values: { portrait: "portrait", landscape: "landscape" }, valueToClassName: { portrait: "esri-view-orientation-portrait", landscape: "esri-view-orientation-landscape" } } }, o$14 = { xsmall: 544, small: 768, medium: 992, large: 1200 };
function m$_(e2) {
  const i2 = e2;
  return i2 && i2.xsmall < i2.small && i2.small < i2.medium && i2.medium < i2.large;
}
function g$D(e2, i2) {
  return i2 ? n$1v[e2].valueToClassName[i2].split(" ") : [];
}
const w$w = (w2) => {
  let d2 = class extends w2 {
    constructor(...e2) {
      super(...e2), this._breakpointsHandles = new t$1N(), this.orientation = null, this.widthBreakpoint = null, this.heightBreakpoint = null, this.breakpoints = o$14;
    }
    initialize() {
      this._breakpointsHandles.add(l$1f(() => [this.breakpoints, this.size], () => this._updateClassNames(), h$S));
    }
    destroy() {
      this.destroyed || (this._removeActiveClassNames(), this._breakpointsHandles = s$26(this._breakpointsHandles));
    }
    set breakpoints(e2) {
      if (e2 === this._get("breakpoints"))
        return;
      const i2 = m$_(e2);
      if (!i2) {
        const e3 = JSON.stringify(o$14, null, 2);
        console.warn("provided breakpoints are not valid, using defaults:" + e3);
      }
      e2 = i2 ? e2 : o$14, this._set("breakpoints", __spreadValues({}, e2));
    }
    _updateClassNames() {
      if (!this.container)
        return;
      const e2 = t$1J.acquire(), s2 = t$1J.acquire();
      let a2, t2 = false;
      for (a2 in n$1v) {
        const i2 = this[a2], r2 = n$1v[a2].getValue({ viewSize: this.size, breakpoints: this.breakpoints });
        i2 !== r2 && (t2 = true, this[a2] = r2, g$D(a2, i2).forEach((e3) => s2.push(e3)), g$D(a2, r2).forEach((i3) => e2.push(i3)));
      }
      t2 && (this._applyClassNameChanges(e2, s2), t$1J.release(e2), t$1J.release(s2));
    }
    _applyClassNameChanges(e2, i2) {
      const s2 = this.container;
      s2 && (i2.forEach((e3) => s2.classList.remove(e3)), e2.forEach((e3) => s2.classList.add(e3)));
    }
    _removeActiveClassNames() {
      const e2 = this.container;
      if (!e2)
        return;
      let i2;
      for (i2 in n$1v)
        g$D(i2, this[i2]).forEach((i3) => e2.classList.remove(i3));
    }
  };
  return e$1W([y$1o()], d2.prototype, "breakpoints", null), e$1W([y$1o()], d2.prototype, "orientation", void 0), e$1W([y$1o()], d2.prototype, "widthBreakpoint", void 0), e$1W([y$1o()], d2.prototype, "heightBreakpoint", void 0), d2 = e$1W([n$2f("esri.views.BreakpointsOwner")], d2), d2;
};
function e$13(e2) {
  return typeof e2 == "string" ? document.getElementById(e2) : e2 != null ? e2 : null;
}
function t$15(e2) {
  for (; e2.hasChildNodes(); )
    e2.removeChild(e2.firstChild);
}
function o$13(e2, t2) {
  const n2 = t2.parentNode;
  n2 && n2.insertBefore(e2, t2);
}
function r$Q(e2, t2) {
  for (; ; ) {
    const n2 = e2.firstChild;
    if (!n2)
      break;
    t2.appendChild(n2);
  }
}
let c$1F = class extends m$1L {
  constructor() {
    super(...arguments), this.updating = false, this._handleId = 0, this._handles = new t$1N(), this._scheduleHandleId = 0, this._pendingPromises = new Set();
  }
  destroy() {
    this.removeAll(), this._handles.destroy();
  }
  add(e2, s2, t2 = {}) {
    return this._installWatch(e2, s2, t2, l$1f);
  }
  addWhen(e2, s2, t2 = {}) {
    return this._installWatch(e2, s2, t2, f$10);
  }
  addOnCollectionChange(e2, s2, { initial: t2 = false, final: i2 = false } = {}) {
    const n2 = ++this._handleId;
    return this._handles.add([a$1I(e2, "after-changes", this._createSyncUpdatingCallback(), U$i), a$1I(e2, "change", s2, { onListenerAdd: t2 ? (e3) => s2({ added: e3.toArray(), removed: [] }) : void 0, onListenerRemove: i2 ? (e3) => s2({ added: [], removed: e3.toArray() }) : void 0 })], n2), { remove: () => this._handles.remove(n2) };
  }
  addPromise(e2) {
    if (t$1W(e2))
      return e2;
    const s2 = ++this._handleId;
    this._handles.add({ remove: () => {
      this._pendingPromises.delete(e2) && (this._pendingPromises.size !== 0 || this._handles.has(_$n) || this._set("updating", false));
    } }, s2), this._pendingPromises.add(e2), this._set("updating", true);
    const t2 = () => this._handles.remove(s2);
    return e2.then(t2, t2), e2;
  }
  removeAll() {
    this._pendingPromises.clear(), this._handles.removeAll(), this._set("updating", false);
  }
  _installWatch(e2, s2, t2 = {}, i2) {
    const n2 = ++this._handleId;
    t2.sync || this._installSyncUpdatingWatch(e2, n2);
    const d2 = i2(e2, s2, t2);
    return this._handles.add(d2, n2), { remove: () => this._handles.remove(n2) };
  }
  _installSyncUpdatingWatch(e2, s2) {
    const t2 = this._createSyncUpdatingCallback(), i2 = l$1f(e2, t2, { sync: true, equals: () => false });
    return this._handles.add(i2, s2), i2;
  }
  _createSyncUpdatingCallback() {
    return () => {
      this._handles.remove(_$n), ++this._scheduleHandleId;
      const e2 = this._scheduleHandleId;
      this._get("updating") || this._set("updating", true), this._handles.add(v$R(() => {
        e2 === this._scheduleHandleId && (this._set("updating", this._pendingPromises.size > 0), this._handles.remove(_$n));
      }), _$n);
    };
  }
};
e$1W([y$1o({ readOnly: true })], c$1F.prototype, "updating", void 0), c$1F = e$1W([n$2f("esri.core.support.WatchUpdatingTracking")], c$1F);
const _$n = -42;
/*!
 * @esri/arcgis-html-sanitizer - v3.0.1 - Tue Nov 15 2022 09:46:54 GMT-0800 (Pacific Standard Time)
 * Copyright (c) 2022 - Environmental Systems Research Institute, Inc.
 * Apache-2.0
 * 
 * js-xss
 * Copyright (c) 2012-2018 Zongmin Lei(雷宗民) <leizongmin@gmail.com>
 * http://ucdok.com
 * MIT License, see https://github.com/leizongmin/js-xss/blob/master/LICENSE for details
 */
var isPlainObject = function(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  if (Object.prototype.toString.call(value) !== "[object Object]") {
    return false;
  }
  var proto = Object.getPrototypeOf(value);
  if (proto === null) {
    return true;
  }
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(value) === proto;
};
var lib$1 = { exports: {} };
var _default$1 = {};
var lib = { exports: {} };
var _default = {};
function getDefaultWhiteList$1() {
  var whiteList = {};
  whiteList["align-content"] = false;
  whiteList["align-items"] = false;
  whiteList["align-self"] = false;
  whiteList["alignment-adjust"] = false;
  whiteList["alignment-baseline"] = false;
  whiteList["all"] = false;
  whiteList["anchor-point"] = false;
  whiteList["animation"] = false;
  whiteList["animation-delay"] = false;
  whiteList["animation-direction"] = false;
  whiteList["animation-duration"] = false;
  whiteList["animation-fill-mode"] = false;
  whiteList["animation-iteration-count"] = false;
  whiteList["animation-name"] = false;
  whiteList["animation-play-state"] = false;
  whiteList["animation-timing-function"] = false;
  whiteList["azimuth"] = false;
  whiteList["backface-visibility"] = false;
  whiteList["background"] = true;
  whiteList["background-attachment"] = true;
  whiteList["background-clip"] = true;
  whiteList["background-color"] = true;
  whiteList["background-image"] = true;
  whiteList["background-origin"] = true;
  whiteList["background-position"] = true;
  whiteList["background-repeat"] = true;
  whiteList["background-size"] = true;
  whiteList["baseline-shift"] = false;
  whiteList["binding"] = false;
  whiteList["bleed"] = false;
  whiteList["bookmark-label"] = false;
  whiteList["bookmark-level"] = false;
  whiteList["bookmark-state"] = false;
  whiteList["border"] = true;
  whiteList["border-bottom"] = true;
  whiteList["border-bottom-color"] = true;
  whiteList["border-bottom-left-radius"] = true;
  whiteList["border-bottom-right-radius"] = true;
  whiteList["border-bottom-style"] = true;
  whiteList["border-bottom-width"] = true;
  whiteList["border-collapse"] = true;
  whiteList["border-color"] = true;
  whiteList["border-image"] = true;
  whiteList["border-image-outset"] = true;
  whiteList["border-image-repeat"] = true;
  whiteList["border-image-slice"] = true;
  whiteList["border-image-source"] = true;
  whiteList["border-image-width"] = true;
  whiteList["border-left"] = true;
  whiteList["border-left-color"] = true;
  whiteList["border-left-style"] = true;
  whiteList["border-left-width"] = true;
  whiteList["border-radius"] = true;
  whiteList["border-right"] = true;
  whiteList["border-right-color"] = true;
  whiteList["border-right-style"] = true;
  whiteList["border-right-width"] = true;
  whiteList["border-spacing"] = true;
  whiteList["border-style"] = true;
  whiteList["border-top"] = true;
  whiteList["border-top-color"] = true;
  whiteList["border-top-left-radius"] = true;
  whiteList["border-top-right-radius"] = true;
  whiteList["border-top-style"] = true;
  whiteList["border-top-width"] = true;
  whiteList["border-width"] = true;
  whiteList["bottom"] = false;
  whiteList["box-decoration-break"] = true;
  whiteList["box-shadow"] = true;
  whiteList["box-sizing"] = true;
  whiteList["box-snap"] = true;
  whiteList["box-suppress"] = true;
  whiteList["break-after"] = true;
  whiteList["break-before"] = true;
  whiteList["break-inside"] = true;
  whiteList["caption-side"] = false;
  whiteList["chains"] = false;
  whiteList["clear"] = true;
  whiteList["clip"] = false;
  whiteList["clip-path"] = false;
  whiteList["clip-rule"] = false;
  whiteList["color"] = true;
  whiteList["color-interpolation-filters"] = true;
  whiteList["column-count"] = false;
  whiteList["column-fill"] = false;
  whiteList["column-gap"] = false;
  whiteList["column-rule"] = false;
  whiteList["column-rule-color"] = false;
  whiteList["column-rule-style"] = false;
  whiteList["column-rule-width"] = false;
  whiteList["column-span"] = false;
  whiteList["column-width"] = false;
  whiteList["columns"] = false;
  whiteList["contain"] = false;
  whiteList["content"] = false;
  whiteList["counter-increment"] = false;
  whiteList["counter-reset"] = false;
  whiteList["counter-set"] = false;
  whiteList["crop"] = false;
  whiteList["cue"] = false;
  whiteList["cue-after"] = false;
  whiteList["cue-before"] = false;
  whiteList["cursor"] = false;
  whiteList["direction"] = false;
  whiteList["display"] = true;
  whiteList["display-inside"] = true;
  whiteList["display-list"] = true;
  whiteList["display-outside"] = true;
  whiteList["dominant-baseline"] = false;
  whiteList["elevation"] = false;
  whiteList["empty-cells"] = false;
  whiteList["filter"] = false;
  whiteList["flex"] = false;
  whiteList["flex-basis"] = false;
  whiteList["flex-direction"] = false;
  whiteList["flex-flow"] = false;
  whiteList["flex-grow"] = false;
  whiteList["flex-shrink"] = false;
  whiteList["flex-wrap"] = false;
  whiteList["float"] = false;
  whiteList["float-offset"] = false;
  whiteList["flood-color"] = false;
  whiteList["flood-opacity"] = false;
  whiteList["flow-from"] = false;
  whiteList["flow-into"] = false;
  whiteList["font"] = true;
  whiteList["font-family"] = true;
  whiteList["font-feature-settings"] = true;
  whiteList["font-kerning"] = true;
  whiteList["font-language-override"] = true;
  whiteList["font-size"] = true;
  whiteList["font-size-adjust"] = true;
  whiteList["font-stretch"] = true;
  whiteList["font-style"] = true;
  whiteList["font-synthesis"] = true;
  whiteList["font-variant"] = true;
  whiteList["font-variant-alternates"] = true;
  whiteList["font-variant-caps"] = true;
  whiteList["font-variant-east-asian"] = true;
  whiteList["font-variant-ligatures"] = true;
  whiteList["font-variant-numeric"] = true;
  whiteList["font-variant-position"] = true;
  whiteList["font-weight"] = true;
  whiteList["grid"] = false;
  whiteList["grid-area"] = false;
  whiteList["grid-auto-columns"] = false;
  whiteList["grid-auto-flow"] = false;
  whiteList["grid-auto-rows"] = false;
  whiteList["grid-column"] = false;
  whiteList["grid-column-end"] = false;
  whiteList["grid-column-start"] = false;
  whiteList["grid-row"] = false;
  whiteList["grid-row-end"] = false;
  whiteList["grid-row-start"] = false;
  whiteList["grid-template"] = false;
  whiteList["grid-template-areas"] = false;
  whiteList["grid-template-columns"] = false;
  whiteList["grid-template-rows"] = false;
  whiteList["hanging-punctuation"] = false;
  whiteList["height"] = true;
  whiteList["hyphens"] = false;
  whiteList["icon"] = false;
  whiteList["image-orientation"] = false;
  whiteList["image-resolution"] = false;
  whiteList["ime-mode"] = false;
  whiteList["initial-letters"] = false;
  whiteList["inline-box-align"] = false;
  whiteList["justify-content"] = false;
  whiteList["justify-items"] = false;
  whiteList["justify-self"] = false;
  whiteList["left"] = false;
  whiteList["letter-spacing"] = true;
  whiteList["lighting-color"] = true;
  whiteList["line-box-contain"] = false;
  whiteList["line-break"] = false;
  whiteList["line-grid"] = false;
  whiteList["line-height"] = false;
  whiteList["line-snap"] = false;
  whiteList["line-stacking"] = false;
  whiteList["line-stacking-ruby"] = false;
  whiteList["line-stacking-shift"] = false;
  whiteList["line-stacking-strategy"] = false;
  whiteList["list-style"] = true;
  whiteList["list-style-image"] = true;
  whiteList["list-style-position"] = true;
  whiteList["list-style-type"] = true;
  whiteList["margin"] = true;
  whiteList["margin-bottom"] = true;
  whiteList["margin-left"] = true;
  whiteList["margin-right"] = true;
  whiteList["margin-top"] = true;
  whiteList["marker-offset"] = false;
  whiteList["marker-side"] = false;
  whiteList["marks"] = false;
  whiteList["mask"] = false;
  whiteList["mask-box"] = false;
  whiteList["mask-box-outset"] = false;
  whiteList["mask-box-repeat"] = false;
  whiteList["mask-box-slice"] = false;
  whiteList["mask-box-source"] = false;
  whiteList["mask-box-width"] = false;
  whiteList["mask-clip"] = false;
  whiteList["mask-image"] = false;
  whiteList["mask-origin"] = false;
  whiteList["mask-position"] = false;
  whiteList["mask-repeat"] = false;
  whiteList["mask-size"] = false;
  whiteList["mask-source-type"] = false;
  whiteList["mask-type"] = false;
  whiteList["max-height"] = true;
  whiteList["max-lines"] = false;
  whiteList["max-width"] = true;
  whiteList["min-height"] = true;
  whiteList["min-width"] = true;
  whiteList["move-to"] = false;
  whiteList["nav-down"] = false;
  whiteList["nav-index"] = false;
  whiteList["nav-left"] = false;
  whiteList["nav-right"] = false;
  whiteList["nav-up"] = false;
  whiteList["object-fit"] = false;
  whiteList["object-position"] = false;
  whiteList["opacity"] = false;
  whiteList["order"] = false;
  whiteList["orphans"] = false;
  whiteList["outline"] = false;
  whiteList["outline-color"] = false;
  whiteList["outline-offset"] = false;
  whiteList["outline-style"] = false;
  whiteList["outline-width"] = false;
  whiteList["overflow"] = false;
  whiteList["overflow-wrap"] = false;
  whiteList["overflow-x"] = false;
  whiteList["overflow-y"] = false;
  whiteList["padding"] = true;
  whiteList["padding-bottom"] = true;
  whiteList["padding-left"] = true;
  whiteList["padding-right"] = true;
  whiteList["padding-top"] = true;
  whiteList["page"] = false;
  whiteList["page-break-after"] = false;
  whiteList["page-break-before"] = false;
  whiteList["page-break-inside"] = false;
  whiteList["page-policy"] = false;
  whiteList["pause"] = false;
  whiteList["pause-after"] = false;
  whiteList["pause-before"] = false;
  whiteList["perspective"] = false;
  whiteList["perspective-origin"] = false;
  whiteList["pitch"] = false;
  whiteList["pitch-range"] = false;
  whiteList["play-during"] = false;
  whiteList["position"] = false;
  whiteList["presentation-level"] = false;
  whiteList["quotes"] = false;
  whiteList["region-fragment"] = false;
  whiteList["resize"] = false;
  whiteList["rest"] = false;
  whiteList["rest-after"] = false;
  whiteList["rest-before"] = false;
  whiteList["richness"] = false;
  whiteList["right"] = false;
  whiteList["rotation"] = false;
  whiteList["rotation-point"] = false;
  whiteList["ruby-align"] = false;
  whiteList["ruby-merge"] = false;
  whiteList["ruby-position"] = false;
  whiteList["shape-image-threshold"] = false;
  whiteList["shape-outside"] = false;
  whiteList["shape-margin"] = false;
  whiteList["size"] = false;
  whiteList["speak"] = false;
  whiteList["speak-as"] = false;
  whiteList["speak-header"] = false;
  whiteList["speak-numeral"] = false;
  whiteList["speak-punctuation"] = false;
  whiteList["speech-rate"] = false;
  whiteList["stress"] = false;
  whiteList["string-set"] = false;
  whiteList["tab-size"] = false;
  whiteList["table-layout"] = false;
  whiteList["text-align"] = true;
  whiteList["text-align-last"] = true;
  whiteList["text-combine-upright"] = true;
  whiteList["text-decoration"] = true;
  whiteList["text-decoration-color"] = true;
  whiteList["text-decoration-line"] = true;
  whiteList["text-decoration-skip"] = true;
  whiteList["text-decoration-style"] = true;
  whiteList["text-emphasis"] = true;
  whiteList["text-emphasis-color"] = true;
  whiteList["text-emphasis-position"] = true;
  whiteList["text-emphasis-style"] = true;
  whiteList["text-height"] = true;
  whiteList["text-indent"] = true;
  whiteList["text-justify"] = true;
  whiteList["text-orientation"] = true;
  whiteList["text-overflow"] = true;
  whiteList["text-shadow"] = true;
  whiteList["text-space-collapse"] = true;
  whiteList["text-transform"] = true;
  whiteList["text-underline-position"] = true;
  whiteList["text-wrap"] = true;
  whiteList["top"] = false;
  whiteList["transform"] = false;
  whiteList["transform-origin"] = false;
  whiteList["transform-style"] = false;
  whiteList["transition"] = false;
  whiteList["transition-delay"] = false;
  whiteList["transition-duration"] = false;
  whiteList["transition-property"] = false;
  whiteList["transition-timing-function"] = false;
  whiteList["unicode-bidi"] = false;
  whiteList["vertical-align"] = false;
  whiteList["visibility"] = false;
  whiteList["voice-balance"] = false;
  whiteList["voice-duration"] = false;
  whiteList["voice-family"] = false;
  whiteList["voice-pitch"] = false;
  whiteList["voice-range"] = false;
  whiteList["voice-rate"] = false;
  whiteList["voice-stress"] = false;
  whiteList["voice-volume"] = false;
  whiteList["volume"] = false;
  whiteList["white-space"] = false;
  whiteList["widows"] = false;
  whiteList["width"] = true;
  whiteList["will-change"] = false;
  whiteList["word-break"] = true;
  whiteList["word-spacing"] = true;
  whiteList["word-wrap"] = true;
  whiteList["wrap-flow"] = false;
  whiteList["wrap-through"] = false;
  whiteList["writing-mode"] = false;
  whiteList["z-index"] = false;
  return whiteList;
}
function onAttr(name, value, options) {
}
function onIgnoreAttr(name, value, options) {
}
var REGEXP_URL_JAVASCRIPT = /javascript\s*\:/img;
function safeAttrValue$1(name, value) {
  if (REGEXP_URL_JAVASCRIPT.test(value))
    return "";
  return value;
}
_default.whiteList = getDefaultWhiteList$1();
_default.getDefaultWhiteList = getDefaultWhiteList$1;
_default.onAttr = onAttr;
_default.onIgnoreAttr = onIgnoreAttr;
_default.safeAttrValue = safeAttrValue$1;
var util$1 = {
  indexOf: function(arr, item) {
    var i2, j2;
    if (Array.prototype.indexOf) {
      return arr.indexOf(item);
    }
    for (i2 = 0, j2 = arr.length; i2 < j2; i2++) {
      if (arr[i2] === item) {
        return i2;
      }
    }
    return -1;
  },
  forEach: function(arr, fn2, scope) {
    var i2, j2;
    if (Array.prototype.forEach) {
      return arr.forEach(fn2, scope);
    }
    for (i2 = 0, j2 = arr.length; i2 < j2; i2++) {
      fn2.call(scope, arr[i2], i2, arr);
    }
  },
  trim: function(str) {
    if (String.prototype.trim) {
      return str.trim();
    }
    return str.replace(/(^\s*)|(\s*$)/g, "");
  },
  trimRight: function(str) {
    if (String.prototype.trimRight) {
      return str.trimRight();
    }
    return str.replace(/(\s*$)/g, "");
  }
};
var _$3$1 = util$1;
function parseStyle$1(css2, onAttr2) {
  css2 = _$3$1.trimRight(css2);
  if (css2[css2.length - 1] !== ";")
    css2 += ";";
  var cssLength = css2.length;
  var isParenthesisOpen = false;
  var lastPos = 0;
  var i2 = 0;
  var retCSS = "";
  function addNewAttr() {
    if (!isParenthesisOpen) {
      var source = _$3$1.trim(css2.slice(lastPos, i2));
      var j3 = source.indexOf(":");
      if (j3 !== -1) {
        var name = _$3$1.trim(source.slice(0, j3));
        var value = _$3$1.trim(source.slice(j3 + 1));
        if (name) {
          var ret = onAttr2(lastPos, retCSS.length, name, value, source);
          if (ret)
            retCSS += ret + "; ";
        }
      }
    }
    lastPos = i2 + 1;
  }
  for (; i2 < cssLength; i2++) {
    var c2 = css2[i2];
    if (c2 === "/" && css2[i2 + 1] === "*") {
      var j2 = css2.indexOf("*/", i2 + 2);
      if (j2 === -1)
        break;
      i2 = j2 + 1;
      lastPos = i2 + 1;
      isParenthesisOpen = false;
    } else if (c2 === "(") {
      isParenthesisOpen = true;
    } else if (c2 === ")") {
      isParenthesisOpen = false;
    } else if (c2 === ";") {
      if (isParenthesisOpen)
        ;
      else {
        addNewAttr();
      }
    } else if (c2 === "\n") {
      addNewAttr();
    }
  }
  return _$3$1.trim(retCSS);
}
var parser$2 = parseStyle$1;
var DEFAULT$1 = _default;
var parseStyle = parser$2;
function isNull$1(obj) {
  return obj === void 0 || obj === null;
}
function shallowCopyObject$1(obj) {
  var ret = {};
  for (var i2 in obj) {
    ret[i2] = obj[i2];
  }
  return ret;
}
function FilterCSS$2(options) {
  options = shallowCopyObject$1(options || {});
  options.whiteList = options.whiteList || DEFAULT$1.whiteList;
  options.onAttr = options.onAttr || DEFAULT$1.onAttr;
  options.onIgnoreAttr = options.onIgnoreAttr || DEFAULT$1.onIgnoreAttr;
  options.safeAttrValue = options.safeAttrValue || DEFAULT$1.safeAttrValue;
  this.options = options;
}
FilterCSS$2.prototype.process = function(css2) {
  css2 = css2 || "";
  css2 = css2.toString();
  if (!css2)
    return "";
  var me2 = this;
  var options = me2.options;
  var whiteList = options.whiteList;
  var onAttr2 = options.onAttr;
  var onIgnoreAttr2 = options.onIgnoreAttr;
  var safeAttrValue2 = options.safeAttrValue;
  var retCSS = parseStyle(css2, function(sourcePosition, position, name, value, source) {
    var check = whiteList[name];
    var isWhite = false;
    if (check === true)
      isWhite = check;
    else if (typeof check === "function")
      isWhite = check(value);
    else if (check instanceof RegExp)
      isWhite = check.test(value);
    if (isWhite !== true)
      isWhite = false;
    value = safeAttrValue2(name, value);
    if (!value)
      return;
    var opts = {
      position,
      sourcePosition,
      source,
      isWhite
    };
    if (isWhite) {
      var ret = onAttr2(name, value, opts);
      if (isNull$1(ret)) {
        return name + ":" + value;
      } else {
        return ret;
      }
    } else {
      var ret = onIgnoreAttr2(name, value, opts);
      if (!isNull$1(ret)) {
        return ret;
      }
    }
  });
  return retCSS;
};
var css = FilterCSS$2;
(function(module, exports) {
  var DEFAULT2 = _default;
  var FilterCSS2 = css;
  function filterCSS(html, options) {
    var xss2 = new FilterCSS2(options);
    return xss2.process(html);
  }
  exports = module.exports = filterCSS;
  exports.FilterCSS = FilterCSS2;
  for (var i2 in DEFAULT2)
    exports[i2] = DEFAULT2[i2];
})(lib, lib.exports);
var util = {
  indexOf: function(arr, item) {
    var i2, j2;
    if (Array.prototype.indexOf) {
      return arr.indexOf(item);
    }
    for (i2 = 0, j2 = arr.length; i2 < j2; i2++) {
      if (arr[i2] === item) {
        return i2;
      }
    }
    return -1;
  },
  forEach: function(arr, fn2, scope) {
    var i2, j2;
    if (Array.prototype.forEach) {
      return arr.forEach(fn2, scope);
    }
    for (i2 = 0, j2 = arr.length; i2 < j2; i2++) {
      fn2.call(scope, arr[i2], i2, arr);
    }
  },
  trim: function(str) {
    if (String.prototype.trim) {
      return str.trim();
    }
    return str.replace(/(^\s*)|(\s*$)/g, "");
  },
  spaceIndex: function(str) {
    var reg = /\s|\n|\t/;
    var match = reg.exec(str);
    return match ? match.index : -1;
  }
};
var FilterCSS$1 = lib.exports.FilterCSS;
var getDefaultCSSWhiteList = lib.exports.getDefaultWhiteList;
var _$2$1 = util;
function getDefaultWhiteList() {
  return {
    a: ["target", "href", "title"],
    abbr: ["title"],
    address: [],
    area: ["shape", "coords", "href", "alt"],
    article: [],
    aside: [],
    audio: [
      "autoplay",
      "controls",
      "crossorigin",
      "loop",
      "muted",
      "preload",
      "src"
    ],
    b: [],
    bdi: ["dir"],
    bdo: ["dir"],
    big: [],
    blockquote: ["cite"],
    br: [],
    caption: [],
    center: [],
    cite: [],
    code: [],
    col: ["align", "valign", "span", "width"],
    colgroup: ["align", "valign", "span", "width"],
    dd: [],
    del: ["datetime"],
    details: ["open"],
    div: [],
    dl: [],
    dt: [],
    em: [],
    figcaption: [],
    figure: [],
    font: ["color", "size", "face"],
    footer: [],
    h1: [],
    h2: [],
    h3: [],
    h4: [],
    h5: [],
    h6: [],
    header: [],
    hr: [],
    i: [],
    img: ["src", "alt", "title", "width", "height"],
    ins: ["datetime"],
    li: [],
    mark: [],
    nav: [],
    ol: [],
    p: [],
    pre: [],
    s: [],
    section: [],
    small: [],
    span: [],
    sub: [],
    summary: [],
    sup: [],
    strong: [],
    strike: [],
    table: ["width", "border", "align", "valign"],
    tbody: ["align", "valign"],
    td: ["width", "rowspan", "colspan", "align", "valign"],
    tfoot: ["align", "valign"],
    th: ["width", "rowspan", "colspan", "align", "valign"],
    thead: ["align", "valign"],
    tr: ["rowspan", "align", "valign"],
    tt: [],
    u: [],
    ul: [],
    video: [
      "autoplay",
      "controls",
      "crossorigin",
      "loop",
      "muted",
      "playsinline",
      "poster",
      "preload",
      "src",
      "height",
      "width"
    ]
  };
}
var defaultCSSFilter = new FilterCSS$1();
function onTag(tag, html, options) {
}
function onIgnoreTag(tag, html, options) {
}
function onTagAttr(tag, name, value) {
}
function onIgnoreTagAttr(tag, name, value) {
}
function escapeHtml(html) {
  return html.replace(REGEXP_LT, "&lt;").replace(REGEXP_GT, "&gt;");
}
function safeAttrValue(tag, name, value, cssFilter) {
  value = friendlyAttrValue(value);
  if (name === "href" || name === "src") {
    value = _$2$1.trim(value);
    if (value === "#")
      return "#";
    if (!(value.substr(0, 7) === "http://" || value.substr(0, 8) === "https://" || value.substr(0, 7) === "mailto:" || value.substr(0, 4) === "tel:" || value.substr(0, 11) === "data:image/" || value.substr(0, 6) === "ftp://" || value.substr(0, 2) === "./" || value.substr(0, 3) === "../" || value[0] === "#" || value[0] === "/")) {
      return "";
    }
  } else if (name === "background") {
    REGEXP_DEFAULT_ON_TAG_ATTR_4.lastIndex = 0;
    if (REGEXP_DEFAULT_ON_TAG_ATTR_4.test(value)) {
      return "";
    }
  } else if (name === "style") {
    REGEXP_DEFAULT_ON_TAG_ATTR_7.lastIndex = 0;
    if (REGEXP_DEFAULT_ON_TAG_ATTR_7.test(value)) {
      return "";
    }
    REGEXP_DEFAULT_ON_TAG_ATTR_8.lastIndex = 0;
    if (REGEXP_DEFAULT_ON_TAG_ATTR_8.test(value)) {
      REGEXP_DEFAULT_ON_TAG_ATTR_4.lastIndex = 0;
      if (REGEXP_DEFAULT_ON_TAG_ATTR_4.test(value)) {
        return "";
      }
    }
    if (cssFilter !== false) {
      cssFilter = cssFilter || defaultCSSFilter;
      value = cssFilter.process(value);
    }
  }
  value = escapeAttrValue(value);
  return value;
}
var REGEXP_LT = /</g;
var REGEXP_GT = />/g;
var REGEXP_QUOTE = /"/g;
var REGEXP_QUOTE_2 = /&quot;/g;
var REGEXP_ATTR_VALUE_1 = /&#([a-zA-Z0-9]*);?/gim;
var REGEXP_ATTR_VALUE_COLON = /&colon;?/gim;
var REGEXP_ATTR_VALUE_NEWLINE = /&newline;?/gim;
var REGEXP_DEFAULT_ON_TAG_ATTR_4 = /((j\s*a\s*v\s*a|v\s*b|l\s*i\s*v\s*e)\s*s\s*c\s*r\s*i\s*p\s*t\s*|m\s*o\s*c\s*h\s*a):/gi;
var REGEXP_DEFAULT_ON_TAG_ATTR_7 = /e\s*x\s*p\s*r\s*e\s*s\s*s\s*i\s*o\s*n\s*\(.*/gi;
var REGEXP_DEFAULT_ON_TAG_ATTR_8 = /u\s*r\s*l\s*\(.*/gi;
function escapeQuote(str) {
  return str.replace(REGEXP_QUOTE, "&quot;");
}
function unescapeQuote(str) {
  return str.replace(REGEXP_QUOTE_2, '"');
}
function escapeHtmlEntities(str) {
  return str.replace(REGEXP_ATTR_VALUE_1, function replaceUnicode(str2, code) {
    return code[0] === "x" || code[0] === "X" ? String.fromCharCode(parseInt(code.substr(1), 16)) : String.fromCharCode(parseInt(code, 10));
  });
}
function escapeDangerHtml5Entities(str) {
  return str.replace(REGEXP_ATTR_VALUE_COLON, ":").replace(REGEXP_ATTR_VALUE_NEWLINE, " ");
}
function clearNonPrintableCharacter(str) {
  var str2 = "";
  for (var i2 = 0, len = str.length; i2 < len; i2++) {
    str2 += str.charCodeAt(i2) < 32 ? " " : str.charAt(i2);
  }
  return _$2$1.trim(str2);
}
function friendlyAttrValue(str) {
  str = unescapeQuote(str);
  str = escapeHtmlEntities(str);
  str = escapeDangerHtml5Entities(str);
  str = clearNonPrintableCharacter(str);
  return str;
}
function escapeAttrValue(str) {
  str = escapeQuote(str);
  str = escapeHtml(str);
  return str;
}
function onIgnoreTagStripAll() {
  return "";
}
function StripTagBody(tags, next) {
  if (typeof next !== "function") {
    next = function() {
    };
  }
  var isRemoveAllTag = !Array.isArray(tags);
  function isRemoveTag(tag) {
    if (isRemoveAllTag)
      return true;
    return _$2$1.indexOf(tags, tag) !== -1;
  }
  var removeList = [];
  var posStart = false;
  return {
    onIgnoreTag: function(tag, html, options) {
      if (isRemoveTag(tag)) {
        if (options.isClosing) {
          var ret = "[/removed]";
          var end = options.position + ret.length;
          removeList.push([
            posStart !== false ? posStart : options.position,
            end
          ]);
          posStart = false;
          return ret;
        } else {
          if (!posStart) {
            posStart = options.position;
          }
          return "[removed]";
        }
      } else {
        return next(tag, html, options);
      }
    },
    remove: function(html) {
      var rethtml = "";
      var lastPos = 0;
      _$2$1.forEach(removeList, function(pos) {
        rethtml += html.slice(lastPos, pos[0]);
        lastPos = pos[1];
      });
      rethtml += html.slice(lastPos);
      return rethtml;
    }
  };
}
function stripCommentTag(html) {
  var retHtml = "";
  var lastPos = 0;
  while (lastPos < html.length) {
    var i2 = html.indexOf("<!--", lastPos);
    if (i2 === -1) {
      retHtml += html.slice(lastPos);
      break;
    }
    retHtml += html.slice(lastPos, i2);
    var j2 = html.indexOf("-->", i2);
    if (j2 === -1) {
      break;
    }
    lastPos = j2 + 3;
  }
  return retHtml;
}
function stripBlankChar(html) {
  var chars = html.split("");
  chars = chars.filter(function(char) {
    var c2 = char.charCodeAt(0);
    if (c2 === 127)
      return false;
    if (c2 <= 31) {
      if (c2 === 10 || c2 === 13)
        return true;
      return false;
    }
    return true;
  });
  return chars.join("");
}
_default$1.whiteList = getDefaultWhiteList();
_default$1.getDefaultWhiteList = getDefaultWhiteList;
_default$1.onTag = onTag;
_default$1.onIgnoreTag = onIgnoreTag;
_default$1.onTagAttr = onTagAttr;
_default$1.onIgnoreTagAttr = onIgnoreTagAttr;
_default$1.safeAttrValue = safeAttrValue;
_default$1.escapeHtml = escapeHtml;
_default$1.escapeQuote = escapeQuote;
_default$1.unescapeQuote = unescapeQuote;
_default$1.escapeHtmlEntities = escapeHtmlEntities;
_default$1.escapeDangerHtml5Entities = escapeDangerHtml5Entities;
_default$1.clearNonPrintableCharacter = clearNonPrintableCharacter;
_default$1.friendlyAttrValue = friendlyAttrValue;
_default$1.escapeAttrValue = escapeAttrValue;
_default$1.onIgnoreTagStripAll = onIgnoreTagStripAll;
_default$1.StripTagBody = StripTagBody;
_default$1.stripCommentTag = stripCommentTag;
_default$1.stripBlankChar = stripBlankChar;
_default$1.cssFilter = defaultCSSFilter;
_default$1.getDefaultCSSWhiteList = getDefaultCSSWhiteList;
var parser$1 = {};
var _$1$1 = util;
function getTagName(html) {
  var i2 = _$1$1.spaceIndex(html);
  var tagName;
  if (i2 === -1) {
    tagName = html.slice(1, -1);
  } else {
    tagName = html.slice(1, i2 + 1);
  }
  tagName = _$1$1.trim(tagName).toLowerCase();
  if (tagName.slice(0, 1) === "/")
    tagName = tagName.slice(1);
  if (tagName.slice(-1) === "/")
    tagName = tagName.slice(0, -1);
  return tagName;
}
function isClosing(html) {
  return html.slice(0, 2) === "</";
}
function parseTag$1(html, onTag2, escapeHtml2) {
  var rethtml = "";
  var lastPos = 0;
  var tagStart = false;
  var quoteStart = false;
  var currentPos = 0;
  var len = html.length;
  var currentTagName = "";
  var currentHtml = "";
  chariterator:
    for (currentPos = 0; currentPos < len; currentPos++) {
      var c2 = html.charAt(currentPos);
      if (tagStart === false) {
        if (c2 === "<") {
          tagStart = currentPos;
          continue;
        }
      } else {
        if (quoteStart === false) {
          if (c2 === "<") {
            rethtml += escapeHtml2(html.slice(lastPos, currentPos));
            tagStart = currentPos;
            lastPos = currentPos;
            continue;
          }
          if (c2 === ">") {
            rethtml += escapeHtml2(html.slice(lastPos, tagStart));
            currentHtml = html.slice(tagStart, currentPos + 1);
            currentTagName = getTagName(currentHtml);
            rethtml += onTag2(tagStart, rethtml.length, currentTagName, currentHtml, isClosing(currentHtml));
            lastPos = currentPos + 1;
            tagStart = false;
            continue;
          }
          if (c2 === '"' || c2 === "'") {
            var i2 = 1;
            var ic = html.charAt(currentPos - i2);
            while (ic.trim() === "" || ic === "=") {
              if (ic === "=") {
                quoteStart = c2;
                continue chariterator;
              }
              ic = html.charAt(currentPos - ++i2);
            }
          }
        } else {
          if (c2 === quoteStart) {
            quoteStart = false;
            continue;
          }
        }
      }
    }
  if (lastPos < html.length) {
    rethtml += escapeHtml2(html.substr(lastPos));
  }
  return rethtml;
}
var REGEXP_ILLEGAL_ATTR_NAME = /[^a-zA-Z0-9\\_:.-]/gim;
function parseAttr$1(html, onAttr2) {
  var lastPos = 0;
  var lastMarkPos = 0;
  var retAttrs = [];
  var tmpName = false;
  var len = html.length;
  function addAttr(name, value) {
    name = _$1$1.trim(name);
    name = name.replace(REGEXP_ILLEGAL_ATTR_NAME, "").toLowerCase();
    if (name.length < 1)
      return;
    var ret = onAttr2(name, value || "");
    if (ret)
      retAttrs.push(ret);
  }
  for (var i2 = 0; i2 < len; i2++) {
    var c2 = html.charAt(i2);
    var v2, j2;
    if (tmpName === false && c2 === "=") {
      tmpName = html.slice(lastPos, i2);
      lastPos = i2 + 1;
      lastMarkPos = html.charAt(lastPos) === '"' || html.charAt(lastPos) === "'" ? lastPos : findNextQuotationMark(html, i2 + 1);
      continue;
    }
    if (tmpName !== false) {
      if (i2 === lastMarkPos) {
        j2 = html.indexOf(c2, i2 + 1);
        if (j2 === -1) {
          break;
        } else {
          v2 = _$1$1.trim(html.slice(lastMarkPos + 1, j2));
          addAttr(tmpName, v2);
          tmpName = false;
          i2 = j2;
          lastPos = i2 + 1;
          continue;
        }
      }
    }
    if (/\s|\n|\t/.test(c2)) {
      html = html.replace(/\s|\n|\t/g, " ");
      if (tmpName === false) {
        j2 = findNextEqual(html, i2);
        if (j2 === -1) {
          v2 = _$1$1.trim(html.slice(lastPos, i2));
          addAttr(v2);
          tmpName = false;
          lastPos = i2 + 1;
          continue;
        } else {
          i2 = j2 - 1;
          continue;
        }
      } else {
        j2 = findBeforeEqual(html, i2 - 1);
        if (j2 === -1) {
          v2 = _$1$1.trim(html.slice(lastPos, i2));
          v2 = stripQuoteWrap(v2);
          addAttr(tmpName, v2);
          tmpName = false;
          lastPos = i2 + 1;
          continue;
        } else {
          continue;
        }
      }
    }
  }
  if (lastPos < html.length) {
    if (tmpName === false) {
      addAttr(html.slice(lastPos));
    } else {
      addAttr(tmpName, stripQuoteWrap(_$1$1.trim(html.slice(lastPos))));
    }
  }
  return _$1$1.trim(retAttrs.join(" "));
}
function findNextEqual(str, i2) {
  for (; i2 < str.length; i2++) {
    var c2 = str[i2];
    if (c2 === " ")
      continue;
    if (c2 === "=")
      return i2;
    return -1;
  }
}
function findNextQuotationMark(str, i2) {
  for (; i2 < str.length; i2++) {
    var c2 = str[i2];
    if (c2 === " ")
      continue;
    if (c2 === "'" || c2 === '"')
      return i2;
    return -1;
  }
}
function findBeforeEqual(str, i2) {
  for (; i2 > 0; i2--) {
    var c2 = str[i2];
    if (c2 === " ")
      continue;
    if (c2 === "=")
      return i2;
    return -1;
  }
}
function isQuoteWrapString(text) {
  if (text[0] === '"' && text[text.length - 1] === '"' || text[0] === "'" && text[text.length - 1] === "'") {
    return true;
  } else {
    return false;
  }
}
function stripQuoteWrap(text) {
  if (isQuoteWrapString(text)) {
    return text.substr(1, text.length - 2);
  } else {
    return text;
  }
}
parser$1.parseTag = parseTag$1;
parser$1.parseAttr = parseAttr$1;
var FilterCSS = lib.exports.FilterCSS;
var DEFAULT = _default$1;
var parser = parser$1;
var parseTag = parser.parseTag;
var parseAttr = parser.parseAttr;
var _$m = util;
function isNull(obj) {
  return obj === void 0 || obj === null;
}
function getAttrs(html) {
  var i2 = _$m.spaceIndex(html);
  if (i2 === -1) {
    return {
      html: "",
      closing: html[html.length - 2] === "/"
    };
  }
  html = _$m.trim(html.slice(i2 + 1, -1));
  var isClosing2 = html[html.length - 1] === "/";
  if (isClosing2)
    html = _$m.trim(html.slice(0, -1));
  return {
    html,
    closing: isClosing2
  };
}
function shallowCopyObject(obj) {
  var ret = {};
  for (var i2 in obj) {
    ret[i2] = obj[i2];
  }
  return ret;
}
function keysToLowerCase(obj) {
  var ret = {};
  for (var i2 in obj) {
    if (Array.isArray(obj[i2])) {
      ret[i2.toLowerCase()] = obj[i2].map(function(item) {
        return item.toLowerCase();
      });
    } else {
      ret[i2.toLowerCase()] = obj[i2];
    }
  }
  return ret;
}
function FilterXSS(options) {
  options = shallowCopyObject(options || {});
  if (options.stripIgnoreTag) {
    if (options.onIgnoreTag) {
      console.error('Notes: cannot use these two options "stripIgnoreTag" and "onIgnoreTag" at the same time');
    }
    options.onIgnoreTag = DEFAULT.onIgnoreTagStripAll;
  }
  if (options.whiteList || options.allowList) {
    options.whiteList = keysToLowerCase(options.whiteList || options.allowList);
  } else {
    options.whiteList = DEFAULT.whiteList;
  }
  options.onTag = options.onTag || DEFAULT.onTag;
  options.onTagAttr = options.onTagAttr || DEFAULT.onTagAttr;
  options.onIgnoreTag = options.onIgnoreTag || DEFAULT.onIgnoreTag;
  options.onIgnoreTagAttr = options.onIgnoreTagAttr || DEFAULT.onIgnoreTagAttr;
  options.safeAttrValue = options.safeAttrValue || DEFAULT.safeAttrValue;
  options.escapeHtml = options.escapeHtml || DEFAULT.escapeHtml;
  this.options = options;
  if (options.css === false) {
    this.cssFilter = false;
  } else {
    options.css = options.css || {};
    this.cssFilter = new FilterCSS(options.css);
  }
}
FilterXSS.prototype.process = function(html) {
  html = html || "";
  html = html.toString();
  if (!html)
    return "";
  var me2 = this;
  var options = me2.options;
  var whiteList = options.whiteList;
  var onTag2 = options.onTag;
  var onIgnoreTag2 = options.onIgnoreTag;
  var onTagAttr2 = options.onTagAttr;
  var onIgnoreTagAttr2 = options.onIgnoreTagAttr;
  var safeAttrValue2 = options.safeAttrValue;
  var escapeHtml2 = options.escapeHtml;
  var cssFilter = me2.cssFilter;
  if (options.stripBlankChar) {
    html = DEFAULT.stripBlankChar(html);
  }
  if (!options.allowCommentTag) {
    html = DEFAULT.stripCommentTag(html);
  }
  var stripIgnoreTagBody = false;
  if (options.stripIgnoreTagBody) {
    stripIgnoreTagBody = DEFAULT.StripTagBody(options.stripIgnoreTagBody, onIgnoreTag2);
    onIgnoreTag2 = stripIgnoreTagBody.onIgnoreTag;
  }
  var retHtml = parseTag(html, function(sourcePosition, position, tag, html2, isClosing2) {
    var info = {
      sourcePosition,
      position,
      isClosing: isClosing2,
      isWhite: Object.prototype.hasOwnProperty.call(whiteList, tag)
    };
    var ret = onTag2(tag, html2, info);
    if (!isNull(ret))
      return ret;
    if (info.isWhite) {
      if (info.isClosing) {
        return "</" + tag + ">";
      }
      var attrs = getAttrs(html2);
      var whiteAttrList = whiteList[tag];
      var attrsHtml = parseAttr(attrs.html, function(name, value) {
        var isWhiteAttr = _$m.indexOf(whiteAttrList, name) !== -1;
        var ret2 = onTagAttr2(tag, name, value, isWhiteAttr);
        if (!isNull(ret2))
          return ret2;
        if (isWhiteAttr) {
          value = safeAttrValue2(tag, name, value, cssFilter);
          if (value) {
            return name + '="' + value + '"';
          } else {
            return name;
          }
        } else {
          ret2 = onIgnoreTagAttr2(tag, name, value, isWhiteAttr);
          if (!isNull(ret2))
            return ret2;
          return;
        }
      });
      html2 = "<" + tag;
      if (attrsHtml)
        html2 += " " + attrsHtml;
      if (attrs.closing)
        html2 += " /";
      html2 += ">";
      return html2;
    } else {
      ret = onIgnoreTag2(tag, html2, info);
      if (!isNull(ret))
        return ret;
      return escapeHtml2(html2);
    }
  }, escapeHtml2);
  if (stripIgnoreTagBody) {
    retHtml = stripIgnoreTagBody.remove(retHtml);
  }
  return retHtml;
};
var xss = FilterXSS;
(function(module, exports) {
  var DEFAULT2 = _default$1;
  var parser2 = parser$1;
  var FilterXSS2 = xss;
  function filterXSS(html, options) {
    var xss2 = new FilterXSS2(options);
    return xss2.process(html);
  }
  exports = module.exports = filterXSS;
  exports.filterXSS = filterXSS;
  exports.FilterXSS = FilterXSS2;
  (function() {
    for (var i2 in DEFAULT2) {
      exports[i2] = DEFAULT2[i2];
    }
    for (var j2 in parser2) {
      exports[j2] = parser2[j2];
    }
  })();
  function isWorkerEnv() {
    return typeof self !== "undefined" && typeof DedicatedWorkerGlobalScope !== "undefined" && self instanceof DedicatedWorkerGlobalScope;
  }
  if (isWorkerEnv()) {
    self.filterXSS = module.exports;
  }
})(lib$1, lib$1.exports);
var Sanitizer = function() {
  function Sanitizer2(filterOptions, extendDefaults) {
    var _this = this;
    this.arcgisWhiteList = {
      a: ["href", "style", "target"],
      abbr: ["title"],
      audio: ["autoplay", "controls", "loop", "muted", "preload"],
      b: [],
      br: [],
      dd: ["style"],
      div: ["align", "style"],
      dl: ["style"],
      dt: ["style"],
      em: [],
      figcaption: ["style"],
      figure: ["style"],
      font: ["color", "face", "size", "style"],
      h1: ["style"],
      h2: ["style"],
      h3: ["style"],
      h4: ["style"],
      h5: ["style"],
      h6: ["style"],
      hr: [],
      i: [],
      img: ["alt", "border", "height", "src", "style", "width"],
      li: [],
      ol: [],
      p: ["style"],
      source: ["media", "src", "type"],
      span: ["style"],
      strong: [],
      sub: ["style"],
      sup: ["style"],
      table: ["border", "cellpadding", "cellspacing", "height", "style", "width"],
      tbody: [],
      tr: ["align", "height", "style", "valign"],
      td: [
        "align",
        "colspan",
        "height",
        "nowrap",
        "rowspan",
        "style",
        "valign",
        "width"
      ],
      th: [
        "align",
        "colspan",
        "height",
        "nowrap",
        "rowspan",
        "style",
        "valign",
        "width"
      ],
      u: [],
      ul: [],
      video: [
        "autoplay",
        "controls",
        "height",
        "loop",
        "muted",
        "poster",
        "preload",
        "width"
      ]
    };
    this.allowedProtocols = [
      "http",
      "https",
      "mailto",
      "iform",
      "tel",
      "flow",
      "lfmobile",
      "arcgis-navigator",
      "arcgis-appstudio-player",
      "arcgis-survey123",
      "arcgis-collector",
      "arcgis-workforce",
      "arcgis-explorer",
      "arcgis-trek2there",
      "arcgis-quickcapture",
      "mspbi",
      "comgooglemaps",
      "pdfefile",
      "pdfehttp",
      "pdfehttps",
      "boxapp",
      "boxemm",
      "awb",
      "awbs",
      "gropen",
      "radarscope"
    ];
    this.arcgisFilterOptions = {
      allowCommentTag: true,
      safeAttrValue: function(tag, name, value, cssFilter) {
        if (tag === "a" && name === "href" || (tag === "img" || tag === "source") && name === "src") {
          return _this.sanitizeUrl(value);
        }
        return lib$1.exports.safeAttrValue(tag, name, value, cssFilter);
      }
    };
    this._entityMap = {
      "&": "&#x38;",
      "<": "&#x3C;",
      ">": "&#x3E;",
      '"': "&#x22;",
      "'": "&#x27;",
      "/": "&#x2F;"
    };
    var xssFilterOptions;
    if (filterOptions && !extendDefaults) {
      xssFilterOptions = filterOptions;
    } else if (filterOptions && extendDefaults) {
      xssFilterOptions = Object.create(this.arcgisFilterOptions);
      Object.keys(filterOptions).forEach(function(key) {
        if (key === "whiteList") {
          xssFilterOptions.whiteList = _this._extendObjectOfArrays([
            _this.arcgisWhiteList,
            filterOptions.whiteList || {}
          ]);
        } else {
          xssFilterOptions[key] = filterOptions[key];
        }
      });
    } else {
      xssFilterOptions = Object.create(this.arcgisFilterOptions);
      xssFilterOptions.whiteList = this.arcgisWhiteList;
    }
    this.xssFilterOptions = xssFilterOptions;
    this._xssFilter = new lib$1.exports.FilterXSS(xssFilterOptions);
  }
  Sanitizer2.prototype.sanitize = function(value, options) {
    if (options === void 0) {
      options = {};
    }
    switch (typeof value) {
      case "number":
        if (isNaN(value) || !isFinite(value)) {
          return null;
        }
        return value;
      case "boolean":
        return value;
      case "string":
        return this._xssFilter.process(value);
      case "object":
        return this._iterateOverObject(value, options);
      default:
        if (options.allowUndefined && typeof value === "undefined") {
          return;
        }
        return null;
    }
  };
  Sanitizer2.prototype.sanitizeUrl = function(value, options) {
    var _a2 = (options !== null && options !== void 0 ? options : {}).isProtocolRequired, isProtocolRequired = _a2 === void 0 ? true : _a2;
    var protocol = this._trim(value.substring(0, value.indexOf(":")));
    var isRootUrl = value === "/";
    var isUrlFragment = /^#/.test(value);
    var isValidProtocol = protocol && this.allowedProtocols.indexOf(protocol.toLowerCase()) > -1;
    if (isRootUrl || isUrlFragment || isValidProtocol) {
      return lib$1.exports.escapeAttrValue(value);
    }
    if (!protocol && !isProtocolRequired) {
      return lib$1.exports.escapeAttrValue("https://".concat(value));
    }
    return "";
  };
  Sanitizer2.prototype.sanitizeHTMLAttribute = function(tag, attribute, value, cssFilter) {
    if (typeof this.xssFilterOptions.safeAttrValue === "function") {
      return this.xssFilterOptions.safeAttrValue(tag, attribute, value, cssFilter);
    }
    return lib$1.exports.safeAttrValue(tag, attribute, value, cssFilter);
  };
  Sanitizer2.prototype.validate = function(value, options) {
    if (options === void 0) {
      options = {};
    }
    var sanitized = this.sanitize(value, options);
    return {
      isValid: value === sanitized,
      sanitized
    };
  };
  Sanitizer2.prototype.encodeHTML = function(value) {
    var _this = this;
    return String(value).replace(/[&<>"'\/]/g, function(s2) {
      return _this._entityMap[s2];
    });
  };
  Sanitizer2.prototype.encodeAttrValue = function(value) {
    var alphanumericRE = /^[a-zA-Z0-9]$/;
    return String(value).replace(/[\x00-\xFF]/g, function(c2, idx) {
      return !alphanumericRE.test(c2) ? "&#x".concat(Number(value.charCodeAt(idx)).toString(16), ";") : c2;
    });
  };
  Sanitizer2.prototype._extendObjectOfArrays = function(objects) {
    var finalObj = {};
    objects.forEach(function(obj) {
      Object.keys(obj).forEach(function(key) {
        if (Array.isArray(obj[key]) && Array.isArray(finalObj[key])) {
          finalObj[key] = finalObj[key].concat(obj[key]);
        } else {
          finalObj[key] = obj[key];
        }
      });
    });
    return finalObj;
  };
  Sanitizer2.prototype._iterateOverObject = function(obj, options) {
    var _this = this;
    if (options === void 0) {
      options = {};
    }
    try {
      var hasChanged_1 = false;
      var changedObj = void 0;
      if (Array.isArray(obj)) {
        changedObj = obj.reduce(function(prev, value) {
          var validation = _this.validate(value, options);
          if (validation.isValid) {
            return prev.concat([value]);
          } else {
            hasChanged_1 = true;
            return prev.concat([validation.sanitized]);
          }
        }, []);
      } else if (!isPlainObject(obj)) {
        if (options.allowUndefined && typeof obj === "undefined") {
          return;
        }
        return null;
      } else {
        var keys = Object.keys(obj);
        changedObj = keys.reduce(function(prev, key) {
          var value = obj[key];
          var validation = _this.validate(value, options);
          if (validation.isValid) {
            prev[key] = value;
          } else {
            hasChanged_1 = true;
            prev[key] = validation.sanitized;
          }
          return prev;
        }, {});
      }
      if (hasChanged_1) {
        return changedObj;
      }
      return obj;
    } catch (err) {
      return null;
    }
  };
  Sanitizer2.prototype._trim = function(val) {
    return String.prototype.trim ? val.trim() : val.replace(/(^\s*)|(\s*$)/g, "");
  };
  return Sanitizer2;
}();
const n$1u = new Map();
function t$14() {
  n$1u.clear();
}
function e$12(t2) {
  return n$1u.get(t2);
}
function c$1E(t2, e2) {
  n$1u.set(t2, e2);
}
function o$12(t2) {
  n$1u.delete(t2);
}
var o$11, s$15, a$1y = function(e2) {
  if ("WebkitTransition" in e2.style)
    o$11 = "webkitTransitionEnd", s$15 = "webkitAnimationEnd";
  else {
    if (!("transition" in e2.style))
      throw new Error("Your browser is not supported!");
    o$11 = "transitionend", s$15 = "animationend";
  }
}, c$1D = function(e2) {
  o$11 || a$1y(e2);
}, l$18 = function(e2, t2) {
  return t2 === void 0 && (t2 = e2 + "-active"), function(n2) {
    c$1D(n2);
    var r2 = false, i2 = function(a2) {
      r2 || (r2 = true, n2.removeEventListener(o$11, i2), n2.removeEventListener(s$15, i2), n2.classList.remove(e2), n2.classList.remove(t2));
    };
    n2.classList.add(e2), n2.addEventListener(o$11, i2), n2.addEventListener(s$15, i2), requestAnimationFrame(function() {
      n2.classList.add(t2);
    });
  };
}, d$W = function(e2, t2) {
  return t2 === void 0 && (t2 = e2 + "-active"), function(n2, r2) {
    c$1D(n2);
    var i2 = false, a2 = function(e3) {
      i2 || (i2 = true, n2.removeEventListener(o$11, a2), n2.removeEventListener(s$15, a2), r2());
    };
    n2.classList.add(e2), n2.addEventListener(o$11, a2), n2.addEventListener(s$15, a2), requestAnimationFrame(function() {
      n2.classList.add(t2);
    });
  };
};
const u$_ = s$22.getLogger("esri.widgets.support.widgetUtils");
function p$1Q(e2) {
  const n2 = t$1J.acquire();
  for (let t2 = 0; t2 < arguments.length; t2++) {
    const e3 = arguments[t2], r3 = typeof e3;
    if (r3 === "string")
      n2.push(e3);
    else if (Array.isArray(e3))
      n2.push.apply(n2, e3);
    else if (r3 === "object")
      for (const t3 in e3)
        e3[t3] && n2.push(t3);
  }
  const r2 = n2.join(" ");
  return t$1J.release(n2), r2;
}
(() => {
  const e2 = new Map(), t2 = new ResizeObserver((t3) => {
    var _a2;
    t$14();
    for (const n2 of t3)
      (_a2 = e2.get(n2.target)) == null ? void 0 : _a2(n2);
  });
  return (r2, i2, o2) => (e2.has(r2) && u$_.error("Already observing element", r2), e2.set(r2, i2), t2.observe(r2, o2), n$2k(() => {
    t2.unobserve(r2), e2.delete(r2);
  }));
})();
function f$U(e2) {
  const t2 = e2 == null ? void 0 : e2.closest("[dir]");
  return t2 !== null && t2 instanceof HTMLElement && t2.dir === "rtl" || document.dir === "rtl";
}
function h$M(e2) {
  const t2 = "data-node-ref";
  this[e2.getAttribute(t2)] = null;
}
function v$A(e2) {
  const t2 = "data-node-ref";
  this[e2.getAttribute(t2)] = e2;
}
function w$v(e2, t2) {
  return (e2 === "enter" ? l$18 : d$W)(t2);
}
const L$g = ["dd", "dl", "dt", "h1", "h2", "h3", "h4", "h5", "h6", "sub", "sup", ...["animate", "animatetransform", "circle", "clippath", "defs", "ellipse", "g", "image", "line", "lineargradient", "marker", "mask", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "svg", "switch", "symbol", "text", "textpath", "tspan", "use"]], b$z = L$g.reduce((e2, t2) => (e2[t2] = [], e2), {}), y$P = ["align", "alink", "alt", "bgcolor", "border", "cellpadding", "cellspacing", "class", "color", "cols", "colspan", "coords", "d", "dir", "face", "height", "hspace", "ismap", "lang", "marginheight", "marginwidth", "multiple", "nohref", "noresize", "noshade", "nowrap", "ref", "rel", "rev", "rows", "rowspan", "scrolling", "shape", "span", "summary", "tabindex", "title", "usemap", "valign", "value", "vlink", "vspace", "width"], E$h = new Sanitizer({ whiteList: b$z, onTagAttr: (e2, t2, n2) => {
  const r2 = `${t2}="${n2}"`;
  if (y$P.includes(t2))
    return r2;
}, stripIgnoreTag: true, stripIgnoreTagBody: ["script", "style"] }, true);
function k$e(e2) {
  return e2 === "Enter" || e2 === " ";
}
const t$13 = "http://www.w3.org/", r$P = `${t$13}2000/svg`, o$10 = `${t$13}1999/xlink`;
let i$1s, l$17 = [], n$1t = (e2, t2) => {
  let r2 = {};
  return Object.keys(e2).forEach((t3) => {
    r2[t3] = e2[t3];
  }), t2 && Object.keys(t2).forEach((e3) => {
    r2[e3] = t2[e3];
  }), r2;
}, s$14 = (e2, t2) => e2.vnodeSelector === t2.vnodeSelector && (e2.properties && t2.properties ? e2.properties.key === t2.properties.key && e2.properties.bind === t2.properties.bind : !e2.properties && !t2.properties), p$1P = (e2) => {
  if (typeof e2 != "string")
    throw new Error("Style values must be strings");
}, d$V = (e2, t2, r2) => {
  if (t2.vnodeSelector !== "") {
    for (let o2 = r2; o2 < e2.length; o2++)
      if (s$14(e2[o2], t2))
        return o2;
  }
  return -1;
}, a$1x = (e2, t2, r2, o2) => {
  let i2 = e2[t2];
  if (i2.vnodeSelector === "")
    return;
  let l2 = i2.properties;
  if (!(l2 ? l2.key === void 0 ? l2.bind : l2.key : void 0)) {
    for (let n2 = 0; n2 < e2.length; n2++)
      if (n2 !== t2) {
        let t3 = e2[n2];
        if (s$14(t3, i2))
          throw new Error(`${r2.vnodeSelector} had a ${i2.vnodeSelector} child ${o2 === "added" ? o2 : "removed"}, but there is now more than one. You must add unique key properties to make them distinguishable.`);
      }
  }
}, f$T = (e2) => {
  if (e2.properties) {
    let t2 = e2.properties.enterAnimation;
    t2 && t2(e2.domNode, e2.properties);
  }
}, c$1C = [], u$Z = false, h$L = (e2) => {
  (e2.children || []).forEach(h$L), e2.properties && e2.properties.afterRemoved && e2.properties.afterRemoved.apply(e2.properties.bind || e2.properties, [e2.domNode]);
}, m$Z = () => {
  u$Z = false, c$1C.forEach(h$L), c$1C.length = 0;
}, v$z = (e2) => {
  c$1C.push(e2), u$Z || (u$Z = true, typeof window != "undefined" && "requestIdleCallback" in window ? window.requestIdleCallback(m$Z, { timeout: 16 }) : setTimeout(m$Z, 16));
}, y$O = (e2) => {
  let t2 = e2.domNode;
  if (e2.properties) {
    let r2 = e2.properties.exitAnimation;
    if (r2) {
      t2.style.pointerEvents = "none";
      let o2 = () => {
        t2.parentNode && (t2.parentNode.removeChild(t2), v$z(e2));
      };
      return void r2(t2, o2, e2.properties);
    }
  }
  t2.parentNode && (t2.parentNode.removeChild(t2), v$z(e2));
}, g$C = (t2, i2, l2) => {
  if (!i2)
    return;
  let n2 = l2.eventHandlerInterceptor, s2 = Object.keys(i2), d2 = s2.length;
  for (let a2 = 0; a2 < d2; a2++) {
    let d3 = s2[a2], f2 = i2[d3];
    if (d3 === "className")
      throw new Error('Property "className" is not supported, use "class".');
    if (d3 === "class")
      x$r(t2, f2, true);
    else if (d3 === "classes") {
      let e2 = Object.keys(f2), r2 = e2.length;
      for (let o2 = 0; o2 < r2; o2++) {
        let r3 = e2[o2];
        f2[r3] && t2.classList.add(r3);
      }
    } else if (d3 === "styles") {
      let e2 = Object.keys(f2), r2 = e2.length;
      for (let o2 = 0; o2 < r2; o2++) {
        let r3 = e2[o2], i3 = f2[r3];
        i3 && (p$1P(i3), l2.styleApplyer(t2, r3, i3));
      }
    } else if (d3 !== "key" && f2 != null) {
      let s3 = typeof f2;
      s3 === "function" ? (d3.lastIndexOf("on", 0) === 0 && (n2 && (f2 = n2(d3, f2, t2, i2)), d3 === "oninput" && function() {
        let e2 = f2;
        f2 = function(t3) {
          e2.apply(this, [t3]), t3.target["oninput-value"] = t3.target.value;
        };
      }()), t2[d3] = f2) : l2.namespace === r$P ? d3 === "href" ? t2.setAttributeNS(o$10, d3, f2) : t2.setAttribute(d3, f2) : s3 === "string" && d3 !== "value" ? d3 === "innerHTML" ? t2[d3] = E$h.sanitize(f2) : t2.setAttribute(d3, f2) : t2[d3] = f2;
    }
  }
}, b$y = (e2, t2, r2) => {
  if (t2)
    for (let o2 of t2)
      w$u(o2, e2, void 0, r2);
}, N$8 = (e2, t2, r2) => {
  b$y(e2, t2.children, r2), t2.text && (e2.textContent = t2.text), g$C(e2, t2.properties, r2), t2.properties && t2.properties.afterCreate && t2.properties.afterCreate.apply(t2.properties.bind || t2.properties, [e2, r2, t2.vnodeSelector, t2.properties, t2.children]);
}, w$u = (e2, t2, o2, i2) => {
  let l2, s2 = 0, p2 = e2.vnodeSelector, d2 = t2.ownerDocument;
  if (p2 === "")
    l2 = e2.domNode = d2.createTextNode(e2.text), o2 !== void 0 ? t2.insertBefore(l2, o2) : t2.appendChild(l2);
  else {
    for (let a2 = 0; a2 <= p2.length; ++a2) {
      let f2 = p2.charAt(a2);
      if (a2 === p2.length || f2 === "." || f2 === "#") {
        let f3 = p2.charAt(s2 - 1), c2 = p2.slice(s2, a2);
        f3 === "." ? l2.classList.add(c2) : f3 === "#" ? l2.id = c2 : (c2 === "svg" && (i2 = n$1t(i2, { namespace: r$P })), i2.namespace !== void 0 ? l2 = e2.domNode = d2.createElementNS(i2.namespace, c2) : (l2 = e2.domNode = e2.domNode || d2.createElement(c2), c2 === "input" && e2.properties && e2.properties.type !== void 0 && l2.setAttribute("type", e2.properties.type)), o2 !== void 0 ? t2.insertBefore(l2, o2) : l2.parentNode !== t2 && t2.appendChild(l2)), s2 = a2 + 1;
      }
    }
    N$8(l2, e2, i2);
  }
}, x$r = (e2, t2, r2) => {
  t2 && t2.split(" ").forEach((t3) => {
    t3 && e2.classList.toggle(t3, r2);
  });
}, k$d = (t2, i2, l2, n2) => {
  if (!l2)
    return;
  let s2 = false, d2 = Object.keys(l2), a2 = d2.length;
  for (let f2 = 0; f2 < a2; f2++) {
    let a3 = d2[f2], c2 = l2[a3], u2 = i2[a3];
    if (a3 === "class")
      u2 !== c2 && (x$r(t2, u2, false), x$r(t2, c2, true));
    else if (a3 === "classes") {
      let e2 = t2.classList, r2 = Object.keys(c2), o2 = r2.length;
      for (let t3 = 0; t3 < o2; t3++) {
        let o3 = r2[t3], i3 = !!c2[o3];
        i3 !== !!u2[o3] && (s2 = true, i3 ? e2.add(o3) : e2.remove(o3));
      }
    } else if (a3 === "styles") {
      let e2 = Object.keys(c2), r2 = e2.length;
      for (let o2 = 0; o2 < r2; o2++) {
        let r3 = e2[o2], i3 = c2[r3];
        i3 !== u2[r3] && (s2 = true, i3 ? (p$1P(i3), n2.styleApplyer(t2, r3, i3)) : n2.styleApplyer(t2, r3, ""));
      }
    } else if (c2 || typeof u2 != "string" || (c2 = ""), a3 === "value") {
      let e2 = t2[a3];
      e2 !== c2 && (t2["oninput-value"] ? e2 === t2["oninput-value"] : c2 !== u2) && (t2[a3] = c2, t2["oninput-value"] = void 0), c2 !== u2 && (s2 = true);
    } else if (c2 !== u2) {
      let i3 = typeof c2;
      i3 === "function" && n2.eventHandlerInterceptor || (n2.namespace === r$P ? a3 === "href" ? t2.setAttributeNS(o$10, a3, c2) : t2.setAttribute(a3, c2) : i3 === "string" ? a3 === "innerHTML" ? t2[a3] = E$h.sanitize(c2) : a3 === "role" && c2 === "" ? t2.removeAttribute(a3) : t2.setAttribute(a3, c2) : t2[a3] !== c2 && (t2[a3] = c2), s2 = true);
    }
  }
  return s2;
}, A$d = (e2, t2, r2, o2, n2) => {
  if (r2 === o2)
    return false;
  o2 = o2 || l$17;
  let p2, c2 = (r2 = r2 || l$17).length, u2 = o2.length, h2 = 0, m2 = 0, v2 = false;
  for (; m2 < u2; ) {
    let l2 = h2 < c2 ? r2[h2] : void 0, u3 = o2[m2];
    if (l2 !== void 0 && s$14(l2, u3))
      v2 = i$1s(l2, u3, n2) || v2, h2++;
    else {
      let l3 = d$V(r2, u3, h2 + 1);
      if (l3 >= 0) {
        for (p2 = h2; p2 < l3; p2++)
          y$O(r2[p2]), a$1x(r2, p2, e2, "removed");
        v2 = i$1s(r2[l3], u3, n2) || v2, h2 = l3 + 1;
      } else
        w$u(u3, t2, h2 < c2 ? r2[h2].domNode : void 0, n2), f$T(u3), a$1x(o2, m2, e2, "added");
    }
    m2++;
  }
  if (c2 > h2)
    for (p2 = h2; p2 < c2; p2++)
      y$O(r2[p2]), a$1x(r2, p2, e2, "removed");
  return v2;
};
i$1s = (e2, t2, o2) => {
  let i2 = e2.domNode, l2 = false;
  if (e2 === t2)
    return false;
  let s2 = false;
  if (t2.vnodeSelector === "") {
    if (t2.text !== e2.text) {
      let e3 = i2.ownerDocument.createTextNode(t2.text);
      return i2.parentNode.replaceChild(e3, i2), t2.domNode = e3, l2 = true, l2;
    }
    t2.domNode = i2;
  } else
    t2.vnodeSelector.lastIndexOf("svg", 0) === 0 && (o2 = n$1t(o2, { namespace: r$P })), e2.text !== t2.text && (s2 = true, t2.text === void 0 ? i2.removeChild(i2.firstChild) : i2.textContent = t2.text), t2.domNode = i2, s2 = A$d(t2, i2, e2.children, t2.children, o2) || s2, s2 = k$d(i2, e2.properties, t2.properties, o2) || s2, t2.properties && t2.properties.afterUpdate && t2.properties.afterUpdate.apply(t2.properties.bind || t2.properties, [i2, o2, t2.vnodeSelector, t2.properties, t2.children]);
  return s2 && t2.properties && t2.properties.updateAnimation && t2.properties.updateAnimation(i2, t2.properties, e2.properties), l2;
};
let S$o = (e2, t2) => ({ getLastRender: () => e2, update: (r2) => {
  if (e2.vnodeSelector !== r2.vnodeSelector)
    throw new Error("The selector for the root VNode may not be changed. (consider using dom.merge and add one extra level to the virtual DOM)");
  let o2 = e2;
  e2 = r2, i$1s(o2, r2, t2);
}, domNode: e2.domNode });
const p$1O = { namespace: void 0, performanceLogger: () => {
}, eventHandlerInterceptor: void 0, styleApplyer: (e2, r2, o2) => {
  r2.charAt(0) === "-" ? e2.style.setProperty(r2, o2) : e2.style[r2] = o2;
} };
let d$U = (r2) => n$1t(p$1O, r2), n$1s = { create: (e2, t2) => (t2 = d$U(t2), w$u(e2, document.createElement("div"), void 0, t2), S$o(e2, t2)), append: (e2, t2, p2) => (p2 = d$U(p2), w$u(t2, e2, void 0, p2), S$o(t2, p2)), insertBefore: (e2, t2, p2) => (p2 = d$U(p2), w$u(t2, e2.parentNode, e2, p2), S$o(t2, p2)), merge: (e2, r2, p2) => (p2 = d$U(p2), r2.domNode = e2, N$8(e2, r2, p2), S$o(r2, p2)), replace: (e2, t2, p2) => (p2 = d$U(p2), w$u(t2, e2.parentNode, e2, p2), e2.parentNode.removeChild(e2), S$o(t2, p2)) };
let t$12, n$1r = (e2, r2) => {
  let t2 = [];
  for (; e2 && e2 !== r2; )
    t2.push(e2), e2 = e2.parentNode;
  return t2;
};
t$12 = Array.prototype.find ? (e2, r2) => e2.find(r2) : (e2, r2) => e2.filter(r2)[0];
let o$$ = (e2, r2) => {
  let n2 = e2;
  return r2.forEach((e3) => {
    n2 = n2 && n2.children ? t$12(n2.children, (r3) => r3.domNode === e3) : void 0;
  }), n2;
}, d$T = (e2, r2, t2) => {
  let d2 = function(d3) {
    t2("domEvent", d3);
    let i2 = r2(), p2 = n$1r(d3.currentTarget, i2.domNode);
    p2.reverse();
    let l2, a2 = o$$(i2.getLastRender(), p2);
    return e2.scheduleRender(), a2 && (l2 = a2.properties[`on${d3.type}`].apply(a2.properties.bind || this, arguments)), t2("domEventProcessed", d3), l2;
  };
  return (e3, r3, t3, n2) => d2;
}, i$1r = (t2) => {
  let n2, o2, i2 = d$U(t2), p2 = i2.performanceLogger, l2 = true, a2 = false, s2 = [], c2 = [], u2 = (e2, r2, t3) => {
    let o3, l3 = () => o3;
    i2.eventHandlerInterceptor = d$T(n2, l3, p2), o3 = e2(r2, t3(), i2), s2.push(o3), c2.push(t3);
  }, f2 = () => {
    if (o2 = void 0, l2) {
      l2 = false, p2("renderStart", void 0);
      for (let e2 = 0; e2 < s2.length; e2++) {
        let r2 = c2[e2]();
        p2("rendered", void 0), s2[e2].update(r2), p2("patched", void 0);
      }
      p2("renderDone", void 0), l2 = true;
    }
  };
  return n2 = { renderNow: f2, scheduleRender: () => {
    o2 || a2 || (o2 = requestAnimationFrame(f2));
  }, stop: () => {
    o2 && (cancelAnimationFrame(o2), o2 = void 0), a2 = true;
  }, resume: () => {
    a2 = false, l2 = true, n2.scheduleRender();
  }, append: (e2, t3) => {
    u2(n$1s.append, e2, t3);
  }, insertBefore: (e2, t3) => {
    u2(n$1s.insertBefore, e2, t3);
  }, merge: (e2, t3) => {
    u2(n$1s.merge, e2, t3);
  }, replace: (e2, t3) => {
    u2(n$1s.replace, e2, t3);
  }, detach: (e2) => {
    for (let r2 = 0; r2 < c2.length; r2++)
      if (c2[r2] === e2)
        return c2.splice(r2, 1), s2.splice(r2, 1)[0];
    throw new Error("renderFunction was not found");
  } }, n2;
};
let a$1w = class extends m$1L {
  constructor() {
    super(...arguments), this.items = new j$F(), this._watchUpdatingTracking = new c$1F(), this._callbacks = new Map(), this._projector = i$1r(), this._hiddenProjector = i$1r();
  }
  get needsRender() {
    return this.items.length > 0;
  }
  get updating() {
    var _a2, _b2;
    return (_b2 = (_a2 = this._watchUpdatingTracking) == null ? void 0 : _a2.updating) != null ? _b2 : false;
  }
  initialize() {
    const t2 = document.createElement("div");
    t2.className = "esri-overlay-surface", this._set("surface", t2), this._hiddenSurface = document.createElement("div"), this._hiddenSurface.setAttribute("style", "visibility: hidden;"), t2.appendChild(this._hiddenSurface), this._watchUpdatingTracking.addOnCollectionChange(() => this.items, (t3) => {
      for (const e2 of t3.added) {
        const t4 = () => e2.render();
        this._callbacks.set(e2, t4), this._projector.append(this.surface, t4);
      }
      for (const e2 of t3.removed) {
        const t4 = this._projector.detach(this._callbacks.get(e2));
        this.surface.removeChild(t4.domNode), this._callbacks.delete(e2);
      }
    });
  }
  addItem(t2) {
    this.items.add(t2);
  }
  removeItem(t2) {
    this.items.remove(t2);
  }
  destroy() {
    this.items.removeAll(), this._callbacks.forEach((t2) => this._projector.detach(t2)), this._callbacks = null, this._projector = null, this._watchUpdatingTracking.destroy();
  }
  render() {
    this._projector.renderNow();
  }
  computeBoundingRect(t2) {
    const e2 = this._hiddenSurface, r2 = this._hiddenProjector;
    let o2 = null;
    const s2 = () => (o2 = t2.render(), o2);
    r2.append(e2, s2), r2.renderNow();
    const i2 = { left: 0, top: 0, right: 0, bottom: 0 };
    if (o2 && o2.domNode) {
      const t3 = o2.domNode.getBoundingClientRect();
      i2.left = t3.left, i2.top = t3.top, i2.right = t3.right, i2.bottom = t3.bottom;
    }
    for (r2.detach(s2); e2.firstChild; )
      e2.removeChild(e2.firstChild);
    return i2;
  }
  overlaps(t2, e2) {
    const r2 = this.computeBoundingRect(t2), o2 = this.computeBoundingRect(e2);
    return Math.max(r2.left, o2.left) <= Math.min(r2.right, o2.right) && Math.max(r2.top, o2.top) <= Math.min(r2.bottom, o2.bottom);
  }
  get hasVisibleItems() {
    return this.items.some((t2) => t2.visible);
  }
  async prepare() {
    await document.fonts.load(this._fontString()).catch(() => {
    });
  }
  renderCanvas(t2) {
    if (!this.items.some((t3) => t3.visible))
      return;
    const e2 = t2.getContext("2d");
    e2.save(), e2.font = this._fontString(), this.items.forEach((t3) => {
      e2.save(), t3.renderCanvas(e2), e2.restore();
    }), e2.restore();
  }
  _fontString() {
    return `10px ${getComputedStyle(this.surface).fontFamily}`;
  }
};
e$1W([y$1o({ readOnly: true })], a$1w.prototype, "surface", void 0), e$1W([y$1o({ readOnly: true })], a$1w.prototype, "items", void 0), e$1W([y$1o({ readOnly: true })], a$1w.prototype, "needsRender", null), e$1W([y$1o({ readOnly: true })], a$1w.prototype, "_watchUpdatingTracking", void 0), e$1W([y$1o({ readOnly: true })], a$1w.prototype, "updating", null), a$1w = e$1W([n$2f("esri.views.overlay.ViewOverlay")], a$1w);
const c$1B = a$1w;
function e$11(e2, t2, l2, n2) {
  let o2 = null, p2 = 1e3;
  typeof t2 == "number" ? (p2 = t2, n2 = l2) : (o2 = t2 != null ? t2 : null, p2 = l2);
  let r2, u2 = 0;
  const a2 = () => {
    u2 = 0, e2.apply(n2, r2);
  }, c2 = (...e3) => {
    o2 && o2.apply(n2, e3), r2 = e3, p2 ? u2 || (u2 = setTimeout(a2, p2)) : a2();
  };
  return c2.remove = () => {
    u2 && (clearTimeout(u2), u2 = 0);
  }, c2.forceUpdate = () => {
    u2 && (clearTimeout(u2), a2());
  }, c2.hasPendingUpdates = () => !!u2, c2;
}
const t$11 = "randomUUID" in crypto;
function n$1q() {
  if (t$11)
    return crypto.randomUUID();
  const n2 = crypto.getRandomValues(new Uint16Array(8));
  n2[3] = 4095 & n2[3] | 16384, n2[4] = 16383 & n2[4] | 32768;
  const r2 = (t2) => n2[t2].toString(16).padStart(4, "0");
  return r2(0) + r2(1) + "-" + r2(2) + "-" + r2(3) + "-" + r2(4) + "-" + r2(5) + r2(6) + r2(7);
}
const e$10 = { handleInterceptedEvent: (e2, p2, t2, n2) => (e2.scheduleRender(), p2.properties[`on${n2.type}`].apply(p2.properties.bind || t2, [n2])) };
const e$$ = { namespace: void 0, performanceLogger: () => {
}, eventHandlerInterceptor: void 0, styleApplyer: (e2, r2, o2) => {
  e2.style[r2] = o2;
} }, r$O = (r2) => __spreadValues(__spreadValues({}, e$$), r2);
const o$_ = (e2, t2) => {
  const r2 = [];
  for (; e2 && e2 !== t2; )
    r2.push(e2), e2 = e2.parentNode;
  return r2;
}, n$1p = (e2, t2) => e2.find(t2), d$S = (e2, t2, r2 = false) => {
  let o2 = e2;
  return t2.forEach((e3, d2) => {
    const s2 = (o2 == null ? void 0 : o2.children) ? n$1p(o2.children, (t3) => t3.domNode === e3) : void 0;
    r2 && !s2 && d2 !== t2.length - 1 || (o2 = s2);
  }), o2;
}, s$13 = (n2) => {
  let s2;
  const i2 = __spreadValues(__spreadValues({}, e$10), n2), c2 = r$O(i2), a2 = c2.performanceLogger;
  let m2, p2 = true, l2 = false;
  const f2 = [], u2 = [], h2 = (e2, t2, r2) => {
    var _a2;
    let n3;
    c2.eventHandlerInterceptor = (e3, t3, r3, c3) => function(e4) {
      let t4;
      a2("domEvent", e4);
      const r4 = o$_(e4.currentTarget, n3.domNode), c4 = r4.some((e5) => {
        var _a3;
        return customElements.get((_a3 = e5 == null ? void 0 : e5.tagName) == null ? void 0 : _a3.toLowerCase());
      });
      if (e4.eventPhase === Event.CAPTURING_PHASE || !c4)
        r4.reverse(), t4 = d$S(n3.getLastRender(), r4);
      else {
        const r5 = e4.composedPath(), o2 = r5.slice(r5.indexOf(e4.currentTarget), r5.indexOf(n3.domNode)).filter((e5) => e5.getRootNode() === e5.ownerDocument).reverse();
        t4 = d$S(n3.getLastRender(), o2, true);
      }
      let m4;
      return t4 && (m4 = i2.handleInterceptedEvent(s2, t4, this, e4)), a2("domEventProcessed", e4), m4;
    }, (_a2 = i2.postProcessProjectionOptions) == null ? void 0 : _a2.call(i2, c2);
    const m3 = r2();
    n3 = e2(t2, m3, c2), f2.push(n3), u2.push(r2), i2.afterFirstVNodeRendered && i2.afterFirstVNodeRendered(n3, m3);
  };
  let v2 = () => {
    if (m2 = void 0, p2) {
      p2 = false, a2("renderStart", void 0);
      for (let e2 = 0; e2 < f2.length; e2++) {
        const t2 = u2[e2]();
        a2("rendered", void 0), f2[e2].update(t2), a2("patched", void 0);
      }
      a2("renderDone", void 0), p2 = true;
    }
  };
  return i2.modifyDoRenderImplementation && (v2 = i2.modifyDoRenderImplementation(v2, f2, u2)), s2 = { renderNow: v2, scheduleRender: () => {
    m2 || l2 || (m2 = requestAnimationFrame(v2));
  }, stop: () => {
    m2 && (cancelAnimationFrame(m2), m2 = void 0), l2 = true;
  }, resume: () => {
    l2 = false, p2 = true, s2.scheduleRender();
  }, append: (t2, r2) => {
    h2(n$1s.append, t2, r2);
  }, insertBefore: (t2, r2) => {
    h2(n$1s.insertBefore, t2, r2);
  }, merge: (t2, r2) => {
    h2(n$1s.merge, t2, r2);
  }, replace: (t2, r2) => {
    h2(n$1s.replace, t2, r2);
  }, detach: (e2) => {
    for (let t2 = 0; t2 < u2.length; t2++)
      if (u2[t2] === e2)
        return u2.splice(t2, 1), f2.splice(t2, 1)[0];
    throw new Error("renderFunction was not found");
  } }, s2;
};
const BUILD = {
  allRenderFn: false,
  cmpDidLoad: true,
  cmpDidUnload: false,
  cmpDidUpdate: true,
  cmpDidRender: true,
  cmpWillLoad: true,
  cmpWillUpdate: true,
  cmpWillRender: true,
  connectedCallback: true,
  disconnectedCallback: true,
  element: true,
  event: true,
  hasRenderFn: true,
  lifecycle: true,
  hostListener: true,
  hostListenerTargetWindow: true,
  hostListenerTargetDocument: true,
  hostListenerTargetBody: true,
  hostListenerTargetParent: false,
  hostListenerTarget: true,
  member: true,
  method: true,
  mode: true,
  observeAttribute: true,
  prop: true,
  propMutable: true,
  reflect: true,
  scoped: true,
  shadowDom: true,
  slot: true,
  cssAnnotations: true,
  state: true,
  style: true,
  svg: true,
  updatable: true,
  vdomAttribute: true,
  vdomXlink: true,
  vdomClass: true,
  vdomFunctional: true,
  vdomKey: true,
  vdomListener: true,
  vdomRef: true,
  vdomPropOrAttr: true,
  vdomRender: true,
  vdomStyle: true,
  vdomText: true,
  watchCallback: true,
  taskQueue: true,
  hotModuleReplacement: false,
  isDebug: false,
  isDev: false,
  isTesting: false,
  hydrateServerSide: false,
  hydrateClientSide: false,
  lifecycleDOMEvents: false,
  lazyLoad: false,
  profile: false,
  slotRelocation: true,
  appendChildSlotFix: false,
  cloneNodeFix: false,
  hydratedAttribute: false,
  hydratedClass: true,
  safari10: false,
  scriptDataOpts: false,
  scopedSlotTextContentFix: false,
  shadowDomShim: false,
  slotChildNodesFix: false,
  invisiblePrehydration: true,
  propBoolean: true,
  propNumber: true,
  propString: true,
  cssVarShim: false,
  constructableCSS: true,
  cmpShouldUpdate: true,
  devTools: false,
  dynamicImportShim: false,
  shadowDelegatesFocus: true,
  initializeNextTick: false,
  asyncLoading: false,
  asyncQueue: false,
  transformTagName: false,
  attachStyles: true
};
let scopeId;
let contentRef;
let hostTagName;
let useNativeShadowDom = false;
let checkSlotFallbackVisibility = false;
let checkSlotRelocate = false;
let isSvgMode = false;
let renderingRef = null;
let queuePending = false;
const Build = {
  isDev: BUILD.isDev ? true : false,
  isBrowser: true,
  isServer: false,
  isTesting: BUILD.isTesting ? true : false
};
const getAssetPath = (path) => {
  const assetUrl = new URL(path, plt.$resourcesUrl$);
  return assetUrl.origin !== win.location.origin ? assetUrl.href : assetUrl.pathname;
};
const setAssetPath = (path) => plt.$resourcesUrl$ = path;
const createTime = (fnName, tagName = "") => {
  {
    return () => {
      return;
    };
  }
};
const XLINK_NS = "http://www.w3.org/1999/xlink";
const EMPTY_OBJ = {};
const SVG_NS = "http://www.w3.org/2000/svg";
const HTML_NS = "http://www.w3.org/1999/xhtml";
const isDef = (v2) => v2 != null;
const isComplexType = (o2) => {
  o2 = typeof o2;
  return o2 === "object" || o2 === "function";
};
const h$K = (nodeName, vnodeData, ...children) => {
  let child = null;
  let key = null;
  let slotName = null;
  let simple = false;
  let lastSimple = false;
  const vNodeChildren = [];
  const walk = (c2) => {
    for (let i2 = 0; i2 < c2.length; i2++) {
      child = c2[i2];
      if (Array.isArray(child)) {
        walk(child);
      } else if (child != null && typeof child !== "boolean") {
        if (simple = typeof nodeName !== "function" && !isComplexType(child)) {
          child = String(child);
        }
        if (simple && lastSimple) {
          vNodeChildren[vNodeChildren.length - 1].$text$ += child;
        } else {
          vNodeChildren.push(simple ? newVNode(null, child) : child);
        }
        lastSimple = simple;
      }
    }
  };
  walk(children);
  if (vnodeData) {
    if (BUILD.isDev && nodeName === "input") {
      validateInputProperties(vnodeData);
    }
    if (BUILD.vdomKey && vnodeData.key) {
      key = vnodeData.key;
    }
    if (BUILD.slotRelocation && vnodeData.name) {
      slotName = vnodeData.name;
    }
    if (BUILD.vdomClass) {
      const classData = vnodeData.className || vnodeData.class;
      if (classData) {
        vnodeData.class = typeof classData !== "object" ? classData : Object.keys(classData).filter((k2) => classData[k2]).join(" ");
      }
    }
  }
  if (BUILD.isDev && vNodeChildren.some(isHost)) {
    consoleDevError(`The <Host> must be the single root component. Make sure:
- You are NOT using hostData() and <Host> in the same component.
- <Host> is used once, and it's the single root component of the render() function.`);
  }
  if (BUILD.vdomFunctional && typeof nodeName === "function") {
    return nodeName(vnodeData === null ? {} : vnodeData, vNodeChildren, vdomFnUtils);
  }
  const vnode = newVNode(nodeName, null);
  vnode.$attrs$ = vnodeData;
  if (vNodeChildren.length > 0) {
    vnode.$children$ = vNodeChildren;
  }
  if (BUILD.vdomKey) {
    vnode.$key$ = key;
  }
  if (BUILD.slotRelocation) {
    vnode.$name$ = slotName;
  }
  return vnode;
};
const newVNode = (tag, text) => {
  const vnode = {
    $flags$: 0,
    $tag$: tag,
    $text$: text,
    $elm$: null,
    $children$: null
  };
  if (BUILD.vdomAttribute) {
    vnode.$attrs$ = null;
  }
  if (BUILD.vdomKey) {
    vnode.$key$ = null;
  }
  if (BUILD.slotRelocation) {
    vnode.$name$ = null;
  }
  return vnode;
};
const Host = {};
const isHost = (node) => node && node.$tag$ === Host;
const vdomFnUtils = {
  forEach: (children, cb) => children.map(convertToPublic).forEach(cb),
  map: (children, cb) => children.map(convertToPublic).map(cb).map(convertToPrivate)
};
const convertToPublic = (node) => ({
  vattrs: node.$attrs$,
  vchildren: node.$children$,
  vkey: node.$key$,
  vname: node.$name$,
  vtag: node.$tag$,
  vtext: node.$text$
});
const convertToPrivate = (node) => {
  if (typeof node.vtag === "function") {
    const vnodeData = Object.assign({}, node.vattrs);
    if (node.vkey) {
      vnodeData.key = node.vkey;
    }
    if (node.vname) {
      vnodeData.name = node.vname;
    }
    return h$K(node.vtag, vnodeData, ...node.vchildren || []);
  }
  const vnode = newVNode(node.vtag, node.vtext);
  vnode.$attrs$ = node.vattrs;
  vnode.$children$ = node.vchildren;
  vnode.$key$ = node.vkey;
  vnode.$name$ = node.vname;
  return vnode;
};
const validateInputProperties = (inputElm) => {
  const props = Object.keys(inputElm);
  const value = props.indexOf("value");
  if (value === -1) {
    return;
  }
  const typeIndex = props.indexOf("type");
  const minIndex = props.indexOf("min");
  const maxIndex = props.indexOf("max");
  const stepIndex = props.indexOf("step");
  if (value < typeIndex || value < minIndex || value < maxIndex || value < stepIndex) {
    consoleDevWarn(`The "value" prop of <input> should be set after "min", "max", "type" and "step"`);
  }
};
const computeMode = (elm) => modeResolutionChain.map((h2) => h2(elm)).find((m2) => !!m2);
const parsePropertyValue = (propValue, propType) => {
  if (propValue != null && !isComplexType(propValue)) {
    if (propType & 4) {
      return propValue === "false" ? false : propValue === "" || !!propValue;
    }
    if (propType & 2) {
      return parseFloat(propValue);
    }
    if (propType & 1) {
      return String(propValue);
    }
    return propValue;
  }
  return propValue;
};
const getElement = (ref2) => BUILD.lazyLoad ? getHostRef(ref2).$hostElement$ : ref2;
const createEvent = (ref2, name, flags) => {
  const elm = getElement(ref2);
  return {
    emit: (detail) => {
      if (BUILD.isDev && !elm.isConnected) {
        consoleDevWarn(`The "${name}" event was emitted, but the dispatcher node is no longer connected to the dom.`);
      }
      return emitEvent(elm, name, {
        bubbles: !!(flags & 4),
        composed: !!(flags & 2),
        cancelable: !!(flags & 1),
        detail
      });
    }
  };
};
const emitEvent = (elm, name, opts) => {
  const ev = plt.ce(name, opts);
  elm.dispatchEvent(ev);
  return ev;
};
const rootAppliedStyles = /* @__PURE__ */ new WeakMap();
const registerStyle = (scopeId2, cssText, allowCS) => {
  let style = styles.get(scopeId2);
  if (supportsConstructableStylesheets && allowCS) {
    style = style || new CSSStyleSheet();
    if (typeof style === "string") {
      style = cssText;
    } else {
      style.replaceSync(cssText);
    }
  } else {
    style = cssText;
  }
  styles.set(scopeId2, style);
};
const addStyle = (styleContainerNode, cmpMeta, mode, hostElm) => {
  let scopeId2 = getScopeId(cmpMeta, mode);
  const style = styles.get(scopeId2);
  styleContainerNode = styleContainerNode.nodeType === 11 ? styleContainerNode : doc;
  if (style) {
    if (typeof style === "string") {
      styleContainerNode = styleContainerNode.head || styleContainerNode;
      let appliedStyles = rootAppliedStyles.get(styleContainerNode);
      let styleElm;
      if (!appliedStyles) {
        rootAppliedStyles.set(styleContainerNode, appliedStyles = new Set());
      }
      if (!appliedStyles.has(scopeId2)) {
        {
          {
            styleElm = doc.createElement("style");
            styleElm.innerHTML = style;
          }
          styleContainerNode.insertBefore(styleElm, styleContainerNode.querySelector("link"));
        }
        if (appliedStyles) {
          appliedStyles.add(scopeId2);
        }
      }
    } else if (!styleContainerNode.adoptedStyleSheets.includes(style)) {
      styleContainerNode.adoptedStyleSheets = [...styleContainerNode.adoptedStyleSheets, style];
    }
  }
  return scopeId2;
};
const attachStyles = (hostRef) => {
  const cmpMeta = hostRef.$cmpMeta$;
  const elm = hostRef.$hostElement$;
  const flags = cmpMeta.$flags$;
  const endAttachStyles = createTime("attachStyles", cmpMeta.$tagName$);
  const scopeId2 = addStyle(supportsShadow && elm.shadowRoot ? elm.shadowRoot : elm.getRootNode(), cmpMeta, hostRef.$modeName$);
  if (flags & 10) {
    elm["s-sc"] = scopeId2;
    elm.classList.add(scopeId2 + "-h");
    if (flags & 2) {
      elm.classList.add(scopeId2 + "-s");
    }
  }
  endAttachStyles();
};
const getScopeId = (cmp, mode) => "sc-" + (mode && cmp.$flags$ & 32 ? cmp.$tagName$ + "-" + mode : cmp.$tagName$);
const setAccessor = (elm, memberName, oldValue, newValue, isSvg, flags) => {
  if (oldValue !== newValue) {
    let isProp = isMemberInElement(elm, memberName);
    let ln2 = memberName.toLowerCase();
    if (memberName === "class") {
      const classList = elm.classList;
      const oldClasses = parseClassList(oldValue);
      const newClasses = parseClassList(newValue);
      classList.remove(...oldClasses.filter((c2) => c2 && !newClasses.includes(c2)));
      classList.add(...newClasses.filter((c2) => c2 && !oldClasses.includes(c2)));
    } else if (memberName === "style") {
      {
        for (const prop in oldValue) {
          if (!newValue || newValue[prop] == null) {
            if (prop.includes("-")) {
              elm.style.removeProperty(prop);
            } else {
              elm.style[prop] = "";
            }
          }
        }
      }
      for (const prop in newValue) {
        if (!oldValue || newValue[prop] !== oldValue[prop]) {
          if (prop.includes("-")) {
            elm.style.setProperty(prop, newValue[prop]);
          } else {
            elm.style[prop] = newValue[prop];
          }
        }
      }
    } else if (memberName === "key")
      ;
    else if (memberName === "ref") {
      if (newValue) {
        newValue(elm);
      }
    } else if (!elm.__lookupSetter__(memberName) && memberName[0] === "o" && memberName[1] === "n") {
      if (memberName[2] === "-") {
        memberName = memberName.slice(3);
      } else if (isMemberInElement(win, ln2)) {
        memberName = ln2.slice(2);
      } else {
        memberName = ln2[2] + memberName.slice(3);
      }
      if (oldValue) {
        plt.rel(elm, memberName, oldValue, false);
      }
      if (newValue) {
        plt.ael(elm, memberName, newValue, false);
      }
    } else {
      const isComplex = isComplexType(newValue);
      if ((isProp || isComplex && newValue !== null) && !isSvg) {
        try {
          if (!elm.tagName.includes("-")) {
            const n2 = newValue == null ? "" : newValue;
            if (memberName === "list") {
              isProp = false;
            } else if (oldValue == null || elm[memberName] != n2) {
              elm[memberName] = n2;
            }
          } else {
            elm[memberName] = newValue;
          }
        } catch (e2) {
        }
      }
      let xlink = false;
      {
        if (ln2 !== (ln2 = ln2.replace(/^xlink\:?/, ""))) {
          memberName = ln2;
          xlink = true;
        }
      }
      if (newValue == null || newValue === false) {
        if (newValue !== false || elm.getAttribute(memberName) === "") {
          if (xlink) {
            elm.removeAttributeNS(XLINK_NS, memberName);
          } else {
            elm.removeAttribute(memberName);
          }
        }
      } else if ((!isProp || flags & 4 || isSvg) && !isComplex) {
        newValue = newValue === true ? "" : newValue;
        if (xlink) {
          elm.setAttributeNS(XLINK_NS, memberName, newValue);
        } else {
          elm.setAttribute(memberName, newValue);
        }
      }
    }
  }
};
const parseClassListRegex = /\s/;
const parseClassList = (value) => !value ? [] : value.split(parseClassListRegex);
const updateElement = (oldVnode, newVnode, isSvgMode2, memberName) => {
  const elm = newVnode.$elm$.nodeType === 11 && newVnode.$elm$.host ? newVnode.$elm$.host : newVnode.$elm$;
  const oldVnodeAttrs = oldVnode && oldVnode.$attrs$ || EMPTY_OBJ;
  const newVnodeAttrs = newVnode.$attrs$ || EMPTY_OBJ;
  {
    for (memberName in oldVnodeAttrs) {
      if (!(memberName in newVnodeAttrs)) {
        setAccessor(elm, memberName, oldVnodeAttrs[memberName], void 0, isSvgMode2, newVnode.$flags$);
      }
    }
  }
  for (memberName in newVnodeAttrs) {
    setAccessor(elm, memberName, oldVnodeAttrs[memberName], newVnodeAttrs[memberName], isSvgMode2, newVnode.$flags$);
  }
};
const createElm = (oldParentVNode, newParentVNode, childIndex, parentElm) => {
  const newVNode2 = newParentVNode.$children$[childIndex];
  let i2 = 0;
  let elm;
  let childNode;
  let oldVNode;
  if (!useNativeShadowDom) {
    checkSlotRelocate = true;
    if (newVNode2.$tag$ === "slot") {
      if (scopeId) {
        parentElm.classList.add(scopeId + "-s");
      }
      newVNode2.$flags$ |= newVNode2.$children$ ? 2 : 1;
    }
  }
  if (newVNode2.$text$ !== null) {
    elm = newVNode2.$elm$ = doc.createTextNode(newVNode2.$text$);
  } else if (newVNode2.$flags$ & 1) {
    elm = newVNode2.$elm$ = doc.createTextNode("");
  } else {
    if (!isSvgMode) {
      isSvgMode = newVNode2.$tag$ === "svg";
    }
    elm = newVNode2.$elm$ = doc.createElementNS(isSvgMode ? SVG_NS : HTML_NS, newVNode2.$flags$ & 2 ? "slot-fb" : newVNode2.$tag$);
    if (isSvgMode && newVNode2.$tag$ === "foreignObject") {
      isSvgMode = false;
    }
    {
      updateElement(null, newVNode2, isSvgMode);
    }
    if (isDef(scopeId) && elm["s-si"] !== scopeId) {
      elm.classList.add(elm["s-si"] = scopeId);
    }
    if (newVNode2.$children$) {
      for (i2 = 0; i2 < newVNode2.$children$.length; ++i2) {
        childNode = createElm(oldParentVNode, newVNode2, i2, elm);
        if (childNode) {
          elm.appendChild(childNode);
        }
      }
    }
    {
      if (newVNode2.$tag$ === "svg") {
        isSvgMode = false;
      } else if (elm.tagName === "foreignObject") {
        isSvgMode = true;
      }
    }
  }
  {
    elm["s-hn"] = hostTagName;
    if (newVNode2.$flags$ & (2 | 1)) {
      elm["s-sr"] = true;
      elm["s-cr"] = contentRef;
      elm["s-sn"] = newVNode2.$name$ || "";
      oldVNode = oldParentVNode && oldParentVNode.$children$ && oldParentVNode.$children$[childIndex];
      if (oldVNode && oldVNode.$tag$ === newVNode2.$tag$ && oldParentVNode.$elm$) {
        putBackInOriginalLocation(oldParentVNode.$elm$, false);
      }
    }
  }
  return elm;
};
const putBackInOriginalLocation = (parentElm, recursive) => {
  plt.$flags$ |= 1;
  const oldSlotChildNodes = parentElm.childNodes;
  for (let i2 = oldSlotChildNodes.length - 1; i2 >= 0; i2--) {
    const childNode = oldSlotChildNodes[i2];
    if (childNode["s-hn"] !== hostTagName && childNode["s-ol"]) {
      parentReferenceNode(childNode).insertBefore(childNode, referenceNode(childNode));
      childNode["s-ol"].remove();
      childNode["s-ol"] = void 0;
      checkSlotRelocate = true;
    }
    if (recursive) {
      putBackInOriginalLocation(childNode, recursive);
    }
  }
  plt.$flags$ &= ~1;
};
const addVnodes = (parentElm, before, parentVNode, vnodes, startIdx, endIdx) => {
  let containerElm = parentElm["s-cr"] && parentElm["s-cr"].parentNode || parentElm;
  let childNode;
  if (containerElm.shadowRoot && containerElm.tagName === hostTagName) {
    containerElm = containerElm.shadowRoot;
  }
  for (; startIdx <= endIdx; ++startIdx) {
    if (vnodes[startIdx]) {
      childNode = createElm(null, parentVNode, startIdx, parentElm);
      if (childNode) {
        vnodes[startIdx].$elm$ = childNode;
        containerElm.insertBefore(childNode, referenceNode(before));
      }
    }
  }
};
const removeVnodes = (vnodes, startIdx, endIdx, vnode, elm) => {
  for (; startIdx <= endIdx; ++startIdx) {
    if (vnode = vnodes[startIdx]) {
      elm = vnode.$elm$;
      callNodeRefs(vnode);
      {
        checkSlotFallbackVisibility = true;
        if (elm["s-ol"]) {
          elm["s-ol"].remove();
        } else {
          putBackInOriginalLocation(elm, true);
        }
      }
      elm.remove();
    }
  }
};
const updateChildren = (parentElm, oldCh, newVNode2, newCh) => {
  let oldStartIdx = 0;
  let newStartIdx = 0;
  let idxInOld = 0;
  let i2 = 0;
  let oldEndIdx = oldCh.length - 1;
  let oldStartVnode = oldCh[0];
  let oldEndVnode = oldCh[oldEndIdx];
  let newEndIdx = newCh.length - 1;
  let newStartVnode = newCh[0];
  let newEndVnode = newCh[newEndIdx];
  let node;
  let elmToMove;
  while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
    if (oldStartVnode == null) {
      oldStartVnode = oldCh[++oldStartIdx];
    } else if (oldEndVnode == null) {
      oldEndVnode = oldCh[--oldEndIdx];
    } else if (newStartVnode == null) {
      newStartVnode = newCh[++newStartIdx];
    } else if (newEndVnode == null) {
      newEndVnode = newCh[--newEndIdx];
    } else if (isSameVnode(oldStartVnode, newStartVnode)) {
      patch(oldStartVnode, newStartVnode);
      oldStartVnode = oldCh[++oldStartIdx];
      newStartVnode = newCh[++newStartIdx];
    } else if (isSameVnode(oldEndVnode, newEndVnode)) {
      patch(oldEndVnode, newEndVnode);
      oldEndVnode = oldCh[--oldEndIdx];
      newEndVnode = newCh[--newEndIdx];
    } else if (isSameVnode(oldStartVnode, newEndVnode)) {
      if (oldStartVnode.$tag$ === "slot" || newEndVnode.$tag$ === "slot") {
        putBackInOriginalLocation(oldStartVnode.$elm$.parentNode, false);
      }
      patch(oldStartVnode, newEndVnode);
      parentElm.insertBefore(oldStartVnode.$elm$, oldEndVnode.$elm$.nextSibling);
      oldStartVnode = oldCh[++oldStartIdx];
      newEndVnode = newCh[--newEndIdx];
    } else if (isSameVnode(oldEndVnode, newStartVnode)) {
      if (oldStartVnode.$tag$ === "slot" || newEndVnode.$tag$ === "slot") {
        putBackInOriginalLocation(oldEndVnode.$elm$.parentNode, false);
      }
      patch(oldEndVnode, newStartVnode);
      parentElm.insertBefore(oldEndVnode.$elm$, oldStartVnode.$elm$);
      oldEndVnode = oldCh[--oldEndIdx];
      newStartVnode = newCh[++newStartIdx];
    } else {
      idxInOld = -1;
      {
        for (i2 = oldStartIdx; i2 <= oldEndIdx; ++i2) {
          if (oldCh[i2] && oldCh[i2].$key$ !== null && oldCh[i2].$key$ === newStartVnode.$key$) {
            idxInOld = i2;
            break;
          }
        }
      }
      if (idxInOld >= 0) {
        elmToMove = oldCh[idxInOld];
        if (elmToMove.$tag$ !== newStartVnode.$tag$) {
          node = createElm(oldCh && oldCh[newStartIdx], newVNode2, idxInOld, parentElm);
        } else {
          patch(elmToMove, newStartVnode);
          oldCh[idxInOld] = void 0;
          node = elmToMove.$elm$;
        }
        newStartVnode = newCh[++newStartIdx];
      } else {
        node = createElm(oldCh && oldCh[newStartIdx], newVNode2, newStartIdx, parentElm);
        newStartVnode = newCh[++newStartIdx];
      }
      if (node) {
        {
          parentReferenceNode(oldStartVnode.$elm$).insertBefore(node, referenceNode(oldStartVnode.$elm$));
        }
      }
    }
  }
  if (oldStartIdx > oldEndIdx) {
    addVnodes(parentElm, newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].$elm$, newVNode2, newCh, newStartIdx, newEndIdx);
  } else if (newStartIdx > newEndIdx) {
    removeVnodes(oldCh, oldStartIdx, oldEndIdx);
  }
};
const isSameVnode = (leftVNode, rightVNode) => {
  if (leftVNode.$tag$ === rightVNode.$tag$) {
    if (leftVNode.$tag$ === "slot") {
      return leftVNode.$name$ === rightVNode.$name$;
    }
    {
      return leftVNode.$key$ === rightVNode.$key$;
    }
  }
  return false;
};
const referenceNode = (node) => {
  return node && node["s-ol"] || node;
};
const parentReferenceNode = (node) => (node["s-ol"] ? node["s-ol"] : node).parentNode;
const patch = (oldVNode, newVNode2) => {
  const elm = newVNode2.$elm$ = oldVNode.$elm$;
  const oldChildren = oldVNode.$children$;
  const newChildren = newVNode2.$children$;
  const tag = newVNode2.$tag$;
  const text = newVNode2.$text$;
  let defaultHolder;
  if (text === null) {
    {
      isSvgMode = tag === "svg" ? true : tag === "foreignObject" ? false : isSvgMode;
    }
    {
      if (tag === "slot")
        ;
      else {
        updateElement(oldVNode, newVNode2, isSvgMode);
      }
    }
    if (oldChildren !== null && newChildren !== null) {
      updateChildren(elm, oldChildren, newVNode2, newChildren);
    } else if (newChildren !== null) {
      if (oldVNode.$text$ !== null) {
        elm.textContent = "";
      }
      addVnodes(elm, null, newVNode2, newChildren, 0, newChildren.length - 1);
    } else if (oldChildren !== null) {
      removeVnodes(oldChildren, 0, oldChildren.length - 1);
    }
    if (isSvgMode && tag === "svg") {
      isSvgMode = false;
    }
  } else if (defaultHolder = elm["s-cr"]) {
    defaultHolder.parentNode.textContent = text;
  } else if (oldVNode.$text$ !== text) {
    elm.data = text;
  }
};
const updateFallbackSlotVisibility = (elm) => {
  const childNodes = elm.childNodes;
  let childNode;
  let i2;
  let ilen;
  let j2;
  let slotNameAttr;
  let nodeType;
  for (i2 = 0, ilen = childNodes.length; i2 < ilen; i2++) {
    childNode = childNodes[i2];
    if (childNode.nodeType === 1) {
      if (childNode["s-sr"]) {
        slotNameAttr = childNode["s-sn"];
        childNode.hidden = false;
        for (j2 = 0; j2 < ilen; j2++) {
          nodeType = childNodes[j2].nodeType;
          if (childNodes[j2]["s-hn"] !== childNode["s-hn"] || slotNameAttr !== "") {
            if (nodeType === 1 && slotNameAttr === childNodes[j2].getAttribute("slot")) {
              childNode.hidden = true;
              break;
            }
          } else {
            if (nodeType === 1 || nodeType === 3 && childNodes[j2].textContent.trim() !== "") {
              childNode.hidden = true;
              break;
            }
          }
        }
      }
      updateFallbackSlotVisibility(childNode);
    }
  }
};
const relocateNodes = [];
const relocateSlotContent = (elm) => {
  let childNode;
  let node;
  let hostContentNodes;
  let slotNameAttr;
  let relocateNodeData;
  let j2;
  let i2 = 0;
  const childNodes = elm.childNodes;
  const ilen = childNodes.length;
  for (; i2 < ilen; i2++) {
    childNode = childNodes[i2];
    if (childNode["s-sr"] && (node = childNode["s-cr"]) && node.parentNode) {
      hostContentNodes = node.parentNode.childNodes;
      slotNameAttr = childNode["s-sn"];
      for (j2 = hostContentNodes.length - 1; j2 >= 0; j2--) {
        node = hostContentNodes[j2];
        if (!node["s-cn"] && !node["s-nr"] && node["s-hn"] !== childNode["s-hn"]) {
          if (isNodeLocatedInSlot(node, slotNameAttr)) {
            relocateNodeData = relocateNodes.find((r2) => r2.$nodeToRelocate$ === node);
            checkSlotFallbackVisibility = true;
            node["s-sn"] = node["s-sn"] || slotNameAttr;
            if (relocateNodeData) {
              relocateNodeData.$slotRefNode$ = childNode;
            } else {
              relocateNodes.push({
                $slotRefNode$: childNode,
                $nodeToRelocate$: node
              });
            }
            if (node["s-sr"]) {
              relocateNodes.map((relocateNode) => {
                if (isNodeLocatedInSlot(relocateNode.$nodeToRelocate$, node["s-sn"])) {
                  relocateNodeData = relocateNodes.find((r2) => r2.$nodeToRelocate$ === node);
                  if (relocateNodeData && !relocateNode.$slotRefNode$) {
                    relocateNode.$slotRefNode$ = relocateNodeData.$slotRefNode$;
                  }
                }
              });
            }
          } else if (!relocateNodes.some((r2) => r2.$nodeToRelocate$ === node)) {
            relocateNodes.push({
              $nodeToRelocate$: node
            });
          }
        }
      }
    }
    if (childNode.nodeType === 1) {
      relocateSlotContent(childNode);
    }
  }
};
const isNodeLocatedInSlot = (nodeToRelocate, slotNameAttr) => {
  if (nodeToRelocate.nodeType === 1) {
    if (nodeToRelocate.getAttribute("slot") === null && slotNameAttr === "") {
      return true;
    }
    if (nodeToRelocate.getAttribute("slot") === slotNameAttr) {
      return true;
    }
    return false;
  }
  if (nodeToRelocate["s-sn"] === slotNameAttr) {
    return true;
  }
  return slotNameAttr === "";
};
const callNodeRefs = (vNode) => {
  {
    vNode.$attrs$ && vNode.$attrs$.ref && vNode.$attrs$.ref(null);
    vNode.$children$ && vNode.$children$.map(callNodeRefs);
  }
};
const renderVdom = (hostRef, renderFnResults) => {
  const hostElm = hostRef.$hostElement$;
  const cmpMeta = hostRef.$cmpMeta$;
  const oldVNode = hostRef.$vnode$ || newVNode(null, null);
  const rootVnode = isHost(renderFnResults) ? renderFnResults : h$K(null, null, renderFnResults);
  hostTagName = hostElm.tagName;
  if (cmpMeta.$attrsToReflect$) {
    rootVnode.$attrs$ = rootVnode.$attrs$ || {};
    cmpMeta.$attrsToReflect$.map(([propName, attribute]) => rootVnode.$attrs$[attribute] = hostElm[propName]);
  }
  rootVnode.$tag$ = null;
  rootVnode.$flags$ |= 4;
  hostRef.$vnode$ = rootVnode;
  rootVnode.$elm$ = oldVNode.$elm$ = hostElm.shadowRoot || hostElm;
  {
    scopeId = hostElm["s-sc"];
  }
  {
    contentRef = hostElm["s-cr"];
    useNativeShadowDom = supportsShadow && (cmpMeta.$flags$ & 1) !== 0;
    checkSlotFallbackVisibility = false;
  }
  patch(oldVNode, rootVnode);
  {
    plt.$flags$ |= 1;
    if (checkSlotRelocate) {
      relocateSlotContent(rootVnode.$elm$);
      let relocateData;
      let nodeToRelocate;
      let orgLocationNode;
      let parentNodeRef;
      let insertBeforeNode;
      let refNode;
      let i2 = 0;
      for (; i2 < relocateNodes.length; i2++) {
        relocateData = relocateNodes[i2];
        nodeToRelocate = relocateData.$nodeToRelocate$;
        if (!nodeToRelocate["s-ol"]) {
          orgLocationNode = doc.createTextNode("");
          orgLocationNode["s-nr"] = nodeToRelocate;
          nodeToRelocate.parentNode.insertBefore(nodeToRelocate["s-ol"] = orgLocationNode, nodeToRelocate);
        }
      }
      for (i2 = 0; i2 < relocateNodes.length; i2++) {
        relocateData = relocateNodes[i2];
        nodeToRelocate = relocateData.$nodeToRelocate$;
        if (relocateData.$slotRefNode$) {
          parentNodeRef = relocateData.$slotRefNode$.parentNode;
          insertBeforeNode = relocateData.$slotRefNode$.nextSibling;
          orgLocationNode = nodeToRelocate["s-ol"];
          while (orgLocationNode = orgLocationNode.previousSibling) {
            refNode = orgLocationNode["s-nr"];
            if (refNode && refNode["s-sn"] === nodeToRelocate["s-sn"] && parentNodeRef === refNode.parentNode) {
              refNode = refNode.nextSibling;
              if (!refNode || !refNode["s-nr"]) {
                insertBeforeNode = refNode;
                break;
              }
            }
          }
          if (!insertBeforeNode && parentNodeRef !== nodeToRelocate.parentNode || nodeToRelocate.nextSibling !== insertBeforeNode) {
            if (nodeToRelocate !== insertBeforeNode) {
              if (!nodeToRelocate["s-hn"] && nodeToRelocate["s-ol"]) {
                nodeToRelocate["s-hn"] = nodeToRelocate["s-ol"].parentNode.nodeName;
              }
              parentNodeRef.insertBefore(nodeToRelocate, insertBeforeNode);
            }
          }
        } else {
          if (nodeToRelocate.nodeType === 1) {
            nodeToRelocate.hidden = true;
          }
        }
      }
    }
    if (checkSlotFallbackVisibility) {
      updateFallbackSlotVisibility(rootVnode.$elm$);
    }
    plt.$flags$ &= ~1;
    relocateNodes.length = 0;
  }
};
const attachToAncestor = (hostRef, ancestorComponent) => {
};
const scheduleUpdate = (hostRef, isInitialLoad) => {
  if (BUILD.taskQueue && BUILD.updatable) {
    hostRef.$flags$ |= 16;
  }
  attachToAncestor(hostRef, hostRef.$ancestorComponent$);
  const dispatch = () => dispatchHooks(hostRef, isInitialLoad);
  return BUILD.taskQueue ? writeTask(dispatch) : dispatch();
};
const dispatchHooks = (hostRef, isInitialLoad) => {
  const elm = hostRef.$hostElement$;
  const endSchedule = createTime("scheduleUpdate", hostRef.$cmpMeta$.$tagName$);
  const instance = elm;
  let promise;
  if (isInitialLoad) {
    {
      promise = safeCall(instance, "componentWillLoad");
    }
  } else {
    {
      promise = safeCall(instance, "componentWillUpdate");
    }
  }
  {
    promise = then(promise, () => safeCall(instance, "componentWillRender"));
  }
  endSchedule();
  return then(promise, () => updateComponent(hostRef, instance, isInitialLoad));
};
const updateComponent = async (hostRef, instance, isInitialLoad) => {
  const elm = hostRef.$hostElement$;
  const endUpdate = createTime("update", hostRef.$cmpMeta$.$tagName$);
  elm["s-rc"];
  if (isInitialLoad) {
    attachStyles(hostRef);
  }
  const endRender = createTime("render", hostRef.$cmpMeta$.$tagName$);
  {
    callRender(hostRef, instance, elm);
  }
  endRender();
  endUpdate();
  {
    postUpdateComponent(hostRef);
  }
};
const callRender = (hostRef, instance, elm) => {
  const allRenderFn = false;
  const lazyLoad = false;
  const taskQueue = true;
  const updatable = true;
  try {
    renderingRef = instance;
    instance = allRenderFn ? instance.render() : instance.render && instance.render();
    if (updatable && taskQueue) {
      hostRef.$flags$ &= ~16;
    }
    if (updatable || lazyLoad) {
      hostRef.$flags$ |= 2;
    }
    if (BUILD.hasRenderFn || BUILD.reflect) {
      if (BUILD.vdomRender || BUILD.reflect) {
        if (BUILD.hydrateServerSide)
          ;
        else {
          renderVdom(hostRef, instance);
        }
      }
    }
  } catch (e2) {
    consoleError(e2, hostRef.$hostElement$);
  }
  renderingRef = null;
  return null;
};
const postUpdateComponent = (hostRef) => {
  const tagName = hostRef.$cmpMeta$.$tagName$;
  const elm = hostRef.$hostElement$;
  const endPostUpdate = createTime("postUpdate", tagName);
  const instance = elm;
  hostRef.$ancestorComponent$;
  {
    safeCall(instance, "componentDidRender");
  }
  if (!(hostRef.$flags$ & 64)) {
    hostRef.$flags$ |= 64;
    {
      safeCall(instance, "componentDidLoad");
    }
    endPostUpdate();
  } else {
    {
      safeCall(instance, "componentDidUpdate");
    }
    endPostUpdate();
  }
};
const forceUpdate = (ref2) => {
  if (BUILD.updatable) {
    const hostRef = getHostRef(ref2);
    const isConnected = hostRef.$hostElement$.isConnected;
    if (isConnected && (hostRef.$flags$ & (2 | 16)) === 2) {
      scheduleUpdate(hostRef, false);
    }
    return isConnected;
  }
  return false;
};
const safeCall = (instance, method, arg) => {
  if (instance && instance[method]) {
    try {
      return instance[method](arg);
    } catch (e2) {
      consoleError(e2);
    }
  }
  return void 0;
};
const then = (promise, thenFn) => {
  return promise && promise.then ? promise.then(thenFn) : thenFn();
};
const getValue = (ref2, propName) => getHostRef(ref2).$instanceValues$.get(propName);
const setValue = (ref2, propName, newVal, cmpMeta) => {
  const hostRef = getHostRef(ref2);
  const elm = ref2;
  const oldVal = hostRef.$instanceValues$.get(propName);
  const flags = hostRef.$flags$;
  const instance = elm;
  newVal = parsePropertyValue(newVal, cmpMeta.$members$[propName][0]);
  const areBothNaN = Number.isNaN(oldVal) && Number.isNaN(newVal);
  const didValueChange = newVal !== oldVal && !areBothNaN;
  if (didValueChange) {
    hostRef.$instanceValues$.set(propName, newVal);
    {
      if (cmpMeta.$watchers$ && flags & 128) {
        const watchMethods = cmpMeta.$watchers$[propName];
        if (watchMethods) {
          watchMethods.map((watchMethodName) => {
            try {
              instance[watchMethodName](newVal, oldVal, propName);
            } catch (e2) {
              consoleError(e2, elm);
            }
          });
        }
      }
      if ((flags & (2 | 16)) === 2) {
        if (instance.componentShouldUpdate) {
          if (instance.componentShouldUpdate(newVal, oldVal, propName) === false) {
            return;
          }
        }
        scheduleUpdate(hostRef, false);
      }
    }
  }
};
const proxyComponent = (Cstr, cmpMeta, flags) => {
  if (cmpMeta.$members$) {
    if (Cstr.watchers) {
      cmpMeta.$watchers$ = Cstr.watchers;
    }
    const members = Object.entries(cmpMeta.$members$);
    const prototype = Cstr.prototype;
    members.map(([memberName, [memberFlags]]) => {
      if (memberFlags & 31 || memberFlags & 32) {
        Object.defineProperty(prototype, memberName, {
          get() {
            return getValue(this, memberName);
          },
          set(newValue) {
            setValue(this, memberName, newValue, cmpMeta);
          },
          configurable: true,
          enumerable: true
        });
      }
    });
    {
      const attrNameToPropName = new Map();
      prototype.attributeChangedCallback = function(attrName, _oldValue, newValue) {
        plt.jmp(() => {
          const propName = attrNameToPropName.get(attrName);
          if (this.hasOwnProperty(propName)) {
            newValue = this[propName];
            delete this[propName];
          } else if (prototype.hasOwnProperty(propName) && typeof this[propName] === "number" && this[propName] == newValue) {
            return;
          }
          this[propName] = newValue === null && typeof this[propName] === "boolean" ? false : newValue;
        });
      };
      Cstr.observedAttributes = members.filter(([_2, m2]) => m2[0] & 15).map(([propName, m2]) => {
        const attrName = m2[1] || propName;
        attrNameToPropName.set(attrName, propName);
        if (m2[0] & 512) {
          cmpMeta.$attrsToReflect$.push([propName, attrName]);
        }
        return attrName;
      });
    }
  }
  return Cstr;
};
const initializeComponent = async (elm, hostRef, cmpMeta, hmrVersionId, Cstr) => {
  if ((hostRef.$flags$ & 32) === 0) {
    {
      Cstr = elm.constructor;
      hostRef.$flags$ |= 32;
      customElements.whenDefined(cmpMeta.$tagName$).then(() => hostRef.$flags$ |= 128);
    }
    if (Cstr.style) {
      let style = Cstr.style;
      if (typeof style !== "string") {
        style = style[hostRef.$modeName$ = computeMode(elm)];
      }
      const scopeId2 = getScopeId(cmpMeta, hostRef.$modeName$);
      if (!styles.has(scopeId2)) {
        const endRegisterStyles = createTime("registerStyles", cmpMeta.$tagName$);
        registerStyle(scopeId2, style, !!(cmpMeta.$flags$ & 1));
        endRegisterStyles();
      }
    }
  }
  hostRef.$ancestorComponent$;
  const schedule = () => scheduleUpdate(hostRef, true);
  {
    schedule();
  }
};
const fireConnectedCallback = (instance) => {
};
const connectedCallback = (elm) => {
  if ((plt.$flags$ & 1) === 0) {
    const hostRef = getHostRef(elm);
    const cmpMeta = hostRef.$cmpMeta$;
    const endConnected = createTime("connectedCallback", cmpMeta.$tagName$);
    if (!(hostRef.$flags$ & 1)) {
      hostRef.$flags$ |= 1;
      {
        if (cmpMeta.$flags$ & (4 | 8)) {
          setContentReference(elm);
        }
      }
      if (cmpMeta.$members$) {
        Object.entries(cmpMeta.$members$).map(([memberName, [memberFlags]]) => {
          if (memberFlags & 31 && elm.hasOwnProperty(memberName)) {
            const value = elm[memberName];
            delete elm[memberName];
            elm[memberName] = value;
          }
        });
      }
      {
        initializeComponent(elm, hostRef, cmpMeta);
      }
    } else {
      addHostEventListeners(elm, hostRef, cmpMeta.$listeners$);
      fireConnectedCallback(hostRef.$lazyInstance$);
    }
    endConnected();
  }
};
const setContentReference = (elm) => {
  const contentRefElm = elm["s-cr"] = doc.createComment("");
  contentRefElm["s-cn"] = true;
  elm.insertBefore(contentRefElm, elm.firstChild);
};
const disconnectedCallback = (elm) => {
  if ((plt.$flags$ & 1) === 0) {
    const hostRef = getHostRef(elm);
    {
      if (hostRef.$rmListeners$) {
        hostRef.$rmListeners$.map((rmListener) => rmListener());
        hostRef.$rmListeners$ = void 0;
      }
    }
  }
};
const proxyCustomElement = (Cstr, compactMeta) => {
  const cmpMeta = {
    $flags$: compactMeta[0],
    $tagName$: compactMeta[1]
  };
  if (BUILD.member) {
    cmpMeta.$members$ = compactMeta[2];
  }
  if (BUILD.hostListener) {
    cmpMeta.$listeners$ = compactMeta[3];
  }
  if (BUILD.watchCallback) {
    cmpMeta.$watchers$ = Cstr.$watchers$;
  }
  if (BUILD.reflect) {
    cmpMeta.$attrsToReflect$ = [];
  }
  if (BUILD.shadowDom && !supportsShadow && cmpMeta.$flags$ & 1) {
    cmpMeta.$flags$ |= 8;
  }
  const originalConnectedCallback = Cstr.prototype.connectedCallback;
  const originalDisconnectedCallback = Cstr.prototype.disconnectedCallback;
  Object.assign(Cstr.prototype, {
    __registerHost() {
      registerHost(this, cmpMeta);
    },
    connectedCallback() {
      connectedCallback(this);
      if (BUILD.connectedCallback && originalConnectedCallback) {
        originalConnectedCallback.call(this);
      }
    },
    disconnectedCallback() {
      disconnectedCallback(this);
      if (BUILD.disconnectedCallback && originalDisconnectedCallback) {
        originalDisconnectedCallback.call(this);
      }
    },
    __attachShadow() {
      if (supportsShadow) {
        if (BUILD.shadowDelegatesFocus) {
          this.attachShadow({
            mode: "open",
            delegatesFocus: !!(cmpMeta.$flags$ & 16)
          });
        } else {
          this.attachShadow({ mode: "open" });
        }
      } else {
        this.shadowRoot = this;
      }
    }
  });
  Cstr.is = cmpMeta.$tagName$;
  return proxyComponent(Cstr, cmpMeta);
};
const Fragment = (_2, children) => children;
const addHostEventListeners = (elm, hostRef, listeners, attachParentListeners) => {
  if (listeners) {
    listeners.map(([flags, name, method]) => {
      const target = getHostListenerTarget(elm, flags);
      const handler = hostListenerProxy(hostRef, method);
      const opts = hostListenerOpts(flags);
      plt.ael(target, name, handler, opts);
      (hostRef.$rmListeners$ = hostRef.$rmListeners$ || []).push(() => plt.rel(target, name, handler, opts));
    });
  }
};
const hostListenerProxy = (hostRef, methodName) => (ev) => {
  try {
    if (BUILD.lazyLoad)
      ;
    else {
      hostRef.$hostElement$[methodName](ev);
    }
  } catch (e2) {
    consoleError(e2);
  }
};
const getHostListenerTarget = (elm, flags) => {
  if (flags & 4)
    return doc;
  if (flags & 8)
    return win;
  if (flags & 16)
    return doc.body;
  return elm;
};
const hostListenerOpts = (flags) => supportsListenerOptions ? {
  passive: (flags & 1) !== 0,
  capture: (flags & 2) !== 0
} : (flags & 2) !== 0;
const hostRefs = /* @__PURE__ */ new WeakMap();
const getHostRef = (ref2) => hostRefs.get(ref2);
const registerHost = (elm, cmpMeta) => {
  const hostRef = {
    $flags$: 0,
    $hostElement$: elm,
    $cmpMeta$: cmpMeta,
    $instanceValues$: new Map()
  };
  if (BUILD.isDev) {
    hostRef.$renderCount$ = 0;
  }
  if (BUILD.method && BUILD.lazyLoad) {
    hostRef.$onInstancePromise$ = new Promise((r2) => hostRef.$onInstanceResolve$ = r2);
  }
  if (BUILD.asyncLoading) {
    hostRef.$onReadyPromise$ = new Promise((r2) => hostRef.$onReadyResolve$ = r2);
    elm["s-p"] = [];
    elm["s-rc"] = [];
  }
  addHostEventListeners(elm, hostRef, cmpMeta.$listeners$);
  return hostRefs.set(elm, hostRef);
};
const isMemberInElement = (elm, memberName) => memberName in elm;
const consoleError = (e2, el) => (0, console.error)(e2, el);
const STENCIL_DEV_MODE = BUILD.isTesting ? ["STENCIL:"] : [
  "%cstencil",
  "color: white;background:#4c47ff;font-weight: bold; font-size:10px; padding:2px 6px; border-radius: 5px"
];
const consoleDevError = (...m2) => console.error(...STENCIL_DEV_MODE, ...m2);
const consoleDevWarn = (...m2) => console.warn(...STENCIL_DEV_MODE, ...m2);
const styles = /* @__PURE__ */ new Map();
const modeResolutionChain = [];
const win = typeof window !== "undefined" ? window : {};
BUILD.cssVarShim ? win.CSS : null;
const doc = win.document || { head: {} };
const H$8 = win.HTMLElement || class {
};
const plt = {
  $flags$: 0,
  $resourcesUrl$: "",
  jmp: (h2) => h2(),
  raf: (h2) => requestAnimationFrame(h2),
  ael: (el, eventName, listener, opts) => el.addEventListener(eventName, listener, opts),
  rel: (el, eventName, listener, opts) => el.removeEventListener(eventName, listener, opts),
  ce: (eventName, opts) => new CustomEvent(eventName, opts)
};
const supportsShadow = BUILD.shadowDomShim && BUILD.shadowDom ? /* @__PURE__ */ (() => (doc.head.attachShadow + "").indexOf("[native") > -1)() : true;
const supportsListenerOptions = /* @__PURE__ */ (() => {
  let supportsListenerOptions2 = false;
  try {
    doc.addEventListener("e", null, Object.defineProperty({}, "passive", {
      get() {
        supportsListenerOptions2 = true;
      }
    }));
  } catch (e2) {
  }
  return supportsListenerOptions2;
})();
const promiseResolve = (v2) => Promise.resolve(v2);
const supportsConstructableStylesheets = BUILD.constructableCSS ? /* @__PURE__ */ (() => {
  try {
    new CSSStyleSheet();
    return typeof new CSSStyleSheet().replaceSync === "function";
  } catch (e2) {
  }
  return false;
})() : false;
const queueDomReads = [];
const queueDomWrites = [];
const queueTask = (queue, write) => (cb) => {
  queue.push(cb);
  if (!queuePending) {
    queuePending = true;
    if (write && plt.$flags$ & 4) {
      nextTick(flush);
    } else {
      plt.raf(flush);
    }
  }
};
const consume = (queue) => {
  for (let i2 = 0; i2 < queue.length; i2++) {
    try {
      queue[i2](performance.now());
    } catch (e2) {
      consoleError(e2);
    }
  }
  queue.length = 0;
};
const flush = () => {
  consume(queueDomReads);
  {
    consume(queueDomWrites);
    if (queuePending = queueDomReads.length > 0) {
      plt.raf(flush);
    }
  }
};
const nextTick = (cb) => promiseResolve().then(cb);
const writeTask = /* @__PURE__ */ queueTask(queueDomWrites, true);
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.
 * v1.0.0-beta.97
 */
const autoTheme = "calcite-theme-auto";
const darkTheme = "calcite-theme-dark";
function getElementDir(el) {
  const prop = "dir";
  const selector = `[${prop}]`;
  const closest = closestElementCrossShadowBoundary(el, selector);
  return closest ? closest.getAttribute(prop) : "ltr";
}
function getRootNode(el) {
  return el.getRootNode();
}
function getHost(root) {
  return root.host || null;
}
function queryElementRoots(element, { selector, id }) {
  function queryFrom(el) {
    if (!el) {
      return null;
    }
    if (el.assignedSlot) {
      el = el.assignedSlot;
    }
    const rootNode = getRootNode(el);
    const found = id ? "getElementById" in rootNode ? rootNode.getElementById(id) : null : selector ? rootNode.querySelector(selector) : null;
    const host = getHost(rootNode);
    return found ? found : host ? queryFrom(host) : null;
  }
  return queryFrom(element);
}
function closestElementCrossShadowBoundary(element, selector) {
  function closestFrom(el) {
    return el ? el.closest(selector) || closestFrom(getHost(getRootNode(el))) : null;
  }
  return closestFrom(element);
}
function isCalciteFocusable(el) {
  return typeof (el === null || el === void 0 ? void 0 : el.setFocus) === "function";
}
async function focusElement(el) {
  if (!el) {
    return;
  }
  return isCalciteFocusable(el) ? el.setFocus() : el.focus();
}
const defaultSlotSelector = ":not([slot])";
function getSlotted(element, slotName, options) {
  if (slotName && !Array.isArray(slotName) && typeof slotName !== "string") {
    options = slotName;
    slotName = null;
  }
  const slotSelector = slotName ? Array.isArray(slotName) ? slotName.map((name) => `[slot="${name}"]`).join(",") : `[slot="${slotName}"]` : defaultSlotSelector;
  if (options === null || options === void 0 ? void 0 : options.all) {
    return queryMultiple(element, slotSelector, options);
  }
  return querySingle(element, slotSelector, options);
}
function getDirectChildren(el, selector) {
  return el ? Array.from(el.children || []).filter((child) => child === null || child === void 0 ? void 0 : child.matches(selector)) : [];
}
function queryMultiple(element, slotSelector, options) {
  let matches = slotSelector === defaultSlotSelector ? getDirectChildren(element, defaultSlotSelector) : Array.from(element.querySelectorAll(slotSelector));
  matches = options && options.direct === false ? matches : matches.filter((el) => el.parentElement === element);
  matches = (options === null || options === void 0 ? void 0 : options.matches) ? matches.filter((el) => el === null || el === void 0 ? void 0 : el.matches(options.matches)) : matches;
  const selector = options === null || options === void 0 ? void 0 : options.selector;
  return selector ? matches.map((item) => Array.from(item.querySelectorAll(selector))).reduce((previousValue, currentValue) => [...previousValue, ...currentValue], []).filter((match) => !!match) : matches;
}
function querySingle(element, slotSelector, options) {
  let match = slotSelector === defaultSlotSelector ? getDirectChildren(element, defaultSlotSelector)[0] || null : element.querySelector(slotSelector);
  match = options && options.direct === false ? match : (match === null || match === void 0 ? void 0 : match.parentElement) === element ? match : null;
  match = (options === null || options === void 0 ? void 0 : options.matches) ? (match === null || match === void 0 ? void 0 : match.matches(options.matches)) ? match : null : match;
  const selector = options === null || options === void 0 ? void 0 : options.selector;
  return selector ? match === null || match === void 0 ? void 0 : match.querySelector(selector) : match;
}
function setRequestedIcon(iconObject, iconValue, matchedValue) {
  if (typeof iconValue === "string" && iconValue !== "") {
    return iconValue;
  } else if (iconValue === "") {
    return iconObject[matchedValue];
  }
}
function toAriaBoolean(value) {
  return Boolean(value).toString();
}
function isPrimaryPointerButton(event) {
  return !!(event.isPrimary && event.button === 0);
}
/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.
 * v1.0.0-beta.97
 */
function initThemeChangeEvent() {
  const { classList } = document.body;
  const prefersDark = window.matchMedia("(prefers-color-scheme: dark)").matches;
  const getTheme = () => classList.contains(darkTheme) || classList.contains(autoTheme) && prefersDark ? "dark" : "light";
  const emitThemeChange = (theme) => document.body.dispatchEvent(new CustomEvent("calciteThemeChange", { bubbles: true, detail: { theme } }));
  const themeChangeHandler = (newTheme) => {
    currentTheme !== newTheme && emitThemeChange(newTheme);
    currentTheme = newTheme;
  };
  let currentTheme = getTheme();
  emitThemeChange(currentTheme);
  window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change", (event) => themeChangeHandler(event.matches ? "dark" : "light"));
  new MutationObserver(() => themeChangeHandler(getTheme())).observe(document.body, {
    attributes: true,
    attributeFilter: ["class"]
  });
}
function appGlobalScript() {
  const isBrowser = typeof window !== "undefined" && typeof location !== "undefined" && typeof document !== "undefined" && window.location === location && window.document === document;
  if (isBrowser) {
    if (document.readyState === "interactive") {
      initThemeChangeEvent();
    } else {
      document.addEventListener("DOMContentLoaded", () => initThemeChangeEvent(), { once: true });
    }
  }
}
const globalScripts = appGlobalScript;
globalScripts();
let e$_;
function r$N() {
  setAssetPath(Q$9(a$1G(e$_)));
}
e$_ = "components/assets";
const t$10 = Symbol("widget"), r$M = [], n$1o = {}, o$Z = new WeakMap();
function i$1q(e2, t2) {
  let o2 = t2.children;
  if (o2 && o2.length)
    for (let r2 = 0; r2 < o2.length; ++r2)
      o2[r2] = i$1q(e2, o2[r2]);
  else
    o2 = r$M;
  const l2 = t2.vnodeSelector;
  if (a$1v(l2)) {
    const r2 = t2.properties || n$1o, i2 = r2.key || l2;
    return { vnodeSelector: "div", properties: { key: i2, afterCreate: d$R, afterUpdate: c$1A, afterRemoved: s$12, parentWidget: e2, widgetConstructor: l2, widgetProperties: __spreadProps(__spreadValues({}, r2), { key: i2, children: o2 }) }, children: void 0, text: void 0, domNode: null };
  }
  return t2;
}
function d$R(t2, r2, n2, { parentWidget: i2, widgetConstructor: d2, widgetProperties: c2 }) {
  var _a2;
  const a2 = new d2(c2);
  a2.container = t2, o$Z.set(t2, a2), (_a2 = a2.afterCreate) == null ? void 0 : _a2.call(a2, a2, t2), i2._internalHandles.add(n$2k(() => s$12(t2)));
}
function c$1A(e2, t2, r2, { widgetProperties: n2 }) {
  var _a2;
  const i2 = o$Z.get(e2);
  i2 && (i2.set(n2), (_a2 = i2.afterUpdate) == null ? void 0 : _a2.call(i2, i2, e2));
}
function s$12(e2) {
  const t2 = o$Z.get(e2);
  t2 && (t2.destroy(), o$Z.delete(e2));
}
function a$1v(e2) {
  return typeof e2 == "function" && e2[t$10];
}
const e$Z = new Set();
function n$1n(n2) {
  e$Z.add(n2), n2.finally(() => e$Z.delete(n2));
}
const U$g = "esri.widgets.Widget";
let $$8 = 0;
const x$q = { widgetIcon: "esri-icon-checkbox-unchecked" };
function z$h(e2, t2) {
  for (const r2 in t2)
    e2[r2] != null && (typeof e2[r2] == "object" && typeof t2[r2] == "object" ? z$h(e2[r2], t2 == null ? void 0 : t2[r2]) : e2[r2] = t2[r2]);
  return e2;
}
const A$c = s$13({ postProcessProjectionOptions(e2) {
  const t2 = e2.eventHandlerInterceptor, r2 = /capture$/i;
  e2.eventHandlerInterceptor = (e3, o2, s2, i2) => {
    const n2 = t2 == null ? void 0 : t2(e3, o2, s2, i2), a2 = r2.test(e3);
    if (!((e3 = e3.replace(r2, "")).toLowerCase() in s2) || a2) {
      const t3 = e3[2].toLowerCase() + e3.slice(3), r3 = (e4) => n2 == null ? void 0 : n2.call(s2, e4);
      s2.addEventListener(t3, r3, a2);
      const o3 = () => s2.removeEventListener(t3, r3, a2), c2 = i2.afterRemoved;
      i2.afterRemoved = (e4) => {
        c2 == null ? void 0 : c2(e4), o3();
      };
    }
    return n2;
  };
}, handleInterceptedEvent(e2, t2, r2, o2) {
  const { eventPhase: s2, type: i2 } = o2, n2 = s2 === Event.CAPTURING_PHASE;
  let a2 = `on${i2}${n2 ? "capture" : ""}`;
  const c2 = t2.properties;
  (c2 && a2 in c2 || (a2 = `on${i2[0].toUpperCase()}${i2.slice(1)}${n2 ? "Capture" : ""}`, c2 && a2 in c2)) && (t$14(), e2.scheduleRender(), c2[a2].call(c2.bind || r2, o2));
} });
let B$a = false, D$c = class extends m$1h(n$26.EventedAccessor) {
  constructor(e2, t2) {
    super(e2, t2), this._attached = false, this._internalHandles = new t$1N(), this._projector = A$c, this._readyForTrueRender = false, this.iconClass = x$q.widgetIcon, this.key = this, this._loadLocale = x$L(async () => {
      if (this._messageBundleProps && this._messageBundleProps.length) {
        const e3 = await E$v(this._messageBundleProps.map(async ({ bundlePath: e4, propertyName: t3 }) => {
          let r3 = await u$15(e4);
          this.uiStrings && Object.keys(this.uiStrings) && (r3 = z$h(y$1r(r3), this.uiStrings)), this[t3] = r3;
        }));
        for (const t3 of e3)
          t3.error && s$22.getLogger(this.declaredClass).error("widget-intl:locale-error", this.declaredClass, t3.error);
      }
      await this.loadLocale();
    }), r$N();
    const r2 = "esri-widget-uid-" + n$1q(), o2 = this.render.bind(this);
    this._trackingTarget = new s$1R(() => this.scheduleRender());
    const s2 = () => {
      var _a2;
      if (!this._readyForTrueRender || this.destroyed)
        return null;
      if (!this.visible)
        return { vnodeSelector: "div", properties: { key: r2, class: "", styles: { display: "none" } }, domNode: null, children: void 0, text: void 0 };
      const e3 = o2();
      let { properties: t3 } = e3;
      t3 || (e3.properties = t3 = {});
      let { key: s3, styles: i2 } = t3;
      s3 || (t3.key = r2), i2 || (t3.styles = i2 = {}), i2.display || (i2.display = "");
      let n2 = 0;
      return (_a2 = e3.children) == null ? void 0 : _a2.forEach((e4) => {
        if (a$1v(e4.vnodeSelector))
          return;
        let { properties: t4 } = e4;
        t4 || (e4.properties = t4 = {}), t4.key || (t4.key = `${this.id}--${n2++}`);
      }), i$1q(this, e3);
    };
    this.render = () => {
      var _a2;
      if (B$a)
        return s2();
      let e3 = (_a2 = e$12(this)) != null ? _a2 : null;
      if (e3)
        return e3;
      this._trackingTarget.clear(), B$a = true;
      try {
        e3 = f$1B(this._trackingTarget, s2);
      } catch (t3) {
        throw console.error(t3), t3;
      } finally {
        B$a = false;
      }
      return e3 && c$1E(this, e3), e3;
    }, this.addResolvingPromise(this._resourcesFetch = this.beforeFirstRender().then(() => {
      this._readyForTrueRender = true, this._postInitialize();
    })), n$1n(this._resourcesFetch);
  }
  normalizeCtorArgs(e2, t2) {
    const r2 = __spreadValues({}, e2);
    return t2 && (r2.container = t2), r2;
  }
  postInitialize() {
  }
  beforeFirstRender() {
    return Promise.all([this.loadDependencies(), this._loadLocale()]).then(() => {
    }).catch(b$T);
  }
  async loadDependencies() {
  }
  async loadLocale() {
  }
  destroy() {
    this.destroyed || (s$26(this._trackingTarget), s$26(this.viewModel), this._detach(this.container), this._set("container", null), this._internalHandles.destroy(), this._emitter.clear(), this.render = () => null, this._projector = null, o$12(this));
  }
  set container(e2) {
    this._get("container") || this._set("container", e2);
  }
  castContainer(e2) {
    return e$13(e2);
  }
  get domNode() {
    return this.container;
  }
  set domNode(e2) {
    this.container = e2;
  }
  get id() {
    return this._get("id") || this.get("container.id") || Date.now().toString(16) + "-widget-" + $$8++;
  }
  set id(e2) {
    e2 && this._set("id", e2);
  }
  get label() {
    return this.declaredClass.split(".").pop();
  }
  set label(e2) {
    this._overrideIfSome("label", e2);
  }
  get renderable() {
    return this._resourcesFetch;
  }
  get visible() {
    return this._get("visible");
  }
  set visible(e2) {
    this._set("visible", e2);
  }
  get test() {
    return { projector: this._projector };
  }
  render() {
    throw new Error("not implemented");
  }
  scheduleRender() {
    this.destroyed || (o$12(this), this._projector.scheduleRender());
  }
  classes(...e2) {
    return p$1Q.apply(this, e2);
  }
  renderNow() {
    o$12(this), this._projector.renderNow();
  }
  _postInitialize() {
    var _a2;
    if (this.destroyed)
      return;
    this.scheduleRender(), ((_a2 = this._delegatedEventNames) == null ? void 0 : _a2.length) && this._internalHandles.add(l$1f(() => this.viewModel, (e3, t2) => {
      t2 && this._internalHandles.remove("delegated-events"), e3 && e$1F(e3) && this._internalHandles.add(this._delegatedEventNames.map((t3) => r$1j(e3, t3, (e4) => {
        this.emit(t3, e4);
      })), "delegated-events");
    }, h$S)), this.postInitialize();
    const e2 = async () => {
      await this._loadLocale().catch(b$T), this.scheduleRender();
    };
    this._internalHandles.add([s$1A(e2), l$1f(() => this.uiStrings, e2), f$10(() => this.container, (e3) => {
      this.destroyed || this._attach(e3);
    }, { initial: true, once: true })]);
  }
  _attach(e2) {
    e2 && (this._projector.merge(e2, this.render), this._attached = true);
  }
  _detach(e2) {
    var _a2;
    this._attached && (this._projector.detach(this.render), this._attached = false), (_a2 = e2 == null ? void 0 : e2.parentNode) == null ? void 0 : _a2.removeChild(e2);
  }
};
D$c[t$10] = true, e$1W([y$1o()], D$c.prototype, "_readyForTrueRender", void 0), e$1W([y$1o({ value: null })], D$c.prototype, "container", null), e$1W([s$1N("container")], D$c.prototype, "castContainer", null), e$1W([y$1o()], D$c.prototype, "domNode", null), e$1W([y$1o()], D$c.prototype, "iconClass", void 0), e$1W([y$1o()], D$c.prototype, "id", null), e$1W([y$1o()], D$c.prototype, "label", null), e$1W([y$1o()], D$c.prototype, "renderable", null), e$1W([y$1o()], D$c.prototype, "uiStrings", void 0), e$1W([y$1o()], D$c.prototype, "viewModel", void 0), e$1W([y$1o({ value: true })], D$c.prototype, "visible", null), e$1W([y$1o()], D$c.prototype, "key", void 0), e$1W([y$1o()], D$c.prototype, "children", void 0), e$1W([y$1o()], D$c.prototype, "afterCreate", void 0), e$1W([y$1o()], D$c.prototype, "afterUpdate", void 0), e$1W([y$1o()], D$c.prototype, "afterRemoved", void 0), D$c = e$1W([n$2f(U$g)], D$c);
const M$d = D$c;
function n$1m(n2) {
  return 32 + n2.length;
}
function r$L(n2) {
  return 16;
}
function t$$(t2) {
  if (!t2)
    return 0;
  let e2 = f$S;
  for (const o2 in t2)
    if (t2.hasOwnProperty(o2)) {
      const u2 = t2[o2];
      switch (typeof u2) {
        case "string":
          e2 += n$1m(u2);
          break;
        case "number":
          e2 += r$L();
          break;
        case "boolean":
          e2 += 4;
      }
    }
  return e2;
}
function e$Y(n2) {
  if (!n2)
    return 0;
  if (Array.isArray(n2))
    return o$Y(n2);
  let r2 = f$S;
  for (const t2 in n2)
    n2.hasOwnProperty(t2) && (r2 += u$Y(n2[t2]));
  return r2;
}
function o$Y(n2) {
  const r2 = n2.length;
  if (r2 === 0 || typeof n2[0] == "number")
    return 32 + 8 * r2;
  let t2 = i$1p;
  for (let e2 = 0; e2 < r2; e2++)
    t2 += u$Y(n2[e2]);
  return t2;
}
function u$Y(t2) {
  switch (typeof t2) {
    case "object":
      return e$Y(t2);
    case "string":
      return n$1m(t2);
    case "number":
      return r$L();
    case "boolean":
      return 4;
    default:
      return 8;
  }
}
function c$1z(n2, r2) {
  return i$1p + n2.length * r2;
}
const f$S = 32, i$1p = 32;
var s$11;
!function(n2) {
  n2[n2.KILOBYTES = 1024] = "KILOBYTES", n2[n2.MEGABYTES = 1048576] = "MEGABYTES", n2[n2.GIGABYTES = 1073741824] = "GIGABYTES";
}(s$11 || (s$11 = {}));
const U$f = ["B", "kB", "MB", "GB", "TB"];
function v$y(n2, i2) {
  let o2 = i2 === 0 ? 0 : Math.floor(Math.log(i2) / Math.log(s$11.KILOBYTES));
  o2 = a$21(o2, 0, U$f.length - 1);
  const u2 = m$1A(i2 / s$11.KILOBYTES ** o2, { maximumFractionDigits: 2 });
  return n$2m(n2.units.bytes[U$f[o2]], { fileSize: u2 });
}
function n$1l(n2) {
  const { exifInfo: e2, exifName: a2, tagName: u2 } = n2;
  if (!e2 || !a2 || !u2)
    return null;
  const f2 = e2.find((n3) => n3.name === a2);
  return f2 ? t$_({ tagName: u2, tags: f2.tags }) : null;
}
function t$_(n2) {
  const { tagName: t2, tags: e2 } = n2;
  if (!e2 || !t2)
    return null;
  const a2 = e2.find((n3) => n3.name === t2);
  return a2 && a2.value || null;
}
var s$10;
const p$1N = { 1: { id: 1, rotation: 0, mirrored: false }, 2: { id: 2, rotation: 0, mirrored: true }, 3: { id: 3, rotation: 180, mirrored: false }, 4: { id: 4, rotation: 180, mirrored: true }, 5: { id: 5, rotation: -90, mirrored: true }, 6: { id: 6, rotation: 90, mirrored: false }, 7: { id: 7, rotation: 90, mirrored: true }, 8: { id: 8, rotation: -90, mirrored: false } };
let l$16 = s$10 = class extends l$1_ {
  constructor(t2) {
    super(t2), this.contentType = null, this.exifInfo = null, this.id = null, this.globalId = null, this.keywords = null, this.name = null, this.parentGlobalId = null, this.parentObjectId = null, this.size = null, this.url = null;
  }
  get orientationInfo() {
    const { exifInfo: t2 } = this, o2 = n$1l({ exifName: "Exif IFD0", tagName: "Orientation", exifInfo: t2 });
    return p$1N[o2] || null;
  }
  clone() {
    return new s$10({ contentType: this.contentType, exifInfo: this.exifInfo, id: this.id, globalId: this.globalId, keywords: this.keywords, name: this.name, parentGlobalId: this.parentGlobalId, parentObjectId: this.parentObjectId, size: this.size, url: this.url });
  }
};
e$1W([y$1o({ type: String })], l$16.prototype, "contentType", void 0), e$1W([y$1o()], l$16.prototype, "exifInfo", void 0), e$1W([y$1o({ readOnly: true })], l$16.prototype, "orientationInfo", null), e$1W([y$1o({ type: T$r })], l$16.prototype, "id", void 0), e$1W([y$1o({ type: String })], l$16.prototype, "globalId", void 0), e$1W([y$1o({ type: String })], l$16.prototype, "keywords", void 0), e$1W([y$1o({ type: String })], l$16.prototype, "name", void 0), e$1W([y$1o({ json: { read: false } })], l$16.prototype, "parentGlobalId", void 0), e$1W([y$1o({ json: { read: false } })], l$16.prototype, "parentObjectId", void 0), e$1W([y$1o({ type: T$r })], l$16.prototype, "size", void 0), e$1W([y$1o({ json: { read: false } })], l$16.prototype, "url", void 0), l$16 = s$10 = e$1W([n$2f("esri.layers.support.AttachmentInfo")], l$16);
const a$1u = l$16;
var a$1t;
let p$1M = a$1t = class extends l$1_ {
  constructor(t2) {
    super(t2), this.attachmentTypes = null, this.attachmentsWhere = null, this.cacheHint = void 0, this.keywords = null, this.globalIds = null, this.name = null, this.num = null, this.objectIds = null, this.returnMetadata = false, this.size = null, this.start = null, this.where = null;
  }
  writeStart(t2, e2) {
    e2.resultOffset = this.start, e2.resultRecordCount = this.num || 10;
  }
  clone() {
    return new a$1t(y$1r({ attachmentTypes: this.attachmentTypes, attachmentsWhere: this.attachmentsWhere, cacheHint: this.cacheHint, keywords: this.keywords, where: this.where, globalIds: this.globalIds, name: this.name, num: this.num, objectIds: this.objectIds, returnMetadata: this.returnMetadata, size: this.size, start: this.start }));
  }
};
e$1W([y$1o({ type: [String], json: { write: true } })], p$1M.prototype, "attachmentTypes", void 0), e$1W([y$1o({ type: String, json: { read: { source: "attachmentsDefinitionExpression" }, write: { target: "attachmentsDefinitionExpression" } } })], p$1M.prototype, "attachmentsWhere", void 0), e$1W([y$1o({ type: Boolean, json: { write: true } })], p$1M.prototype, "cacheHint", void 0), e$1W([y$1o({ type: [String], json: { write: true } })], p$1M.prototype, "keywords", void 0), e$1W([y$1o({ type: [Number], json: { write: true } })], p$1M.prototype, "globalIds", void 0), e$1W([y$1o({ json: { write: true } })], p$1M.prototype, "name", void 0), e$1W([y$1o({ type: Number, json: { read: { source: "resultRecordCount" } } })], p$1M.prototype, "num", void 0), e$1W([y$1o({ type: [Number], json: { write: true } })], p$1M.prototype, "objectIds", void 0), e$1W([y$1o({ type: Boolean, json: { default: false, write: true } })], p$1M.prototype, "returnMetadata", void 0), e$1W([y$1o({ type: [Number], json: { write: true } })], p$1M.prototype, "size", void 0), e$1W([y$1o({ type: Number, json: { read: { source: "resultOffset" } } })], p$1M.prototype, "start", void 0), e$1W([r$1h("start"), r$1h("num")], p$1M.prototype, "writeStart", null), e$1W([y$1o({ type: String, json: { read: { source: "definitionExpression" }, write: { target: "definitionExpression" } } })], p$1M.prototype, "where", void 0), p$1M = a$1t = e$1W([n$2f("esri.rest.support.AttachmentQuery")], p$1M), p$1M.from = b$U(p$1M);
const c$1y = p$1M;
const d$Q = "esri.widgets.Feature.support.featureUtils", p$1L = s$22.getLogger(d$Q), m$Y = /href=(""|'')/gi, y$N = /(\{([^\{\r\n]+)\})/g, g$B = /\'/g, h$J = /^\s*expression\//i, I$j = /(\n)/gi, b$x = /[\u00A0-\u9999<>\&]/gim, F$c = /href\s*=\s*(?:\"([^\"]+)\"|\'([^\']+)\')/gi, w$t = /^(?:mailto:|tel:)/, N$7 = "relationships/", E$g = S$B("short-date-short-time");
function T$f(e2) {
  if (!t$1W(e2))
    return e2.get("sourceLayer") || e2.get("layer");
}
async function j$p(e2, t2) {
  return typeof e2 == "function" ? e2.call(null, t2) : e2;
}
function x$p(e2 = "") {
  if (e2)
    return !w$t.test(e2.trim().toLowerCase());
}
function C$g(e2) {
  return !!e2 && h$J.test(e2);
}
function M$c(e2, t2) {
  if (!C$g(t2) || !e2)
    return null;
  const r2 = t2.replace(h$J, "").toLowerCase();
  let n2;
  return e2.some((e3) => e3.name.toLowerCase() === r2 && (n2 = e3, true)), n2;
}
function q$7(e2, t2) {
  const r2 = M$c(t2, e2 == null ? void 0 : e2.fieldName);
  return r2 ? r2.title || null : e2 ? e2.label || e2.fieldName : null;
}
function R$f(e2, t2) {
  const r2 = t2.get(e2.toLowerCase());
  return `{${r2 && r2.fieldName || e2}}`;
}
function v$x(e2) {
  return e2.replace(m$Y, "");
}
function D$b(e2, t2) {
  const r2 = A$b(t2, e2);
  return r2 ? r2.name : e2;
}
function L$f(e2, t2) {
  return e2 && e2.map((e3) => D$b(e3, t2));
}
function A$b(e2, t2) {
  return e2 && typeof e2.getField == "function" ? e2.getField(t2) : null;
}
function U$e(e2) {
  return `${e2}`.trim();
}
function $$7({ attributes: e2, globalAttributes: t2, layer: r2, text: n2, expressionAttributes: i2, fieldInfoMap: o2 }) {
  return n2 ? S$n({ formattedAttributes: t2, template: _$l(n2, __spreadValues(__spreadValues(__spreadValues({}, t2), i2), e2), r2), fieldInfoMap: o2 }) : "";
}
function S$n({ formattedAttributes: e2, template: t2, fieldInfoMap: r2 }) {
  return U$e(v$x(n$2m(n$2m(t2, (e3) => R$f(e3, r2)), e2)));
}
function G$6(e2, t2, r2 = false) {
  const n2 = t2[e2];
  if (typeof n2 == "string") {
    const i2 = "%27", o2 = (r2 ? encodeURIComponent(n2) : n2).replace(g$B, i2);
    t2[e2] = o2;
  }
}
function k$c(e2, t2 = false) {
  const r2 = __spreadValues({}, e2);
  return Object.keys(r2).forEach((e3) => G$6(e3, r2, t2)), r2;
}
function O$b(e2, t2, r2) {
  const i2 = (t2 = U$e(t2)) && t2[0] !== "{";
  return n$2m(e2, k$c(r2, i2));
}
function P$e(e2, t2) {
  return e2.replace(y$N, (e3, r2, n2) => {
    const i2 = A$b(t2, n2);
    return i2 ? `{${i2.name}}` : r2;
  });
}
function _$l(e2, t2, r2) {
  const n2 = P$e(e2, r2);
  return n2 ? n2.replace(F$c, (e3, r3, n3) => O$b(e3, r3 || n3, t2)) : n2;
}
function z$g(e2, t2) {
  if (typeof e2 == "string" && t2 && t2.dateFormat == null && (t2.places != null || t2.digitSeparator != null)) {
    const t3 = Number(e2);
    if (!isNaN(t3))
      return t3;
  }
  return e2;
}
function H$7(e2) {
  return (e2 == null ? void 0 : e2.type) === "feature";
}
function Q$4(e2) {
  return !!(e2 == null ? void 0 : e2.layer);
}
function Z$2(e2) {
  return (e2 == null ? void 0 : e2.type) === "map-image";
}
function V$7(e2, t2) {
  var _a2;
  const r2 = t2.fieldInfos, n2 = t2.fieldName, i2 = (_a2 = B$9(r2, n2)) == null ? void 0 : _a2.clone(), o2 = t2.preventPlacesFormatting, s2 = t2.layer, c2 = A$b(s2, n2);
  if (i2 && (c2 == null ? void 0 : c2.type) === "date") {
    const e3 = i2.format || new u$1x();
    e3.dateFormat = e3.dateFormat || "short-date-short-time", e3.dateTimeFormatOptions = !Q$4(s2) && H$7(s2) && s2.datesInUnknownTimezone || Q$4(s2) && Z$2(s2.layer) && s2.layer.datesInUnknownTimezone ? { timeZone: "UTC" } : null, i2.format = e3;
  }
  const d2 = i2 && i2.format;
  return typeof e2 == "string" && he$2(n2) && d2 ? d2.formatRasterPixelValue(e2) : typeof (e2 = z$g(e2, d2)) == "string" || e2 == null || d2 == null ? te(e2) : o2 ? m$1A(e2, __spreadProps(__spreadValues({}, u$1y(d2)), { minimumFractionDigits: 0, maximumFractionDigits: 20 })) : d2.format(e2);
}
function B$9(e2, t2) {
  if (!e2 || !e2.length || !t2)
    return;
  const r2 = t2.toLowerCase();
  let n2;
  return e2.some((e3) => !(!e3.fieldName || e3.fieldName.toLowerCase() !== r2) && (n2 = e3, true)), n2;
}
function J$5({ fieldName: e2, graphic: t2, layer: r2 }) {
  if (le(e2))
    return null;
  if (!r2 || typeof r2.getFeatureType != "function")
    return null;
  const { typeIdField: n2 } = r2;
  if (!n2 || e2 !== n2)
    return null;
  const i2 = r2.getFeatureType(t2);
  return i2 ? i2.name : null;
}
function K$5({ fieldName: e2, value: t2, graphic: r2, layer: n2 }) {
  if (le(e2))
    return null;
  if (!n2 || typeof n2.getFieldDomain != "function")
    return null;
  const i2 = n2.getFieldDomain(e2, { feature: r2 });
  return i2 && i2.type === "coded-value" ? i2.getName(t2) : null;
}
function W$5(e2, t2) {
  const { creatorField: r2, creationDateField: n2, editorField: o2, editDateField: a2 } = e2;
  if (!t2)
    return;
  const l2 = t2[a2];
  if (typeof l2 == "number") {
    const e3 = t2[o2];
    return { type: "edit", date: L$p(l2, E$g), user: e3 };
  }
  const u2 = t2[n2];
  if (typeof u2 == "number") {
    const e3 = t2[r2];
    return { type: "create", date: L$p(u2, E$g), user: e3 };
  }
  return null;
}
function X$2(e2, t2) {
  const r2 = new Map();
  return e2 && e2.forEach((e3) => {
    const n2 = D$b(e3.fieldName, t2);
    e3.fieldName = n2, r2.set(n2.toLowerCase(), e3);
  }), r2;
}
function Y$2(e2) {
  const t2 = [];
  if (!e2)
    return t2;
  const { fieldInfos: r2, content: n2 } = e2;
  return r2 && t2.push(...r2), n2 && Array.isArray(n2) ? (n2.forEach((e3) => {
    if (e3.type === "fields") {
      const r3 = e3 && e3.fieldInfos;
      r3 && t2.push(...r3);
    }
  }), t2) : t2;
}
function ee(e2) {
  return e2.replace(b$x, (e3) => `&#${e3.charCodeAt(0)};`);
}
function te(e2) {
  return typeof e2 == "string" ? e2.replace(I$j, '<br class="esri-text-new-line" />') : e2;
}
function re(e2) {
  const { value: t2, fieldName: r2, fieldInfos: n2, fieldInfoMap: o2, layer: a2, graphic: l2 } = e2;
  if (t2 == null)
    return "";
  const u2 = K$5({ fieldName: r2, value: t2, graphic: l2, layer: a2 });
  if (u2)
    return u2;
  const s2 = J$5({ fieldName: r2, graphic: l2, layer: a2 });
  if (s2)
    return s2;
  if (o2.get(r2.toLowerCase()))
    return V$7(t2, { fieldInfos: n2 || Array.from(o2.values()), fieldName: r2, layer: a2 });
  const f2 = a2 && a2.fieldsIndex;
  return f2 && f2.isDateField(r2) ? L$p(t2, E$g) : te(t2);
}
function ne({ fieldInfos: e2, attributes: t2, layer: r2, graphic: n2, fieldInfoMap: i2, relatedInfos: o2 }) {
  const a2 = {};
  return o2 == null ? void 0 : o2.forEach((t3) => fe$1({ attributes: a2, relatedInfo: t3, fieldInfoMap: i2, fieldInfos: e2, layer: r2 })), Object.keys(t2).forEach((o3) => {
    const l2 = t2[o3];
    a2[o3] = re({ fieldName: o3, fieldInfos: e2, fieldInfoMap: i2, layer: r2, value: l2, graphic: n2 });
  }), a2;
}
async function ie(e2, t2) {
  var _a2, _b2;
  const { layer: r2, graphic: n2, outFields: i2, objectIds: o2, returnGeometry: a2, spatialReference: l2 } = e2, u2 = o2[0];
  if (typeof u2 != "number" && typeof u2 != "string") {
    const e3 = "Could not query required fields for the specified feature. The feature's ID is invalid.", t3 = { layer: r2, graphic: n2, objectId: u2, requiredFields: i2 };
    return p$1L.warn(e3, t3), null;
  }
  if (!((_b2 = (_a2 = r2.capabilities) == null ? void 0 : _a2.operations) == null ? void 0 : _b2.supportsQuery)) {
    const e3 = "The specified layer cannot be queried. The following fields will not be available.", t3 = { layer: r2, graphic: n2, requiredFields: i2, returnGeometry: a2 };
    return p$1L.warn(e3, t3), null;
  }
  const s2 = r2.createQuery();
  s2.objectIds = o2, s2.outFields = (i2 == null ? void 0 : i2.length) ? i2 : [r2.objectIdField], s2.returnGeometry = !!a2, s2.returnZ = !!a2, s2.returnM = !!a2, s2.outSpatialReference = l2;
  return (await r2.queryFeatures(s2, t2)).features[0];
}
async function oe(e2) {
  var _a2;
  if (!((_a2 = e2.expressionInfos) == null ? void 0 : _a2.length))
    return false;
  const t2 = await i$26(), { arcadeUtils: { hasGeometryFunctions: r2 } } = t2;
  return r2(e2);
}
async function ae({ graphic: e2, popupTemplate: t2, layer: r2, spatialReference: n2 }, i2) {
  if (!r2 || !t2)
    return;
  if (typeof r2.load == "function" && await r2.load(i2), !e2.attributes)
    return;
  const o2 = e2.attributes[r2.objectIdField];
  if (o2 == null)
    return;
  const a2 = [o2], l2 = await t2.getRequiredFields(r2.fieldsIndex), u2 = xe$1(l2, e2), f2 = u2 ? [] : l2, c2 = t2.returnGeometry || await oe(t2);
  if (u2 && !c2)
    return;
  const d2 = await ie({ layer: r2, graphic: e2, outFields: f2, objectIds: a2, returnGeometry: c2, spatialReference: n2 }, i2);
  d2 && (d2.geometry && (e2.geometry = d2.geometry), d2.attributes && (e2.attributes = __spreadValues(__spreadValues({}, e2.attributes), d2.attributes)));
}
function le(e2 = "") {
  return !!e2 && e2.includes(N$7);
}
function ue$1(e2) {
  return e2 ? `${N$7}${e2.layerId}/${e2.fieldName}` : "";
}
function se({ attributes: e2, graphic: t2, relatedInfo: r2, fieldInfos: n2, fieldInfoMap: i2, layer: o2 }) {
  e2 && t2 && r2 && Object.keys(t2.attributes).forEach((a2) => {
    const l2 = ue$1({ layerId: r2.relation.id.toString(), fieldName: a2 }), u2 = t2.attributes[a2];
    e2[l2] = re({ fieldName: l2, fieldInfos: n2, fieldInfoMap: i2, layer: o2, value: u2, graphic: t2 });
  });
}
function fe$1({ attributes: e2, relatedInfo: t2, fieldInfoMap: r2, fieldInfos: n2, layer: i2 }) {
  e2 && t2 && (t2.relatedFeatures && t2.relatedFeatures && t2.relatedFeatures.forEach((o2) => se({ attributes: e2, graphic: o2, relatedInfo: t2, fieldInfoMap: r2, fieldInfos: n2, layer: i2 })), t2.relatedStatsFeatures && t2.relatedStatsFeatures && t2.relatedStatsFeatures.forEach((o2) => se({ attributes: e2, graphic: o2, relatedInfo: t2, fieldInfoMap: r2, fieldInfos: n2, layer: i2 })));
}
const ce$1 = (e2) => {
  if (!e2)
    return false;
  const t2 = e2.toUpperCase();
  return t2.includes("CURRENT_TIMESTAMP") || t2.includes("CURRENT_DATE") || t2.includes("CURRENT_TIME");
}, de$1 = ({ layer: e2, method: t2, query: n2, definitionExpression: i2 }) => {
  var _a2, _b2;
  if (!((_b2 = (_a2 = e2.capabilities) == null ? void 0 : _a2.query) == null ? void 0 : _b2.supportsCacheHint) || t2 === "attachments")
    return;
  const o2 = r$1t(n2.where) && n2.where, a2 = r$1t(n2.geometry) && n2.geometry;
  ce$1(i2) || ce$1(o2) || (a2 == null ? void 0 : a2.type) === "extent" || n2.resultType === "tile" || (n2.cacheHint = true);
}, pe$1 = ({ query: e2, layer: t2, method: r2 }) => {
  de$1({ layer: t2, method: r2, query: e2, definitionExpression: `${t2.definitionExpression} ${t2.serviceDefinitionExpression}` });
}, me$1 = ({ queryPayload: e2, layer: t2, method: r2 }) => {
  de$1({ layer: t2, method: r2, query: e2, definitionExpression: `${t2.definitionExpression} ${t2.serviceDefinitionExpression}` });
};
function ye$1(e2, t2, r2) {
  return e2 && t2 && r2 ? ge$1(e2.allLayers, t2, r2) || ge$1(e2.allTables, t2, r2) : null;
}
function ge$1(e2, t2, r2) {
  return e2.find((e3) => e3 !== t2 && e3.type === "feature" && e3.url === t2.url && e3.layerId === r2.relatedTableId);
}
const f$R = { editing: false, operations: { add: true, update: true, delete: true } }, u$X = j$F.ofType(a$1u);
let y$M = class extends m$1L {
  constructor(t2) {
    super(t2), this._getAttachmentsPromise = null, this._attachmentLayer = null, this.abilities = __spreadValues({}, f$R), this.activeAttachmentInfo = null, this.activeFileInfo = null, this.attachmentInfos = new u$X(), this.fileInfos = new j$F(), this.graphic = null, this.mode = "view", this.filesEnabled = false, this.addHandles(l$1f(() => this.graphic, () => this._graphicChanged(), h$S));
  }
  destroy() {
    this._attachmentLayer = null, this.graphic = null;
  }
  castAbilities(t2) {
    return __spreadValues(__spreadValues({}, f$R), t2);
  }
  get state() {
    return this._getAttachmentsPromise ? "loading" : this.graphic ? "ready" : "disabled";
  }
  get supportsResizeAttachments() {
    const { graphic: t2 } = this;
    if (!t2)
      return false;
    const e2 = t2.layer || t2.sourceLayer;
    return (e2 == null ? void 0 : e2.loaded) && "capabilities" in e2 && "operations" in e2.capabilities && "supportsResizeAttachments" in e2.capabilities.operations && e2.capabilities.operations.supportsResizeAttachments || false;
  }
  async getAttachments() {
    const { _attachmentLayer: t2, attachmentInfos: e2 } = this;
    if (!t2 || typeof t2.queryAttachments != "function")
      throw new s$1Z("invalid-layer", "getAttachments(): A valid layer is required.");
    const i2 = this._getObjectId(), a2 = new c$1y({ objectIds: [i2], returnMetadata: true }), s2 = [], r2 = t2.queryAttachments(a2).then((t3) => t3[i2] || s2).catch(() => s2);
    this._getAttachmentsPromise = r2, this.notifyChange("state");
    const o2 = await r2;
    return e2.removeAll(), o2.length && e2.addMany(o2), this._getAttachmentsPromise = null, this.notifyChange("state"), o2;
  }
  async addAttachment(t2, e2 = this.graphic) {
    const { _attachmentLayer: i2, attachmentInfos: a2, abilities: s2 } = this;
    if (!e2)
      throw new s$1Z("invalid-graphic", "addAttachment(): A valid graphic is required.", { graphic: e2 });
    if (!t2)
      throw new s$1Z("invalid-attachment", "addAttachment(): An attachment is required.", { attachment: t2 });
    if (!s2.operations.add)
      throw new s$1Z("invalid-abilities", "addAttachment(): add abilities are required.");
    if (!i2 || typeof i2.addAttachment != "function")
      throw new s$1Z("invalid-layer", "addAttachment(): A valid layer is required.");
    const r2 = i2.addAttachment(e2, t2).then((t3) => this._queryAttachment(t3.objectId, e2)), o2 = await r2;
    return a2.add(o2), o2;
  }
  async deleteAttachment(t2) {
    const { _attachmentLayer: e2, attachmentInfos: i2, graphic: a2, abilities: s2 } = this;
    if (!t2)
      throw new s$1Z("invalid-attachment-info", "deleteAttachment(): An attachmentInfo is required.", { attachmentInfo: t2 });
    if (!s2.operations.delete)
      throw new s$1Z("invalid-abilities", "deleteAttachment(): delete abilities are required.");
    if (!e2 || typeof e2.deleteAttachments != "function")
      throw new s$1Z("invalid-layer", "deleteAttachment(): A valid layer is required.");
    const r2 = e2.deleteAttachments(a2, [t2.id]).then(() => t2), o2 = await r2;
    return i2.remove(o2), o2;
  }
  async updateAttachment(t2, e2 = this.activeAttachmentInfo) {
    const { _attachmentLayer: i2, attachmentInfos: a2, graphic: s2, abilities: r2 } = this;
    if (!t2)
      throw new s$1Z("invalid-attachment", "updateAttachment(): An attachment is required.", { attachment: t2 });
    if (!e2)
      throw new s$1Z("invalid-attachment-info", "updateAttachment(): An attachmentInfo is required.", { attachmentInfo: e2 });
    if (!r2.operations.update)
      throw new s$1Z("invalid-abilities", "updateAttachment(): Update abilities are required.");
    const o2 = a2.findIndex((t3) => t3 === e2);
    if (!i2 || typeof i2.updateAttachment != "function")
      throw new s$1Z("invalid-layer", "updateAttachment(): A valid layer is required.");
    const c2 = i2.updateAttachment(s2, e2.id, t2).then((t3) => this._queryAttachment(t3.objectId)), h2 = await c2;
    return a2.splice(o2, 1, h2), h2;
  }
  async commitFiles() {
    return await Promise.all(this.fileInfos.items.map((t2) => this.addAttachment(t2.form))), this.fileInfos.removeAll(), this.getAttachments();
  }
  addFile(t2, e2) {
    if (!t2 || !e2)
      return null;
    const i2 = { file: t2, form: e2 };
    return this.fileInfos.add(i2), i2;
  }
  updateFile(t2, e2, i2 = this.activeFileInfo) {
    if (!t2 || !e2 || !i2)
      return null;
    const a2 = this.fileInfos.findIndex((t3) => i2 === t3);
    return a2 > -1 && this.fileInfos.splice(a2, 1, { file: t2, form: e2 }), this.fileInfos.items[a2];
  }
  deleteFile(t2) {
    var _a2;
    const e2 = this.fileInfos.find((e3) => e3.file === t2);
    return (_a2 = this.fileInfos.remove(e2)) != null ? _a2 : null;
  }
  async _queryAttachment(t2, e2) {
    if (!t2)
      throw new s$1Z("invalid-attachment-id", "Could not query attachment.");
    const { _attachmentLayer: i2 } = this, a2 = this._getObjectId(e2), s2 = new c$1y({ objectIds: [a2], attachmentsWhere: `AttachmentId=${t2}`, returnMetadata: true });
    return i2.queryAttachments(s2).then((t3) => t3[a2][0]);
  }
  _getObjectId(t2 = this.graphic) {
    var _a2;
    return (_a2 = t2 == null ? void 0 : t2.getObjectId()) != null ? _a2 : null;
  }
  _graphicChanged() {
    this.graphic && (this._setAttachmentLayer(), this.getAttachments().catch(() => {
    }));
  }
  _setAttachmentLayer() {
    const { graphic: t2 } = this, e2 = T$f(t2);
    this._attachmentLayer = e2 ? e2.type === "scene" && r$1t(e2.associatedLayer) ? e2.associatedLayer : e2 : null;
  }
};
e$1W([y$1o()], y$M.prototype, "abilities", void 0), e$1W([s$1N("abilities")], y$M.prototype, "castAbilities", null), e$1W([y$1o()], y$M.prototype, "activeAttachmentInfo", void 0), e$1W([y$1o()], y$M.prototype, "activeFileInfo", void 0), e$1W([y$1o({ readOnly: true, type: u$X })], y$M.prototype, "attachmentInfos", void 0), e$1W([y$1o()], y$M.prototype, "fileInfos", void 0), e$1W([y$1o({ type: g$J })], y$M.prototype, "graphic", void 0), e$1W([y$1o()], y$M.prototype, "mode", void 0), e$1W([y$1o({ readOnly: true })], y$M.prototype, "state", null), e$1W([y$1o()], y$M.prototype, "filesEnabled", void 0), e$1W([y$1o({ readOnly: true })], y$M.prototype, "supportsResizeAttachments", null), y$M = e$1W([n$2f("esri.widgets.Attachments.AttachmentsViewModel")], y$M);
const A$a = y$M;
function e$X(i2) {
  const e2 = i2.toLowerCase();
  return e2 === "image/bmp" || e2 === "image/emf" || e2 === "image/exif" || e2 === "image/gif" || e2 === "image/x-icon" || e2 === "image/jpeg" || e2 === "image/png" || e2 === "image/tiff" || e2 === "image/x-wmf";
}
function p$1K(e2) {
  const p2 = a$1G("esri/themes/base/images/files/");
  return e2 ? e2 === "text/plain" ? `${p2}text-32.svg` : e2 === "application/pdf" ? `${p2}pdf-32.svg` : e2 === "text/csv" ? `${p2}csv-32.svg` : e2 === "application/gpx+xml" ? `${p2}gpx-32.svg` : e2 === "application/x-dwf" ? `${p2}cad-32.svg` : e2 === "application/postscript" || e2 === "application/json" || e2 === "text/xml" || e2 === "model/vrml" ? `${p2}code-32.svg` : e2 === "application/x-zip-compressed" || e2 === "application/x-7z-compressed" || e2 === "application/x-gzip" || e2 === "application/x-tar" || e2 === "application/x-gtar" || e2 === "application/x-bzip2" || e2 === "application/gzip" || e2 === "application/x-compress" || e2 === "application/x-apple-diskimage" || e2 === "application/x-rar-compressed" || e2 === "application/zip" ? `${p2}zip-32.svg` : e2.includes("image/") ? `${p2}image-32.svg` : e2.includes("audio/") ? `${p2}sound-32.svg` : e2.includes("video/") ? `${p2}video-32.svg` : e2.includes("msexcel") || e2.includes("ms-excel") || e2.includes("spreadsheetml") ? `${p2}excel-32.svg` : e2.includes("msword") || e2.includes("ms-word") || e2.includes("wordprocessingml") ? `${p2}word-32.svg` : e2.includes("powerpoint") || e2.includes("presentationml") ? `${p2}report-32.svg` : `${p2}generic-32.svg` : `${p2}generic-32.svg`;
}
function e$W(e2) {
  return (s2, r2) => {
    s2.hasOwnProperty("_messageBundleProps") || (s2._messageBundleProps = s2._messageBundleProps ? s2._messageBundleProps.slice() : []);
    s2._messageBundleProps.push({ bundlePath: e2, propertyName: r2 });
  };
}
var e$V = function(r2) {
  return { vnodeSelector: "", properties: void 0, children: void 0, text: r2.toString(), domNode: null };
}, o$X = function(r2, t2) {
  for (var n2 = 0, i2 = r2.length; n2 < i2; n2++) {
    var d2 = r2[n2];
    Array.isArray(d2) ? o$X(d2, t2) : d2 != null && d2 !== false && (d2.hasOwnProperty("vnodeSelector") || (d2 = e$V(d2)), t2.push(d2));
  }
}, t$Z = function(r2, e2) {
  for (var t2 = [], n2 = 2; n2 < arguments.length; n2++)
    t2[n2 - 2] = arguments[n2];
  if (t2.length === 1 && typeof t2[0] == "string")
    return { vnodeSelector: r2, properties: e2 || void 0, children: void 0, text: t2[0], domNode: null };
  var i2 = [];
  return o$X(t2, i2), { vnodeSelector: r2, properties: e2 || void 0, children: i2, text: void 0, domNode: null };
};
function n$1k(e2, o2, ...n2) {
  return typeof e2 != "function" || a$1v(e2) ? t$Z(e2, o2, ...n2) : e2(o2, ...n2);
}
const v$w = { addButton: true, addSubmitButton: true, cancelAddButton: true, cancelUpdateButton: true, deleteButton: true, errorMessage: true, progressBar: true, updateButton: true }, y$L = { base: "esri-attachments", loaderContainer: "esri-attachments__loader-container", loader: "esri-attachments__loader", fadeIn: "esri-attachments--fade-in", container: "esri-attachments__container", containerList: "esri-attachments__container--list", containerPreview: "esri-attachments__container--preview", actions: "esri-attachments__actions", deleteButton: "esri-attachments__delete-button", addAttachmentButton: "esri-attachments__add-attachment-button", errorMessage: "esri-attachments__error-message", items: "esri-attachments__items", item: "esri-attachments__item", itemButton: "esri-attachments__item-button", itemMask: "esri-attachments__item-mask", itemMaskIcon: "esri-attachments__item-mask--icon", itemImage: "esri-attachments__image", itemImageResizable: "esri-attachments__image--resizable", itemLabel: "esri-attachments__label", itemFilename: "esri-attachments__filename", itemChevronIcon: "esri-attachments__item-chevron-icon", itemLink: "esri-attachments__item-link", itemLinkOverlay: "esri-attachments__item-link-overlay", itemLinkOverlayIcon: "esri-attachments__item-link-overlay-icon", itemEditIcon: "esri-attachments__item-edit-icon", itemAddIcon: "esri-attachments__item-add-icon", itemAddButton: "esri-attachments__item-add-button", formNode: "esri-attachments__form-node", fileFieldset: "esri-attachments__file-fieldset", fileLabel: "esri-attachments__file-label", fileName: "esri-attachments__file-name", fileInput: "esri-attachments__file-input", metadata: "esri-attachments__metadata", metadataFieldset: "esri-attachments__metadata-fieldset", progressBar: "esri-attachments__progress-bar", esriWidget: "esri-widget", esriButton: "esri-button", buttonDisabled: "esri-button--disabled", esriButtonSecondary: "esri-button--secondary", esriButtonTertiary: "esri-button--tertiary", esriButtonThird: "esri-button--third", esriButtonSmall: "esri-button--small", esriButtonHalf: "esri-button--half", empty: "esri-widget__content--empty", iconExternalLink: "esri-icon-link-external", iconEdit: "esri-icon-edit", iconRight: "esri-icon-right", iconLeft: "esri-icon-left", iconPlus: "esri-icon-plus" }, A$9 = window.CSS;
let w$s = class extends M$d {
  constructor(e2, t2) {
    super(e2, t2), this.displayType = "auto", this.messages = null, this.messagesUnits = null, this.selectedFile = null, this.submitting = false, this.viewModel = new A$a(), this.visibleElements = __spreadValues({}, v$w), this._supportsImageOrientation = A$9 && A$9.supports && A$9.supports("image-orientation", "from-image"), this._addAttachmentForm = null, this._updateAttachmentForm = null;
  }
  initialize() {
    this.addHandles([a$1I(() => {
      var _a2;
      return (_a2 = this.viewModel) == null ? void 0 : _a2.attachmentInfos;
    }, "change", () => this.scheduleRender()), a$1I(() => {
      var _a2;
      return (_a2 = this.viewModel) == null ? void 0 : _a2.fileInfos;
    }, "change", () => this.scheduleRender()), l$1f(() => {
      var _a2;
      return (_a2 = this.viewModel) == null ? void 0 : _a2.mode;
    }, () => this._modeChanged(), h$S)]);
  }
  loadDependencies() {
    return Promise.all([import("./calcite-icon.js")]);
  }
  get abilities() {
    return this.viewModel.abilities;
  }
  set abilities(e2) {
    this.viewModel.abilities = e2;
  }
  get effectiveDisplayType() {
    const { displayType: e2 } = this;
    return e2 && e2 !== "auto" ? e2 : this.viewModel.supportsResizeAttachments ? "preview" : "list";
  }
  get graphic() {
    return this.viewModel.graphic;
  }
  set graphic(e2) {
    this.viewModel.graphic = e2;
  }
  get label() {
    var _a2, _b2;
    return (_b2 = (_a2 = this.messages) == null ? void 0 : _a2.widgetLabel) != null ? _b2 : "";
  }
  set label(e2) {
    this._overrideIfSome("label", e2);
  }
  castVisibleElements(e2) {
    return __spreadValues(__spreadValues({}, v$w), e2);
  }
  addAttachment() {
    const { _addAttachmentForm: e2, viewModel: s2 } = this;
    return this._set("submitting", true), this._set("error", null), s2.addAttachment(e2).then((e3) => (this._set("submitting", false), this._set("error", null), s2.mode = "view", e3)).catch((e3) => {
      throw this._set("submitting", false), this._set("error", new s$1Z("attachments:add-attachment", this.messages.addErrorMessage, e3)), e3;
    });
  }
  deleteAttachment(e2) {
    const { viewModel: s2 } = this;
    return this._set("submitting", true), this._set("error", null), s2.deleteAttachment(e2).then((e3) => (this._set("submitting", false), this._set("error", null), s2.mode = "view", e3)).catch((e3) => {
      throw this._set("submitting", false), this._set("error", new s$1Z("attachments:delete-attachment", this.messages.deleteErrorMessage, e3)), e3;
    });
  }
  updateAttachment() {
    const { viewModel: e2 } = this, { _updateAttachmentForm: s2 } = this;
    return this._set("submitting", true), this._set("error", null), e2.updateAttachment(s2).then((t2) => (this._set("submitting", false), this._set("error", null), e2.mode = "view", t2)).catch((e3) => {
      throw this._set("submitting", false), this._set("error", new s$1Z("attachments:update-attachment", this.messages.updateErrorMessage, e3)), e3;
    });
  }
  addFile() {
    const e2 = this.viewModel.addFile(this.selectedFile, this._addAttachmentForm);
    return this.viewModel.mode = "view", e2;
  }
  updateFile() {
    const { viewModel: e2 } = this, t2 = e2.updateFile(this.selectedFile, this._updateAttachmentForm, e2.activeFileInfo);
    return e2.mode = "view", t2;
  }
  deleteFile(e2) {
    const t2 = this.viewModel.deleteFile(e2 || this.viewModel.activeFileInfo.file);
    return this.viewModel.mode = "view", t2;
  }
  render() {
    const { submitting: e2, viewModel: t2 } = this, { state: s2 } = t2;
    return n$1k("div", { class: this.classes(y$L.base, y$L.esriWidget) }, e2 ? this.renderProgressBar() : null, s2 === "loading" ? this.renderLoading() : this.renderAttachments(), this.renderErrorMessage());
  }
  renderErrorMessage() {
    const { error: e2, visibleElements: t2 } = this;
    return e2 && t2.errorMessage ? n$1k("div", { key: "error-message", class: y$L.errorMessage }, e2.message) : null;
  }
  renderAttachments() {
    const { activeFileInfo: e2, mode: t2, activeAttachmentInfo: s2 } = this.viewModel;
    return t2 === "add" ? this.renderAddForm() : t2 === "edit" ? this.renderDetailsForm(s2 || e2) : this.renderAttachmentContainer();
  }
  renderLoading() {
    return n$1k("div", { class: y$L.loaderContainer, key: "loader" }, n$1k("div", { class: y$L.loader }));
  }
  renderProgressBar() {
    return this.visibleElements.progressBar ? n$1k("div", { class: y$L.progressBar, key: "progress-bar" }) : null;
  }
  renderAddForm() {
    const { submitting: e2, selectedFile: t2 } = this, s2 = e2 || !t2, i2 = this.visibleElements.cancelAddButton ? n$1k("button", { type: "button", bind: this, disabled: e2, onclick: this._cancelForm, class: this.classes(y$L.esriButton, y$L.esriButtonTertiary, y$L.esriButtonSmall, y$L.esriButtonHalf, e2 && y$L.buttonDisabled) }, this.messages.cancel) : null, a2 = this.visibleElements.addSubmitButton ? n$1k("button", { type: "submit", disabled: s2, class: this.classes(y$L.esriButton, y$L.esriButtonSecondary, y$L.esriButtonSmall, y$L.esriButtonHalf, { [y$L.buttonDisabled]: s2 }) }, this.messages.add) : null, n2 = t2 ? n$1k("span", { key: "file-name", class: y$L.fileName }, t2.name) : null, r2 = n$1k("form", { bind: this, afterCreate: v$A, afterRemoved: h$M, "data-node-ref": "_addAttachmentForm", onsubmit: this._submitAddAttachment }, n$1k("fieldset", { class: y$L.fileFieldset }, n2, n$1k("label", { class: this.classes(y$L.fileLabel, y$L.esriButton, y$L.esriButtonSecondary) }, t2 ? this.messages.changeFile : this.messages.selectFile, n$1k("input", { class: y$L.fileInput, type: "file", name: "attachment", bind: this, onchange: this._handleFileInputChange }))), a2, i2);
    return n$1k("div", { key: "add-form-container", class: y$L.formNode }, r2);
  }
  renderDetailsForm(e2) {
    const { visibleElements: t2, viewModel: i2, selectedFile: a2, submitting: n2 } = this, { abilities: l2 } = i2, o2 = n2 || !a2;
    let d2, c2, m2, h2;
    a2 ? (d2 = a2.type, c2 = a2.name, m2 = a2.size) : "file" in e2 ? (d2 = e2.file.type, c2 = e2.file.name, m2 = e2.file.size) : (d2 = e2.contentType, c2 = e2.name, m2 = e2.size, h2 = e2.url);
    const u2 = l2.editing && l2.operations.delete && t2.deleteButton ? n$1k("button", { key: "delete-button", type: "button", disabled: n2, bind: this, onclick: (t3) => this._submitDeleteAttachment(t3, e2), class: this.classes(y$L.esriButton, y$L.esriButtonSmall, y$L.esriButtonTertiary, y$L.deleteButton, { [y$L.buttonDisabled]: n2 }) }, this.messages.delete) : void 0, g2 = l2.editing && l2.operations.update && t2.updateButton ? n$1k("button", { disabled: o2, key: "update-button", type: "submit", class: this.classes(y$L.esriButton, y$L.esriButtonSmall, y$L.esriButtonThird, { [y$L.buttonDisabled]: o2 }) }, this.messages.update) : void 0, _2 = this.visibleElements.cancelUpdateButton ? n$1k("button", { disabled: n2, key: "cancel-button", type: "button", bind: this, onclick: this._cancelForm, class: this.classes(y$L.esriButton, y$L.esriButtonSmall, y$L.esriButtonTertiary, y$L.esriButtonThird, { [y$L.buttonDisabled]: n2 }) }, this.messages.cancel) : void 0, v2 = l2.editing && l2.operations.update ? n$1k("fieldset", { key: "file", class: y$L.fileFieldset }, n$1k("span", { key: "file-name", class: y$L.fileName }, c2), n$1k("label", { class: this.classes(y$L.fileLabel, y$L.esriButton, y$L.esriButtonSecondary) }, this.messages.changeFile, n$1k("input", { class: y$L.fileInput, type: "file", name: "attachment", bind: this, onchange: this._handleFileInputChange }))) : void 0, A2 = n$1k("fieldset", { key: "size", class: y$L.metadataFieldset }, n$1k("label", null, v$y(this.messagesUnits, m2))), w2 = n$1k("fieldset", { key: "content-type", class: y$L.metadataFieldset }, n$1k("label", null, d2)), F2 = r$1t(h2) ? n$1k("a", { class: y$L.itemLink, href: h2, rel: "noreferrer", target: "_blank" }, this.renderImageMask(e2, 400), n$1k("div", { class: y$L.itemLinkOverlay }, n$1k("span", { class: y$L.itemLinkOverlayIcon }, n$1k("calcite-icon", { icon: "launch" })))) : this.renderImageMask(e2, 400), k2 = n$1k("form", { bind: this, afterCreate: v$A, afterRemoved: h$M, "data-node-ref": "_updateAttachmentForm", onsubmit: (t3) => this._submitUpdateAttachment(t3, e2) }, n$1k("div", { class: y$L.metadata }, A2, w2), v2, n$1k("div", { class: y$L.actions }, u2, _2, g2));
    return n$1k("div", { key: "edit-form-container", class: y$L.formNode }, F2, k2);
  }
  renderImageMask(e2, t2) {
    return "file" in e2 ? this.renderGenericImageMask(e2.file.name, e2.file.type) : this.renderImageMaskForAttachment(e2, t2);
  }
  renderGenericImageMask(e2, t2) {
    const { supportsResizeAttachments: s2 } = this.viewModel, i2 = p$1K(t2), a2 = { [y$L.itemImageResizable]: s2 };
    return n$1k("div", { class: this.classes(y$L.itemMaskIcon, y$L.itemMask) }, n$1k("img", { title: e2, alt: e2, src: i2, class: this.classes(a2, y$L.itemImage) }));
  }
  renderImageMaskForAttachment(e2, t2) {
    const { supportsResizeAttachments: s2 } = this.viewModel, { contentType: i2, name: a2, url: n2 } = e2;
    if (!s2 || !e$X(i2))
      return this.renderGenericImageMask(a2, i2);
    const r2 = this._getCSSTransform(e2), l2 = r2 ? { transform: r2, "image-orientation": "none" } : {}, o2 = `${n2}${n2.includes("?") ? "&" : "?"}w=${t2}`, d2 = { [y$L.itemImageResizable]: s2 };
    return n$1k("div", { class: this.classes(y$L.itemMask) }, n$1k("img", { styles: l2, alt: a2, title: a2, src: o2, class: this.classes(d2, y$L.itemImage) }));
  }
  renderFile(e2) {
    const { file: t2 } = e2;
    return n$1k("li", { class: y$L.item, key: t2 }, n$1k("button", { key: "details-button", bind: this, class: y$L.itemButton, title: this.messages.attachmentDetails, "aria-label": this.messages.attachmentDetails, onclick: () => this._startEditFile(e2), type: "button" }, this.renderImageMask(e2), n$1k("label", { class: y$L.itemLabel }, n$1k("span", { class: y$L.itemFilename }, t2.name || this.messages.noTitle), n$1k("span", { "aria-hidden": "true", class: this.classes(y$L.itemChevronIcon, f$U(this.container) ? y$L.iconLeft : y$L.iconRight) }))));
  }
  renderAttachmentInfo({ attachmentInfo: e2, displayType: t2 }) {
    const { viewModel: s2, effectiveDisplayType: i2 } = this, { abilities: a2, supportsResizeAttachments: n2 } = s2, { contentType: r2, name: l2, url: o2 } = e2, d2 = this.renderImageMask(e2, t2 === "list" ? 48 : 400), c2 = a2.editing ? n$1k("span", { "aria-hidden": "true", class: this.classes(y$L.itemChevronIcon, f$U(this.container) ? y$L.iconLeft : y$L.iconRight) }) : null, m2 = [d2, i2 === "preview" && n2 && e$X(r2) ? null : n$1k("label", { class: y$L.itemLabel }, n$1k("span", { class: y$L.itemFilename }, l2 || this.messages.noTitle), c2)], h2 = a2.editing ? n$1k("button", { key: "details-button", bind: this, class: y$L.itemButton, title: this.messages.attachmentDetails, "aria-label": this.messages.attachmentDetails, "data-attachment-info-id": e2.id, onclick: () => this._startEditAttachment(e2), type: "button" }, m2) : n$1k("a", { key: "details-link", class: y$L.itemButton, href: o2, target: "_blank" }, m2);
    return n$1k("li", { class: y$L.item, key: e2 }, h2);
  }
  renderAttachmentContainer() {
    const { effectiveDisplayType: e2, viewModel: t2, visibleElements: s2 } = this, { attachmentInfos: i2, abilities: a2, fileInfos: n2 } = t2, r2 = !!(i2 == null ? void 0 : i2.length), l2 = !!(n2 == null ? void 0 : n2.length), o2 = { [y$L.containerList]: e2 !== "preview", [y$L.containerPreview]: e2 === "preview" }, d2 = a2.editing && a2.operations.add && s2.addButton ? n$1k("button", { bind: this, onclick: () => this._startAddAttachment(), class: this.classes(y$L.esriButton, y$L.esriButtonTertiary, y$L.addAttachmentButton), type: "button" }, n$1k("span", { "aria-hidden": "true", class: this.classes(y$L.itemAddIcon, y$L.iconPlus) }), this.messages.add) : void 0, c2 = r2 ? n$1k("ul", { key: "attachments-list", class: y$L.items }, i2.toArray().map((t3) => this.renderAttachmentInfo({ attachmentInfo: t3, displayType: e2 }))) : void 0, m2 = l2 ? n$1k("ul", { key: "file-list", class: y$L.items }, n2.toArray().map((e3) => this.renderFile(e3))) : void 0, h2 = l2 || r2 ? void 0 : n$1k("div", { class: y$L.empty }, this.messages.noAttachments);
    return n$1k("div", { key: "attachments-container", class: this.classes(y$L.container, o2) }, c2, m2, h2, d2);
  }
  _modeChanged() {
    this._set("error", null), this._set("selectedFile", null);
  }
  _handleFileInputChange(e2) {
    const t2 = e2.target, s2 = t2 && t2.files && t2.files.item(0);
    this._set("selectedFile", s2);
  }
  _submitDeleteAttachment(e2, t2) {
    e2.preventDefault(), "file" in t2 ? this.deleteFile(t2.file) : this.deleteAttachment(t2);
  }
  _submitAddAttachment(e2) {
    e2.preventDefault(), this.viewModel.filesEnabled ? this.addFile() : this.addAttachment();
  }
  _submitUpdateAttachment(e2, t2) {
    e2.preventDefault(), "file" in t2 ? this.updateFile() : this.updateAttachment();
  }
  _startEditAttachment(e2) {
    const { viewModel: t2 } = this;
    t2.activeFileInfo = null, t2.activeAttachmentInfo = e2, t2.mode = "edit";
  }
  _startEditFile(e2) {
    const { viewModel: t2 } = this;
    t2.activeAttachmentInfo = null, t2.activeFileInfo = e2, t2.mode = "edit";
  }
  _startAddAttachment() {
    this.viewModel.mode = "add";
  }
  _cancelForm(e2) {
    e2.preventDefault(), this.viewModel.mode = "view";
  }
  _getCSSTransform(e2) {
    const { orientationInfo: t2 } = e2;
    return !this._supportsImageOrientation && t2 ? [t2.rotation ? `rotate(${t2.rotation}deg)` : "", t2.mirrored ? "scaleX(-1)" : ""].join(" ") : "";
  }
};
e$1W([y$1o()], w$s.prototype, "abilities", null), e$1W([y$1o()], w$s.prototype, "displayType", void 0), e$1W([y$1o({ readOnly: true })], w$s.prototype, "effectiveDisplayType", null), e$1W([y$1o()], w$s.prototype, "graphic", null), e$1W([y$1o()], w$s.prototype, "label", null), e$1W([y$1o(), e$W("esri/widgets/Attachments/t9n/Attachments")], w$s.prototype, "messages", void 0), e$1W([y$1o(), e$W("esri/core/t9n/Units")], w$s.prototype, "messagesUnits", void 0), e$1W([y$1o({ readOnly: true })], w$s.prototype, "selectedFile", void 0), e$1W([y$1o({ readOnly: true })], w$s.prototype, "submitting", void 0), e$1W([y$1o({ readOnly: true })], w$s.prototype, "error", void 0), e$1W([y$1o({ type: A$a })], w$s.prototype, "viewModel", void 0), e$1W([y$1o()], w$s.prototype, "visibleElements", void 0), e$1W([s$1N("visibleElements")], w$s.prototype, "castVisibleElements", null), w$s = e$1W([n$2f("esri.widgets.Attachments")], w$s);
const F$b = w$s;
let o$W = class extends A$a {
  constructor(t2) {
    super(t2), this.description = null, this.title = null;
  }
};
e$1W([y$1o()], o$W.prototype, "description", void 0), e$1W([y$1o()], o$W.prototype, "title", void 0), o$W = e$1W([n$2f("esri.widgets.Feature.FeatureAttachments.FeatureAttachmentsViewModel")], o$W);
const c$1x = o$W;
const i$1o = { heading: "esri-widget__heading" };
function n$1j(e2, n2) {
  const l2 = o$V(e2.level), s2 = `h${l2}`;
  return delete e2.level, n$1k(s2, __spreadProps(__spreadValues({}, e2), { class: p$1Q(i$1o.heading, e2.class), role: "heading", "aria-level": String(l2) }), n2);
}
function o$V(t2) {
  return a$21(Math.ceil(t2), 1, 6);
}
const p$1J = { base: "esri-feature-element-info", title: "esri-feature-element-info__title", description: "esri-feature-element-info__description" };
let n$1i = class extends M$d {
  constructor(e2, t2) {
    super(e2, t2), this.description = null, this.headingLevel = 2, this.title = null;
  }
  render() {
    return n$1k("div", { class: p$1J.base }, this.renderTitle(), this.renderDescription());
  }
  renderTitle() {
    const { title: e2 } = this;
    return e2 ? n$1k(n$1j, { level: this.headingLevel, class: p$1J.title }, e2) : null;
  }
  renderDescription() {
    const { description: e2 } = this;
    return e2 ? n$1k("div", { key: "description", class: p$1J.description }, e2) : null;
  }
};
e$1W([y$1o()], n$1i.prototype, "description", void 0), e$1W([y$1o()], n$1i.prototype, "headingLevel", void 0), e$1W([y$1o()], n$1i.prototype, "title", void 0), n$1i = e$1W([n$2f("esri.widgets.Feature.support.FeatureElementInfo")], n$1i);
const l$15 = n$1i;
const d$P = { base: "esri-feature-attachments" };
let c$1w = class extends M$d {
  constructor(e2, t2) {
    super(e2, t2), this._featureElementInfo = null, this.attachmentsWidget = new F$b(), this.headingLevel = 2, this.viewModel = new c$1x();
  }
  initialize() {
    this._featureElementInfo = new l$15(), this.addHandles([l$1f(() => {
      var _a2, _b2;
      return [(_a2 = this.viewModel) == null ? void 0 : _a2.description, (_b2 = this.viewModel) == null ? void 0 : _b2.title, this.headingLevel];
    }, () => this._setupFeatureElementInfo(), h$S), l$1f(() => {
      var _a2;
      return (_a2 = this.viewModel) == null ? void 0 : _a2.graphic;
    }, (e2) => this.attachmentsWidget.graphic = e2, h$S)]);
  }
  destroy() {
    this.attachmentsWidget.destroy(), this._featureElementInfo.destroy();
  }
  get description() {
    return this.viewModel.description;
  }
  set description(e2) {
    this.viewModel.description = e2;
  }
  get displayType() {
    return this.attachmentsWidget.displayType;
  }
  set displayType(e2) {
    this.attachmentsWidget.displayType = e2;
  }
  get graphic() {
    return this.viewModel.graphic;
  }
  set graphic(e2) {
    this.viewModel.graphic = e2;
  }
  get title() {
    return this.viewModel.title;
  }
  set title(e2) {
    this.viewModel.title = e2;
  }
  render() {
    var _a2;
    const { attachmentsWidget: e2 } = this;
    return n$1k("div", { class: d$P.base }, (_a2 = this._featureElementInfo) == null ? void 0 : _a2.render(), e2 == null ? void 0 : e2.render());
  }
  _setupFeatureElementInfo() {
    const { description: e2, title: t2, headingLevel: i2 } = this;
    this._featureElementInfo.set({ description: e2, title: t2, headingLevel: i2 });
  }
};
e$1W([y$1o({ readOnly: true })], c$1w.prototype, "attachmentsWidget", void 0), e$1W([y$1o()], c$1w.prototype, "description", null), e$1W([y$1o()], c$1w.prototype, "displayType", null), e$1W([y$1o()], c$1w.prototype, "graphic", null), e$1W([y$1o()], c$1w.prototype, "headingLevel", void 0), e$1W([y$1o()], c$1w.prototype, "title", null), e$1W([y$1o({ type: c$1x })], c$1w.prototype, "viewModel", void 0), c$1w = e$1W([n$2f("esri.widgets.Feature.FeatureAttachments")], c$1w);
const h$I = c$1w;
const a$1s = (s2) => {
  let a2 = class extends s2 {
    destroy() {
      var _a2, _b2;
      this.destroyed || ((_a2 = this._get("handles")) == null ? void 0 : _a2.destroy(), (_b2 = this._get("updatingHandles")) == null ? void 0 : _b2.destroy());
    }
    get handles() {
      return this._get("handles") || new t$1N();
    }
    get updatingHandles() {
      return this._get("updatingHandles") || new c$1F();
    }
  };
  return e$1W([y$1o({ readOnly: true })], a2.prototype, "handles", null), e$1W([y$1o({ readOnly: true })], a2.prototype, "updatingHandles", null), a2 = e$1W([n$2f("esri.core.HandleOwner")], a2), a2;
};
let d$O = class extends a$1s(m$1L) {
};
d$O = e$1W([n$2f("esri.core.HandleOwner")], d$O);
let p$1I = class extends a$1s(m$1L) {
  constructor(t2) {
    super(t2), this._loadingPromise = null, this.created = null, this.creator = null, this.destroyer = null, this.graphic = null, this.handles.add(l$1f(() => this.creator, (t3) => {
      this._destroyContent(), this._createContent(t3);
    }, h$S));
  }
  destroy() {
    this._destroyContent();
  }
  get state() {
    return this._loadingPromise ? "loading" : "ready";
  }
  _destroyContent() {
    const { created: t2, graphic: e2, destroyer: r2 } = this;
    t2 && (j$p(r2, { graphic: e2 }).catch(() => null), this._set("created", null));
  }
  async _createContent(t2) {
    const { graphic: e2 } = this, r2 = j$p(t2, { graphic: e2 }).catch(() => null);
    this._loadingPromise = r2, this.notifyChange("state");
    const o2 = await r2;
    r2 === this._loadingPromise && (this._loadingPromise = null, this.notifyChange("state"), this._set("created", o2));
  }
};
e$1W([y$1o({ readOnly: true })], p$1I.prototype, "created", void 0), e$1W([y$1o()], p$1I.prototype, "creator", void 0), e$1W([y$1o()], p$1I.prototype, "destroyer", void 0), e$1W([y$1o({ type: g$J })], p$1I.prototype, "graphic", void 0), e$1W([y$1o({ readOnly: true })], p$1I.prototype, "state", null), p$1I = e$1W([n$2f("esri.widgets.Feature.FeatureContent.FeatureContentViewModel")], p$1I);
const l$14 = p$1I;
function t$Y() {
  return function(n2, t2) {
    if (!n2[t2])
      throw new TypeError(`Cannot auto bind undefined function '${t2}'`);
    return { value: o$U(n2[t2]) };
  };
}
function e$U(n2) {
  const { type: t2 } = n2;
  return n2 instanceof KeyboardEvent || t2 === "keyup" || t2 === "keydown" || t2 === "keypress";
}
function o$U(t2) {
  return function(o2, ...r2) {
    e$U(o2) ? k$e(o2.key) && (o2.preventDefault(), o2.stopPropagation(), o2.target.click()) : t2.call(this, o2, ...r2);
  };
}
function e$T(e2) {
  return (a2) => {
    a2.hasOwnProperty("_delegatedEventNames") || (a2._delegatedEventNames = a2._delegatedEventNames ? a2._delegatedEventNames.slice() : []);
    const n2 = a2._delegatedEventNames, r2 = Array.isArray(e2) ? e2 : t$X(e2);
    n2.push(...r2);
  };
}
function t$X(e2) {
  return e2.split(",").map((e3) => e3.trim());
}
const t$W = "calcite-theme-";
function e$S() {
  return getComputedStyle(document.body).getPropertyValue("--esri-calcite-theme-name").replace(/\s|'|"/g, "");
}
function r$K() {
  return e$S().startsWith("dark");
}
function c$1v() {
  return `${t$W}${r$K() ? "dark" : "light"}`;
}
function n$1h(t2) {
  s$$(t2), t2.classList.add(c$1v());
}
function s$$(e2) {
  Array.from(e2.classList).forEach((r2) => {
    r2.startsWith(t$W) && e2.classList.remove(r2);
  });
}
function e$R(e2) {
  return e2 && typeof e2.render == "function";
}
function t$V(e2) {
  return e2 && typeof e2.postMixInProperties == "function" && typeof e2.buildRendering == "function" && typeof e2.postCreate == "function" && typeof e2.startup == "function";
}
const d$N = { base: "esri-feature-content", loaderContainer: "esri-feature-content__loader-container", loader: "esri-feature-content__loader" };
let c$1u = class extends M$d {
  constructor(e2, r2) {
    super(e2, r2), this.viewModel = null, this._addTargetToAnchors = (e3) => {
      Array.from(e3.querySelectorAll("a")).forEach((e4) => {
        x$p(e4.href) && !e4.hasAttribute("target") && e4.setAttribute("target", "_blank");
      });
    };
  }
  get creator() {
    return this.viewModel.creator;
  }
  set creator(e2) {
    this.viewModel.creator = e2;
  }
  get graphic() {
    return this.viewModel.graphic;
  }
  set graphic(e2) {
    this.viewModel.graphic = e2;
  }
  renderLoading() {
    return n$1k("div", { class: d$N.loaderContainer, key: "loader" }, n$1k("div", { class: d$N.loader }));
  }
  renderCreated() {
    var _a2;
    const e2 = (_a2 = this.viewModel) == null ? void 0 : _a2.created;
    return e2 ? e2 instanceof HTMLElement ? n$1k("div", { key: e2, bind: e2, afterCreate: this._attachToNode }) : e$R(e2) ? n$1k("div", { key: e2 }, !e2.destroyed && e2.render()) : n$1k("div", { key: e2, innerHTML: e2, afterCreate: this._addTargetToAnchors }) : null;
  }
  render() {
    var _a2;
    const e2 = (_a2 = this.viewModel) == null ? void 0 : _a2.state;
    return n$1k("div", { class: d$N.base }, e2 === "loading" ? this.renderLoading() : this.renderCreated());
  }
  _attachToNode(e2) {
    const r2 = this;
    e2.appendChild(r2);
  }
};
e$1W([y$1o()], c$1u.prototype, "creator", null), e$1W([y$1o()], c$1u.prototype, "graphic", null), e$1W([y$1o({ type: l$14 })], c$1u.prototype, "viewModel", void 0), c$1u = e$1W([n$2f("esri.widgets.Feature.FeatureContent")], c$1u);
const l$13 = c$1u;
let l$12 = class extends m$1L {
  constructor(o2) {
    super(o2), this.attributes = null, this.expressionInfos = null, this.description = null, this.fieldInfos = null, this.title = null;
  }
  get formattedFieldInfos() {
    const { expressionInfos: o2, fieldInfos: e2 } = this, s2 = [];
    return e2 == null ? void 0 : e2.forEach((e3) => {
      if (!(!e3.hasOwnProperty("visible") || e3.visible))
        return;
      const t2 = e3.clone();
      t2.label = q$7(t2, o2), s2.push(t2);
    }), s2;
  }
};
e$1W([y$1o()], l$12.prototype, "attributes", void 0), e$1W([y$1o({ type: [i$1W] })], l$12.prototype, "expressionInfos", void 0), e$1W([y$1o()], l$12.prototype, "description", void 0), e$1W([y$1o({ type: [c$2q] })], l$12.prototype, "fieldInfos", void 0), e$1W([y$1o({ readOnly: true })], l$12.prototype, "formattedFieldInfos", null), e$1W([y$1o()], l$12.prototype, "title", void 0), l$12 = e$1W([n$2f("esri.widgets.Feature.FeatureFields.FeatureFieldsViewModel")], l$12);
const n$1g = l$12;
const s$_ = [{ pattern: /^\s*(https?:\/\/([^\s]+))\s*$/i, target: "_blank", label: "{messages.view}" }, { pattern: /^\s*(tel:([^\s]+))\s*$/i, label: "{hierPart}" }, { pattern: /^\s*(mailto:([^\s]+))\s*$/i, label: "{hierPart}" }, { pattern: /^\s*(arcgis-appstudio-player:\/\/([^\s]+))\s*$/i, label: "{messages.openInApp}", appName: "App Studio Player" }, { pattern: /^\s*(arcgis-collector:\/\/([^\s]+))\s*$/i, label: "{messages.openInApp}", appName: "Collector" }, { pattern: /^\s*(arcgis-explorer:\/\/([^\s]+))\s*$/i, label: "{messages.openInApp}", appName: "Explorer" }, { pattern: /^\s*(arcgis-navigator:\/\/([^\s]+))\s*$/i, label: "{messages.openInApp}", appName: "Navigator" }, { pattern: /^\s*(arcgis-survey123:\/\/([^\s]+))\s*$/i, label: "{messages.openInApp}", appName: "Survey123" }, { pattern: /^\s*(arcgis-trek2there:\/\/([^\s]+))\s*$/i, label: "{messages.openInApp}", appName: "Trek2There" }, { pattern: /^\s*(arcgis-workforce:\/\/([^\s]+))\s*$/i, label: "{messages.openInApp}", appName: "Workforce" }, { pattern: /^\s*(iform:\/\/([^\s]+))\s*$/i, label: "{messages.openInApp}", appName: "iForm" }, { pattern: /^\s*(flow:\/\/([^\s]+))\s*$/i, label: "{messages.openInApp}", appName: "FlowFinity" }, { pattern: /^\s*(lfmobile:\/\/([^\s]+))\s*$/i, label: "{messages.openInApp}", appName: "Laserfische" }, { pattern: /^\s*(mspbi:\/\/([^\s]+))\s*$/i, label: "{messages.openInApp}", appName: "Microsoft Power Bi" }];
function a$1r(e2) {
  let a2 = null;
  return s$_.some((s2) => (s2.pattern.test(e2) && (a2 = s2), !!a2)), a2;
}
function p$1H(s2, p2) {
  if (typeof p2 != "string" || !p2)
    return p2;
  const r2 = a$1r(p2);
  if (!r2)
    return p2;
  const t2 = p2.match(r2.pattern), n2 = t2 && t2[2], l2 = n$2m(n$2m(r2.label, { messages: s2, hierPart: n2 }), { appName: r2.appName }), i2 = r2.target ? ` target="${r2.target}"` : "", o2 = r2.target === "_blank" ? ' rel="noreferrer"' : "";
  return p2.replace(r2.pattern, `<a${i2} href="$1"${o2}>${l2}</a>`);
}
const p$1G = { base: "esri-feature-fields", fieldHeader: "esri-feature-fields__field-header", fieldData: "esri-feature-fields__field-data", fieldDataDate: "esri-feature-fields__field-data--date", esriTable: "esri-widget__table" };
let u$W = class extends M$d {
  constructor(e2, t2) {
    super(e2, t2), this._featureElementInfo = null, this.viewModel = new n$1g(), this.messages = null, this.messagesURIUtils = null;
  }
  initialize() {
    this._featureElementInfo = new l$15(), this.addHandles(l$1f(() => {
      var _a2, _b2;
      return [(_a2 = this.viewModel) == null ? void 0 : _a2.description, (_b2 = this.viewModel) == null ? void 0 : _b2.title];
    }, () => this._setupFeatureElementInfo(), h$S));
  }
  destroy() {
    this._featureElementInfo.destroy();
  }
  get attributes() {
    return this.viewModel.attributes;
  }
  set attributes(e2) {
    this.viewModel.attributes = e2;
  }
  get description() {
    return this.viewModel.description;
  }
  set description(e2) {
    this.viewModel.description = e2;
  }
  get expressionInfos() {
    return this.viewModel.expressionInfos;
  }
  set expressionInfos(e2) {
    this.viewModel.expressionInfos = e2;
  }
  get fieldInfos() {
    return this.viewModel.fieldInfos;
  }
  set fieldInfos(e2) {
    this.viewModel.fieldInfos = e2;
  }
  get title() {
    return this.viewModel.title;
  }
  set title(e2) {
    this.viewModel.title = e2;
  }
  renderFieldInfo(e2, t2) {
    const { attributes: s2 } = this.viewModel, i2 = e2.fieldName, r2 = e2.label || i2, o2 = s2 ? s2[i2] == null ? "" : s2[i2] : "", l2 = !(!e2.format || !e2.format.dateFormat), n2 = typeof o2 == "number" && !l2 ? this._forceLTR(o2) : p$1H(this.messagesURIUtils, o2), a2 = { [p$1G.fieldDataDate]: l2 };
    return n$1k("tr", { key: `fields-element-info-row-${i2}-${t2}` }, n$1k("th", { key: `fields-element-info-row-header-${i2}-${t2}`, class: p$1G.fieldHeader, innerHTML: r2 }), n$1k("td", { key: `fields-element-info-row-data-${i2}-${t2}`, class: this.classes(p$1G.fieldData, a2), innerHTML: n2 }));
  }
  renderFields() {
    const { formattedFieldInfos: e2 } = this.viewModel;
    return (e2 == null ? void 0 : e2.length) ? n$1k("table", { class: p$1G.esriTable, summary: this.messages.fieldsSummary }, n$1k("tbody", null, e2.map((e3, t2) => this.renderFieldInfo(e3, t2)))) : null;
  }
  render() {
    var _a2;
    return n$1k("div", { class: p$1G.base }, (_a2 = this._featureElementInfo) == null ? void 0 : _a2.render(), this.renderFields());
  }
  _setupFeatureElementInfo() {
    const { description: e2, title: t2 } = this;
    this._featureElementInfo.set({ description: e2, title: t2 });
  }
  _forceLTR(e2) {
    return `&lrm;${e2}`;
  }
};
e$1W([y$1o()], u$W.prototype, "attributes", null), e$1W([y$1o()], u$W.prototype, "description", null), e$1W([y$1o()], u$W.prototype, "expressionInfos", null), e$1W([y$1o()], u$W.prototype, "fieldInfos", null), e$1W([y$1o()], u$W.prototype, "title", null), e$1W([y$1o({ type: n$1g, nonNullable: true })], u$W.prototype, "viewModel", void 0), e$1W([y$1o(), e$W("esri/widgets/Feature/t9n/Feature")], u$W.prototype, "messages", void 0), e$1W([y$1o(), e$W("esri/widgets/support/t9n/uriUtils")], u$W.prototype, "messagesURIUtils", void 0), u$W = e$1W([n$2f("esri.widgets.Feature.FeatureFields")], u$W);
const m$X = u$W;
const s$Z = { maximumFractionDigits: 20 };
function c$1t(n2) {
  return m$1A(n2, s$Z);
}
var i$1n;
let c$1s = i$1n = class extends l$1_ {
  constructor(r2) {
    super(r2), this.color = null, this.label = null, this.value = null;
  }
  writeValue(r2, o2, e2) {
    o2[e2] = r2 != null ? r2 : 0;
  }
  clone() {
    return new i$1n({ color: this.color && this.color.clone(), label: this.label, value: this.value });
  }
};
e$1W([y$1o({ type: l$1D, json: { type: [T$r], write: true } })], c$1s.prototype, "color", void 0), e$1W([y$1o({ type: String, json: { write: true } })], c$1s.prototype, "label", void 0), e$1W([y$1o({ type: Number, json: { write: { writerEnsuresNonNull: true } } })], c$1s.prototype, "value", void 0), e$1W([r$1h("value")], c$1s.prototype, "writeValue", null), c$1s = i$1n = e$1W([n$2f("esri.renderers.visualVariables.support.ColorStop")], c$1s);
const a$1q = c$1s;
function c$1r(r2, t2, o2) {
  return E$v(r2.map((r3, e2) => t2.apply(o2, [r3, e2])));
}
async function h$H(r2, t2, o2) {
  return (await E$v(r2.map((r3, e2) => t2.apply(o2, [r3, e2])))).map((r3) => r3.value);
}
function m$W(r2) {
  return { ok: true, value: r2 };
}
function f$Q(r2) {
  return { ok: false, error: r2 };
}
function _$k(r2) {
  return r$1t(r2) && r2.ok === true ? r2.value : null;
}
function y$K(r2) {
  return r$1t(r2) && r2.ok === false ? r2.error : null;
}
async function b$w(r2) {
  if (t$1W(r2))
    return { ok: false, error: new Error("no promise provided") };
  try {
    return m$W(await r2);
  } catch (t2) {
    return f$Q(t2);
  }
}
async function d$M(r2) {
  try {
    return m$W(await r2);
  } catch (t2) {
    return w$O(t2), f$Q(t2);
  }
}
function j$o(r2, t2) {
  return new k$b(r2, t2);
}
let k$b = class extends m$1L {
  constructor(r2, t2) {
    super({}), this._result = null, this._abortHandle = null, this.abort = () => {
      this._abortController = p$33(this._abortController);
    }, this.remove = this.abort, this._abortController = new AbortController();
    const { signal: o2 } = this._abortController;
    this.promise = r2(o2), this.promise.then((r3) => {
      this._result = m$W(r3), this._cleanup();
    }, (r3) => {
      this._result = f$Q(r3), this._cleanup();
    }), this._abortHandle = v$S(t2, this.abort);
  }
  get value() {
    return _$k(this._result);
  }
  get error() {
    return y$K(this._result);
  }
  get finished() {
    return r$1t(this._result);
  }
  normalizeCtorArgs() {
    return {};
  }
  destroy() {
    this.abort();
  }
  _cleanup() {
    this._abortHandle = h$1s(this._abortHandle), this._abortController = null;
  }
};
e$1W([y$1o()], k$b.prototype, "value", null), e$1W([y$1o()], k$b.prototype, "error", null), e$1W([y$1o()], k$b.prototype, "finished", null), e$1W([y$1o()], k$b.prototype, "promise", void 0), e$1W([y$1o()], k$b.prototype, "_result", void 0), k$b = e$1W([n$2f("esri.core.asyncUtils.ReactiveTask")], k$b);
function e$Q() {
  const e2 = new Float32Array(16);
  return e2[0] = 1, e2[5] = 1, e2[10] = 1, e2[15] = 1, e2;
}
function r$J(e2) {
  const r2 = new Float32Array(16);
  return r2[0] = e2[0], r2[1] = e2[1], r2[2] = e2[2], r2[3] = e2[3], r2[4] = e2[4], r2[5] = e2[5], r2[6] = e2[6], r2[7] = e2[7], r2[8] = e2[8], r2[9] = e2[9], r2[10] = e2[10], r2[11] = e2[11], r2[12] = e2[12], r2[13] = e2[13], r2[14] = e2[14], r2[15] = e2[15], r2;
}
function t$U(e2, r2, t2, n2, o2, a2, c2, u2, l2, s2, f2, i2, y2, w2, b2, A2) {
  const F2 = new Float32Array(16);
  return F2[0] = e2, F2[1] = r2, F2[2] = t2, F2[3] = n2, F2[4] = o2, F2[5] = a2, F2[6] = c2, F2[7] = u2, F2[8] = l2, F2[9] = s2, F2[10] = f2, F2[11] = i2, F2[12] = y2, F2[13] = w2, F2[14] = b2, F2[15] = A2, F2;
}
function n$1f(e2, r2) {
  return new Float32Array(e2, r2, 16);
}
const o$T = e$Q();
Object.freeze(Object.defineProperty({ __proto__: null, create: e$Q, clone: r$J, fromValues: t$U, createView: n$1f, IDENTITY: o$T }, Symbol.toStringTag, { value: "Module" }));
const r$I = (r2, s2) => {
  const o2 = s$1b(r2, s2, 0, 0, 0, 0, s2, 0, 0, 0, 0, s2, 0, 0, 0, 0, 1);
  return o$17(o2, o2);
}, s$Y = (r2, s2) => {
  const o2 = s$1b(r2, s2, 0, 0, 0.5 - 0.5 * s2, 0, s2, 0, 0.5 - 0.5 * s2, 0, 0, s2, 0.5 - 0.5 * s2, 0, 0, 0, 1);
  return o$17(o2, o2);
}, o$S = (r2, s2) => {
  const o2 = 1 - s2, c2 = s$1b(r2, 0.2126 + 0.7874 * o2, 0.7152 - 0.7152 * o2, 0.0722 - 0.0722 * o2, 0, 0.2126 - 0.2126 * o2, 0.7152 + 0.2848 * o2, 0.0722 - 0.0722 * o2, 0, 0.2126 - 0.2126 * o2, 0.7152 - 0.7152 * o2, 0.0722 + 0.9278 * o2, 0, 0, 0, 0, 1);
  return o$17(c2, c2);
}, c$1q = (r2, s2) => {
  const o2 = Math.sin(s2 * Math.PI / 180), c2 = Math.cos(s2 * Math.PI / 180), e2 = s$1b(r2, 0.213 + 0.787 * c2 - 0.213 * o2, 0.715 - 0.715 * c2 - 0.715 * o2, 0.072 - 0.072 * c2 + 0.928 * o2, 0, 0.213 - 0.213 * c2 + 0.143 * o2, 0.715 + 0.285 * c2 + 0.14 * o2, 0.072 - 0.072 * c2 - 0.283 * o2, 0, 0.213 - 0.213 * c2 - 0.787 * o2, 0.715 - 0.715 * c2 + 0.715 * o2, 0.072 + 0.928 * c2 + 0.072 * o2, 0, 0, 0, 0, 1);
  return o$17(e2, e2);
}, e$P = (r2, s2) => {
  const o2 = 1 - 2 * s2, c2 = s$1b(r2, o2, 0, 0, s2, 0, o2, 0, s2, 0, 0, o2, s2, 0, 0, 0, 1);
  return o$17(c2, c2);
}, u$V = (r2, s2) => {
  const o2 = s$1b(r2, 0.213 + 0.787 * s2, 0.715 - 0.715 * s2, 0.072 - 0.072 * s2, 0, 0.213 - 0.213 * s2, 0.715 + 0.285 * s2, 0.072 - 0.072 * s2, 0, 0.213 - 0.213 * s2, 0.715 - 0.715 * s2, 0.072 + 0.928 * s2, 0, 0, 0, 0, 1);
  return o$17(o2, o2);
}, a$1p = (r2, s2) => {
  const o2 = 1 - s2, c2 = s$1b(r2, 0.393 + 0.607 * o2, 0.769 - 0.769 * o2, 0.189 - 0.189 * o2, 0, 0.349 - 0.349 * o2, 0.686 + 0.314 * o2, 0.168 - 0.168 * o2, 0, 0.272 - 0.272 * o2, 0.534 - 0.534 * o2, 0.131 + 0.869 * o2, 0, 0, 0, 0, 1);
  return o$17(c2, c2);
};
class c$1p {
  constructor(t2, s2, r2) {
    this.strength = t2, this.radius = s2, this.threshold = r2, this.type = "bloom";
  }
  interpolate(t2, s2, r2) {
    this.strength = M$b(t2.strength, s2.strength, r2), this.radius = M$b(t2.radius, s2.radius, r2), this.threshold = M$b(t2.threshold, s2.threshold, r2);
  }
  clone() {
    return new c$1p(this.strength, this.radius, this.threshold);
  }
  toJSON() {
    return { type: "bloom", radius: y$J(this.radius), strength: this.strength, threshold: this.threshold };
  }
}
class l$11 {
  constructor(t2) {
    this.radius = t2, this.type = "blur";
  }
  interpolate(t2, s2, r2) {
    this.radius = Math.round(M$b(t2.radius, s2.radius, r2));
  }
  clone() {
    return new l$11(this.radius);
  }
  toJSON() {
    return { type: "blur", radius: y$J(this.radius) };
  }
}
class p$1F {
  constructor(t2, s2) {
    this.type = t2, this.amount = s2, this.type !== "invert" && this.type !== "grayscale" && this.type !== "sepia" || (this.amount = Math.min(this.amount, 1));
  }
  get colorMatrix() {
    return this._colorMatrix || this._updateMatrix(), this._colorMatrix;
  }
  interpolate(t2, s2, r2) {
    this.amount = M$b(t2.amount, s2.amount, r2), this._updateMatrix();
  }
  clone() {
    return new p$1F(this.type, this.amount);
  }
  toJSON() {
    return { type: this.type, amount: this.amount };
  }
  _updateMatrix() {
    const t2 = this._colorMatrix || e$Q();
    switch (this.type) {
      case "brightness":
        this._colorMatrix = r$I(t2, this.amount);
        break;
      case "contrast":
        this._colorMatrix = s$Y(t2, this.amount);
        break;
      case "grayscale":
        this._colorMatrix = o$S(t2, this.amount);
        break;
      case "invert":
        this._colorMatrix = e$P(t2, this.amount);
        break;
      case "saturate":
        this._colorMatrix = u$V(t2, this.amount);
        break;
      case "sepia":
        this._colorMatrix = a$1p(t2, this.amount);
    }
  }
}
class d$L {
  constructor(t2, s2, r2, o2) {
    this.offsetX = t2, this.offsetY = s2, this.blurRadius = r2, this.color = o2, this.type = "drop-shadow";
  }
  interpolate(t2, s2, r2) {
    this.offsetX = M$b(t2.offsetX, s2.offsetX, r2), this.offsetY = M$b(t2.offsetY, s2.offsetY, r2), this.blurRadius = M$b(t2.blurRadius, s2.blurRadius, r2), this.color[0] = Math.round(M$b(t2.color[0], s2.color[0], r2)), this.color[1] = Math.round(M$b(t2.color[1], s2.color[1], r2)), this.color[2] = Math.round(M$b(t2.color[2], s2.color[2], r2)), this.color[3] = M$b(t2.color[3], s2.color[3], r2);
  }
  clone() {
    return new d$L(this.offsetX, this.offsetY, this.blurRadius, [...this.color]);
  }
  toJSON() {
    const t2 = [...this.color];
    return t2[3] *= 255, { type: "drop-shadow", xoffset: y$J(this.offsetX), yoffset: y$J(this.offsetY), blurRadius: y$J(this.blurRadius), color: t2 };
  }
}
class m$V {
  constructor(t2) {
    this.angle = t2, this.type = "hue-rotate";
  }
  get colorMatrix() {
    return this._colorMatrix || this._updateMatrix(), this._colorMatrix;
  }
  interpolate(t2, s2, r2) {
    this.angle = M$b(t2.angle, s2.angle, r2), this._updateMatrix();
  }
  clone() {
    return new m$V(this.angle);
  }
  toJSON() {
    return { type: "hue-rotate", angle: this.angle };
  }
  _updateMatrix() {
    const t2 = this._colorMatrix || e$Q();
    this._colorMatrix = c$1q(t2, this.angle);
  }
}
class f$P {
  constructor(t2) {
    this.amount = t2, this.type = "opacity", this.amount = Math.min(this.amount, 1);
  }
  interpolate(t2, s2, r2) {
    this.amount = M$b(t2.amount, s2.amount, r2);
  }
  clone() {
    return new f$P(this.amount);
  }
  toJSON() {
    return { type: "opacity", amount: this.amount };
  }
}
function M$b(t2, s2, r2) {
  return t2 + (s2 - t2) * r2;
}
function y$J(t2) {
  return Math.round(1e3 * e$1h(t2)) / 1e3;
}
function x$o(s2) {
  switch (s2.type) {
    case "grayscale":
    case "sepia":
    case "invert":
      return new p$1F(s2.type, 0);
    case "saturate":
    case "brightness":
    case "contrast":
      return new p$1F(s2.type, 1);
    case "opacity":
      return new f$P(1);
    case "hue-rotate":
      return new m$V(0);
    case "blur":
      return new l$11(0);
    case "drop-shadow":
      return new d$L(0, 0, 0, [...l$1I("transparent")]);
    case "bloom":
      return new c$1p(0, 0, 1);
  }
}
function n$1e(t2, n2) {
  const e2 = t2.length > n2.length ? t2 : n2;
  return (t2.length > n2.length ? n2 : t2).every((t3, n3) => t3.type === e2[n3].type);
}
function e$O(n2, e2) {
  const h2 = n2.length > e2.length ? n2 : e2, l2 = n2.length > e2.length ? e2 : n2;
  for (let g2 = l2.length; g2 < h2.length; g2++)
    l2.push(x$o(h2[g2]));
}
function h$G(t2) {
  const n2 = t2[0];
  return !!n2 && "type" in n2;
}
var m$U, g$A, v$v = { exports: {} };
function d$K(t2) {
  if (!t2 || t2.length === 0)
    return null;
  if (typeof t2 == "string") {
    const e3 = y$I(t2);
    return e3 && e3.length !== 0 ? e3 : null;
  }
  const e2 = t2.map((t3) => {
    if (!Number.isFinite(t3.scale) || t3.scale <= 0)
      throw new s$1Z("effect:invalid-scale", "scale must be finite and greater than 0", { stop: t3 });
    return { scale: t3.scale, effects: y$I(t3.value) };
  });
  e2.sort((t3, e3) => e3.effects.length - t3.effects.length);
  for (let r2 = 0; r2 < e2.length - 1; r2++) {
    if (!n$1e(e2[r2].effects, e2[r2 + 1].effects))
      throw new s$1Z("effect:interpolation-impossible", "Cannot interpolate by scale between 2 lists of mixed effects", { a: e2[r2].effects, b: e2[r2 + 1].effects });
    e$O(e2[r2].effects, e2[r2 + 1].effects);
  }
  return e2.sort((t3, e3) => e3.scale - t3.scale), e2;
}
function y$I(t2) {
  let e2;
  if (!t2)
    return [];
  try {
    e2 = v$v.exports.parse(t2);
  } catch (r2) {
    throw new s$1Z("effect:invalid-syntax", "Invalid effect syntax", { value: t2, error: r2 });
  }
  return e2.map((t3) => A$8(t3));
}
function A$8(t2) {
  try {
    switch (t2.name) {
      case "grayscale":
      case "sepia":
      case "saturate":
      case "invert":
      case "brightness":
      case "contrast":
        return w$r(t2);
      case "opacity":
        return x$n(t2);
      case "hue-rotate":
        return b$v(t2);
      case "blur":
        return C$f(t2);
      case "drop-shadow":
        return F$a(t2);
      case "bloom":
        return E$f(t2);
    }
  } catch (e2) {
    throw e2.details.filter = t2, e2;
  }
  throw new s$1Z("effect:unknown-effect", `Effect '${t2.name}' is not supported`, { effect: t2 });
}
function w$r(t2) {
  let e2 = 1;
  return j$n(t2.parameters, 1), t2.parameters.length === 1 && (e2 = M$a(t2.parameters[0])), new p$1F(t2.name, e2);
}
function x$n(t2) {
  let e2 = 1;
  return j$n(t2.parameters, 1), t2.parameters.length === 1 && (e2 = M$a(t2.parameters[0])), new f$P(e2);
}
function b$v(t2) {
  let e2 = 0;
  return j$n(t2.parameters, 1), t2.parameters.length === 1 && (e2 = N$6(t2.parameters[0])), new m$V(e2);
}
function C$f(t2) {
  let e2 = 0;
  return j$n(t2.parameters, 1), t2.parameters.length === 1 && (e2 = T$e(t2.parameters[0]), O$a(e2, t2.parameters[0])), new l$11(e2);
}
function F$a(t2) {
  const e2 = [];
  let r2 = null;
  for (const n2 of t2.parameters)
    if (n2.type === "color") {
      if (e2.length && Object.freeze(e2), r2)
        throw new s$1Z("effect:type-error", "Accepts only one color", {});
      r2 = U$d(n2);
    } else {
      const t3 = T$e(n2);
      if (Object.isFrozen(e2))
        throw new s$1Z("effect:type-error", "<length> parameters not consecutive", { lengths: e2 });
      e2.push(t3), e2.length === 3 && O$a(t3, n2);
    }
  if (e2.length < 2 || e2.length > 3)
    throw new s$1Z("effect:type-error", `Expected <length>{2,3}, Actual: <length>{${e2.length}}`, { lengths: e2 });
  return new d$L(e2[0], e2[1], e2[2] || 0, r2 || H$6("black"));
}
function E$f(t2) {
  let e2 = 1, r2 = 0, n2 = 0;
  return j$n(t2.parameters, 3), t2.parameters[0] && (e2 = M$a(t2.parameters[0])), t2.parameters[1] && (r2 = T$e(t2.parameters[1]), O$a(r2, t2.parameters[1])), t2.parameters[2] && (n2 = M$a(t2.parameters[2])), new c$1p(e2, r2, n2);
}
function j$n(t2, e2) {
  if (t2.length > e2)
    throw new s$1Z("effect:type-error", `Function supports up to ${e2} parameters, Actual: ${t2.length}`, { parameters: t2 });
}
function $$6(t2) {
  if (t2.type === "color")
    return "<color>";
  if (t2.unit) {
    if (R$e[t2.unit])
      return "<length>";
    if (S$m[t2.unit])
      return "<angle>";
    if (t2.unit === "%")
      return "<percentage>";
  }
  return "<double>";
}
function O$a(t2, e2) {
  if (t2 < 0)
    throw new s$1Z("effect:type-error", `Negative values are not allowed, Actual: ${t2}`, { term: e2 });
}
function k$a(t2) {
  if (t2.type !== "quantity" || t2.unit !== null)
    throw new s$1Z("effect:type-error", `Expected <double>, Actual: ${$$6(t2)}`, { term: t2 });
}
function q$6(t2) {
  if (t2.type !== "quantity" || t2.unit !== null && t2.unit !== "%")
    throw new s$1Z("effect:type-error", `Expected <double> or <percentage>, Actual: ${$$6(t2)}`, { term: t2 });
}
g$A = function() {
  function t2(t3, e3) {
    function r3() {
      this.constructor = t3;
    }
    r3.prototype = e3.prototype, t3.prototype = new r3();
  }
  function e2(t3, r3, n3, u2) {
    var a2 = Error.call(this, t3);
    return Object.setPrototypeOf && Object.setPrototypeOf(a2, e2.prototype), a2.expected = r3, a2.found = n3, a2.location = u2, a2.name = "SyntaxError", a2;
  }
  function r2(t3, e3, r3) {
    return r3 = r3 || " ", t3.length > e3 ? t3 : (e3 -= t3.length, t3 + (r3 += r3.repeat(e3)).slice(0, e3));
  }
  function n2(t3, r3) {
    var n3, u2 = {}, a2 = (r3 = r3 !== void 0 ? r3 : {}).grammarSource, o2 = { start: Lt2 }, c2 = Lt2, i2 = "none", l2 = ")", s2 = ",", f2 = "(", p2 = "%", h2 = "px", m2 = "cm", g2 = "mm", v2 = "in", d2 = "pt", y2 = "pc", A2 = "deg", w2 = "rad", x2 = "grad", b2 = "turn", C2 = "#", F2 = ".", E2 = "e", j2 = /^[ \t\n\r]/, $2 = /^[a-z\-]/, O2 = /^[0-9a-fA-F]/, k2 = /^[+\-]/, q2 = /^[0-9]/, S2 = Bt2("none"), z2 = Ut2("none", false), R2 = Ut2(")", false), I2 = Ut2(",", false), M2 = Bt2("whitespace"), P2 = Ht([" ", "	", "\n", "\r"], false, false), N2 = Bt2("function"), T2 = Ut2("(", false), U2 = Bt2("identifier"), H2 = Ht([["a", "z"], "-"], false, false), _2 = Bt2("percentage"), B2 = Ut2("%", false), D2 = Bt2("length"), G2 = Ut2("px", false), J2 = Ut2("cm", false), K2 = Ut2("mm", false), L2 = Ut2("in", false), Q2 = Ut2("pt", false), V2 = Ut2("pc", false), W2 = Bt2("angle"), X2 = Ut2("deg", false), Y2 = Ut2("rad", false), Z2 = Ut2("grad", false), tt2 = Ut2("turn", false), et2 = Bt2("number"), rt2 = Bt2("color"), nt2 = Ut2("#", false), ut2 = Ht([["0", "9"], ["a", "f"], ["A", "F"]], false, false), at2 = Ht(["+", "-"], false, false), ot2 = Ht([["0", "9"]], false, false), ct2 = Ut2(".", false), it2 = Ut2("e", false), lt2 = function() {
      return [];
    }, st2 = function(t4, e3) {
      return { type: "function", name: t4, parameters: e3 || [] };
    }, ft2 = function(t4, e3) {
      return e3.length > 0 ? le2(t4, e3, 3) : [t4];
    }, pt2 = function(t4) {
      return { type: "quantity", value: t4.value, unit: t4.unit };
    }, ht2 = function(t4) {
      return { type: "color", colorType: t4.type, value: t4.value };
    }, mt2 = function(t4) {
      return t4;
    }, gt2 = function() {
      return Tt2();
    }, vt2 = function(t4) {
      return { value: t4, unit: "%" };
    }, dt2 = function(t4) {
      return { value: t4, unit: "px" };
    }, yt2 = function(t4) {
      return { value: t4, unit: "cm" };
    }, At2 = function(t4) {
      return { value: t4, unit: "mm" };
    }, wt2 = function(t4) {
      return { value: t4, unit: "in" };
    }, xt2 = function(t4) {
      return { value: t4, unit: "pt" };
    }, bt2 = function(t4) {
      return { value: t4, unit: "pc" };
    }, Ct2 = function(t4) {
      return { value: t4, unit: "deg" };
    }, Ft2 = function(t4) {
      return { value: t4, unit: "rad" };
    }, Et2 = function(t4) {
      return { value: t4, unit: "grad" };
    }, jt2 = function(t4) {
      return { value: t4, unit: "turn" };
    }, $t2 = function(t4) {
      return { value: t4, unit: null };
    }, Ot2 = function() {
      return { type: "hex", value: Tt2() };
    }, kt2 = function(t4) {
      return { type: "function", value: t4 };
    }, qt2 = function() {
      return { type: "named", value: Tt2() };
    }, St2 = function() {
      return parseFloat(Tt2());
    }, zt = 0, Rt2 = 0, It2 = [{ line: 1, column: 1 }], Mt2 = 0, Pt2 = [], Nt2 = 0;
    if ("startRule" in r3) {
      if (!(r3.startRule in o2))
        throw new Error(`Can't start parsing from rule "` + r3.startRule + '".');
      c2 = o2[r3.startRule];
    }
    function Tt2() {
      return t3.substring(Rt2, zt);
    }
    function Ut2(t4, e3) {
      return { type: "literal", text: t4, ignoreCase: e3 };
    }
    function Ht(t4, e3, r4) {
      return { type: "class", parts: t4, inverted: e3, ignoreCase: r4 };
    }
    function _t() {
      return { type: "end" };
    }
    function Bt2(t4) {
      return { type: "other", description: t4 };
    }
    function Dt(e3) {
      var r4, n4 = It2[e3];
      if (n4)
        return n4;
      for (r4 = e3 - 1; !It2[r4]; )
        r4--;
      for (n4 = { line: (n4 = It2[r4]).line, column: n4.column }; r4 < e3; )
        t3.charCodeAt(r4) === 10 ? (n4.line++, n4.column = 1) : n4.column++, r4++;
      return It2[e3] = n4, n4;
    }
    function Gt2(t4, e3) {
      var r4 = Dt(t4), n4 = Dt(e3);
      return { source: a2, start: { offset: t4, line: r4.line, column: r4.column }, end: { offset: e3, line: n4.line, column: n4.column } };
    }
    function Jt2(t4) {
      zt < Mt2 || (zt > Mt2 && (Mt2 = zt, Pt2 = []), Pt2.push(t4));
    }
    function Kt(t4, r4, n4) {
      return new e2(e2.buildMessage(t4, r4), t4, r4, n4);
    }
    function Lt2() {
      var t4;
      return (t4 = Qt()) === u2 && (t4 = Vt()), t4;
    }
    function Qt() {
      var e3, r4;
      return Nt2++, e3 = zt, Zt(), t3.substr(zt, 4) === i2 ? (r4 = i2, zt += 4) : (r4 = u2, Nt2 === 0 && Jt2(z2)), r4 !== u2 ? (Zt(), Rt2 = e3, e3 = lt2()) : (zt = e3, e3 = u2), Nt2--, e3 === u2 && Nt2 === 0 && Jt2(S2), e3;
    }
    function Vt() {
      var t4, e3;
      if (t4 = [], (e3 = Wt()) !== u2)
        for (; e3 !== u2; )
          t4.push(e3), e3 = Wt();
      else
        t4 = u2;
      return t4;
    }
    function Wt() {
      var e3, r4, n4, a3;
      return e3 = zt, Zt(), (r4 = te2()) !== u2 ? (Zt(), (n4 = Xt()) === u2 && (n4 = null), Zt(), t3.charCodeAt(zt) === 41 ? (a3 = l2, zt++) : (a3 = u2, Nt2 === 0 && Jt2(R2)), a3 !== u2 ? (Zt(), Rt2 = e3, e3 = st2(r4, n4)) : (zt = e3, e3 = u2)) : (zt = e3, e3 = u2), e3;
    }
    function Xt() {
      var e3, r4, n4, a3, o3, c3, i3, l3;
      if (e3 = zt, (r4 = Yt()) !== u2) {
        for (n4 = [], a3 = zt, o3 = Zt(), t3.charCodeAt(zt) === 44 ? (c3 = s2, zt++) : (c3 = u2, Nt2 === 0 && Jt2(I2)), c3 === u2 && (c3 = null), i3 = Zt(), (l3 = Yt()) !== u2 ? a3 = o3 = [o3, c3, i3, l3] : (zt = a3, a3 = u2); a3 !== u2; )
          n4.push(a3), a3 = zt, o3 = Zt(), t3.charCodeAt(zt) === 44 ? (c3 = s2, zt++) : (c3 = u2, Nt2 === 0 && Jt2(I2)), c3 === u2 && (c3 = null), i3 = Zt(), (l3 = Yt()) !== u2 ? a3 = o3 = [o3, c3, i3, l3] : (zt = a3, a3 = u2);
        Rt2 = e3, e3 = ft2(r4, n4);
      } else
        zt = e3, e3 = u2;
      return e3;
    }
    function Yt() {
      var t4, e3;
      return t4 = zt, (e3 = re2()) === u2 && (e3 = ne2()) === u2 && (e3 = ue2()) === u2 && (e3 = ae2()), e3 !== u2 && (Rt2 = t4, e3 = pt2(e3)), (t4 = e3) === u2 && (t4 = zt, (e3 = oe2()) !== u2 && (Rt2 = t4, e3 = ht2(e3)), t4 = e3), t4;
    }
    function Zt() {
      var e3, r4;
      for (Nt2++, e3 = [], j2.test(t3.charAt(zt)) ? (r4 = t3.charAt(zt), zt++) : (r4 = u2, Nt2 === 0 && Jt2(P2)); r4 !== u2; )
        e3.push(r4), j2.test(t3.charAt(zt)) ? (r4 = t3.charAt(zt), zt++) : (r4 = u2, Nt2 === 0 && Jt2(P2));
      return Nt2--, r4 = u2, Nt2 === 0 && Jt2(M2), e3;
    }
    function te2() {
      var e3, r4, n4;
      return Nt2++, e3 = zt, (r4 = ee2()) !== u2 ? (t3.charCodeAt(zt) === 40 ? (n4 = f2, zt++) : (n4 = u2, Nt2 === 0 && Jt2(T2)), n4 !== u2 ? (Rt2 = e3, e3 = mt2(r4)) : (zt = e3, e3 = u2)) : (zt = e3, e3 = u2), Nt2--, e3 === u2 && (r4 = u2, Nt2 === 0 && Jt2(N2)), e3;
    }
    function ee2() {
      var e3, r4, n4;
      if (Nt2++, e3 = zt, r4 = [], $2.test(t3.charAt(zt)) ? (n4 = t3.charAt(zt), zt++) : (n4 = u2, Nt2 === 0 && Jt2(H2)), n4 !== u2)
        for (; n4 !== u2; )
          r4.push(n4), $2.test(t3.charAt(zt)) ? (n4 = t3.charAt(zt), zt++) : (n4 = u2, Nt2 === 0 && Jt2(H2));
      else
        r4 = u2;
      return r4 !== u2 && (Rt2 = e3, r4 = gt2()), Nt2--, (e3 = r4) === u2 && (r4 = u2, Nt2 === 0 && Jt2(U2)), e3;
    }
    function re2() {
      var e3, r4, n4;
      return Nt2++, e3 = zt, Zt(), (r4 = ce2()) !== u2 ? (t3.charCodeAt(zt) === 37 ? (n4 = p2, zt++) : (n4 = u2, Nt2 === 0 && Jt2(B2)), n4 !== u2 ? (Rt2 = e3, e3 = vt2(r4)) : (zt = e3, e3 = u2)) : (zt = e3, e3 = u2), Nt2--, e3 === u2 && Nt2 === 0 && Jt2(_2), e3;
    }
    function ne2() {
      var e3, r4, n4;
      return Nt2++, e3 = zt, Zt(), (r4 = ce2()) !== u2 ? (t3.substr(zt, 2) === h2 ? (n4 = h2, zt += 2) : (n4 = u2, Nt2 === 0 && Jt2(G2)), n4 !== u2 ? (Rt2 = e3, e3 = dt2(r4)) : (zt = e3, e3 = u2)) : (zt = e3, e3 = u2), e3 === u2 && (e3 = zt, Zt(), (r4 = ce2()) !== u2 ? (t3.substr(zt, 2) === m2 ? (n4 = m2, zt += 2) : (n4 = u2, Nt2 === 0 && Jt2(J2)), n4 !== u2 ? (Rt2 = e3, e3 = yt2(r4)) : (zt = e3, e3 = u2)) : (zt = e3, e3 = u2), e3 === u2 && (e3 = zt, Zt(), (r4 = ce2()) !== u2 ? (t3.substr(zt, 2) === g2 ? (n4 = g2, zt += 2) : (n4 = u2, Nt2 === 0 && Jt2(K2)), n4 !== u2 ? (Rt2 = e3, e3 = At2(r4)) : (zt = e3, e3 = u2)) : (zt = e3, e3 = u2), e3 === u2 && (e3 = zt, Zt(), (r4 = ce2()) !== u2 ? (t3.substr(zt, 2) === v2 ? (n4 = v2, zt += 2) : (n4 = u2, Nt2 === 0 && Jt2(L2)), n4 !== u2 ? (Rt2 = e3, e3 = wt2(r4)) : (zt = e3, e3 = u2)) : (zt = e3, e3 = u2), e3 === u2 && (e3 = zt, Zt(), (r4 = ce2()) !== u2 ? (t3.substr(zt, 2) === d2 ? (n4 = d2, zt += 2) : (n4 = u2, Nt2 === 0 && Jt2(Q2)), n4 !== u2 ? (Rt2 = e3, e3 = xt2(r4)) : (zt = e3, e3 = u2)) : (zt = e3, e3 = u2), e3 === u2 && (e3 = zt, Zt(), (r4 = ce2()) !== u2 ? (t3.substr(zt, 2) === y2 ? (n4 = y2, zt += 2) : (n4 = u2, Nt2 === 0 && Jt2(V2)), n4 !== u2 ? (Rt2 = e3, e3 = bt2(r4)) : (zt = e3, e3 = u2)) : (zt = e3, e3 = u2)))))), Nt2--, e3 === u2 && Nt2 === 0 && Jt2(D2), e3;
    }
    function ue2() {
      var e3, r4, n4;
      return Nt2++, e3 = zt, (r4 = ce2()) !== u2 ? (t3.substr(zt, 3) === A2 ? (n4 = A2, zt += 3) : (n4 = u2, Nt2 === 0 && Jt2(X2)), n4 !== u2 ? (Rt2 = e3, e3 = Ct2(r4)) : (zt = e3, e3 = u2)) : (zt = e3, e3 = u2), e3 === u2 && (e3 = zt, (r4 = ce2()) !== u2 ? (t3.substr(zt, 3) === w2 ? (n4 = w2, zt += 3) : (n4 = u2, Nt2 === 0 && Jt2(Y2)), n4 !== u2 ? (Rt2 = e3, e3 = Ft2(r4)) : (zt = e3, e3 = u2)) : (zt = e3, e3 = u2), e3 === u2 && (e3 = zt, (r4 = ce2()) !== u2 ? (t3.substr(zt, 4) === x2 ? (n4 = x2, zt += 4) : (n4 = u2, Nt2 === 0 && Jt2(Z2)), n4 !== u2 ? (Rt2 = e3, e3 = Et2(r4)) : (zt = e3, e3 = u2)) : (zt = e3, e3 = u2), e3 === u2 && (e3 = zt, (r4 = ce2()) !== u2 ? (t3.substr(zt, 4) === b2 ? (n4 = b2, zt += 4) : (n4 = u2, Nt2 === 0 && Jt2(tt2)), n4 !== u2 ? (Rt2 = e3, e3 = jt2(r4)) : (zt = e3, e3 = u2)) : (zt = e3, e3 = u2)))), Nt2--, e3 === u2 && (r4 = u2, Nt2 === 0 && Jt2(W2)), e3;
    }
    function ae2() {
      var t4, e3;
      return Nt2++, t4 = zt, Zt(), (e3 = ce2()) !== u2 ? (Rt2 = t4, t4 = $t2(e3)) : (zt = t4, t4 = u2), Nt2--, t4 === u2 && Nt2 === 0 && Jt2(et2), t4;
    }
    function oe2() {
      var e3, r4, n4, a3;
      if (Nt2++, e3 = zt, t3.charCodeAt(zt) === 35 ? (r4 = C2, zt++) : (r4 = u2, Nt2 === 0 && Jt2(nt2)), r4 !== u2) {
        if (n4 = [], O2.test(t3.charAt(zt)) ? (a3 = t3.charAt(zt), zt++) : (a3 = u2, Nt2 === 0 && Jt2(ut2)), a3 !== u2)
          for (; a3 !== u2; )
            n4.push(a3), O2.test(t3.charAt(zt)) ? (a3 = t3.charAt(zt), zt++) : (a3 = u2, Nt2 === 0 && Jt2(ut2));
        else
          n4 = u2;
        n4 !== u2 ? (Rt2 = e3, e3 = Ot2()) : (zt = e3, e3 = u2);
      } else
        zt = e3, e3 = u2;
      return e3 === u2 && (e3 = zt, (r4 = Wt()) !== u2 && (Rt2 = e3, r4 = kt2(r4)), (e3 = r4) === u2 && (e3 = zt, (r4 = ee2()) !== u2 && (Rt2 = e3, r4 = qt2()), e3 = r4)), Nt2--, e3 === u2 && (r4 = u2, Nt2 === 0 && Jt2(rt2)), e3;
    }
    function ce2() {
      var e3, r4, n4, a3, o3, c3, i3;
      for (e3 = zt, k2.test(t3.charAt(zt)) ? (t3.charAt(zt), zt++) : Nt2 === 0 && Jt2(at2), r4 = zt, n4 = [], q2.test(t3.charAt(zt)) ? (a3 = t3.charAt(zt), zt++) : (a3 = u2, Nt2 === 0 && Jt2(ot2)); a3 !== u2; )
        n4.push(a3), q2.test(t3.charAt(zt)) ? (a3 = t3.charAt(zt), zt++) : (a3 = u2, Nt2 === 0 && Jt2(ot2));
      if (t3.charCodeAt(zt) === 46 ? (a3 = F2, zt++) : (a3 = u2, Nt2 === 0 && Jt2(ct2)), a3 !== u2) {
        if (o3 = [], q2.test(t3.charAt(zt)) ? (c3 = t3.charAt(zt), zt++) : (c3 = u2, Nt2 === 0 && Jt2(ot2)), c3 !== u2)
          for (; c3 !== u2; )
            o3.push(c3), q2.test(t3.charAt(zt)) ? (c3 = t3.charAt(zt), zt++) : (c3 = u2, Nt2 === 0 && Jt2(ot2));
        else
          o3 = u2;
        o3 !== u2 ? r4 = n4 = [n4, a3, o3] : (zt = r4, r4 = u2);
      } else
        zt = r4, r4 = u2;
      if (r4 === u2)
        if (r4 = [], q2.test(t3.charAt(zt)) ? (n4 = t3.charAt(zt), zt++) : (n4 = u2, Nt2 === 0 && Jt2(ot2)), n4 !== u2)
          for (; n4 !== u2; )
            r4.push(n4), q2.test(t3.charAt(zt)) ? (n4 = t3.charAt(zt), zt++) : (n4 = u2, Nt2 === 0 && Jt2(ot2));
        else
          r4 = u2;
      if (r4 !== u2) {
        if (n4 = zt, t3.charCodeAt(zt) === 101 ? (a3 = E2, zt++) : (a3 = u2, Nt2 === 0 && Jt2(it2)), a3 !== u2) {
          if (k2.test(t3.charAt(zt)) ? (o3 = t3.charAt(zt), zt++) : (o3 = u2, Nt2 === 0 && Jt2(at2)), o3 === u2 && (o3 = null), c3 = [], q2.test(t3.charAt(zt)) ? (i3 = t3.charAt(zt), zt++) : (i3 = u2, Nt2 === 0 && Jt2(ot2)), i3 !== u2)
            for (; i3 !== u2; )
              c3.push(i3), q2.test(t3.charAt(zt)) ? (i3 = t3.charAt(zt), zt++) : (i3 = u2, Nt2 === 0 && Jt2(ot2));
          else
            c3 = u2;
          c3 !== u2 ? n4 = a3 = [a3, o3, c3] : (zt = n4, n4 = u2);
        } else
          zt = n4, n4 = u2;
        n4 === u2 && (n4 = null), Rt2 = e3, e3 = St2();
      } else
        zt = e3, e3 = u2;
      return e3;
    }
    function ie2(t4, e3) {
      return t4.map(function(t5) {
        return t5[e3];
      });
    }
    function le2(t4, e3, r4) {
      return [t4].concat(ie2(e3, r4));
    }
    if ((n3 = c2()) !== u2 && zt === t3.length)
      return n3;
    throw n3 !== u2 && zt < t3.length && Jt2(_t()), Kt(Pt2, Mt2 < t3.length ? t3.charAt(Mt2) : null, Mt2 < t3.length ? Gt2(Mt2, Mt2 + 1) : Gt2(Mt2, Mt2));
  }
  return t2(e2, Error), e2.prototype.format = function(t3) {
    var e3 = "Error: " + this.message;
    if (this.location) {
      var n3, u2 = null;
      for (n3 = 0; n3 < t3.length; n3++)
        if (t3[n3].source === this.location.source) {
          u2 = t3[n3].text.split(/\r\n|\n|\r/g);
          break;
        }
      var a2 = this.location.start, o2 = this.location.source + ":" + a2.line + ":" + a2.column;
      if (u2) {
        var c2 = this.location.end, i2 = r2("", a2.line.toString().length, " "), l2 = u2[a2.line - 1], s2 = (a2.line === c2.line ? c2.column : l2.length + 1) - a2.column || 1;
        e3 += "\n --> " + o2 + "\n" + i2 + " |\n" + a2.line + " | " + l2 + "\n" + i2 + " | " + r2("", a2.column - 1, " ") + r2("", s2, "^");
      } else
        e3 += "\n at " + o2;
    }
    return e3;
  }, e2.buildMessage = function(t3, e3) {
    var r3 = { literal: function(t4) {
      return '"' + u2(t4.text) + '"';
    }, class: function(t4) {
      var e4 = t4.parts.map(function(t5) {
        return Array.isArray(t5) ? a2(t5[0]) + "-" + a2(t5[1]) : a2(t5);
      });
      return "[" + (t4.inverted ? "^" : "") + e4.join("") + "]";
    }, any: function() {
      return "any character";
    }, end: function() {
      return "end of input";
    }, other: function(t4) {
      return t4.description;
    } };
    function n3(t4) {
      return t4.charCodeAt(0).toString(16).toUpperCase();
    }
    function u2(t4) {
      return t4.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(t5) {
        return "\\x0" + n3(t5);
      }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(t5) {
        return "\\x" + n3(t5);
      });
    }
    function a2(t4) {
      return t4.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(t5) {
        return "\\x0" + n3(t5);
      }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(t5) {
        return "\\x" + n3(t5);
      });
    }
    function o2(t4) {
      return r3[t4.type](t4);
    }
    function c2(t4) {
      var e4, r4, n4 = t4.map(o2);
      if (n4.sort(), n4.length > 0) {
        for (e4 = 1, r4 = 1; e4 < n4.length; e4++)
          n4[e4 - 1] !== n4[e4] && (n4[r4] = n4[e4], r4++);
        n4.length = r4;
      }
      switch (n4.length) {
        case 1:
          return n4[0];
        case 2:
          return n4[0] + " or " + n4[1];
        default:
          return n4.slice(0, -1).join(", ") + ", or " + n4[n4.length - 1];
      }
    }
    function i2(t4) {
      return t4 ? '"' + u2(t4) + '"' : "end of input";
    }
    return "Expected " + c2(t3) + " but " + i2(e3) + " found.";
  }, { SyntaxError: e2, parse: n2 };
}, (m$U = v$v).exports && (m$U.exports = g$A());
const S$m = { deg: 1, grad: 0.9, rad: 180 / Math.PI, turn: 360 };
function z$f(t2) {
  if (t2.type !== "quantity" || !(t2.value === 0 && t2.unit === null || t2.unit && S$m[t2.unit] != null))
    throw new s$1Z("effect:type-error", `Expected <angle>, Actual: ${$$6(t2)}`, { term: t2 });
}
const R$e = { px: 1, cm: 96 / 2.54, mm: 96 / 2.54 / 10, in: 96, pc: 16, pt: 96 / 72 };
function I$i(t2) {
  if (t2.type !== "quantity" || !(t2.value === 0 && t2.unit === null || t2.unit && R$e[t2.unit] != null))
    throw new s$1Z("effect:type-error", `Expected <length>, Actual: ${$$6(t2)}`, { term: t2 });
}
function M$a(t2) {
  q$6(t2);
  const e2 = t2.value;
  return O$a(e2, t2), t2.unit === "%" ? 0.01 * e2 : e2;
}
function P$d(t2) {
  return k$a(t2), O$a(t2.value, t2), t2.value;
}
function N$6(t2) {
  return z$f(t2), t2.value * S$m[t2.unit] || 0;
}
function T$e(t2) {
  return I$i(t2), t2.value * R$e[t2.unit] || 0;
}
function U$d(e2) {
  switch (e2.colorType) {
    case "hex":
      return i$1U(e2.value);
    case "named":
      return H$6(e2.value);
    case "function":
      return D$a(e2.value);
  }
}
function H$6(t2) {
  if (!r$15(t2))
    throw new s$1Z("effect:unknown-color", `color '${t2}' isn't valid`, { namedColor: t2 });
  return a$25(t2);
}
const _$j = /^rgba?/i, B$8 = /^hsla?/i;
function D$a(t2) {
  if (j$n(t2.parameters, 4), _$j.test(t2.name))
    return [M$a(t2.parameters[0]), M$a(t2.parameters[1]), M$a(t2.parameters[2]), t2.parameters[3] ? M$a(t2.parameters[3]) : 1];
  if (B$8.test(t2.name))
    return o$1p(P$d(t2.parameters[0]), M$a(t2.parameters[1]), M$a(t2.parameters[2]), t2.parameters[3] ? M$a(t2.parameters[3]) : 1);
  throw new s$1Z("effect:syntax-error", `Invalid color function '${t2.name}'`, { colorFunction: t2 });
}
function n$1d(e2, t2, r2) {
  var _a2;
  try {
    return c$1o(e2);
  } catch (s2) {
    (_a2 = r2 == null ? void 0 : r2.messages) == null ? void 0 : _a2.push(s2);
  }
  return null;
}
function a$1o(e2, r2, s2, n2) {
  try {
    const n3 = o$R(e2);
    o$1X(s2, n3, r2);
  } catch (a2) {
    n2.messages && n2.messages.push(a2);
  }
}
function o$R(e2) {
  const t2 = d$K(e2);
  return t2 ? h$G(t2) ? t2.map((e3) => e3.toJSON()) : t2.map(({ scale: e3, effects: t3 }) => ({ scale: e3, value: t3.map((e4) => e4.toJSON()) })) : null;
}
function c$1o(e2) {
  if (!e2 || e2.length === 0)
    return null;
  if (f$O(e2)) {
    const t2 = [];
    for (const r2 of e2)
      t2.push({ scale: r2.scale, value: i$1m(r2.value) });
    return t2;
  }
  return i$1m(e2);
}
function f$O(e2) {
  const t2 = e2[0];
  return !!t2 && "scale" in t2;
}
function i$1m(e2) {
  if (!e2 || !e2.length)
    return "";
  const t2 = [];
  for (const s2 of e2) {
    let e3 = [];
    switch (s2.type) {
      case "grayscale":
      case "sepia":
      case "saturate":
      case "invert":
      case "brightness":
      case "contrast":
      case "opacity":
        e3 = [u$U(s2, "amount")];
        break;
      case "blur":
        e3 = [u$U(s2, "radius", "pt")];
        break;
      case "hue-rotate":
        e3 = [u$U(s2, "angle", "deg")];
        break;
      case "drop-shadow":
        e3 = [u$U(s2, "xoffset", "pt"), u$U(s2, "yoffset", "pt"), u$U(s2, "blurRadius", "pt"), l$10(s2, "color")];
        break;
      case "bloom":
        e3 = [u$U(s2, "strength"), u$U(s2, "radius", "pt"), u$U(s2, "threshold")];
    }
    const n2 = `${s2.type}(${e3.filter(Boolean).join(" ")})`;
    d$K(n2), t2.push(n2);
  }
  return t2.join(" ");
}
function u$U(t2, r2, s2) {
  if (t2[r2] == null)
    throw new s$1Z("effect:missing-parameter", `Missing parameter '${r2}' in ${t2.type} effect`, { effect: t2 });
  return s2 ? t2[r2] + s2 : "" + t2[r2];
}
function l$10(t2, r2) {
  if (t2[r2] == null)
    throw new s$1Z("effect:missing-parameter", `Missing parameter '${r2}' in ${t2.type} effect`, { effect: t2 });
  const s2 = t2[r2];
  return `rgba(${s2[0] || 0}, ${s2[1] || 0}, ${s2[2] || 0}, ${s2[3] / 255 || 0})`;
}
const s$X = -3;
var i$1l;
!function(t2) {
  t2[t2.ALL = 0] = "ALL", t2[t2.SOME = 1] = "SOME";
}(i$1l || (i$1l = {}));
class r$H {
  constructor(t2, e2, s2) {
    this._namespace = t2, this._storage = e2, this._removeFunc = false, this._hit = 0, this._miss = 0, this._storage.register(this), this._namespace += ":", s2 && (this._storage.registerRemoveFunc(this._namespace, s2), this._removeFunc = true);
  }
  destroy() {
    this._storage.clear(this._namespace), this._removeFunc && this._storage.deregisterRemoveFunc(this._namespace), this._storage.deregister(this), this._storage = null;
  }
  get namespace() {
    return this._namespace.slice(0, -1);
  }
  get hitRate() {
    return this._hit / (this._hit + this._miss);
  }
  get size() {
    return this._storage.size;
  }
  get maxSize() {
    return this._storage.maxSize;
  }
  resetHitRate() {
    this._hit = this._miss = 0;
  }
  put(t2, e2, s2, i2 = 0) {
    this._storage.put(this._namespace + t2, e2, s2, i2);
  }
  get(t2) {
    const e2 = this._storage.get(this._namespace + t2);
    return e2 === void 0 ? ++this._miss : ++this._hit, e2;
  }
  pop(t2) {
    const e2 = this._storage.pop(this._namespace + t2);
    return e2 === void 0 ? ++this._miss : ++this._hit, e2;
  }
  updateSize(t2, e2, s2) {
    this._storage.updateSize(this._namespace + t2, e2, s2);
  }
  clear() {
    this._storage.clear(this._namespace);
  }
  clearAll() {
    this._storage.clearAll();
  }
  getStats() {
    return this._storage.getStats();
  }
  resetStats() {
    this._storage.resetStats();
  }
}
class h$F {
  constructor(t2 = 10485760) {
    this._maxSize = t2, this._db = new Map(), this._size = 0, this._hit = 0, this._miss = 0, this._removeFuncs = new l$22(), this._users = new l$22();
  }
  destroy() {
    this.clearAll(), this._removeFuncs.clear(), this._users.clear(), this._db = null;
  }
  register(t2) {
    this._users.push(t2);
  }
  deregister(t2) {
    this._users.removeUnordered(t2);
  }
  registerRemoveFunc(t2, e2) {
    this._removeFuncs.push([t2, e2]);
  }
  deregisterRemoveFunc(t2) {
    this._removeFuncs.filterInPlace((e2) => e2[0] !== t2);
  }
  get size() {
    return this._size;
  }
  get maxSize() {
    return this._maxSize;
  }
  set maxSize(t2) {
    this._maxSize = Math.max(t2, 0), this._checkSizeLimit();
  }
  put(t2, e2, r2, h2) {
    const _2 = this._db.get(t2);
    if (_2 && (this._size -= _2.size, this._db.delete(t2), _2.entry !== e2 && this._notifyRemove(t2, _2.entry, i$1l.ALL)), r2 > this._maxSize)
      return void this._notifyRemove(t2, e2, i$1l.ALL);
    if (e2 === void 0)
      return void console.warn("Refusing to cache undefined entry ");
    if (!r2 || r2 < 0)
      return void console.warn("Refusing to cache entry with invalid size " + r2);
    const o2 = 1 + Math.max(h2, s$X) - s$X;
    this._db.set(t2, { entry: e2, size: r2, lifetime: o2, lives: o2 }), this._size += r2, this._checkSizeLimit();
  }
  updateSize(e2, s2, r2) {
    const h2 = this._db.get(e2);
    if (h2 && h2.entry === s2) {
      for (this._size -= h2.size; r2 > this._maxSize; ) {
        const h3 = this._notifyRemove(e2, s2, i$1l.SOME);
        if (!(r$1t(h3) && h3 > 0))
          return void this._db.delete(e2);
        r2 = h3;
      }
      h2.size = r2, this._size += r2, this._checkSizeLimit();
    }
  }
  pop(t2) {
    const e2 = this._db.get(t2);
    if (e2)
      return this._size -= e2.size, this._db.delete(t2), ++this._hit, e2.entry;
    ++this._miss;
  }
  get(t2) {
    const e2 = this._db.get(t2);
    if (e2 !== void 0)
      return this._db.delete(t2), e2.lives = e2.lifetime, this._db.set(t2, e2), ++this._hit, e2.entry;
    ++this._miss;
  }
  getStats() {
    const t2 = { Size: Math.round(this._size / 1048576) + "/" + Math.round(this._maxSize / 1048576) + "MB", "Hit rate": Math.round(100 * this._getHitRate()) + "%", Entries: this._db.size.toString() }, e2 = {}, i2 = new Array();
    this._db.forEach((t3, s2) => {
      const r3 = t3.lifetime;
      i2[r3] = (i2[r3] || 0) + t3.size, this._users.forAll((i3) => {
        const r4 = i3.namespace;
        if (s2.startsWith(r4)) {
          const s3 = e2[r4] || 0;
          e2[r4] = s3 + t3.size;
        }
      });
    });
    const r2 = {};
    this._users.forAll((t3) => {
      const s2 = t3.namespace;
      if (!isNaN(t3.hitRate) && t3.hitRate > 0) {
        const i3 = e2[s2] || 0;
        e2[s2] = i3, r2[s2] = Math.round(100 * t3.hitRate) + "%";
      } else
        r2[s2] = "0%";
    });
    const h2 = Object.keys(e2);
    h2.sort((t3, s2) => e2[s2] - e2[t3]), h2.forEach((s2) => t2[s2] = Math.round(e2[s2] / 2 ** 20) + "MB / " + r2[s2]);
    for (let _2 = i2.length - 1; _2 >= 0; --_2) {
      const e3 = i2[_2];
      e3 && (t2["Priority " + (_2 + s$X - 1)] = Math.round(e3 / this.size * 100) + "%");
    }
    return t2;
  }
  resetStats() {
    this._hit = this._miss = 0, this._users.forAll((t2) => t2.resetHitRate());
  }
  clear(t2) {
    this._db.forEach((e2, s2) => {
      s2.startsWith(t2) && (this._size -= e2.size, this._db.delete(s2), this._notifyRemove(s2, e2.entry, i$1l.ALL));
    });
  }
  clearAll() {
    this._db.forEach((t2, e2) => this._notifyRemove(e2, t2.entry, i$1l.ALL)), this._size = 0, this._db.clear();
  }
  _getHitRate() {
    return this._hit / (this._hit + this._miss);
  }
  _notifyRemove(t2, e2, s2) {
    let i2;
    return this._removeFuncs.some((r2) => {
      if (t2.startsWith(r2[0])) {
        const t3 = r2[1](e2, s2);
        return typeof t3 == "number" && (i2 = t3), true;
      }
      return false;
    }), i2;
  }
  _checkSizeLimit() {
    if (!(this._size <= this._maxSize))
      for (const [e2, s2] of this._db) {
        if (this._db.delete(e2), s2.lives <= 1) {
          this._size -= s2.size;
          const r2 = this._notifyRemove(e2, s2.entry, i$1l.SOME);
          r$1t(r2) && r2 > 0 && (this._size += r2, s2.lives = s2.lifetime, s2.size = r2, this._db.set(e2, s2));
        } else
          --s2.lives, this._db.set(e2, s2);
        if (this._size <= 0.9 * this.maxSize)
          return;
      }
  }
}
class e$N {
  constructor(e2, s2) {
    this._storage = new h$F(), this._storage.maxSize = e2, s2 && this._storage.registerRemoveFunc("", s2);
  }
  put(t2, e2) {
    this._storage.put(t2, e2, 1, 1);
  }
  pop(t2) {
    return this._storage.pop(t2);
  }
  get(t2) {
    return this._storage.get(t2);
  }
  clear() {
    this._storage.clearAll();
  }
  destroy() {
    this._storage.destroy();
  }
}
new e$N(1e3);
new l$1D([128, 128, 128]);
const h$E = new l$1D("white");
function j$m(r2, n2) {
  if (!r2)
    return null;
  let l2 = null;
  return c$1N(r2) ? l2 = k$9(r2) : x$v(r2) && (l2 = r2.color ? new l$1D(r2.color) : null), l2 ? L$e(l2, n2) : null;
}
function k$9(t2) {
  const o2 = t2.symbolLayers;
  if (!o2)
    return null;
  let r2 = null;
  return o2.forEach((e2) => {
    var _a2;
    e2.type === "object" && ((_a2 = e2.resource) == null ? void 0 : _a2.href) != null || (r2 = e2.type === "water" ? e$1U(e2.color) : r$1t(e2.material) ? e$1U(e2.material.color) : null);
  }), r2 ? new l$1D(r2) : null;
}
function L$e(t2, o2) {
  if (o2 == null || t2 == null)
    return t2;
  const r2 = t2.toRgba();
  return r2[3] = r2[3] * o2, new l$1D(r2);
}
function z$e(e2, t2, o2) {
  const r2 = e2.symbolLayers;
  if (!r2)
    return;
  const i2 = (e3) => {
    var _a2;
    const r3 = r$1t(e3) ? e3 : null;
    return L$e(t2 = (_a2 = t2 != null ? t2 : r3) != null ? _a2 : o2 != null ? h$E : null, o2);
  };
  r2.forEach((e3) => {
    var _a2;
    if (e3.type !== "object" || ((_a2 = e3.resource) == null ? void 0 : _a2.href) == null || t2)
      if (e3.type === "water")
        e3.color = i2(e3.color);
      else {
        const t3 = r$1t(e3.material) ? e3.material.color : null, r3 = i2(t3);
        t$1W(e3.material) ? e3.material = new l$1A({ color: r3 }) : e3.material.color = r3, o2 != null && "outline" in e3 && r$1t(e3.outline) && r$1t(e3.outline.color) && (e3.outline.color = L$e(e3.outline.color, o2));
      }
  });
}
function v$u(e2, t2, o2) {
  (t2 = t2 != null ? t2 : e2.color) && (e2.color = L$e(t2, o2)), o2 != null && "outline" in e2 && e2.outline && e2.outline.color && (e2.outline.color = L$e(e2.outline.color, o2));
}
function x$m(r2, n2, l2) {
  r2 && (n2 || l2 != null) && (n2 && (n2 = new l$1D(n2)), c$1N(r2) ? z$e(r2, n2, l2) : x$v(r2) && v$u(r2, n2, l2));
}
async function S$l(e2, t2) {
  const o2 = e2.symbolLayers;
  o2 && await c$1r(o2, async (e3) => U$c(e3, t2));
}
async function U$c(e2, t2) {
  switch (e2.type) {
    case "extrude":
      R$d(e2, t2);
      break;
    case "icon":
    case "line":
    case "text":
      O$9(e2, t2);
      break;
    case "path":
      A$7(e2, t2);
      break;
    case "object":
      await $$5(e2, t2);
  }
}
function O$9(e2, t2) {
  const o2 = E$e(t2);
  r$1t(o2) && (e2.size = o2);
}
function E$e(e2) {
  for (const t2 of e2)
    if (typeof t2 == "number")
      return t2;
  return null;
}
function R$d(e2, t2) {
  e2.size = typeof t2[2] == "number" ? t2[2] : 0;
}
async function $$5(e2, t2) {
  const { resourceSize: o2, symbolSize: r2 } = await D$9(e2), n2 = C$e(t2, o2, r2);
  e2.width = I$h(t2[0], r2[0], o2[0], n2), e2.depth = I$h(t2[1], r2[1], o2[1], n2), e2.height = I$h(t2[2], r2[2], o2[2], n2);
}
function A$7(e2, t2) {
  const o2 = C$e(t2, l$1H, [e2.width, void 0, e2.height]);
  e2.width = I$h(t2[0], e2.width, 1, o2), e2.height = I$h(t2[2], e2.height, 1, o2);
}
function C$e(e2, t2, o2) {
  for (let r2 = 0; r2 < 3; r2++) {
    const n2 = e2[r2];
    switch (n2) {
      case "symbol-value": {
        const e3 = o2[r2];
        return e3 != null ? e3 / t2[r2] : 1;
      }
      case "proportional":
        break;
      default:
        if (n2 && t2[r2])
          return n2 / t2[r2];
    }
  }
  return 1;
}
async function D$9(e2) {
  const t2 = await import("./symbolLayerUtils.js"), o2 = await t2.computeObjectLayerResourceSize(e2, 10), { width: r2, height: n2, depth: l2 } = e2, i2 = [r2, l2, n2];
  let s2 = 1;
  for (let c2 = 0; c2 < 3; c2++) {
    const e3 = i2[c2];
    if (e3 != null) {
      s2 = e3 / o2[c2];
      break;
    }
  }
  for (let c2 = 0; c2 < 3; c2++)
    i2[c2] == null && (i2[c2] = o2[c2] * s2);
  return { resourceSize: o2, symbolSize: i2 };
}
function I$h(e2, t2, o2, r2) {
  switch (e2) {
    case "proportional":
      return o2 * r2;
    case "symbol-value":
      return t2 != null ? t2 : o2;
    default:
      return e2;
  }
}
function J$4(e2, t2) {
  const o2 = E$e(t2);
  if (!t$1W(o2))
    switch (e2.type) {
      case "simple-marker":
        e2.size = o2;
        break;
      case "picture-marker": {
        const t3 = e2.width / e2.height;
        t3 > 1 ? (e2.width = o2, e2.height = o2 * t3) : (e2.width = o2 * t3, e2.height = o2);
        break;
      }
      case "simple-line":
        e2.width = o2;
        break;
      case "text":
        e2.font.size = o2;
    }
}
async function M$9(e2, r2) {
  if (e2 && r2)
    return c$1N(e2) ? S$l(e2, r2) : void (x$v(e2) && J$4(e2, r2));
}
function N$5(e2, r2, n2) {
  if (e2 && r2 != null)
    if (c$1N(e2)) {
      const t2 = e2.symbolLayers;
      t2 && t2.forEach((e3) => {
        if (e3 && e3.type === "object")
          switch (n2) {
            case "tilt":
              e3.tilt = r2;
              break;
            case "roll":
              e3.roll = r2;
              break;
            default:
              e3.heading = r2;
          }
      });
    } else
      x$v(e2) && (e2.type !== "simple-marker" && e2.type !== "picture-marker" && e2.type !== "text" || (e2.angle = r2));
}
const s$W = "<", i$1k = ">", r$G = S$B("short-date");
function o$Q(t2, l2, o2, e2) {
  let n2 = "";
  l2 === 0 ? n2 = `${s$W} ` : l2 === o2 && (n2 = `${i$1k} `);
  let u2 = null;
  return u2 = e2 ? L$p(t2, r$G) : c$1t(t2), n2 + u2;
}
const o$P = new l$1D([64, 64, 64]);
function n$1c(l2, o2) {
  const n2 = [], r2 = l2.length - 1;
  return l2.length === 5 ? n2.push(0, 2, 4) : n2.push(0, r2), l2.map((l3, t2) => n2.includes(t2) ? o$Q(l3, t2, r2, o2) : null);
}
async function r$F(l2, e2, o2) {
  let r2 = false, a2 = [], u2 = [];
  if (l2.stops) {
    const e3 = l2.stops;
    a2 = e3.map((l3) => l3.value), r2 = e3.some((l3) => !!l3.label), r2 && (u2 = e3.map((l3) => l3.label));
  }
  const s2 = a2[0], i2 = a2[a2.length - 1];
  if (s2 == null && i2 == null)
    return null;
  const c2 = r2 ? null : n$1c(a2, o2);
  return (await Promise.all(a2.map(async (o3, n2) => ({ value: o3, color: l2.type === "opacity" ? await t$T(o3, l2, e2) : (await Promise.resolve().then(function() {
    return visualVariableUtils;
  })).getColor(l2, o3), label: r2 ? u2[n2] : c2[n2] })))).reverse();
}
async function t$T(e2, n2, r2 = o$P) {
  const t2 = new l$1D(r2), a2 = (await Promise.resolve().then(function() {
    return visualVariableUtils;
  })).getOpacity(n2, e2);
  return a2 != null && (t2.a = a2), t2;
}
var c$1n;
let i$1j = c$1n = class extends l$1_ {
  constructor(o2) {
    super(o2), this.color = null, this.ratio = null;
  }
  clone() {
    return new c$1n({ color: this.color, ratio: this.ratio });
  }
};
e$1W([y$1o({ type: l$1D, json: { type: [T$r], default: null, write: true } })], i$1j.prototype, "color", void 0), e$1W([y$1o({ type: Number, json: { write: true } })], i$1j.prototype, "ratio", void 0), i$1j = c$1n = e$1W([n$2f("esri.renderers.support.HeatmapColorStop")], i$1j);
const a$1n = i$1j;
function r$E(r2) {
  if (!r2.colorStops)
    return [];
  const e2 = [...r2.colorStops].filter((o2) => {
    var _a2;
    return ((_a2 = o2.color) == null ? void 0 : _a2.a) > 0;
  });
  let t2 = e2.length - 1;
  if (e2 && e2[0]) {
    const r3 = e2[t2];
    r3 && r3.ratio !== 1 && (e2.push(new a$1n({ ratio: 1, color: r3.color })), t2++);
  }
  return e2.map((o2, e3) => {
    var _a2, _b2;
    let l2 = "";
    return e3 === 0 ? l2 = ((_a2 = r2.legendOptions) == null ? void 0 : _a2.minLabel) || "low" : e3 === t2 && (l2 = ((_b2 = r2.legendOptions) == null ? void 0 : _b2.maxLabel) || "high"), { color: o2.color, label: l2, ratio: o2.ratio };
  }).reverse();
}
s$22.getLogger("esri.renderers.support.utils");
async function h$D(e2, t2, i2) {
  r$1r(e2, t2, () => []).push(...i2);
}
async function b$u(t2) {
  var _a2, _b2, _c2, _d2;
  const l2 = new Map();
  if (!t2)
    return l2;
  if ("visualVariables" in t2 && t2.visualVariables) {
    const e2 = t2.visualVariables.filter((e3) => e3.type === "color");
    for (const t3 of e2) {
      const e3 = (await r$F(t3)).map((e4) => e4.color);
      await h$D(l2, t3.field || t3.valueExpression, e3);
    }
  }
  if (t2.type === "heatmap") {
    const e2 = r$E(t2).map((e3) => e3.color);
    await h$D(l2, t2.field || t2.valueExpression, e2);
  } else if (t2.type === "pie-chart") {
    for (const e2 of t2.attributes)
      await h$D(l2, e2.field || e2.valueExpression, [e2.color]);
    await h$D(l2, "default", [(_a2 = t2 == null ? void 0 : t2.othersCategory) == null ? void 0 : _a2.color, j$m(t2.backgroundFillSymbol, null)]);
  } else if (t2.type === "dot-density") {
    for (const e2 of t2.attributes)
      await h$D(l2, e2.field || e2.valueExpression, [e2.color]);
    await h$D(l2, "default", [t2.backgroundColor]);
  } else if (t2.type === "unique-value")
    if (((_b2 = t2.authoringInfo) == null ? void 0 : _b2.type) === "predominance")
      for (const e2 of (_c2 = t2.uniqueValueInfos) != null ? _c2 : [])
        await h$D(l2, e2.value.toString(), [j$m(e2.symbol, null)]);
    else {
      const e2 = ((_d2 = t2.uniqueValueInfos) != null ? _d2 : []).map((e3) => j$m(e3.symbol, null)), { field: i2, field2: o2, field3: n2, valueExpression: a2 } = t2;
      (i2 || a2) && await h$D(l2, i2 || a2, e2), o2 && await h$D(l2, o2, e2), n2 && await h$D(l2, n2, e2);
    }
  else if (t2.type === "class-breaks") {
    const e2 = t2.classBreakInfos.map((e3) => j$m(e3.symbol, null)), { field: i2, valueExpression: o2 } = t2;
    await h$D(l2, i2 != null ? i2 : o2, e2);
  } else
    t2.type === "simple" && await h$D(l2, "default", [j$m(t2.symbol, null)]);
  return "defaultSymbol" in t2 && t2.defaultSymbol && await h$D(l2, "default", [j$m(t2.defaultSymbol, null)]), l2.forEach((t3, i2) => {
    const o2 = u$1Z(t3.filter(Boolean), (e2, t4) => JSON.stringify(e2) === JSON.stringify(t4));
    l2.set(i2, o2);
  }), l2;
}
var t$S;
let p$1E = t$S = class extends l$1_ {
  constructor(r2) {
    super(r2), this.name = null, this.code = null;
  }
  clone() {
    return new t$S({ name: this.name, code: this.code });
  }
};
e$1W([y$1o({ type: String, json: { write: true } })], p$1E.prototype, "name", void 0), e$1W([y$1o({ type: [String, Number], json: { write: true } })], p$1E.prototype, "code", void 0), p$1E = t$S = e$1W([n$2f("esri.layers.support.CodedValue")], p$1E);
const c$1m = new s$1F({ inherited: "inherited", codedValue: "coded-value", range: "range" });
let a$1m = class extends l$1_ {
  constructor(r2) {
    super(r2), this.name = null, this.type = null;
  }
};
e$1W([y$1o({ type: String, json: { write: true } })], a$1m.prototype, "name", void 0), e$1W([r$1a(c$1m)], a$1m.prototype, "type", void 0), a$1m = e$1W([n$2f("esri.layers.support.Domain")], a$1m);
const i$1i = a$1m;
var d$J;
let p$1D = d$J = class extends i$1i {
  constructor(e2) {
    super(e2), this.codedValues = null, this.type = "coded-value";
  }
  getName(e2) {
    let o2 = null;
    if (this.codedValues) {
      const r2 = String(e2);
      this.codedValues.some((e3) => (String(e3.code) === r2 && (o2 = e3.name), !!o2));
    }
    return o2;
  }
  clone() {
    return new d$J({ codedValues: y$1r(this.codedValues), name: this.name });
  }
};
e$1W([y$1o({ type: [p$1E], json: { write: true } })], p$1D.prototype, "codedValues", void 0), e$1W([r$1a({ codedValue: "coded-value" })], p$1D.prototype, "type", void 0), p$1D = d$J = e$1W([n$2f("esri.layers.support.CodedValueDomain")], p$1D);
const u$T = p$1D;
var t$R;
let i$1h = t$R = class extends i$1i {
  constructor(r2) {
    super(r2), this.type = "inherited";
  }
  clone() {
    return new t$R();
  }
};
e$1W([r$1a({ inherited: "inherited" })], i$1h.prototype, "type", void 0), i$1h = t$R = e$1W([n$2f("esri.layers.support.InheritedDomain")], i$1h);
const p$1C = i$1h;
var s$V;
let n$1b = s$V = class extends i$1i {
  constructor(e2) {
    super(e2), this.maxValue = null, this.minValue = null, this.type = "range";
  }
  clone() {
    return new s$V({ maxValue: this.maxValue, minValue: this.minValue, name: this.name });
  }
};
e$1W([y$1o({ type: Number, json: { type: [Number], read: { source: "range", reader: (e2, r2) => r2.range && r2.range[1] }, write: { enabled: false, overridePolicy() {
  return { enabled: this.maxValue != null && this.minValue == null };
}, target: "range", writer(e2, r2, a2) {
  r2[a2] = [this.minValue || 0, e2];
} } } })], n$1b.prototype, "maxValue", void 0), e$1W([y$1o({ type: Number, json: { type: [Number], read: { source: "range", reader: (e2, r2) => r2.range && r2.range[0] }, write: { target: "range", writer(e2, r2, a2) {
  r2[a2] = [e2, this.maxValue || 0];
} } } })], n$1b.prototype, "minValue", void 0), e$1W([r$1a({ range: "range" })], n$1b.prototype, "type", void 0), n$1b = s$V = e$1W([n$2f("esri.layers.support.RangeDomain")], n$1b);
const i$1g = n$1b;
const n$1a = { key: "type", base: i$1i, typeMap: { range: i$1g, "coded-value": u$T, inherited: p$1C } };
function t$Q(o2) {
  if (!o2 || !o2.type)
    return null;
  switch (o2.type) {
    case "range":
      return i$1g.fromJSON(o2);
    case "codedValue":
      return u$T.fromJSON(o2);
    case "inherited":
      return p$1C.fromJSON(o2);
  }
  return null;
}
const i$1f = new s$1F({ esriFieldTypeSmallInteger: "small-integer", esriFieldTypeInteger: "integer", esriFieldTypeSingle: "single", esriFieldTypeDouble: "double", esriFieldTypeLong: "long", esriFieldTypeString: "string", esriFieldTypeDate: "date", esriFieldTypeOID: "oid", esriFieldTypeGeometry: "geometry", esriFieldTypeBlob: "blob", esriFieldTypeRaster: "raster", esriFieldTypeGUID: "guid", esriFieldTypeGlobalID: "global-id", esriFieldTypeXML: "xml" });
var u$S;
const c$1l = new s$1F({ binary: "binary", coordinate: "coordinate", countOrAmount: "count-or-amount", dateAndTime: "date-and-time", description: "description", locationOrPlaceName: "location-or-place-name", measurement: "measurement", nameOrTitle: "name-or-title", none: "none", orderedOrRanked: "ordered-or-ranked", percentageOrRatio: "percentage-or-ratio", typeOrCategory: "type-or-category", uniqueIdentifier: "unique-identifier" });
let m$T = u$S = class extends l$1_ {
  constructor(e2) {
    super(e2), this.alias = null, this.defaultValue = void 0, this.description = null, this.domain = null, this.editable = true, this.length = -1, this.name = null, this.nullable = true, this.type = null, this.valueType = null, this.visible = true;
  }
  readDescription(e2, { description: t2 }) {
    var _a2;
    let o2 = null;
    try {
      o2 = t2 ? JSON.parse(t2) : null;
    } catch (r2) {
    }
    return (_a2 = o2 == null ? void 0 : o2.value) != null ? _a2 : null;
  }
  readValueType(e2, { description: t2 }) {
    let o2 = null;
    try {
      o2 = t2 ? JSON.parse(t2) : null;
    } catch (r2) {
    }
    return o2 ? c$1l.fromJSON(o2.fieldValueType) : null;
  }
  clone() {
    return new u$S({ alias: this.alias, defaultValue: this.defaultValue, description: this.description, domain: this.domain && this.domain.clone() || null, editable: this.editable, length: this.length, name: this.name, nullable: this.nullable, type: this.type, valueType: this.valueType, visible: this.visible });
  }
};
e$1W([y$1o({ type: String, json: { write: true } })], m$T.prototype, "alias", void 0), e$1W([y$1o({ type: [String, Number], json: { write: { allowNull: true } } })], m$T.prototype, "defaultValue", void 0), e$1W([y$1o()], m$T.prototype, "description", void 0), e$1W([o$1H("description")], m$T.prototype, "readDescription", null), e$1W([y$1o({ types: n$1a, json: { read: { reader: t$Q }, write: true } })], m$T.prototype, "domain", void 0), e$1W([y$1o({ type: Boolean, json: { write: true } })], m$T.prototype, "editable", void 0), e$1W([y$1o({ type: T$r, json: { write: true } })], m$T.prototype, "length", void 0), e$1W([y$1o({ type: String, json: { write: true } })], m$T.prototype, "name", void 0), e$1W([y$1o({ type: Boolean, json: { write: true } })], m$T.prototype, "nullable", void 0), e$1W([r$1a(i$1f)], m$T.prototype, "type", void 0), e$1W([y$1o()], m$T.prototype, "valueType", void 0), e$1W([o$1H("valueType", ["description"])], m$T.prototype, "readValueType", null), e$1W([y$1o({ type: Boolean, json: { read: false } })], m$T.prototype, "visible", void 0), m$T = u$S = e$1W([n$2f("esri.layers.support.Field")], m$T);
const y$H = m$T;
var a$1l;
let c$1k = a$1l = class extends l$1_ {
  constructor(r2) {
    super(r2), this.type = "map-layer";
  }
  clone() {
    const { mapLayerId: r2, gdbVersion: o2 } = this;
    return new a$1l({ mapLayerId: r2, gdbVersion: o2 });
  }
};
e$1W([r$1a({ mapLayer: "map-layer" })], c$1k.prototype, "type", void 0), e$1W([y$1o({ type: T$r, json: { write: true } })], c$1k.prototype, "mapLayerId", void 0), e$1W([y$1o({ type: String, json: { write: true } })], c$1k.prototype, "gdbVersion", void 0), c$1k = a$1l = e$1W([n$2f("esri.layers.support.source.MapLayerSource")], c$1k);
var c$1j;
let y$G = c$1j = class extends l$1_ {
  constructor(e2) {
    super(e2), this.type = "query-table";
  }
  clone() {
    var _a2;
    const { workspaceId: e2, query: r2, oidFields: o2, spatialReference: t2, geometryType: p2 } = this, s2 = { workspaceId: e2, query: r2, oidFields: o2, spatialReference: (_a2 = t2 == null ? void 0 : t2.clone()) != null ? _a2 : void 0, geometryType: p2 };
    return new c$1j(s2);
  }
};
e$1W([r$1a({ queryTable: "query-table" })], y$G.prototype, "type", void 0), e$1W([y$1o({ type: String, json: { write: true } })], y$G.prototype, "workspaceId", void 0), e$1W([y$1o({ type: String, json: { write: true } })], y$G.prototype, "query", void 0), e$1W([y$1o({ type: String, json: { write: true } })], y$G.prototype, "oidFields", void 0), e$1W([y$1o({ type: k$p, json: { write: true } })], y$G.prototype, "spatialReference", void 0), e$1W([r$1a(i$2a)], y$G.prototype, "geometryType", void 0), y$G = c$1j = e$1W([n$2f("esri.layers.support.source.QueryTableDataSource")], y$G);
var p$1B;
let a$1k = p$1B = class extends l$1_ {
  constructor(r2) {
    super(r2), this.type = "raster";
  }
  clone() {
    const { workspaceId: r2, dataSourceName: o2 } = this;
    return new p$1B({ workspaceId: r2, dataSourceName: o2 });
  }
};
e$1W([r$1a({ raster: "raster" })], a$1k.prototype, "type", void 0), e$1W([y$1o({ type: String, json: { write: true } })], a$1k.prototype, "dataSourceName", void 0), e$1W([y$1o({ type: String, json: { write: true } })], a$1k.prototype, "workspaceId", void 0), a$1k = p$1B = e$1W([n$2f("esri.layers.support.source.RasterDataSource")], a$1k);
var p$1A;
let a$1j = p$1A = class extends l$1_ {
  constructor(r2) {
    super(r2), this.type = "table";
  }
  clone() {
    const { workspaceId: r2, gdbVersion: o2, dataSourceName: e2 } = this;
    return new p$1A({ workspaceId: r2, gdbVersion: o2, dataSourceName: e2 });
  }
};
e$1W([r$1a({ table: "table" })], a$1j.prototype, "type", void 0), e$1W([y$1o({ type: String, json: { write: true } })], a$1j.prototype, "workspaceId", void 0), e$1W([y$1o({ type: String, json: { write: true } })], a$1j.prototype, "gdbVersion", void 0), e$1W([y$1o({ type: String, json: { write: true } })], a$1j.prototype, "dataSourceName", void 0), a$1j = p$1A = e$1W([n$2f("esri.layers.support.source.TableDataSource")], a$1j);
var d$I, m$S;
const j$l = o$1w()({ esriLeftInnerJoin: "left-inner-join", esriLeftOuterJoin: "left-outer-join" });
let T$d = d$I = class extends l$1_ {
  constructor(e2) {
    super(e2), this.type = "join-table";
  }
  readLeftTableSource(e2, r2, o2) {
    return g$z()(e2, r2, o2);
  }
  castLeftTableSource(e2) {
    return S$H(L$d(), e2);
  }
  readRightTableSource(e2, r2, o2) {
    return g$z()(e2, r2, o2);
  }
  castRightTableSource(e2) {
    return S$H(L$d(), e2);
  }
  clone() {
    var _a2, _b2;
    const { leftTableKey: e2, rightTableKey: r2, leftTableSource: o2, rightTableSource: t2, joinType: a2 } = this, s2 = { leftTableKey: e2, rightTableKey: r2, leftTableSource: (_a2 = o2 == null ? void 0 : o2.clone()) != null ? _a2 : void 0, rightTableSource: (_b2 = t2 == null ? void 0 : t2.clone()) != null ? _b2 : void 0, joinType: a2 };
    return new d$I(s2);
  }
};
e$1W([r$1a({ joinTable: "join-table" })], T$d.prototype, "type", void 0), e$1W([y$1o({ type: String, json: { write: true } })], T$d.prototype, "leftTableKey", void 0), e$1W([y$1o({ type: String, json: { write: true } })], T$d.prototype, "rightTableKey", void 0), e$1W([y$1o({ json: { write: true } })], T$d.prototype, "leftTableSource", void 0), e$1W([o$1H("leftTableSource")], T$d.prototype, "readLeftTableSource", null), e$1W([s$1N("leftTableSource")], T$d.prototype, "castLeftTableSource", null), e$1W([y$1o({ json: { write: true } })], T$d.prototype, "rightTableSource", void 0), e$1W([o$1H("rightTableSource")], T$d.prototype, "readRightTableSource", null), e$1W([s$1N("rightTableSource")], T$d.prototype, "castRightTableSource", null), e$1W([r$1a(j$l)], T$d.prototype, "joinType", void 0), T$d = d$I = e$1W([n$2f("esri.layers.support.source.JoinTableDataSource")], T$d);
let h$C = null;
function g$z() {
  return h$C || (h$C = s$1W({ types: L$d() })), h$C;
}
let v$t = null;
function L$d() {
  return v$t || (v$t = { key: "type", base: null, typeMap: { "data-layer": K$4, "map-layer": c$1k } }), v$t;
}
const w$q = { key: "type", base: null, typeMap: { "join-table": T$d, "query-table": y$G, raster: a$1k, table: a$1j } };
let K$4 = m$S = class extends l$1_ {
  constructor(e2) {
    super(e2), this.type = "data-layer";
  }
  clone() {
    const { fields: e2, dataSource: r2 } = this;
    return new m$S({ fields: e2, dataSource: r2 });
  }
};
e$1W([r$1a({ dataLayer: "data-layer" })], K$4.prototype, "type", void 0), e$1W([y$1o({ type: [y$H], json: { write: true } })], K$4.prototype, "fields", void 0), e$1W([y$1o({ types: w$q, json: { write: true } })], K$4.prototype, "dataSource", void 0), K$4 = m$S = e$1W([n$2f("esri.layers.support.source.DataLayerSource")], K$4), K$4.from = b$U(K$4);
function i$1e(r2, t2) {
  return t2 ? __spreadProps(__spreadValues({}, t2), { query: __spreadValues(__spreadValues({}, r2), t2.query) }) : { query: r2 };
}
function f$N(r2) {
  return typeof r2 == "string" ? j$B(r2) : y$1r(r2);
}
function s$U(r2, t2, o2) {
  const e2 = {};
  for (const n2 in r2) {
    if (n2 === "declaredClass")
      continue;
    const i2 = r2[n2];
    if (i2 != null && typeof i2 != "function")
      if (Array.isArray(i2)) {
        e2[n2] = [];
        for (let r3 = 0; r3 < i2.length; r3++)
          e2[n2][r3] = s$U(i2[r3]);
      } else if (typeof i2 == "object")
        if (i2.toJSON) {
          const r3 = i2.toJSON(o2 && o2[n2]);
          e2[n2] = t2 ? r3 : JSON.stringify(r3);
        } else
          e2[n2] = t2 ? i2 : JSON.stringify(i2);
      else
        e2[n2] = i2;
  }
  return e2;
}
const r$D = { 102100: { maxX: 20037508342788905e-9, minX: -20037508342788905e-9, plus180Line: new m$1D({ paths: [[[20037508342788905e-9, -20037508342788905e-9], [20037508342788905e-9, 20037508342788905e-9]]], spatialReference: k$p.WebMercator }), minus180Line: new m$1D({ paths: [[[-20037508342788905e-9, -20037508342788905e-9], [-20037508342788905e-9, 20037508342788905e-9]]], spatialReference: k$p.WebMercator }) }, 4326: { maxX: 180, minX: -180, plus180Line: new m$1D({ paths: [[[180, -180], [180, 180]]], spatialReference: k$p.WGS84 }), minus180Line: new m$1D({ paths: [[[-180, -180], [-180, 180]]], spatialReference: k$p.WGS84 }) } };
function i$1d(e2, n2) {
  return Math.ceil((e2 - n2) / (2 * n2));
}
function s$T(e2, n2) {
  const t2 = o$O(e2);
  for (const r2 of t2)
    for (const e3 of r2)
      e3[0] += n2;
  return e2;
}
function o$O(e2) {
  return y$1a(e2) ? e2.rings : e2.paths;
}
async function o$N(o2, i2, n2, m2) {
  const a2 = f$N(o2), p2 = i2[0].spatialReference, u2 = __spreadProps(__spreadValues({}, m2), { query: __spreadProps(__spreadValues({}, a2.query), { f: "json", sr: JSON.stringify(p2), target: JSON.stringify({ geometryType: c$2v(i2[0]), geometries: i2 }), cutter: JSON.stringify(n2) }) }), c2 = await U$k(a2.path + "/cut", u2), { cutIndexes: f2, geometries: g2 = [] } = c2.data;
  return { cutIndexes: f2, geometries: g2.map((e2) => {
    const t2 = v$N(e2);
    return t2.spatialReference = p2, t2;
  }) };
}
function r$C(t2) {
  return { geometryType: c$2v(t2[0]), geometries: t2.map((e2) => e2.toJSON()) };
}
function o$M(e2, r2, o2) {
  const n2 = d$1p(r2);
  return e2.map((e3) => {
    const t2 = n2.fromJSON(e3);
    return t2.spatialReference = o2, t2;
  });
}
async function o$L(o2, m2, f2) {
  const n2 = typeof o2 == "string" ? j$B(o2) : o2, p2 = m2[0].spatialReference, a2 = c$2v(m2[0]), u2 = __spreadProps(__spreadValues({}, f2), { query: __spreadProps(__spreadValues({}, n2.query), { f: "json", sr: p2.wkid ? p2.wkid : JSON.stringify(p2), geometries: JSON.stringify(r$C(m2)) }) }), { data: y2 } = await U$k(n2.path + "/simplify", u2);
  return o$M(y2.geometries, a2, p2);
}
const y$F = s$22.getLogger("esri.geometry.support.normalizeUtils");
function x$l(e2) {
  return e2.type === "polygon";
}
function d$H(e2) {
  return e2[0].type === "polygon";
}
function w$p(e2) {
  return e2[0].type === "polyline";
}
function M$8(e2, n2) {
  if (!(e2 instanceof m$1D || e2 instanceof v$O)) {
    const e3 = "straightLineDensify: the input geometry is neither polyline nor polygon";
    throw y$F.error(e3), new s$1Z(e3);
  }
  const o2 = o$O(e2), s2 = [];
  for (const t2 of o2) {
    const e3 = [];
    s2.push(e3), e3.push([t2[0][0], t2[0][1]]);
    for (let o3 = 0; o3 < t2.length - 1; o3++) {
      const s3 = t2[o3][0], r2 = t2[o3][1], i2 = t2[o3 + 1][0], l2 = t2[o3 + 1][1], f2 = Math.sqrt((i2 - s3) * (i2 - s3) + (l2 - r2) * (l2 - r2)), c2 = (l2 - r2) / f2, p2 = (i2 - s3) / f2, u2 = f2 / n2;
      if (u2 > 1) {
        for (let l3 = 1; l3 <= u2 - 1; l3++) {
          const t4 = l3 * n2, o5 = p2 * t4 + s3, i4 = c2 * t4 + r2;
          e3.push([o5, i4]);
        }
        const t3 = (f2 + Math.floor(u2 - 1) * n2) / 2, o4 = p2 * t3 + s3, i3 = c2 * t3 + r2;
        e3.push([o4, i3]);
      }
      e3.push([i2, l2]);
    }
  }
  return x$l(e2) ? new v$O({ rings: s2, spatialReference: e2.spatialReference }) : new m$1D({ paths: s2, spatialReference: e2.spatialReference });
}
function R$c(e2, t2, n2) {
  if (t2) {
    const t3 = M$8(e2, 1e6);
    e2 = j$H(t3, true);
  }
  return n2 && (e2 = s$T(e2, n2)), e2;
}
function b$t(e2, t2, n2) {
  if (Array.isArray(e2)) {
    const o2 = e2[0];
    if (o2 > t2) {
      const n3 = i$1d(o2, t2);
      e2[0] = o2 + n3 * (-2 * t2);
    } else if (o2 < n2) {
      const t3 = i$1d(o2, n2);
      e2[0] = o2 + t3 * (-2 * n2);
    }
  } else {
    const o2 = e2.x;
    if (o2 > t2) {
      const n3 = i$1d(o2, t2);
      e2 = e2.clone().offset(n3 * (-2 * t2), 0);
    } else if (o2 < n2) {
      const t3 = i$1d(o2, n2);
      e2 = e2.clone().offset(t3 * (-2 * n2), 0);
    }
  }
  return e2;
}
function P$c(e2, t2) {
  let n2 = -1;
  for (let o2 = 0; o2 < t2.cutIndexes.length; o2++) {
    const s2 = t2.cutIndexes[o2], r2 = t2.geometries[o2], i2 = o$O(r2);
    for (let e3 = 0; e3 < i2.length; e3++) {
      const t3 = i2[e3];
      t3.some((n3) => {
        if (n3[0] < 180)
          return true;
        {
          let n4 = 0;
          for (let e4 = 0; e4 < t3.length; e4++) {
            const o4 = t3[e4][0];
            n4 = o4 > n4 ? o4 : n4;
          }
          n4 = Number(n4.toFixed(9));
          const o3 = -360 * i$1d(n4, 180);
          for (let s3 = 0; s3 < t3.length; s3++) {
            const t4 = r2.getPoint(e3, s3);
            r2.setPoint(e3, s3, t4.clone().offset(o3, 0));
          }
          return true;
        }
      });
    }
    if (s2 === n2) {
      if (d$H(e2))
        for (const t3 of o$O(r2))
          e2[s2] = e2[s2].addRing(t3);
      else if (w$p(e2))
        for (const t3 of o$O(r2))
          e2[s2] = e2[s2].addPath(t3);
    } else
      n2 = s2, e2[s2] = r2;
  }
  return e2;
}
async function v$s(t2, n2, l2) {
  var _a2;
  if (!Array.isArray(t2))
    return v$s([t2], n2);
  n2 && typeof n2 != "string" && y$F.warn("normalizeCentralMeridian()", "The url object is deprecated, use the url string instead");
  const h2 = typeof n2 == "string" ? n2 : (_a2 = n2 == null ? void 0 : n2.url) != null ? _a2 : s$23.geometryServiceUrl;
  let x2, d2, w2, j2, M2, L2, U2, z2, A2 = 0;
  const S2 = [], k2 = [];
  for (const e2 of t2)
    if (t$1W(e2))
      k2.push(e2);
    else if (x2 || (x2 = e2.spatialReference, d2 = R$n(x2), w2 = x2.isWebMercator, L2 = w2 ? 102100 : 4326, j2 = r$D[L2].maxX, M2 = r$D[L2].minX, U2 = r$D[L2].plus180Line, z2 = r$D[L2].minus180Line), d2)
      if (e2.type === "mesh")
        k2.push(e2);
      else if (e2.type === "point")
        k2.push(b$t(e2.clone(), j2, M2));
      else if (e2.type === "multipoint") {
        const t3 = e2.clone();
        t3.points = t3.points.map((e3) => b$t(e3, j2, M2)), k2.push(t3);
      } else if (e2.type === "extent") {
        const t3 = e2.clone()._normalize(false, false, d2);
        k2.push(t3.rings ? new v$O(t3) : t3);
      } else if (e2.extent) {
        const t3 = e2.extent, n3 = i$1d(t3.xmin, M2) * (2 * j2);
        let o2 = n3 === 0 ? e2.clone() : s$T(e2.clone(), n3);
        t3.offset(n3, 0), t3.intersects(U2) && t3.xmax !== j2 ? (A2 = t3.xmax > A2 ? t3.xmax : A2, o2 = R$c(o2, w2), S2.push(o2), k2.push("cut")) : t3.intersects(z2) && t3.xmin !== M2 ? (A2 = t3.xmax * (2 * j2) > A2 ? t3.xmax * (2 * j2) : A2, o2 = R$c(o2, w2, 360), S2.push(o2), k2.push("cut")) : k2.push(o2);
      } else
        k2.push(e2.clone());
    else
      k2.push(e2);
  let C2 = i$1d(A2, j2), I2 = -90;
  const X2 = C2, q2 = new m$1D();
  for (; C2 > 0; ) {
    const e2 = 360 * C2 - 180;
    q2.addPath([[e2, I2], [e2, -1 * I2]]), I2 *= -1, C2--;
  }
  if (S2.length > 0 && X2 > 0) {
    const e2 = P$c(S2, await o$N(h2, S2, q2, l2)), n3 = [], o2 = [];
    for (let l3 = 0; l3 < k2.length; l3++) {
      const r3 = k2[l3];
      if (r3 !== "cut")
        o2.push(r3);
      else {
        const r4 = e2.shift(), i3 = t2[l3];
        r$1t(i3) && i3.type === "polygon" && i3.rings && i3.rings.length > 1 && r4.rings.length >= i3.rings.length ? (n3.push(r4), o2.push("simplify")) : o2.push(w2 ? R$m(r4) : r4);
      }
    }
    if (!n3.length)
      return o2;
    const r2 = await o$L(h2, n3, l2), i2 = [];
    for (let t3 = 0; t3 < o2.length; t3++) {
      const e3 = o2[t3];
      e3 !== "simplify" ? i2.push(e3) : i2.push(w2 ? R$m(r2.shift()) : r2.shift());
    }
    return i2;
  }
  const D2 = [];
  for (let e2 = 0; e2 < k2.length; e2++) {
    const t3 = k2[e2];
    if (t3 !== "cut")
      D2.push(t3);
    else {
      const e3 = S2.shift();
      D2.push(w2 === true ? R$m(e3) : e3);
    }
  }
  return D2;
}
function U$b(e2, t2) {
  const n2 = R$n(t2);
  if (n2) {
    const [t3, o2] = n2.valid, s2 = o2 - t3;
    if (e2 < t3)
      for (; e2 < t3; )
        e2 += s2;
    if (e2 > o2)
      for (; e2 > o2; )
        e2 -= s2;
  }
  return e2;
}
function t$P(n2) {
  const o2 = {};
  for (const e2 in n2) {
    if (e2 === "declaredClass")
      continue;
    const r2 = n2[e2];
    if (r2 != null && typeof r2 != "function")
      if (Array.isArray(r2)) {
        o2[e2] = [];
        for (let n3 = 0; n3 < r2.length; n3++)
          o2[e2][n3] = t$P(r2[n3]);
      } else
        typeof r2 == "object" ? r2.toJSON && (o2[e2] = JSON.stringify(r2)) : o2[e2] = r2;
  }
  return o2;
}
var e$M;
!function(t2) {
  t2[t2.varint = 0] = "varint", t2[t2.fixed64 = 1] = "fixed64", t2[t2.delimited = 2] = "delimited", t2[t2.fixed32 = 5] = "fixed32", t2[t2.unknown = 99] = "unknown";
}(e$M || (e$M = {}));
const i$1c = 4294967296, s$S = new TextDecoder("utf-8"), r$B = has("safari") || has("ios") ? 6 : has("ff") ? 12 : 32;
class n$19 {
  constructor(t2, i2, s2 = 0, r2 = t2 ? t2.byteLength : 0) {
    this._tag = 0, this._dataType = e$M.unknown, this._init(t2, i2, s2, r2);
  }
  _init(t2, e2, i2, s2) {
    this._data = t2, this._dataView = e2, this._pos = i2, this._end = s2;
  }
  asUnsafe() {
    return this;
  }
  clone() {
    return new n$19(this._data, this._dataView, this._pos, this._end);
  }
  pos() {
    return this._pos;
  }
  move(t2) {
    this._pos = t2;
  }
  nextTag(t2) {
    for (; ; ) {
      if (this._pos === this._end)
        return false;
      const e2 = this._decodeVarint();
      if (this._tag = e2 >> 3, this._dataType = 7 & e2, !t2 || t2 === this._tag)
        break;
      this.skip();
    }
    return true;
  }
  next() {
    if (this._pos === this._end)
      return false;
    const t2 = this._decodeVarint();
    return this._tag = t2 >> 3, this._dataType = 7 & t2, true;
  }
  empty() {
    return this._pos >= this._end;
  }
  tag() {
    return this._tag;
  }
  getInt32() {
    return this._decodeVarint();
  }
  getInt64() {
    return this._decodeVarint();
  }
  getUInt32() {
    let t2 = 4294967295;
    return t2 = (127 & this._data[this._pos]) >>> 0, this._data[this._pos++] < 128 ? t2 : (t2 = (t2 | (127 & this._data[this._pos]) << 7) >>> 0, this._data[this._pos++] < 128 ? t2 : (t2 = (t2 | (127 & this._data[this._pos]) << 14) >>> 0, this._data[this._pos++] < 128 ? t2 : (t2 = (t2 | (127 & this._data[this._pos]) << 21) >>> 0, this._data[this._pos++] < 128 ? t2 : (t2 = (t2 | (15 & this._data[this._pos]) << 28) >>> 0, this._data[this._pos++] < 128 ? t2 : void 0))));
  }
  getUInt64() {
    return this._decodeVarint();
  }
  getSInt32() {
    const t2 = this.getUInt32();
    if (t2 !== void 0)
      return t2 >>> 1 ^ -(1 & t2) | 0;
  }
  getSInt64() {
    return this._decodeSVarint();
  }
  getBool() {
    const t2 = this._data[this._pos] !== 0;
    return this._skip(1), t2;
  }
  getEnum() {
    return this._decodeVarint();
  }
  getFixed64() {
    const t2 = this._dataView, e2 = this._pos, s2 = t2.getUint32(e2, true) + t2.getUint32(e2 + 4, true) * i$1c;
    return this._skip(8), s2;
  }
  getSFixed64() {
    const t2 = this._dataView, e2 = this._pos, s2 = t2.getUint32(e2, true) + t2.getInt32(e2 + 4, true) * i$1c;
    return this._skip(8), s2;
  }
  getDouble() {
    const t2 = this._dataView.getFloat64(this._pos, true);
    return this._skip(8), t2;
  }
  getFixed32() {
    const t2 = this._dataView.getUint32(this._pos, true);
    return this._skip(4), t2;
  }
  getSFixed32() {
    const t2 = this._dataView.getInt32(this._pos, true);
    return this._skip(4), t2;
  }
  getFloat() {
    const t2 = this._dataView.getFloat32(this._pos, true);
    return this._skip(4), t2;
  }
  getString() {
    const t2 = this._getLength(), e2 = this._pos, i2 = this._toString(this._data, e2, e2 + t2);
    return this._skip(t2), i2;
  }
  getBytes() {
    const t2 = this._getLength(), e2 = this._pos, i2 = this._toBytes(this._data, e2, e2 + t2);
    return this._skip(t2), i2;
  }
  getLength() {
    return this._getLengthUnsafe();
  }
  processMessageWithArgs(t2, e2, i2, s2) {
    const r2 = this.getMessage(), n2 = t2(r2, e2, i2, s2);
    return r2.release(), n2;
  }
  processMessage(t2) {
    const e2 = this.getMessage(), i2 = t2(e2);
    return e2.release(), i2;
  }
  getMessage() {
    const t2 = this._getLength(), e2 = n$19.pool.acquire();
    return e2._init(this._data, this._dataView, this._pos, this._pos + t2), this._skip(t2), e2;
  }
  release() {
    n$19.pool.release(this);
  }
  dataType() {
    return this._dataType;
  }
  skip() {
    switch (this._dataType) {
      case e$M.varint:
        this._decodeVarint();
        break;
      case e$M.fixed64:
        this._skip(8);
        break;
      case e$M.delimited:
        this._skip(this._getLength());
        break;
      case e$M.fixed32:
        this._skip(4);
        break;
      default:
        throw new Error("Invalid data type!");
    }
  }
  skipLen(t2) {
    this._skip(t2);
  }
  _skip(t2) {
    if (this._pos + t2 > this._end)
      throw new Error("Attempt to skip past the end of buffer!");
    this._pos += t2;
  }
  _decodeVarint() {
    const t2 = this._data;
    let e2 = this._pos, i2 = 0, s2 = 0;
    if (this._end - e2 >= 10)
      do {
        if (s2 = t2[e2++], i2 |= 127 & s2, (128 & s2) == 0)
          break;
        if (s2 = t2[e2++], i2 |= (127 & s2) << 7, (128 & s2) == 0)
          break;
        if (s2 = t2[e2++], i2 |= (127 & s2) << 14, (128 & s2) == 0)
          break;
        if (s2 = t2[e2++], i2 |= (127 & s2) << 21, (128 & s2) == 0)
          break;
        if (s2 = t2[e2++], i2 += 268435456 * (127 & s2), (128 & s2) == 0)
          break;
        if (s2 = t2[e2++], i2 += 34359738368 * (127 & s2), (128 & s2) == 0)
          break;
        if (s2 = t2[e2++], i2 += 4398046511104 * (127 & s2), (128 & s2) == 0)
          break;
        if (s2 = t2[e2++], i2 += 562949953421312 * (127 & s2), (128 & s2) == 0)
          break;
        if (s2 = t2[e2++], i2 += 72057594037927940 * (127 & s2), (128 & s2) == 0)
          break;
        if (s2 = t2[e2++], i2 += 9223372036854776e3 * (127 & s2), (128 & s2) == 0)
          break;
        throw new Error("Varint too long!");
      } while (0);
    else {
      let r2 = 1;
      for (; e2 !== this._end && (s2 = t2[e2], (128 & s2) != 0); )
        ++e2, i2 += (127 & s2) * r2, r2 *= 128;
      if (e2 === this._end)
        throw new Error("Varint overrun!");
      ++e2, i2 += s2 * r2;
    }
    return this._pos = e2, i2;
  }
  _decodeSVarint() {
    const t2 = this._data;
    let e2 = this._pos, i2 = 0, s2 = 0;
    const r2 = 1 & t2[e2];
    if (this._end - e2 >= 10)
      do {
        if (s2 = t2[e2++], i2 |= 127 & s2, (128 & s2) == 0)
          break;
        if (s2 = t2[e2++], i2 |= (127 & s2) << 7, (128 & s2) == 0)
          break;
        if (s2 = t2[e2++], i2 |= (127 & s2) << 14, (128 & s2) == 0)
          break;
        if (s2 = t2[e2++], i2 |= (127 & s2) << 21, (128 & s2) == 0)
          break;
        if (s2 = t2[e2++], i2 += 268435456 * (127 & s2), (128 & s2) == 0)
          break;
        if (s2 = t2[e2++], i2 += 34359738368 * (127 & s2), (128 & s2) == 0)
          break;
        if (s2 = t2[e2++], i2 += 4398046511104 * (127 & s2), (128 & s2) == 0)
          break;
        if (s2 = t2[e2++], i2 += 562949953421312 * (127 & s2), (128 & s2) == 0)
          break;
        if (s2 = t2[e2++], i2 += 72057594037927940 * (127 & s2), (128 & s2) == 0)
          break;
        if (s2 = t2[e2++], i2 += 9223372036854776e3 * (127 & s2), (128 & s2) == 0)
          break;
        throw new Error("Varint too long!");
      } while (0);
    else {
      let r3 = 1;
      for (; e2 !== this._end && (s2 = t2[e2], (128 & s2) != 0); )
        ++e2, i2 += (127 & s2) * r3, r3 *= 128;
      if (e2 === this._end)
        throw new Error("Varint overrun!");
      ++e2, i2 += s2 * r3;
    }
    return this._pos = e2, r2 ? -(i2 + 1) / 2 : i2 / 2;
  }
  _getLength() {
    if (this._dataType !== e$M.delimited)
      throw new Error("Not a delimited data type!");
    return this._decodeVarint();
  }
  _getLengthUnsafe() {
    return this.getUInt32();
  }
  _toString(t2, e2, i2) {
    if ((i2 = Math.min(this._end, i2)) - e2 > r$B) {
      const r2 = t2.subarray(e2, i2);
      return s$S.decode(r2);
    }
    let n2 = "", a2 = "";
    for (let s2 = e2; s2 < i2; ++s2) {
      const e3 = t2[s2];
      128 & e3 ? a2 += "%" + e3.toString(16) : (n2 += decodeURIComponent(a2) + String.fromCharCode(e3), a2 = "");
    }
    return a2.length && (n2 += decodeURIComponent(a2)), n2;
  }
  _toBytes(t2, e2, i2) {
    return i2 = Math.min(this._end, i2), new Uint8Array(t2.buffer, e2, i2 - e2);
  }
}
n$19.pool = new e$1K(n$19, void 0, (t2) => {
  t2._data = null, t2._dataView = null;
});
class t$O {
  constructor(t2 = [], e2 = [], s2 = false) {
    this.lengths = t2 != null ? t2 : [], this.coords = e2 != null ? e2 : [], this.hasIndeterminateRingOrder = s2;
  }
  static fromRect(e2) {
    const [s2, h2, n2, r2] = e2, i2 = n2 - s2, o2 = r2 - h2;
    return new t$O([5], [s2, h2, i2, 0, 0, o2, -i2, 0, 0, -o2]);
  }
  get isPoint() {
    return this.lengths.length === 0;
  }
  get maxLength() {
    return Math.max(...this.lengths);
  }
  get size() {
    return this.lengths.reduce((t2, e2) => t2 + e2);
  }
  forEachVertex(t2) {
    let e2 = 0;
    this.lengths.length || t2(this.coords[0], this.coords[1]);
    for (let s2 = 0; s2 < this.lengths.length; s2++) {
      const h2 = this.lengths[s2];
      for (let s3 = 0; s3 < h2; s3++) {
        t2(this.coords[2 * (s3 + e2)], this.coords[2 * (s3 + e2) + 1]);
      }
      e2 += h2;
    }
  }
  clone(e2) {
    return e2 ? (e2.set(this.coords), new t$O(this.lengths.slice(), e2, this.hasIndeterminateRingOrder)) : new t$O(this.lengths.slice(), this.coords.slice(), this.hasIndeterminateRingOrder);
  }
}
class s$R {
  constructor(t2 = null, s2 = {}, e2, o2) {
    this.geometry = t2, this.attributes = s2, this.centroid = e2, this.objectId = o2, this.displayId = 0, this.geohashX = 0, this.geohashY = 0;
  }
  weakClone() {
    const t2 = new s$R(this.geometry, this.attributes, this.centroid, this.objectId);
    return t2.displayId = this.displayId, t2.geohashX = this.geohashX, t2.geohashY = this.geohashY, t2;
  }
}
function e$L(s2) {
  return !(t$1W(s2.geometry) || !s2.geometry.coords || !s2.geometry.coords.length);
}
class o$K extends s$R {
}
class e$K {
  constructor() {
    this.objectIdFieldName = null, this.globalIdFieldName = null, this.geohashFieldName = null, this.geometryProperties = null, this.geometryType = null, this.spatialReference = null, this.hasZ = false, this.hasM = false, this.features = [], this.fields = [], this.transform = null, this.exceededTransferLimit = false, this.uniqueIdField = null, this.queryGeometryType = null, this.queryGeometry = null;
  }
  weakClone() {
    const t2 = new e$K();
    return t2.objectIdFieldName = this.objectIdFieldName, t2.globalIdFieldName = this.globalIdFieldName, t2.geohashFieldName = this.geohashFieldName, t2.geometryProperties = this.geometryProperties, t2.geometryType = this.geometryType, t2.spatialReference = this.spatialReference, t2.hasZ = this.hasZ, t2.hasM = this.hasM, t2.features = this.features, t2.fields = this.fields, t2.transform = this.transform, t2.exceededTransferLimit = this.exceededTransferLimit, t2.uniqueIdField = this.uniqueIdField, t2.queryGeometry = this.queryGeometry, t2.queryGeometryType = this.queryGeometryType, t2;
  }
}
const n$18 = ["esriGeometryPoint", "esriGeometryMultipoint", "esriGeometryPolyline", "esriGeometryPolygon"];
class a$1i {
  constructor(e2) {
    this._options = e2, this.geometryTypes = n$18, this._coordinatePtr = 0, this._vertexDimension = 0;
  }
  createFeatureResult() {
    return new e$K();
  }
  prepareFeatures(e2) {
    this._vertexDimension = 2, e2.hasZ && this._vertexDimension++, e2.hasM && this._vertexDimension++;
  }
  finishFeatureResult(o2) {
    if (!o2 || !o2.features || !o2.hasZ || !this._options.sourceSpatialReference || !o2.spatialReference || E$u(o2.spatialReference, this._options.sourceSpatialReference) || o2.spatialReference.vcsWkid)
      return;
    const i2 = L$h(this._options.sourceSpatialReference) / L$h(o2.spatialReference);
    if (i2 !== 1)
      for (const e2 of o2.features) {
        if (!e$L(e2))
          continue;
        const t2 = e2.geometry.coords;
        for (let e3 = 2; e3 < t2.length; e3 += 3)
          t2[e3] *= i2;
      }
  }
  addFeature(e2, t2) {
    e2.features.push(t2);
  }
  createFeature() {
    return new s$R();
  }
  createSpatialReference() {
    return { wkid: 0 };
  }
  createGeometry() {
    return new t$O();
  }
  addField(e2, t2) {
    e2.fields.push(t2);
  }
  allocateCoordinates(e2) {
    e2.coords.length = e2.lengths.reduce((e3, t2) => e3 + t2, 0) * this._vertexDimension, this._coordinatePtr = 0;
  }
  addCoordinate(e2, t2) {
    e2.coords[this._coordinatePtr++] = t2;
  }
  addCoordinatePoint(e2, t2) {
    e2.coords.push(t2);
  }
  addLength(e2, t2) {
    e2.lengths.push(t2);
  }
  addQueryGeometry(e2, t2) {
    e2.queryGeometry = t2.queryGeometry, e2.queryGeometryType = t2.queryGeometryType;
  }
  createPointGeometry() {
    return new t$O();
  }
}
const n$17 = ["esriFieldTypeSmallInteger", "esriFieldTypeInteger", "esriFieldTypeSingle", "esriFieldTypeDouble", "esriFieldTypeString", "esriFieldTypeDate", "esriFieldTypeOID", "esriFieldTypeGeometry", "esriFieldTypeBlob", "esriFieldTypeRaster", "esriFieldTypeGUID", "esriFieldTypeGlobalID", "esriFieldTypeXML"], o$J = ["sqlTypeBigInt", "sqlTypeBinary", "sqlTypeBit", "sqlTypeChar", "sqlTypeDate", "sqlTypeDecimal", "sqlTypeDouble", "sqlTypeFloat", "sqlTypeGeometry", "sqlTypeGUID", "sqlTypeInteger", "sqlTypeLongNVarchar", "sqlTypeLongVarbinary", "sqlTypeLongVarchar", "sqlTypeNChar", "sqlTypeNVarchar", "sqlTypeOther", "sqlTypeReal", "sqlTypeSmallInt", "sqlTypeSqlXml", "sqlTypeTime", "sqlTypeTimestamp", "sqlTypeTimestamp2", "sqlTypeTinyInt", "sqlTypeVarbinary", "sqlTypeVarchar"], i$1b = ["upperLeft", "lowerLeft"];
function c$1i(e2) {
  return e2 >= n$17.length ? null : n$17[e2];
}
function l$$(e2) {
  return e2 >= o$J.length ? null : o$J[e2];
}
function g$y(e2) {
  return e2 >= i$1b.length ? null : i$1b[e2];
}
function p$1z(e2, t2) {
  return t2 >= e2.geometryTypes.length ? null : e2.geometryTypes[t2];
}
function u$R(e2, t2, s2) {
  const r2 = 3, a2 = e2.asUnsafe(), n2 = t2.createPointGeometry(s2);
  for (; a2.next(); )
    switch (a2.tag()) {
      case r2: {
        const e3 = a2.getUInt32(), s3 = a2.pos() + e3;
        let r3 = 0;
        for (; a2.pos() < s3; )
          t2.addCoordinatePoint(n2, a2.getSInt64(), r3++);
        break;
      }
      default:
        a2.skip();
    }
  return n2;
}
function f$M(e2, t2, s2) {
  const r2 = 2, a2 = 3, n2 = e2.asUnsafe(), o2 = t2.createGeometry(s2), i2 = 2 + (s2.hasZ ? 1 : 0) + (s2.hasM ? 1 : 0);
  for (; n2.next(); )
    switch (n2.tag()) {
      case r2: {
        const e3 = n2.getUInt32(), s3 = n2.pos() + e3;
        let r3 = 0;
        for (; n2.pos() < s3; )
          t2.addLength(o2, n2.getUInt32(), r3++);
        break;
      }
      case a2: {
        const e3 = n2.getUInt32(), s3 = n2.pos() + e3;
        let r3 = 0;
        for (t2.allocateCoordinates(o2); n2.pos() < s3; )
          t2.addCoordinate(o2, n2.getSInt64(), r3), r3++, r3 === i2 && (r3 = 0);
        break;
      }
      default:
        n2.skip();
    }
  return o2;
}
function y$E(e2) {
  const t2 = 1, s2 = 2, n2 = 3, o2 = e2.asUnsafe(), i2 = new t$O();
  let c2 = "esriGeometryPoint";
  for (; o2.next(); )
    switch (o2.tag()) {
      case s2: {
        const e3 = o2.getUInt32(), t3 = o2.pos() + e3;
        for (; o2.pos() < t3; )
          i2.lengths.push(o2.getUInt32());
        break;
      }
      case n2: {
        const e3 = o2.getUInt32(), t3 = o2.pos() + e3;
        for (; o2.pos() < t3; )
          i2.coords.push(o2.getSInt64());
        break;
      }
      case t2:
        c2 = n$18[o2.getEnum()];
        break;
      default:
        o2.skip();
    }
  return { queryGeometry: i2, queryGeometryType: c2 };
}
function b$s(e2) {
  const t2 = 1, s2 = 2, r2 = 3, a2 = 4, n2 = 5, o2 = 6, i2 = 7, c2 = 8, l2 = 9, g2 = e2.asUnsafe();
  for (; g2.next(); )
    switch (g2.tag()) {
      case t2:
        return g2.getString();
      case s2:
        return g2.getFloat();
      case r2:
        return g2.getDouble();
      case a2:
        return g2.getSInt32();
      case n2:
        return g2.getUInt32();
      case o2:
        return g2.getInt64();
      case i2:
        return g2.getUInt64();
      case c2:
        return g2.getSInt64();
      case l2:
        return g2.getBool();
      default:
        return g2.skip(), null;
    }
  return null;
}
function k$8(e2) {
  const t2 = 1, s2 = 2, r2 = 3, a2 = 4, n2 = 5, o2 = 6, i2 = e2.asUnsafe(), g2 = { type: c$1i(0) };
  for (; i2.next(); )
    switch (i2.tag()) {
      case t2:
        g2.name = i2.getString();
        break;
      case s2:
        g2.type = c$1i(i2.getEnum());
        break;
      case r2:
        g2.alias = i2.getString();
        break;
      case a2:
        g2.sqlType = l$$(i2.getEnum());
        break;
      case n2:
        i2.skip();
        break;
      case o2:
        g2.defaultValue = i2.getString();
        break;
      default:
        i2.skip();
    }
  return g2;
}
function d$G(e2) {
  const t2 = 1, s2 = 2, r2 = {}, a2 = e2.asUnsafe();
  for (; a2.next(); )
    switch (a2.tag()) {
      case t2:
        r2.name = a2.getString();
        break;
      case s2:
        r2.isSystemMaintained = a2.getBool();
        break;
      default:
        a2.skip();
    }
  return r2;
}
function m$R(e2, t2, s2, r2) {
  const a2 = 1, n2 = 2, o2 = 4, i2 = t2.createFeature(s2);
  let c2 = 0;
  for (; e2.next(); )
    switch (e2.tag()) {
      case a2: {
        const t3 = r2[c2++].name;
        i2.attributes[t3] = e2.processMessage(b$s);
        break;
      }
      case n2:
        i2.geometry = e2.processMessageWithArgs(f$M, t2, s2);
        break;
      case o2:
        i2.centroid = e2.processMessageWithArgs(u$R, t2, s2);
        break;
      default:
        e2.skip();
    }
  return i2;
}
function h$B(e2) {
  const t2 = 1, s2 = 2, r2 = 3, a2 = 4, n2 = [1, 1, 1, 1], o2 = e2.asUnsafe();
  for (; o2.next(); )
    switch (o2.tag()) {
      case t2:
        n2[0] = o2.getDouble();
        break;
      case s2:
        n2[1] = o2.getDouble();
        break;
      case a2:
        n2[2] = o2.getDouble();
        break;
      case r2:
        n2[3] = o2.getDouble();
        break;
      default:
        o2.skip();
    }
  return n2;
}
function T$c(e2) {
  const t2 = 1, s2 = 2, r2 = 3, a2 = 4, n2 = [0, 0, 0, 0], o2 = e2.asUnsafe();
  for (; o2.next(); )
    switch (o2.tag()) {
      case t2:
        n2[0] = o2.getDouble();
        break;
      case s2:
        n2[1] = o2.getDouble();
        break;
      case a2:
        n2[2] = o2.getDouble();
        break;
      case r2:
        n2[3] = o2.getDouble();
        break;
      default:
        o2.skip();
    }
  return n2;
}
function q$5(e2) {
  const t2 = 1, s2 = 2, r2 = 3, a2 = { originPosition: g$y(0) }, n2 = e2.asUnsafe();
  for (; n2.next(); )
    switch (n2.tag()) {
      case t2:
        a2.originPosition = g$y(n2.getEnum());
        break;
      case s2:
        a2.scale = n2.processMessage(h$B);
        break;
      case r2:
        a2.translate = n2.processMessage(T$c);
        break;
      default:
        n2.skip();
    }
  return a2;
}
function I$g(e2) {
  const t2 = 1, s2 = 2, r2 = 3, a2 = {}, n2 = e2.asUnsafe();
  for (; n2.next(); )
    switch (n2.tag()) {
      case t2:
        a2.shapeAreaFieldName = n2.getString();
        break;
      case s2:
        a2.shapeLengthFieldName = n2.getString();
        break;
      case r2:
        a2.units = n2.getString();
        break;
      default:
        n2.skip();
    }
  return a2;
}
function F$9(e2, t2) {
  const s2 = 1, r2 = 2, a2 = 3, n2 = 4, o2 = 5, i2 = t2.createSpatialReference();
  for (; e2.next(); )
    switch (e2.tag()) {
      case s2:
        i2.wkid = e2.getUInt32();
        break;
      case o2:
        i2.wkt = e2.getString();
        break;
      case r2:
        i2.latestWkid = e2.getUInt32();
        break;
      case a2:
        i2.vcsWkid = e2.getUInt32();
        break;
      case n2:
        i2.latestVcsWkid = e2.getUInt32();
        break;
      default:
        e2.skip();
    }
  return i2;
}
function U$a(e2, t2) {
  const s2 = 1, r2 = 2, a2 = 3, n2 = 4, o2 = 5, i2 = 7, c2 = 8, l2 = 9, g2 = 10, u2 = 11, f2 = 12, y2 = 13, b2 = 15, h2 = t2.createFeatureResult(), T2 = e2.asUnsafe();
  h2.geometryType = p$1z(t2, 0);
  let U2 = false;
  for (; T2.next(); )
    switch (T2.tag()) {
      case s2:
        h2.objectIdFieldName = T2.getString();
        break;
      case a2:
        h2.globalIdFieldName = T2.getString();
        break;
      case n2:
        h2.geohashFieldName = T2.getString();
        break;
      case o2:
        h2.geometryProperties = T2.processMessage(I$g);
        break;
      case i2:
        h2.geometryType = p$1z(t2, T2.getEnum());
        break;
      case c2:
        h2.spatialReference = T2.processMessageWithArgs(F$9, t2);
        break;
      case g2:
        h2.hasZ = T2.getBool();
        break;
      case u2:
        h2.hasM = T2.getBool();
        break;
      case f2:
        h2.transform = T2.processMessage(q$5);
        break;
      case l2: {
        const e3 = T2.getBool();
        h2.exceededTransferLimit = e3;
        break;
      }
      case y2:
        t2.addField(h2, T2.processMessage(k$8));
        break;
      case b2:
        U2 || (t2.prepareFeatures(h2), U2 = true), t2.addFeature(h2, T2.processMessageWithArgs(m$R, t2, h2, h2.fields));
        break;
      case r2:
        h2.uniqueIdField = T2.processMessage(d$G);
        break;
      default:
        T2.skip();
    }
  return t2.finishFeatureResult(h2), h2;
}
function S$k(e2, s2) {
  const r2 = 1, a2 = 4, n2 = {};
  let o2 = null;
  for (; e2.next(); )
    switch (e2.tag()) {
      case a2:
        o2 = e2.processMessageWithArgs(y$E);
        break;
      case r2:
        n2.featureResult = e2.processMessageWithArgs(U$a, s2);
        break;
      default:
        e2.skip();
    }
  return r$1t(o2) && n2.featureResult && s2.addQueryGeometry(n2, o2), n2;
}
function w$o(t2, r2) {
  try {
    const e2 = 2, a2 = new n$19(new Uint8Array(t2), new DataView(t2)), n2 = {};
    for (; a2.next(); )
      if (a2.tag() === e2)
        n2.queryResult = a2.processMessageWithArgs(S$k, r2);
      else
        a2.skip();
    return n2;
  } catch (a2) {
    throw new s$1Z("query:parsing-pbf", "Error while parsing FeatureSet PBF payload", { error: a2 });
  }
}
function t$N(t2, r2) {
  const u2 = w$o(t2, r2), o2 = u2.queryResult.featureResult, s2 = u2.queryResult.queryGeometry, y2 = u2.queryResult.queryGeometryType;
  if (o2 && o2.features && o2.features.length && o2.objectIdFieldName) {
    const e2 = o2.objectIdFieldName;
    for (const t3 of o2.features)
      t3.attributes && (t3.objectId = t3.attributes[e2]);
  }
  return o2 && (o2.queryGeometry = s2, o2.queryGeometryType = y2), o2;
}
function r$A(r2, t2, f2) {
  if (!f2 || !f2.features || !f2.hasZ)
    return;
  const s2 = o$15(f2.geometryType, t2, r2.outSpatialReference);
  if (!t$1W(s2))
    for (const e2 of f2.features)
      s2(e2.geometry);
}
const l$_ = "Layer does not support extent calculation.";
function m$Q(e2, t2) {
  if (t2 && e2.type === "extent")
    return `${e2.xmin},${e2.ymin},${e2.xmax},${e2.ymax}`;
  if (t2 && e2.type === "point")
    return `${e2.x},${e2.y}`;
  const r2 = e2.toJSON();
  return delete r2.spatialReference, JSON.stringify(r2);
}
function y$D(e2, r2) {
  const n2 = e2.geometry, o2 = e2.toJSON();
  delete o2.compactGeometryEnabled, delete o2.defaultSpatialReferenceEnabled;
  const a2 = o2;
  let s2, u2, l2;
  if (r$1t(n2) && (u2 = n2.spatialReference, l2 = n2.spatialReference.wkid || JSON.stringify(n2.spatialReference), a2.geometryType = c$2v(n2), a2.geometry = m$Q(n2, e2.compactGeometryEnabled), a2.inSR = l2), o2.groupByFieldsForStatistics && (a2.groupByFieldsForStatistics = o2.groupByFieldsForStatistics.join(",")), o2.objectIds && (a2.objectIds = o2.objectIds.join(",")), o2.orderByFields && (a2.orderByFields = o2.orderByFields.join(",")), !o2.outFields || !o2.returnDistinctValues && ((r2 == null ? void 0 : r2.returnCountOnly) || (r2 == null ? void 0 : r2.returnExtentOnly) || (r2 == null ? void 0 : r2.returnIdsOnly)) ? delete a2.outFields : o2.outFields.includes("*") ? a2.outFields = "*" : a2.outFields = o2.outFields.join(","), o2.outSR ? (a2.outSR = o2.outSR.wkid || JSON.stringify(o2.outSR), s2 = e2.outSpatialReference) : n2 && (o2.returnGeometry || o2.returnCentroid) && (a2.outSR = a2.inSR, s2 = u2), o2.returnGeometry && delete o2.returnGeometry, o2.outStatistics && (a2.outStatistics = JSON.stringify(o2.outStatistics)), o2.fullText && (a2.fullText = JSON.stringify(o2.fullText)), o2.pixelSize && (a2.pixelSize = JSON.stringify(o2.pixelSize)), o2.quantizationParameters && (e2.defaultSpatialReferenceEnabled && r$1t(u2) && r$1t(e2.quantizationParameters) && r$1t(e2.quantizationParameters.extent) && u2.equals(e2.quantizationParameters.extent.spatialReference) && delete o2.quantizationParameters.extent.spatialReference, a2.quantizationParameters = JSON.stringify(o2.quantizationParameters)), o2.parameterValues && (a2.parameterValues = JSON.stringify(o2.parameterValues)), o2.rangeValues && (a2.rangeValues = JSON.stringify(o2.rangeValues)), o2.dynamicDataSource && (a2.layer = JSON.stringify({ source: o2.dynamicDataSource }), delete o2.dynamicDataSource), o2.timeExtent) {
    const e3 = o2.timeExtent, { start: t2, end: r3 } = e3;
    t2 == null && r3 == null || (a2.time = t2 === r3 ? t2 : `${t2 != null ? t2 : "null"},${r3 != null ? r3 : "null"}`), delete o2.timeExtent;
  }
  return e2.defaultSpatialReferenceEnabled && r$1t(u2) && r$1t(s2) && u2.equals(s2) && (a2.defaultSR = a2.inSR, delete a2.inSR, delete a2.outSR), a2;
}
async function c$1h(e2, r2, n2, i2) {
  const o2 = r$1t(r2.timeExtent) && r2.timeExtent.isEmpty ? { data: { features: [] } } : await E$d(e2, r2, "json", i2);
  return r$A(r2, n2, o2.data), o2;
}
async function f$L(e2, r2, n2, i2) {
  if (r$1t(r2.timeExtent) && r2.timeExtent.isEmpty)
    return { data: n2.createFeatureResult() };
  const o2 = await d$F(e2, r2, i2), a2 = o2;
  return a2.data = t$N(o2.data, n2), a2;
}
function d$F(e2, t2, r2) {
  return E$d(e2, t2, "pbf", r2);
}
function p$1y(e2, r2, n2) {
  return r$1t(r2.timeExtent) && r2.timeExtent.isEmpty ? Promise.resolve({ data: { objectIds: [] } }) : E$d(e2, r2, "json", n2, { returnIdsOnly: true });
}
function S$j(e2, r2, n2) {
  return r$1t(r2.timeExtent) && r2.timeExtent.isEmpty ? Promise.resolve({ data: { count: 0 } }) : E$d(e2, r2, "json", n2, { returnIdsOnly: true, returnCountOnly: true });
}
function x$k(e2, r2, n2) {
  return r$1t(r2.timeExtent) && r2.timeExtent.isEmpty ? Promise.resolve({ data: { count: 0, extent: null } }) : E$d(e2, r2, "json", n2, { returnExtentOnly: true, returnCountOnly: true }).then((e3) => {
    const t2 = e3.data;
    if (t2.hasOwnProperty("extent"))
      return e3;
    if (t2.features)
      throw new Error(l$_);
    if (t2.hasOwnProperty("count"))
      throw new Error(l$_);
    return e3;
  });
}
function E$d(i2, s2, u2, l2 = {}, m2 = {}) {
  const c2 = typeof i2 == "string" ? j$B(i2) : i2, f2 = s2.geometry ? [s2.geometry] : [];
  return l2.responseType = u2 === "pbf" ? "array-buffer" : "json", v$s(f2, null, l2).then((r2) => {
    const i3 = r2 && r2[0];
    r$1t(i3) && ((s2 = s2.clone()).geometry = i3);
    const o2 = t$P(__spreadValues(__spreadValues(__spreadProps(__spreadValues({}, c2.query), { f: u2 }), m2), y$D(s2, m2)));
    return U$k(G$c(c2.path, "query"), __spreadProps(__spreadValues({}, l2), { query: __spreadValues(__spreadValues({}, o2), l2.query) }));
  });
}
var query = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  encodeGeometry: m$Q,
  executeQuery: c$1h,
  executeQueryForCount: S$j,
  executeQueryForExtent: x$k,
  executeQueryForIds: p$1y,
  executeQueryPBF: f$L,
  executeQueryPBFBuffer: d$F,
  queryToQueryStringParameters: y$D,
  runQuery: E$d
});
var d$E;
const g$x = new s$1F({ esriGeometryPoint: "point", esriGeometryMultipoint: "multipoint", esriGeometryPolyline: "polyline", esriGeometryPolygon: "polygon", esriGeometryEnvelope: "extent", mesh: "mesh", "": null });
let j$k = d$E = class extends l$1_ {
  constructor(e2) {
    super(e2), this.displayFieldName = null, this.exceededTransferLimit = false, this.features = [], this.fields = null, this.geometryType = null, this.hasM = false, this.hasZ = false, this.queryGeometry = null, this.spatialReference = null;
  }
  readFeatures(e2, t2) {
    var _a2;
    const o2 = k$p.fromJSON(t2.spatialReference), s2 = [];
    for (let i2 = 0; i2 < e2.length; i2++) {
      const t3 = e2[i2], a2 = g$J.fromJSON(t3), p2 = t3.geometry && t3.geometry.spatialReference;
      r$1t(a2.geometry) && !p2 && (a2.geometry.spatialReference = o2);
      const l2 = t3.aggregateGeometries, y2 = a2.aggregateGeometries;
      if (l2 && r$1t(y2))
        for (const e3 in y2) {
          const t4 = y2[e3], r2 = (_a2 = l2[e3]) == null ? void 0 : _a2.spatialReference;
          r$1t(t4) && !r2 && (t4.spatialReference = o2);
        }
      s2.push(a2);
    }
    return s2;
  }
  writeGeometryType(e2, t2, r2, o2) {
    if (e2)
      return void g$x.write(e2, t2, r2, o2);
    const { features: s2 } = this;
    if (s2) {
      for (const i2 of s2)
        if (i2 && r$1t(i2.geometry))
          return void g$x.write(i2.geometry.type, t2, r2, o2);
    }
  }
  readQueryGeometry(e2, t2) {
    if (!e2)
      return null;
    const r2 = !!e2.spatialReference, o2 = v$N(e2);
    return o2 && !r2 && t2.spatialReference && (o2.spatialReference = k$p.fromJSON(t2.spatialReference)), o2;
  }
  writeSpatialReference(e2, t2) {
    if (e2)
      return void (t2.spatialReference = e2.toJSON());
    const { features: r2 } = this;
    if (r2) {
      for (const o2 of r2)
        if (o2 && r$1t(o2.geometry) && o2.geometry.spatialReference)
          return void (t2.spatialReference = o2.geometry.spatialReference.toJSON());
    }
  }
  clone() {
    return new d$E(this.cloneProperties());
  }
  cloneProperties() {
    return y$1r({ displayFieldName: this.displayFieldName, exceededTransferLimit: this.exceededTransferLimit, features: this.features, fields: this.fields, geometryType: this.geometryType, hasM: this.hasM, hasZ: this.hasZ, queryGeometry: this.queryGeometry, spatialReference: this.spatialReference, transform: this.transform });
  }
  toJSON(e2) {
    const t2 = this.write();
    if (t2.features && Array.isArray(e2) && e2.length > 0)
      for (let r2 = 0; r2 < t2.features.length; r2++) {
        const o2 = t2.features[r2];
        if (o2.geometry) {
          const t3 = e2 && e2[r2];
          o2.geometry = t3 && t3.toJSON() || o2.geometry;
        }
      }
    return t2;
  }
  quantize(e2) {
    const { scale: [t2, r2], translate: [o2, s2] } = e2, i2 = (e3) => Math.round((e3 - o2) / t2), n2 = (e3) => Math.round((s2 - e3) / r2), p2 = this.features, l2 = this._getQuantizationFunction(this.geometryType, i2, n2);
    for (let y2 = 0, m2 = p2.length; y2 < m2; y2++)
      (l2 == null ? void 0 : l2(e$1U(p2[y2].geometry))) || (p2.splice(y2, 1), y2--, m2--);
    return this.transform = e2, this;
  }
  unquantize() {
    const { geometryType: e2, features: t2, transform: r2 } = this;
    if (!r2)
      return this;
    const { translate: [o2, s2], scale: [i2, a2] } = r2, p2 = (e3) => e3 * i2 + o2, l2 = (e3) => s2 - e3 * a2, y2 = this._getHydrationFunction(e2, p2, l2);
    for (const { geometry: m2 } of t2)
      r$1t(m2) && y2 && y2(m2);
    return this.transform = null, this;
  }
  _quantizePoints(e2, t2, r2) {
    let o2, s2;
    const i2 = [];
    for (let n2 = 0, a2 = e2.length; n2 < a2; n2++) {
      const a3 = e2[n2];
      if (n2 > 0) {
        const e3 = t2(a3[0]), n3 = r2(a3[1]);
        e3 === o2 && n3 === s2 || (i2.push([e3 - o2, n3 - s2]), o2 = e3, s2 = n3);
      } else
        o2 = t2(a3[0]), s2 = r2(a3[1]), i2.push([o2, s2]);
    }
    return i2.length > 0 ? i2 : null;
  }
  _getQuantizationFunction(e2, t2, r2) {
    return e2 === "point" ? (e3) => (e3.x = t2(e3.x), e3.y = r2(e3.y), e3) : e2 === "polyline" || e2 === "polygon" ? (e3) => {
      const o2 = y$1a(e3) ? e3.rings : e3.paths, s2 = [];
      for (let i2 = 0, n2 = o2.length; i2 < n2; i2++) {
        const e4 = o2[i2], n3 = this._quantizePoints(e4, t2, r2);
        n3 && s2.push(n3);
      }
      return s2.length > 0 ? (y$1a(e3) ? e3.rings = s2 : e3.paths = s2, e3) : null;
    } : e2 === "multipoint" ? (e3) => {
      const o2 = this._quantizePoints(e3.points, t2, r2);
      return o2 && o2.length > 0 ? (e3.points = o2, e3) : null;
    } : e2 === "extent" ? (e3) => e3 : null;
  }
  _getHydrationFunction(e2, t2, r2) {
    return e2 === "point" ? (e3) => {
      e3.x = t2(e3.x), e3.y = r2(e3.y);
    } : e2 === "polyline" || e2 === "polygon" ? (e3) => {
      const o2 = y$1a(e3) ? e3.rings : e3.paths;
      let s2, i2;
      for (let n2 = 0, a2 = o2.length; n2 < a2; n2++) {
        const e4 = o2[n2];
        for (let o3 = 0, n3 = e4.length; o3 < n3; o3++) {
          const n4 = e4[o3];
          o3 > 0 ? (s2 += n4[0], i2 += n4[1]) : (s2 = n4[0], i2 = n4[1]), n4[0] = t2(s2), n4[1] = r2(i2);
        }
      }
    } : e2 === "extent" ? (e3) => {
      e3.xmin = t2(e3.xmin), e3.ymin = r2(e3.ymin), e3.xmax = t2(e3.xmax), e3.ymax = r2(e3.ymax);
    } : e2 === "multipoint" ? (e3) => {
      const o2 = e3.points;
      let s2, i2;
      for (let n2 = 0, a2 = o2.length; n2 < a2; n2++) {
        const e4 = o2[n2];
        n2 > 0 ? (s2 += e4[0], i2 += e4[1]) : (s2 = e4[0], i2 = e4[1]), e4[0] = t2(s2), e4[1] = r2(i2);
      }
    } : null;
  }
};
e$1W([y$1o({ type: String, json: { write: true } })], j$k.prototype, "displayFieldName", void 0), e$1W([y$1o({ type: Boolean, json: { write: { overridePolicy: (e2) => ({ enabled: e2 }) } } })], j$k.prototype, "exceededTransferLimit", void 0), e$1W([y$1o({ type: [g$J], json: { write: true } })], j$k.prototype, "features", void 0), e$1W([o$1H("features")], j$k.prototype, "readFeatures", null), e$1W([y$1o({ type: [y$H], json: { write: true } })], j$k.prototype, "fields", void 0), e$1W([y$1o({ type: ["point", "multipoint", "polyline", "polygon", "extent", "mesh"], json: { read: { reader: g$x.read } } })], j$k.prototype, "geometryType", void 0), e$1W([r$1h("geometryType")], j$k.prototype, "writeGeometryType", null), e$1W([y$1o({ type: Boolean, json: { write: { overridePolicy: (e2) => ({ enabled: e2 }) } } })], j$k.prototype, "hasM", void 0), e$1W([y$1o({ type: Boolean, json: { write: { overridePolicy: (e2) => ({ enabled: e2 }) } } })], j$k.prototype, "hasZ", void 0), e$1W([y$1o({ types: i$29, json: { write: true } })], j$k.prototype, "queryGeometry", void 0), e$1W([o$1H("queryGeometry")], j$k.prototype, "readQueryGeometry", null), e$1W([y$1o({ type: k$p, json: { write: true } })], j$k.prototype, "spatialReference", void 0), e$1W([r$1h("spatialReference")], j$k.prototype, "writeSpatialReference", null), e$1W([y$1o({ json: { write: true } })], j$k.prototype, "transform", void 0), j$k = d$E = e$1W([n$2f("esri.rest.support.FeatureSet")], j$k), j$k.prototype.toJSON.isDefaultToJSON = true;
const x$j = j$k;
var FeatureSet = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": x$j
});
const e$J = { milliseconds: 1, seconds: 1e3, minutes: 6e4, hours: 36e5, days: 864e5, weeks: 6048e5, months: 26784e5, years: 31536e6, decades: 31536e7, centuries: 31536e8 }, t$M = { milliseconds: { getter: "getMilliseconds", setter: "setMilliseconds", multiplier: 1 }, seconds: { getter: "getSeconds", setter: "setSeconds", multiplier: 1 }, minutes: { getter: "getMinutes", setter: "setMinutes", multiplier: 1 }, hours: { getter: "getHours", setter: "setHours", multiplier: 1 }, days: { getter: "getDate", setter: "setDate", multiplier: 1 }, weeks: { getter: "getDate", setter: "setDate", multiplier: 7 }, months: { getter: "getMonth", setter: "setMonth", multiplier: 1 }, years: { getter: "getFullYear", setter: "setFullYear", multiplier: 1 }, decades: { getter: "getFullYear", setter: "setFullYear", multiplier: 10 }, centuries: { getter: "getFullYear", setter: "setFullYear", multiplier: 100 } };
function s$Q(e2, t2) {
  const s2 = new Date(e2, t2 + 1, 1);
  return s2.setDate(0), s2.getDate();
}
function n$16(e2, n2, r2) {
  const l2 = new Date(e2.getTime());
  if (n2 && r2) {
    const e3 = t$M[r2], { getter: u2, setter: i2, multiplier: a2 } = e3;
    if (r2 === "months") {
      const e4 = s$Q(l2.getFullYear(), l2.getMonth() + n2);
      l2.getDate() > e4 && l2.setDate(e4);
    }
    l2[i2](l2[u2]() + n2 * a2);
  }
  return l2;
}
function l$Z(e2, t2) {
  switch (t2) {
    case "milliseconds":
      return new Date(e2.getTime());
    case "seconds":
      return new Date(e2.getFullYear(), e2.getMonth(), e2.getDate(), e2.getHours(), e2.getMinutes(), e2.getSeconds());
    case "minutes":
      return new Date(e2.getFullYear(), e2.getMonth(), e2.getDate(), e2.getHours(), e2.getMinutes());
    case "hours":
      return new Date(e2.getFullYear(), e2.getMonth(), e2.getDate(), e2.getHours());
    case "days":
      return new Date(e2.getFullYear(), e2.getMonth(), e2.getDate());
    case "weeks":
      return new Date(e2.getFullYear(), e2.getMonth(), e2.getDate() - e2.getDay());
    case "months":
      return new Date(e2.getFullYear(), e2.getMonth(), 1);
    case "years":
      return new Date(e2.getFullYear(), 0, 1);
    case "decades":
      return new Date(e2.getFullYear() - e2.getFullYear() % 10, 0, 1);
    case "centuries":
      return new Date(e2.getFullYear() - e2.getFullYear() % 100, 0, 1);
    default:
      return new Date();
  }
}
function g$w(t2, s2, n2) {
  if (t2 === 0)
    return 0;
  return t2 * e$J[s2] / e$J[n2];
}
var p$1x;
let d$D = p$1x = class extends l$1_ {
  constructor(t2) {
    super(t2), this.end = null, this.start = null;
  }
  static get allTime() {
    return c$1g;
  }
  static get empty() {
    return h$A;
  }
  readEnd(t2, e2) {
    return e2.end != null ? new Date(e2.end) : null;
  }
  writeEnd(t2, e2) {
    e2.end = t2 ? t2.getTime() : null;
  }
  get isAllTime() {
    return this.equals(p$1x.allTime);
  }
  get isEmpty() {
    return this.equals(p$1x.empty);
  }
  readStart(t2, e2) {
    return e2.start != null ? new Date(e2.start) : null;
  }
  writeStart(t2, e2) {
    e2.start = t2 ? t2.getTime() : null;
  }
  clone() {
    return new p$1x({ end: this.end, start: this.start });
  }
  equals(t2) {
    if (!t2)
      return false;
    const e2 = r$1t(this.start) ? this.start.getTime() : this.start, s2 = r$1t(this.end) ? this.end.getTime() : this.end, n2 = r$1t(t2.start) ? t2.start.getTime() : t2.start, i2 = r$1t(t2.end) ? t2.end.getTime() : t2.end;
    return e2 === n2 && s2 === i2;
  }
  expandTo(t2) {
    if (this.isEmpty || this.isAllTime)
      return this.clone();
    const e2 = o$1Z(this.start, (e3) => l$Z(e3, t2)), r2 = o$1Z(this.end, (e3) => {
      const r3 = l$Z(e3, t2);
      return e3.getTime() === r3.getTime() ? r3 : n$16(r3, 1, t2);
    });
    return new p$1x({ start: e2, end: r2 });
  }
  intersection(t2) {
    if (!t2)
      return this.clone();
    if (this.isEmpty || t2.isEmpty)
      return p$1x.empty;
    if (this.isAllTime)
      return t2.clone();
    if (t2.isAllTime)
      return this.clone();
    const e2 = b$X(this.start, -1 / 0, (t3) => t3.getTime()), r2 = b$X(this.end, 1 / 0, (t3) => t3.getTime()), s2 = b$X(t2.start, -1 / 0, (t3) => t3.getTime()), i2 = b$X(t2.end, 1 / 0, (t3) => t3.getTime());
    let o2, l2;
    if (s2 >= e2 && s2 <= r2 ? o2 = s2 : e2 >= s2 && e2 <= i2 && (o2 = e2), r2 >= s2 && r2 <= i2 ? l2 = r2 : i2 >= e2 && i2 <= r2 && (l2 = i2), o2 != null && l2 != null && !isNaN(o2) && !isNaN(l2)) {
      const t3 = new p$1x();
      return t3.start = o2 === -1 / 0 ? null : new Date(o2), t3.end = l2 === 1 / 0 ? null : new Date(l2), t3;
    }
    return p$1x.empty;
  }
  offset(t2, e2) {
    if (this.isEmpty || this.isAllTime)
      return this.clone();
    const s2 = new p$1x(), { start: n2, end: i2 } = this;
    return r$1t(n2) && (s2.start = n$16(n2, t2, e2)), r$1t(i2) && (s2.end = n$16(i2, t2, e2)), s2;
  }
  union(t2) {
    if (!t2 || t2.isEmpty)
      return this.clone();
    if (this.isEmpty)
      return t2.clone();
    if (this.isAllTime || t2.isAllTime)
      return c$1g.clone();
    const e2 = r$1t(this.start) && r$1t(t2.start) ? new Date(Math.min(this.start.getTime(), t2.start.getTime())) : null, s2 = r$1t(this.end) && r$1t(t2.end) ? new Date(Math.max(this.end.getTime(), t2.end.getTime())) : null;
    return new p$1x({ start: e2, end: s2 });
  }
};
e$1W([y$1o({ type: Date, json: { write: { allowNull: true } } })], d$D.prototype, "end", void 0), e$1W([o$1H("end")], d$D.prototype, "readEnd", null), e$1W([r$1h("end")], d$D.prototype, "writeEnd", null), e$1W([y$1o({ readOnly: true, json: { read: false } })], d$D.prototype, "isAllTime", null), e$1W([y$1o({ readOnly: true, json: { read: false } })], d$D.prototype, "isEmpty", null), e$1W([y$1o({ type: Date, json: { write: { allowNull: true } } })], d$D.prototype, "start", void 0), e$1W([o$1H("start")], d$D.prototype, "readStart", null), e$1W([r$1h("start")], d$D.prototype, "writeStart", null), d$D = p$1x = e$1W([n$2f("esri.TimeExtent")], d$D);
const c$1g = new d$D(), h$A = new d$D({ start: void 0, end: void 0 }), T$b = d$D;
let i$1a = class extends i$28(l$1_) {
  constructor(r2) {
    super(r2), this.onFields = null, this.operator = null, this.searchTerm = null, this.searchType = null;
  }
};
e$1W([y$1o({ type: [String], json: { write: { enabled: true, overridePolicy() {
  return { enabled: r$1t(this.onFields) && this.onFields.length > 0 };
} } } })], i$1a.prototype, "onFields", void 0), e$1W([y$1o({ type: String, json: { write: true } })], i$1a.prototype, "operator", void 0), e$1W([y$1o({ type: String, json: { write: true } })], i$1a.prototype, "searchTerm", void 0), e$1W([y$1o({ type: String, json: { write: true } })], i$1a.prototype, "searchType", void 0), i$1a = e$1W([n$2f("esri.rest.support.FullTextSearch")], i$1a);
const c$1f = i$1a;
var n$15;
const c$1e = new s$1F({ upperLeft: "upper-left", lowerLeft: "lower-left" });
let m$P = n$15 = class extends l$1_ {
  constructor(e2) {
    super(e2), this.extent = null, this.mode = "view", this.originPosition = "upper-left", this.tolerance = 1;
  }
  clone() {
    return new n$15(y$1r({ extent: this.extent, mode: this.mode, originPosition: this.originPosition, tolerance: this.tolerance }));
  }
};
e$1W([y$1o({ type: w$J, json: { write: { overridePolicy() {
  return { enabled: this.mode === "view" };
} } } })], m$P.prototype, "extent", void 0), e$1W([y$1o({ type: ["view", "edit"], json: { write: true } })], m$P.prototype, "mode", void 0), e$1W([y$1o({ type: String, json: { read: c$1e.read, write: c$1e.write } })], m$P.prototype, "originPosition", void 0), e$1W([y$1o({ type: Number, json: { write: { overridePolicy() {
  return { enabled: this.mode === "view" };
} } } })], m$P.prototype, "tolerance", void 0), m$P = n$15 = e$1W([n$2f("esri.rest.support.QuantizationParameters")], m$P);
const a$1h = m$P;
var c$1d;
const n$14 = new s$1F({ count: "count", sum: "sum", min: "min", max: "max", avg: "avg", stddev: "stddev", var: "var", exceedslimit: "exceedslimit", percentile_cont: "percentile-continuous", percentile_disc: "percentile-discrete", EnvelopeAggregate: "envelope-aggregate", CentroidAggregate: "centroid-aggregate", ConvexHullAggregate: "convex-hull-aggregate" });
let p$1w = c$1d = class extends l$1_ {
  constructor(t2) {
    super(t2), this.maxPointCount = void 0, this.maxRecordCount = void 0, this.maxVertexCount = void 0, this.onStatisticField = null, this.outStatisticFieldName = null, this.statisticType = null, this.statisticParameters = null;
  }
  writeStatisticParameters(t2, e2) {
    this.statisticType !== "percentile-continuous" && this.statisticType !== "percentile-discrete" || (e2.statisticParameters = y$1r(t2));
  }
  clone() {
    return new c$1d({ maxPointCount: this.maxPointCount, maxRecordCount: this.maxRecordCount, maxVertexCount: this.maxVertexCount, onStatisticField: this.onStatisticField, outStatisticFieldName: this.outStatisticFieldName, statisticType: this.statisticType, statisticParameters: y$1r(this.statisticParameters) });
  }
};
e$1W([y$1o({ type: Number, json: { write: true } })], p$1w.prototype, "maxPointCount", void 0), e$1W([y$1o({ type: Number, json: { write: true } })], p$1w.prototype, "maxRecordCount", void 0), e$1W([y$1o({ type: Number, json: { write: true } })], p$1w.prototype, "maxVertexCount", void 0), e$1W([y$1o({ type: String, json: { write: true } })], p$1w.prototype, "onStatisticField", void 0), e$1W([y$1o({ type: String, json: { write: true } })], p$1w.prototype, "outStatisticFieldName", void 0), e$1W([y$1o({ type: String, json: { read: { source: "statisticType", reader: n$14.read }, write: { target: "statisticType", writer: n$14.write } } })], p$1w.prototype, "statisticType", void 0), e$1W([y$1o({ type: Object })], p$1w.prototype, "statisticParameters", void 0), e$1W([r$1h("statisticParameters")], p$1w.prototype, "writeStatisticParameters", null), p$1w = c$1d = e$1W([n$2f("esri.rest.support.StatisticDefinition")], p$1w);
const m$O = p$1w;
var v$r;
const g$v = new s$1F({ esriSpatialRelIntersects: "intersects", esriSpatialRelContains: "contains", esriSpatialRelCrosses: "crosses", esriSpatialRelDisjoint: "disjoint", esriSpatialRelEnvelopeIntersects: "envelope-intersects", esriSpatialRelIndexIntersects: "index-intersects", esriSpatialRelOverlaps: "overlaps", esriSpatialRelTouches: "touches", esriSpatialRelWithin: "within", esriSpatialRelRelation: "relation" }), R$b = new s$1F({ esriSRUnit_Meter: "meters", esriSRUnit_Kilometer: "kilometers", esriSRUnit_Foot: "feet", esriSRUnit_StatuteMile: "miles", esriSRUnit_NauticalMile: "nautical-miles", esriSRUnit_USNauticalMile: "us-nautical-miles" });
let b$r = v$r = class extends l$1_ {
  constructor(t2) {
    super(t2), this.aggregateIds = null, this.cacheHint = void 0, this.compactGeometryEnabled = false, this.datumTransformation = null, this.defaultSpatialReferenceEnabled = false, this.distance = void 0, this.dynamicDataSource = void 0, this.formatOf3DObjects = null, this.fullText = null, this.gdbVersion = null, this.geometry = null, this.geometryPrecision = void 0, this.groupByFieldsForStatistics = null, this.having = null, this.historicMoment = null, this.maxAllowableOffset = void 0, this.maxRecordCountFactor = 1, this.multipatchOption = null, this.num = void 0, this.objectIds = null, this.orderByFields = null, this.outFields = null, this.outSpatialReference = null, this.outStatistics = null, this.parameterValues = null, this.pixelSize = null, this.quantizationParameters = null, this.rangeValues = null, this.relationParameter = null, this.resultType = null, this.returnCentroid = false, this.returnDistinctValues = false, this.returnExceededLimitFeatures = true, this.returnGeometry = false, this.returnQueryGeometry = false, this.returnM = void 0, this.returnZ = void 0, this.sourceSpatialReference = null, this.spatialRelationship = "intersects", this.start = void 0, this.sqlFormat = null, this.text = null, this.timeExtent = null, this.timeReferenceUnknownClient = false, this.units = null, this.where = null;
  }
  static from(t2) {
    return v$V(v$r, t2);
  }
  castDatumTransformation(t2) {
    return typeof t2 == "number" || typeof t2 == "object" ? t2 : null;
  }
  writeHistoricMoment(t2, e2) {
    e2.historicMoment = t2 && t2.getTime();
  }
  writeParameterValues(t2, e2) {
    if (t2) {
      const r2 = {};
      for (const e3 in t2) {
        const o2 = t2[e3];
        Array.isArray(o2) ? r2[e3] = o2.map((t3) => t3 instanceof Date ? t3.getTime() : t3) : o2 instanceof Date ? r2[e3] = o2.getTime() : r2[e3] = o2;
      }
      e2.parameterValues = r2;
    }
  }
  writeStart(t2, e2) {
    e2.resultOffset = this.start, e2.resultRecordCount = this.num || 10, e2.where = "1=1";
  }
  writeWhere(t2, e2) {
    e2.where = t2 || "1=1";
  }
  clone() {
    return new v$r(y$1r({ aggregateIds: this.aggregateIds, cacheHint: this.cacheHint, compactGeometryEnabled: this.compactGeometryEnabled, datumTransformation: this.datumTransformation, defaultSpatialReferenceEnabled: this.defaultSpatialReferenceEnabled, distance: this.distance, fullText: this.fullText, gdbVersion: this.gdbVersion, geometry: this.geometry, geometryPrecision: this.geometryPrecision, groupByFieldsForStatistics: this.groupByFieldsForStatistics, having: this.having, historicMoment: r$1t(this.historicMoment) ? new Date(this.historicMoment.getTime()) : null, maxAllowableOffset: this.maxAllowableOffset, maxRecordCountFactor: this.maxRecordCountFactor, multipatchOption: this.multipatchOption, num: this.num, objectIds: this.objectIds, orderByFields: this.orderByFields, outFields: this.outFields, outSpatialReference: this.outSpatialReference, outStatistics: this.outStatistics, parameterValues: this.parameterValues, pixelSize: this.pixelSize, quantizationParameters: this.quantizationParameters, rangeValues: this.rangeValues, relationParameter: this.relationParameter, resultType: this.resultType, returnDistinctValues: this.returnDistinctValues, returnGeometry: this.returnGeometry, returnCentroid: this.returnCentroid, returnExceededLimitFeatures: this.returnExceededLimitFeatures, returnQueryGeometry: this.returnQueryGeometry, returnM: this.returnM, returnZ: this.returnZ, dynamicDataSource: this.dynamicDataSource, sourceSpatialReference: this.sourceSpatialReference, spatialRelationship: this.spatialRelationship, start: this.start, sqlFormat: this.sqlFormat, text: this.text, timeExtent: this.timeExtent, timeReferenceUnknownClient: this.timeReferenceUnknownClient, units: this.units, where: this.where }));
  }
};
b$r.MAX_MAX_RECORD_COUNT_FACTOR = 5, e$1W([y$1o({ json: { write: true } })], b$r.prototype, "aggregateIds", void 0), e$1W([y$1o({ type: Boolean, json: { write: true } })], b$r.prototype, "cacheHint", void 0), e$1W([y$1o({ type: Boolean, json: { default: false, write: true } })], b$r.prototype, "compactGeometryEnabled", void 0), e$1W([y$1o({ json: { write: true } })], b$r.prototype, "datumTransformation", void 0), e$1W([s$1N("datumTransformation")], b$r.prototype, "castDatumTransformation", null), e$1W([y$1o({ type: Boolean, json: { default: false, write: true } })], b$r.prototype, "defaultSpatialReferenceEnabled", void 0), e$1W([y$1o({ type: Number, json: { write: { overridePolicy: (t2) => ({ enabled: t2 > 0 }) } } })], b$r.prototype, "distance", void 0), e$1W([y$1o({ type: K$4, json: { write: true } })], b$r.prototype, "dynamicDataSource", void 0), e$1W([y$1o({ type: String, json: { write: true } })], b$r.prototype, "formatOf3DObjects", void 0), e$1W([y$1o({ type: [c$1f], json: { write: { enabled: true, overridePolicy() {
  return { enabled: r$1t(this.fullText) && this.fullText.length > 0 };
} } } })], b$r.prototype, "fullText", void 0), e$1W([y$1o({ type: String, json: { write: true } })], b$r.prototype, "gdbVersion", void 0), e$1W([y$1o({ types: i$29, json: { read: v$N, write: true } })], b$r.prototype, "geometry", void 0), e$1W([y$1o({ type: Number, json: { write: true } })], b$r.prototype, "geometryPrecision", void 0), e$1W([y$1o({ type: [String], json: { write: true } })], b$r.prototype, "groupByFieldsForStatistics", void 0), e$1W([y$1o({ type: String, json: { write: true } })], b$r.prototype, "having", void 0), e$1W([y$1o({ type: Date })], b$r.prototype, "historicMoment", void 0), e$1W([r$1h("historicMoment")], b$r.prototype, "writeHistoricMoment", null), e$1W([y$1o({ type: Number, json: { write: true } })], b$r.prototype, "maxAllowableOffset", void 0), e$1W([y$1o({ type: Number, cast: (t2) => t2 < 1 ? 1 : t2 > v$r.MAX_MAX_RECORD_COUNT_FACTOR ? v$r.MAX_MAX_RECORD_COUNT_FACTOR : t2, json: { write: { overridePolicy: (t2) => ({ enabled: t2 > 1 }) } } })], b$r.prototype, "maxRecordCountFactor", void 0), e$1W([y$1o({ type: ["xyFootprint"], json: { write: true } })], b$r.prototype, "multipatchOption", void 0), e$1W([y$1o({ type: Number, json: { read: { source: "resultRecordCount" } } })], b$r.prototype, "num", void 0), e$1W([y$1o({ json: { write: true } })], b$r.prototype, "objectIds", void 0), e$1W([y$1o({ type: [String], json: { write: true } })], b$r.prototype, "orderByFields", void 0), e$1W([y$1o({ type: [String], json: { write: true } })], b$r.prototype, "outFields", void 0), e$1W([y$1o({ type: k$p, json: { name: "outSR", write: true } })], b$r.prototype, "outSpatialReference", void 0), e$1W([y$1o({ type: [m$O], json: { write: { enabled: true, overridePolicy() {
  return { enabled: r$1t(this.outStatistics) && this.outStatistics.length > 0 };
} } } })], b$r.prototype, "outStatistics", void 0), e$1W([y$1o({ json: { write: true } })], b$r.prototype, "parameterValues", void 0), e$1W([r$1h("parameterValues")], b$r.prototype, "writeParameterValues", null), e$1W([y$1o({ type: w$K, json: { write: true } })], b$r.prototype, "pixelSize", void 0), e$1W([y$1o({ type: a$1h, json: { write: true } })], b$r.prototype, "quantizationParameters", void 0), e$1W([y$1o({ type: [Object], json: { write: true } })], b$r.prototype, "rangeValues", void 0), e$1W([y$1o({ type: String, json: { read: { source: "relationParam" }, write: { target: "relationParam", overridePolicy() {
  return { enabled: this.spatialRelationship === "relation" };
} } } })], b$r.prototype, "relationParameter", void 0), e$1W([y$1o({ type: String, json: { write: true } })], b$r.prototype, "resultType", void 0), e$1W([y$1o({ type: Boolean, json: { default: false, write: true } })], b$r.prototype, "returnCentroid", void 0), e$1W([y$1o({ type: Boolean, json: { default: false, write: true } })], b$r.prototype, "returnDistinctValues", void 0), e$1W([y$1o({ type: Boolean, json: { default: true, write: true } })], b$r.prototype, "returnExceededLimitFeatures", void 0), e$1W([y$1o({ type: Boolean, json: { write: true } })], b$r.prototype, "returnGeometry", void 0), e$1W([y$1o({ type: Boolean, json: { default: false, write: true } })], b$r.prototype, "returnQueryGeometry", void 0), e$1W([y$1o({ type: Boolean, json: { default: false, write: true } })], b$r.prototype, "returnM", void 0), e$1W([y$1o({ type: Boolean, json: { write: { overridePolicy: (t2) => ({ enabled: t2 }) } } })], b$r.prototype, "returnZ", void 0), e$1W([y$1o({ type: k$p, json: { write: true } })], b$r.prototype, "sourceSpatialReference", void 0), e$1W([r$1a(g$v, { ignoreUnknown: false, name: "spatialRel" })], b$r.prototype, "spatialRelationship", void 0), e$1W([y$1o({ type: Number, json: { read: { source: "resultOffset" } } })], b$r.prototype, "start", void 0), e$1W([r$1h("start"), r$1h("num")], b$r.prototype, "writeStart", null), e$1W([y$1o({ type: String, json: { write: true } })], b$r.prototype, "sqlFormat", void 0), e$1W([y$1o({ type: String, json: { write: true } })], b$r.prototype, "text", void 0), e$1W([y$1o({ type: T$b, json: { write: true } })], b$r.prototype, "timeExtent", void 0), e$1W([y$1o({ type: Boolean, json: { default: false, write: true } })], b$r.prototype, "timeReferenceUnknownClient", void 0), e$1W([r$1a(R$b, { ignoreUnknown: false }), y$1o({ json: { write: { overridePolicy(t2) {
  return { enabled: !!t2 && this.distance != null && this.distance > 0 };
} } } })], b$r.prototype, "units", void 0), e$1W([y$1o({ type: String, json: { write: { overridePolicy(t2) {
  return { enabled: t2 != null || this.start != null && this.start > 0 };
} } } })], b$r.prototype, "where", void 0), e$1W([r$1h("where")], b$r.prototype, "writeWhere", null), b$r = v$r = e$1W([n$2f("esri.rest.support.Query")], b$r);
const x$i = b$r;
async function s$P(r2, t2, e2) {
  const s2 = await a$1g(r2, t2, e2);
  return x$j.fromJSON(s2);
}
async function a$1g(o2, s2, a2) {
  const n2 = f$N(o2), i2 = __spreadValues({}, a2), p2 = x$i.from(s2), { data: u2 } = await c$1h(n2, p2, p2.sourceSpatialReference, i2);
  return u2;
}
function h$z(t2, e2) {
  return t2 ? e2 ? 4 : 3 : e2 ? 3 : 2;
}
const d$C = s$22.getLogger("esri.layers.graphics.featureConversionUtils"), m$N = { esriGeometryPoint: 0, esriGeometryPolyline: 2, esriGeometryPolygon: 3, esriGeometryMultipoint: 0 }, g$u = (t2, e2, o2, n2, r2, s2) => {
  t2[o2] = r2, t2[o2 + 1] = s2;
}, y$C = (t2, e2, o2, n2, r2, s2) => {
  t2[o2] = r2, t2[o2 + 1] = s2, t2[o2 + 2] = e2[n2 + 2];
}, p$1v = (t2, e2, o2, n2, r2, s2) => {
  t2[o2] = r2, t2[o2 + 1] = s2, t2[o2 + 2] = e2[n2 + 3];
}, I$f = (t2, e2, o2, n2, r2, s2) => {
  t2[o2] = r2, t2[o2 + 1] = s2, t2[o2 + 2] = e2[n2 + 2], t2[o2 + 3] = e2[n2 + 3];
};
function b$q(t2, e2, o2, n2) {
  if (t2) {
    if (o2)
      return e2 && n2 ? I$f : y$C;
    if (e2 && n2)
      return p$1v;
  } else if (e2 && n2)
    return y$C;
  return g$u;
}
function w$n({ scale: t2, translate: e2 }, o2) {
  return Math.round((o2 - e2[0]) / t2[0]);
}
function M$7({ scale: t2, translate: e2 }, o2) {
  return Math.round((e2[1] - o2) / t2[1]);
}
function T$a({ scale: t2, translate: e2 }, o2, n2) {
  return o2 * t2[n2] + e2[n2];
}
function F$8(t2, e2, o2) {
  return t2 ? e2 ? o2 ? E$c(t2) : Z$1(t2) : o2 ? k$7(t2) : P$b(t2) : null;
}
function P$b(t2) {
  const e2 = t2.coords;
  return { x: e2[0], y: e2[1] };
}
function x$h(t2, e2) {
  return t2.coords[0] = e2.x, t2.coords[1] = e2.y, t2;
}
function Z$1(t2) {
  const e2 = t2.coords;
  return { x: e2[0], y: e2[1], z: e2[2] };
}
function j$j(t2, e2) {
  return t2.coords[0] = e2.x, t2.coords[1] = e2.y, t2.coords[2] = e2.z, t2;
}
function k$7(t2) {
  const e2 = t2.coords;
  return { x: e2[0], y: e2[1], m: e2[2] };
}
function v$q(t2, e2) {
  return t2.coords[0] = e2.x, t2.coords[1] = e2.y, t2.coords[2] = e2.m, t2;
}
function E$c(t2) {
  const e2 = t2.coords;
  return { x: e2[0], y: e2[1], z: e2[2], m: e2[3] };
}
function z$d(t2, e2) {
  return t2.coords[0] = e2.x, t2.coords[1] = e2.y, t2.coords[2] = e2.z, t2.coords[3] = e2.m, t2;
}
function S$i(t2, e2, n2, r2) {
  let s2 = P$b;
  n2 && r2 ? s2 = E$c : n2 ? s2 = Z$1 : r2 && (s2 = k$7);
  for (const c2 of e2) {
    const { geometry: e3, attributes: n3 } = c2, r3 = r$1t(e3) ? s2(e3) : null;
    t2.push({ attributes: n3, geometry: r3 });
  }
  return t2;
}
function V$6(t2, e2) {
  return t2 && e2 ? z$d : t2 ? j$j : e2 ? v$q : x$h;
}
function Y$1(t2, e2, n2, r2, s2) {
  const c2 = V$6(n2, r2);
  for (const { geometry: u2, attributes: l2 } of e2) {
    const e3 = r$1t(u2) ? c2(new t$O(), u2) : null;
    t2.push(new s$R(e3, l2, null, s2 ? l2[s2] : void 0));
  }
  return t2;
}
function _$i(t2, e2, o2 = V$6(e2.z != null, e2.m != null)) {
  return o2(t2, e2);
}
function L$c(t2, e2, n2, r2) {
  for (const { geometry: s2, attributes: c2 } of e2)
    t2.push({ attributes: c2, geometry: r$1t(s2) ? O$8(s2, n2, r2) : null });
  return t2;
}
function O$8(t2, e2, o2) {
  if (t$1W(t2))
    return null;
  const r2 = h$z(e2, o2), s2 = [];
  for (let n2 = 0; n2 < t2.coords.length; n2 += r2) {
    const e3 = [];
    for (let o3 = 0; o3 < r2; o3++)
      e3.push(t2.coords[n2 + o3]);
    s2.push(e3);
  }
  return e2 ? o2 ? { points: s2, hasZ: e2, hasM: o2 } : { points: s2, hasZ: e2 } : o2 ? { points: s2, hasM: o2 } : { points: s2 };
}
function U$9(t2, e2, n2, r2, s2) {
  const c2 = h$z(n2, r2);
  for (const { geometry: u2, attributes: l2 } of e2) {
    const e3 = r$1t(u2) ? A$6(new t$O(), u2, c2) : null;
    t2.push(new s$R(e3, l2, null, s2 ? l2[s2] : void 0));
  }
  return t2;
}
function A$6(t2, e2, o2 = h$z(e2.hasZ, e2.hasM)) {
  t2.lengths[0] = e2.points.length;
  const n2 = t2.coords;
  let r2 = 0;
  for (const s2 of e2.points)
    for (let t3 = 0; t3 < o2; t3++)
      n2[r2++] = s2[t3];
  return t2;
}
function q$4(t2, e2, n2, r2) {
  for (const { geometry: s2, attributes: c2 } of e2)
    t2.push({ attributes: c2, geometry: r$1t(s2) ? $$4(s2, n2, r2) : null });
  return t2;
}
function $$4(t2, e2, o2) {
  if (!t2)
    return null;
  const n2 = h$z(e2, o2), { coords: r2, lengths: s2 } = t2, c2 = [];
  let u2 = 0;
  for (const l2 of s2) {
    const t3 = [];
    for (let e3 = 0; e3 < l2; e3++) {
      const e4 = [];
      for (let t4 = 0; t4 < n2; t4++)
        e4.push(r2[u2++]);
      t3.push(e4);
    }
    c2.push(t3);
  }
  return e2 ? o2 ? { paths: c2, hasZ: e2, hasM: o2 } : { paths: c2, hasZ: e2 } : o2 ? { paths: c2, hasM: o2 } : { paths: c2 };
}
function R$a(t2, e2, n2, r2, s2) {
  const c2 = h$z(n2, r2);
  for (const { geometry: u2, attributes: l2 } of e2) {
    const e3 = r$1t(u2) ? C$d(new t$O(), u2, c2) : null;
    t2.push(new s$R(e3, l2, null, s2 ? l2[s2] : void 0));
  }
  return t2;
}
function C$d(t2, e2, o2 = h$z(e2.hasZ, e2.hasM)) {
  const { lengths: n2, coords: r2 } = t2;
  let s2 = 0;
  for (const c2 of e2.paths) {
    for (const t3 of c2)
      for (let e3 = 0; e3 < o2; e3++)
        r2[s2++] = t3[e3];
    n2.push(c2.length);
  }
  return t2;
}
function B$7(t2, e2, n2, r2) {
  for (const { geometry: s2, attributes: c2, centroid: u2 } of e2) {
    const e3 = r$1t(s2) ? D$8(s2, n2, r2) : null;
    if (r$1t(u2)) {
      const o2 = P$b(u2);
      t2.push({ attributes: c2, centroid: o2, geometry: e3 });
    } else
      t2.push({ attributes: c2, geometry: e3 });
  }
  return t2;
}
function D$8(t2, e2, o2) {
  if (!t2)
    return null;
  const n2 = h$z(e2, o2), { coords: r2, lengths: s2 } = t2, c2 = [];
  let u2 = 0;
  for (const l2 of s2) {
    const t3 = [];
    for (let e3 = 0; e3 < l2; e3++) {
      const e4 = [];
      for (let t4 = 0; t4 < n2; t4++)
        e4.push(r2[u2++]);
      t3.push(e4);
    }
    c2.push(t3);
  }
  return e2 ? o2 ? { rings: c2, hasZ: e2, hasM: o2 } : { rings: c2, hasZ: e2 } : o2 ? { rings: c2, hasM: o2 } : { rings: c2 };
}
function H$5(t2, e2, n2, r2, s2) {
  for (const { geometry: c2, centroid: u2, attributes: l2 } of e2) {
    const e3 = r$1t(c2) ? J$3(new t$O(), c2, n2, r2) : null, f2 = s2 ? l2[s2] : void 0;
    r$1t(u2) ? t2.push(new s$R(e3, l2, x$h(new t$O(), u2), f2)) : t2.push(new s$R(e3, l2, null, f2));
  }
  return t2;
}
function J$3(t2, e2, o2 = e2.hasZ, n2 = e2.hasM) {
  return K$3(t2, e2.rings, o2, n2), t2;
}
function K$3(t2, e2, o2, n2) {
  const r2 = h$z(o2, n2), { lengths: s2, coords: c2 } = t2;
  let u2 = 0;
  Tt(t2);
  for (const l2 of e2) {
    for (const t3 of l2)
      for (let e3 = 0; e3 < r2; e3++)
        c2[u2++] = t3[e3];
    s2.push(l2.length);
  }
  return t2;
}
const Q$3 = [], W$4 = [];
function X$1(t2, e2, o2, n2, r2) {
  Q$3[0] = t2;
  const [s2] = tt$1(W$4, Q$3, e2, o2, n2, r2);
  return Ft(Q$3), Ft(W$4), s2;
}
function tt$1(e2, o2, n2, r2, s2, c2) {
  if (Ft(e2), !n2) {
    for (const t2 of o2) {
      const o3 = c2 ? t2.attributes[c2] : void 0;
      e2.push(new s$R(null, t2.attributes, null, o3));
    }
    return e2;
  }
  switch (n2) {
    case "esriGeometryPoint":
      return Y$1(e2, o2, r2, s2, c2);
    case "esriGeometryMultipoint":
      return U$9(e2, o2, r2, s2, c2);
    case "esriGeometryPolyline":
      return R$a(e2, o2, r2, s2, c2);
    case "esriGeometryPolygon":
      return H$5(e2, o2, r2, s2, c2);
    default:
      d$C.error("convertToFeatureSet:unknown-geometry", new s$1Z(`Unable to parse unknown geometry type '${n2}'`)), Ft(e2);
  }
  return e2;
}
function et$1(e2, o2, n2, r2, s2, c2) {
  const u2 = e2.length;
  switch (n2) {
    case "esriGeometryPoint":
      Y$1(e2, o2, r2, s2, c2);
      break;
    case "esriGeometryMultipoint":
      U$9(e2, o2, r2, s2, c2);
      break;
    case "esriGeometryPolyline":
      R$a(e2, o2, r2, s2, c2);
      break;
    case "esriGeometryPolygon":
      H$5(e2, o2, r2, s2, c2);
      break;
    default:
      d$C.error("convertToFeatureSet:unknown-geometry", new s$1Z(`Unable to parse unknown geometry type '${n2}'`));
  }
  for (let t2 = 0; t2 < o2.length; t2++)
    e2[t2 + u2].geometryType = n2, e2[t2 + u2].insertAfter = o2[t2].insertAfter, e2[t2 + u2].groupId = o2[t2].groupId;
  return e2;
}
function ot$1(t2, e2, o2, n2) {
  W$4[0] = t2, ct$1(Q$3, W$4, e2, o2, n2);
  const r2 = Q$3[0];
  return Ft(Q$3), Ft(W$4), r2;
}
function nt$1(e2, o2, r2) {
  if (t$1W(e2))
    return null;
  const i2 = new t$O();
  if ("hasZ" in e2 && o2 == null && (o2 = e2.hasZ), "hasM" in e2 && r2 == null && (r2 = e2.hasM), s$1E(e2)) {
    return V$6(o2 != null ? o2 : e2.z != null, r2 != null ? r2 : e2.m != null)(i2, e2);
  }
  return y$1a(e2) ? J$3(i2, e2, o2, r2) : f$1j(e2) ? C$d(i2, e2, h$z(o2, r2)) : l$1S(e2) ? A$6(i2, e2, h$z(o2, r2)) : void d$C.error("convertFromGeometry:unknown-geometry", new s$1Z(`Unable to parse unknown geometry type '${e2}'`));
}
function rt$1(e2, o2, r2, s2) {
  const c2 = e2 && ("coords" in e2 ? e2 : e2.geometry);
  if (t$1W(c2))
    return null;
  switch (o2) {
    case "esriGeometryPoint": {
      let t2 = P$b;
      return r2 && s2 ? t2 = E$c : r2 ? t2 = Z$1 : s2 && (t2 = k$7), t2(c2);
    }
    case "esriGeometryMultipoint":
      return O$8(c2, r2, s2);
    case "esriGeometryPolyline":
      return $$4(c2, r2, s2);
    case "esriGeometryPolygon":
      return D$8(c2, r2, s2);
    default:
      return d$C.error("convertToGeometry:unknown-geometry", new s$1Z(`Unable to parse unknown geometry type '${o2}'`)), null;
  }
}
function st$1(t2, e2) {
  for (const o2 of e2)
    t2.push({ attributes: o2.attributes });
  return t2;
}
function ct$1(e2, o2, r2, s2, c2) {
  if (Ft(e2), t$1W(r2))
    return st$1(e2, o2);
  switch (r2) {
    case "esriGeometryPoint":
      return S$i(e2, o2, s2, c2);
    case "esriGeometryMultipoint":
      return L$c(e2, o2, s2, c2);
    case "esriGeometryPolyline":
      return q$4(e2, o2, s2, c2);
    case "esriGeometryPolygon":
      return B$7(e2, o2, s2, c2);
    default:
      d$C.error("convertToFeatureSet:unknown-geometry", new s$1Z(`Unable to parse unknown geometry type '${r2}'`));
  }
  return e2;
}
function ut$1(t2) {
  const { objectIdFieldName: e2, spatialReference: o2, transform: n2, fields: r2, hasM: s2, hasZ: c2, features: u2, geometryType: l2, exceededTransferLimit: i2, uniqueIdField: f2, queryGeometry: a2, queryGeometryType: h2 } = t2, d2 = { features: ct$1([], u2, l2, c2, s2), fields: r2, geometryType: l2, objectIdFieldName: e2, spatialReference: o2, uniqueIdField: f2, queryGeometry: rt$1(a2, h2, false, false) };
  return n2 && (d2.transform = n2), i2 && (d2.exceededTransferLimit = i2), s2 && (d2.hasM = s2), c2 && (d2.hasZ = c2), d2;
}
function lt$1(e2, o2) {
  var _a2;
  const n2 = new e$K(), { hasM: r2, hasZ: s2, features: c2, objectIdFieldName: u2, spatialReference: l2, geometryType: i2, exceededTransferLimit: a2, transform: h2, fields: m2 } = e2;
  return m2 && (n2.fields = m2), n2.geometryType = i2 != null ? i2 : null, n2.objectIdFieldName = (_a2 = u2 != null ? u2 : o2) != null ? _a2 : null, n2.spatialReference = l2 != null ? l2 : null, n2.objectIdFieldName ? (c2 && tt$1(n2.features, c2, i2, s2, r2, n2.objectIdFieldName), a2 && (n2.exceededTransferLimit = a2), r2 && (n2.hasM = r2), s2 && (n2.hasZ = s2), h2 && (n2.transform = h2), n2) : (d$C.error(new s$1Z("optimized-features:invalid-objectIdFieldName", "objectIdFieldName is missing")), n2);
}
function it$1(t2) {
  const { transform: e2, features: n2, hasM: r2, hasZ: s2 } = t2;
  if (!e2)
    return t2;
  for (const c2 of n2)
    r$1t(c2.geometry) && pt$1(c2.geometry, c2.geometry, r2, s2, e2), r$1t(c2.centroid) && pt$1(c2.centroid, c2.centroid, r2, s2, e2);
  return t2.transform = null, t2;
}
function ft$1(t2, e2) {
  const { geometryType: o2, features: n2, hasM: r2, hasZ: s2 } = e2;
  if (!t2)
    return e2;
  for (let c2 = 0; c2 < n2.length; c2++) {
    const e3 = n2[c2], u2 = e3.weakClone();
    u2.geometry = new t$O(), at$1(u2.geometry, e3.geometry, r2, s2, o2, t2), e3.centroid && (u2.centroid = new t$O(), at$1(u2.centroid, e3.centroid, r2, s2, "esriGeometryPoint", t2)), n2[c2] = u2;
  }
  return e2.transform = t2, e2;
}
function at$1(t2, e2, o2, r2, s2, c2, u2 = o2, l2 = r2) {
  if (Tt(t2), t$1W(e2) || !e2.coords.length)
    return null;
  const i2 = m$N[s2], { coords: f2, lengths: a2 } = e2, d2 = h$z(o2, r2), g2 = h$z(o2 && u2, r2 && l2), y2 = b$q(o2, r2, u2, l2);
  if (!a2.length)
    return y2(t2.coords, f2, 0, 0, w$n(c2, f2[0]), M$7(c2, f2[1])), Tt(t2, d2, 0), t2;
  let p2, I2, N2, G2, T2 = 0, F2 = 0, P2 = F2;
  for (const n2 of a2) {
    if (n2 < i2)
      continue;
    let e3 = 0;
    F2 = P2, N2 = p2 = w$n(c2, f2[T2]), G2 = I2 = M$7(c2, f2[T2 + 1]), y2(t2.coords, f2, F2, T2, N2, G2), e3++, T2 += d2, F2 += g2;
    for (let o3 = 1; o3 < n2; o3++, T2 += d2)
      N2 = w$n(c2, f2[T2]), G2 = M$7(c2, f2[T2 + 1]), N2 === p2 && G2 === I2 || (y2(t2.coords, f2, F2, T2, N2 - p2, G2 - I2), F2 += g2, e3++, p2 = N2, I2 = G2);
    e3 >= i2 && (t2.lengths.push(e3), P2 = F2);
  }
  return Ft(t2.coords, P2), t2.coords.length ? t2 : null;
}
function ht$1(t2, e2, o2, n2, r2, s2, c2 = o2, u2 = n2) {
  if (Tt(t2), !e2 || !e2.coords.length)
    return null;
  const l2 = m$N[r2], { coords: i2, lengths: f2 } = e2, a2 = h$z(o2, n2), d2 = h$z(o2 && c2, n2 && u2), g2 = b$q(o2, n2, c2, u2);
  if (!f2.length)
    return g2(t2.coords, i2, 0, 0, i2[0], i2[1]), Tt(t2, a2, 0), t2;
  let y2 = 0;
  const p2 = s2 * s2;
  for (const h2 of f2) {
    if (h2 < l2) {
      y2 += h2 * a2;
      continue;
    }
    const e3 = t2.coords.length / d2, o3 = y2, n3 = y2 + (h2 - 1) * a2;
    g2(t2.coords, i2, t2.coords.length, o3, i2[o3], i2[o3 + 1]), mt$1(t2.coords, i2, a2, p2, g2, o3, n3), g2(t2.coords, i2, t2.coords.length, n3, i2[n3], i2[n3 + 1]);
    const r3 = t2.coords.length / d2 - e3;
    r3 >= l2 ? t2.lengths.push(r3) : Ft(t2.coords, e3 * d2), y2 += h2 * a2;
  }
  return t2.coords.length ? t2 : null;
}
function dt$1(t2, e2, o2, n2) {
  const r2 = t2[e2], s2 = t2[e2 + 1], c2 = t2[o2], u2 = t2[o2 + 1], l2 = t2[n2], i2 = t2[n2 + 1];
  let f2 = c2, a2 = u2, h2 = l2 - f2, d2 = i2 - a2;
  if (h2 !== 0 || d2 !== 0) {
    const t3 = ((r2 - f2) * h2 + (s2 - a2) * d2) / (h2 * h2 + d2 * d2);
    t3 > 1 ? (f2 = l2, a2 = i2) : t3 > 0 && (f2 += h2 * t3, a2 += d2 * t3);
  }
  return h2 = r2 - f2, d2 = s2 - a2, h2 * h2 + d2 * d2;
}
function mt$1(t2, e2, o2, n2, r2, s2, c2) {
  let u2, l2 = n2, i2 = 0;
  for (let f2 = s2 + o2; f2 < c2; f2 += o2)
    u2 = dt$1(e2, f2, s2, c2), u2 > l2 && (i2 = f2, l2 = u2);
  l2 > n2 && (i2 - s2 > o2 && mt$1(t2, e2, o2, n2, r2, s2, i2), r2(t2, e2, t2.length, i2, e2[i2], e2[i2 + 1]), c2 - i2 > o2 && mt$1(t2, e2, o2, n2, r2, i2, c2));
}
function gt$1(t2, e2, o2, r2) {
  if (t$1W(e2) || !e2.coords || !e2.coords.length)
    return null;
  const s2 = h$z(o2, r2);
  let c2 = Number.POSITIVE_INFINITY, u2 = Number.POSITIVE_INFINITY, l2 = Number.NEGATIVE_INFINITY, i2 = Number.NEGATIVE_INFINITY;
  if (e2 && e2.coords) {
    const t3 = e2.coords;
    for (let e3 = 0; e3 < t3.length; e3 += s2) {
      const o3 = t3[e3], n2 = t3[e3 + 1];
      c2 = Math.min(c2, o3), l2 = Math.max(l2, o3), u2 = Math.min(u2, n2), i2 = Math.max(i2, n2);
    }
  }
  return t2[0] = c2, t2[1] = u2, t2[2] = l2, t2[3] = i2, t2;
}
function pt$1(t2, e2, o2, n2, s2) {
  var _a2, _b2, _c2, _d2, _e3, _f2, _g2, _h2;
  const { coords: c2, lengths: u2 } = e2, l2 = h$z(o2, n2);
  if (!c2.length)
    return t2 !== e2 && Tt(t2), t2;
  c$2W(s2);
  const { originPosition: i2, scale: f2, translate: a2 } = s2, d2 = Pt;
  d2.originPosition = i2;
  const m2 = d2.scale;
  m2[0] = (_a2 = f2[0]) != null ? _a2 : 1, m2[1] = -((_b2 = f2[1]) != null ? _b2 : 1), m2[2] = (_c2 = f2[2]) != null ? _c2 : 1, m2[3] = (_d2 = f2[3]) != null ? _d2 : 1;
  const g2 = d2.translate;
  if (g2[0] = (_e3 = a2[0]) != null ? _e3 : 0, g2[1] = (_f2 = a2[1]) != null ? _f2 : 0, g2[2] = (_g2 = a2[2]) != null ? _g2 : 0, g2[3] = (_h2 = a2[3]) != null ? _h2 : 0, !u2.length) {
    for (let e3 = 0; e3 < l2; ++e3)
      t2.coords[e3] = T$a(d2, c2[e3], e3);
    return t2 !== e2 && Tt(t2, l2, 0), t2;
  }
  let y2 = 0;
  for (let r2 = 0; r2 < u2.length; r2++) {
    const e3 = u2[r2];
    t2.lengths[r2] = e3;
    for (let r3 = 0; r3 < l2; ++r3)
      t2.coords[y2 + r3] = T$a(d2, c2[y2 + r3], r3);
    let o3 = t2.coords[y2], n3 = t2.coords[y2 + 1];
    y2 += l2;
    for (let r3 = 1; r3 < e3; r3++, y2 += l2) {
      o3 += c2[y2] * m2[0], n3 += c2[y2 + 1] * m2[1], t2.coords[y2] = o3, t2.coords[y2 + 1] = n3;
      for (let e4 = 2; e4 < l2; ++e4)
        t2.coords[y2 + e4] = T$a(d2, c2[y2 + e4], e4);
    }
  }
  return t2 !== e2 && Tt(t2, c2.length, u2.length), t2;
}
function It(t2, e2, o2, n2, r2, s2) {
  if (Tt(t2), t2.lengths.push(...e2.lengths), o2 === r2 && n2 === s2)
    for (let c2 = 0; c2 < e2.coords.length; c2++)
      t2.coords.push(e2.coords[c2]);
  else {
    const c2 = h$z(o2, n2), u2 = b$q(o2, n2, r2, s2), l2 = e2.coords;
    for (let e3 = 0; e3 < l2.length; e3 += c2)
      u2(t2.coords, l2, t2.coords.length, e3, l2[e3], l2[e3 + 1]);
  }
  return t2;
}
function wt$1(t2, e2, o2, n2) {
  let r2 = 0, s2 = t2[n2 * e2], c2 = t2[n2 * (e2 + 1)];
  for (let u2 = 1; u2 < o2; u2++) {
    const o3 = s2 + t2[n2 * (e2 + u2)], l2 = c2 + t2[n2 * (e2 + u2) + 1], i2 = (o3 - s2) * (l2 + c2);
    s2 = o3, c2 = l2, r2 += i2;
  }
  return 0.5 * r2;
}
function Mt(t2, e2) {
  const { coords: o2, lengths: n2 } = t2;
  let r2 = 0, s2 = 0;
  for (let c2 = 0; c2 < n2.length; c2++) {
    const t3 = n2[c2];
    s2 += wt$1(o2, r2, t3, e2), r2 += t3;
  }
  return Math.abs(s2);
}
function Gt$1(t2, e2) {
  if (t$1W(t2))
    return null;
  const o2 = t2.clone(), r2 = t2.coords, s2 = t2.lengths;
  let c2 = 0;
  for (let n2 = 0; n2 < s2.length; n2++) {
    const t3 = s2[n2];
    let u2 = r2[e2 * c2], l2 = r2[e2 * c2 + 1];
    for (let n3 = 1; n3 < t3; n3++) {
      const t4 = u2 + r2[e2 * (c2 + n3)], s3 = l2 + r2[e2 * (c2 + n3) + 1];
      o2.coords[e2 * (c2 + n3)] = t4, o2.coords[e2 * (c2 + n3) + 1] = s3, u2 = t4, l2 = s3;
    }
    c2 += t3;
  }
  return o2;
}
function Tt(t2, e2 = 0, o2 = 0) {
  Ft(t2.lengths, o2), Ft(t2.coords, e2);
}
function Ft(t2, e2 = 0) {
  t2.length !== e2 && (t2.length = e2);
}
const Pt = { originPosition: "lowerLeft", scale: [1, 1, 1, 1], translate: [0, 0, 0, 0] };
var u$Q;
let c$1c = u$Q = class extends l$1_ {
  constructor(t2) {
    super(t2), this.cacheHint = void 0, this.dynamicDataSource = void 0, this.gdbVersion = null, this.geometryPrecision = void 0, this.historicMoment = null, this.maxAllowableOffset = void 0, this.objectIds = null, this.orderByFields = null, this.outFields = null, this.outSpatialReference = null, this.relationshipId = void 0, this.start = void 0, this.num = void 0, this.returnGeometry = false, this.returnM = void 0, this.returnZ = void 0, this.where = null;
  }
  _writeHistoricMoment(t2, e2) {
    e2.historicMoment = t2 && t2.getTime();
  }
  writeStart(t2, e2) {
    e2.resultOffset = this.start, e2.resultRecordCount = this.num || 10, this.start > 0 && this.where == null && (e2.definitionExpression = "1=1");
  }
  clone() {
    return new u$Q(y$1r({ cacheHint: this.cacheHint, dynamicDataSource: this.dynamicDataSource, gdbVersion: this.gdbVersion, geometryPrecision: this.geometryPrecision, historicMoment: this.historicMoment && new Date(this.historicMoment.getTime()), maxAllowableOffset: this.maxAllowableOffset, objectIds: this.objectIds, orderByFields: this.orderByFields, outFields: this.outFields, outSpatialReference: this.outSpatialReference, relationshipId: this.relationshipId, start: this.start, num: this.num, returnGeometry: this.returnGeometry, where: this.where, returnZ: this.returnZ, returnM: this.returnM }));
  }
};
e$1W([y$1o({ type: Boolean, json: { write: true } })], c$1c.prototype, "cacheHint", void 0), e$1W([y$1o({ type: K$4, json: { write: true } })], c$1c.prototype, "dynamicDataSource", void 0), e$1W([y$1o({ type: String, json: { write: true } })], c$1c.prototype, "gdbVersion", void 0), e$1W([y$1o({ type: Number, json: { write: true } })], c$1c.prototype, "geometryPrecision", void 0), e$1W([y$1o({ type: Date })], c$1c.prototype, "historicMoment", void 0), e$1W([r$1h("historicMoment")], c$1c.prototype, "_writeHistoricMoment", null), e$1W([y$1o({ type: Number, json: { write: true } })], c$1c.prototype, "maxAllowableOffset", void 0), e$1W([y$1o({ type: [Number], json: { write: true } })], c$1c.prototype, "objectIds", void 0), e$1W([y$1o({ type: [String], json: { write: true } })], c$1c.prototype, "orderByFields", void 0), e$1W([y$1o({ type: [String], json: { write: true } })], c$1c.prototype, "outFields", void 0), e$1W([y$1o({ type: k$p, json: { read: { source: "outSR" }, write: { target: "outSR" } } })], c$1c.prototype, "outSpatialReference", void 0), e$1W([y$1o({ json: { write: true } })], c$1c.prototype, "relationshipId", void 0), e$1W([y$1o({ type: Number, json: { read: { source: "resultOffset" } } })], c$1c.prototype, "start", void 0), e$1W([r$1h("start"), r$1h("num")], c$1c.prototype, "writeStart", null), e$1W([y$1o({ type: Number, json: { read: { source: "resultRecordCount" } } })], c$1c.prototype, "num", void 0), e$1W([y$1o({ json: { write: true } })], c$1c.prototype, "returnGeometry", void 0), e$1W([y$1o({ type: Boolean, json: { write: { overridePolicy: (t2) => ({ enabled: t2 }) } } })], c$1c.prototype, "returnM", void 0), e$1W([y$1o({ type: Boolean, json: { write: { overridePolicy: (t2) => ({ enabled: t2 }) } } })], c$1c.prototype, "returnZ", void 0), e$1W([y$1o({ type: String, json: { read: { source: "definitionExpression" }, write: { target: "definitionExpression" } } })], c$1c.prototype, "where", void 0), c$1c = u$Q = e$1W([n$2f("esri.rest.support.RelationshipQuery")], c$1c), c$1c.from = b$U(c$1c);
const d$B = c$1c;
var e$I;
let p$1u = e$I = class extends l$1_ {
  constructor(o2) {
    super(o2), this.groupByFields = void 0, this.topCount = void 0, this.orderByFields = void 0;
  }
  clone() {
    return new e$I({ groupByFields: this.groupByFields, topCount: this.topCount, orderByFields: this.orderByFields });
  }
};
e$1W([y$1o({ type: [String], json: { write: true } })], p$1u.prototype, "groupByFields", void 0), e$1W([y$1o({ type: Number, json: { write: true } })], p$1u.prototype, "topCount", void 0), e$1W([y$1o({ type: [String], json: { write: true } })], p$1u.prototype, "orderByFields", void 0), p$1u = e$I = e$1W([n$2f("esri.rest.support.TopFilter")], p$1u);
const i$19 = p$1u;
var y$B;
const h$y = new s$1F({ esriSpatialRelIntersects: "intersects", esriSpatialRelContains: "contains", esriSpatialRelCrosses: "crosses", esriSpatialRelDisjoint: "disjoint", esriSpatialRelEnvelopeIntersects: "envelope-intersects", esriSpatialRelIndexIntersects: "index-intersects", esriSpatialRelOverlaps: "overlaps", esriSpatialRelTouches: "touches", esriSpatialRelWithin: "within", esriSpatialRelRelation: "relation" }), j$i = new s$1F({ esriSRUnit_Meter: "meters", esriSRUnit_Kilometer: "kilometers", esriSRUnit_Foot: "feet", esriSRUnit_StatuteMile: "miles", esriSRUnit_NauticalMile: "nautical-miles", esriSRUnit_USNauticalMile: "us-nautical-miles" });
let S$h = y$B = class extends l$1_ {
  constructor(e2) {
    super(e2), this.cacheHint = void 0, this.distance = void 0, this.geometry = null, this.geometryPrecision = void 0, this.maxAllowableOffset = void 0, this.num = void 0, this.objectIds = null, this.orderByFields = null, this.outFields = null, this.outSpatialReference = null, this.resultType = null, this.returnGeometry = false, this.returnM = void 0, this.returnZ = void 0, this.start = void 0, this.spatialRelationship = "intersects", this.timeExtent = null, this.topFilter = void 0, this.units = null, this.where = "1=1";
  }
  writeStart(e2, t2) {
    t2.resultOffset = this.start, t2.resultRecordCount = this.num || 10;
  }
  clone() {
    return new y$B(y$1r({ cacheHint: this.cacheHint, distance: this.distance, geometry: this.geometry, geometryPrecision: this.geometryPrecision, maxAllowableOffset: this.maxAllowableOffset, num: this.num, objectIds: this.objectIds, orderByFields: this.orderByFields, outFields: this.outFields, outSpatialReference: this.outSpatialReference, resultType: this.resultType, returnGeometry: this.returnGeometry, returnZ: this.returnZ, returnM: this.returnM, start: this.start, spatialRelationship: this.spatialRelationship, timeExtent: this.timeExtent, topFilter: this.topFilter, units: this.units, where: this.where }));
  }
};
e$1W([y$1o({ type: Boolean, json: { write: true } })], S$h.prototype, "cacheHint", void 0), e$1W([y$1o({ type: Number, json: { write: { overridePolicy: (e2) => ({ enabled: e2 > 0 }) } } })], S$h.prototype, "distance", void 0), e$1W([y$1o({ types: i$29, json: { read: v$N, write: true } })], S$h.prototype, "geometry", void 0), e$1W([y$1o({ type: Number, json: { write: true } })], S$h.prototype, "geometryPrecision", void 0), e$1W([y$1o({ type: Number, json: { write: true } })], S$h.prototype, "maxAllowableOffset", void 0), e$1W([y$1o({ type: Number, json: { read: { source: "resultRecordCount" } } })], S$h.prototype, "num", void 0), e$1W([y$1o({ json: { write: true } })], S$h.prototype, "objectIds", void 0), e$1W([y$1o({ type: [String], json: { write: true } })], S$h.prototype, "orderByFields", void 0), e$1W([y$1o({ type: [String], json: { write: true } })], S$h.prototype, "outFields", void 0), e$1W([y$1o({ type: k$p, json: { read: { source: "outSR" }, write: { target: "outSR" } } })], S$h.prototype, "outSpatialReference", void 0), e$1W([y$1o({ type: String, json: { write: true } })], S$h.prototype, "resultType", void 0), e$1W([y$1o({ json: { write: true } })], S$h.prototype, "returnGeometry", void 0), e$1W([y$1o({ type: Boolean, json: { write: { overridePolicy: (e2) => ({ enabled: e2 }) } } })], S$h.prototype, "returnM", void 0), e$1W([y$1o({ type: Boolean, json: { write: { overridePolicy: (e2) => ({ enabled: e2 }) } } })], S$h.prototype, "returnZ", void 0), e$1W([y$1o({ type: Number, json: { read: { source: "resultOffset" } } })], S$h.prototype, "start", void 0), e$1W([r$1h("start"), r$1h("num")], S$h.prototype, "writeStart", null), e$1W([y$1o({ type: String, json: { read: { source: "spatialRel", reader: h$y.read }, write: { target: "spatialRel", writer: h$y.write } } })], S$h.prototype, "spatialRelationship", void 0), e$1W([y$1o({ type: T$b, json: { write: true } })], S$h.prototype, "timeExtent", void 0), e$1W([y$1o({ type: i$19, json: { write: true } })], S$h.prototype, "topFilter", void 0), e$1W([y$1o({ type: String, json: { read: j$i.read, write: { writer: j$i.write, overridePolicy(e2) {
  return { enabled: r$1t(e2) && r$1t(this.distance) && this.distance > 0 };
} } } })], S$h.prototype, "units", void 0), e$1W([y$1o({ type: String, json: { write: true } })], S$h.prototype, "where", void 0), S$h = y$B = e$1W([n$2f("esri.rest.support.TopFeaturesQuery")], S$h), S$h.from = b$U(S$h);
const v$p = S$h;
const p$1t = "esri.widgets.Feature.support.relatedFeatureUtils", c$1b = s$22.getLogger(p$1t), f$K = new Map();
function d$A(e2) {
  if (!le(e2))
    return null;
  const [t2, r2] = e2.split("/").slice(1);
  return { layerId: t2, fieldName: r2 };
}
function m$M(e2, t2) {
  if (!t2.relationships)
    return null;
  let r2 = null;
  const { relationships: s2 } = t2;
  return s2.some((t3) => t3.id === parseInt(e2, 10) && (r2 = t3, true)), r2;
}
function y$A({ originRelationship: e2, relationships: t2, layerId: r2 }) {
  let s2;
  return t2 && t2.some((t3) => (`${t3.relatedTableId}` === r2 && t3.id === e2.id && (s2 = t3), !!s2)), s2;
}
function j$h(e2, t2) {
  const r2 = t2.toLowerCase();
  for (const s2 in e2)
    if (s2.toLowerCase() === r2)
      return e2[s2];
  return null;
}
function h$x(e2, t2) {
  const r2 = m$M(e2, t2);
  if (!r2)
    return;
  return { url: `${t2.url}/${r2.relatedTableId}`, sourceSpatialReference: t2.spatialReference, relation: r2, relatedFields: [], outStatistics: [] };
}
function g$t(e2, t2) {
  if (!t2)
    return;
  if (!e2)
    return;
  const { features: r2, statsFeatures: s2 } = e2, o2 = r2 && r2.value;
  t2.relatedFeatures = o2 ? o2.features : [];
  const i2 = s2 && s2.value;
  t2.relatedStatsFeatures = i2 ? i2.features : [];
}
function F$7(e2, t2, r2, s2) {
  const o2 = new d$B();
  return o2.outFields = ["*"], o2.relationshipId = typeof t2.id == "number" ? t2.id : parseInt(t2.id, 10), o2.objectIds = [e2.attributes[r2.objectIdField]], r2.queryRelatedFeatures(o2, s2);
}
function I$e(e2, t2, r2) {
  let s2 = 0;
  const o2 = [];
  for (; s2 < t2.length; )
    o2.push(`${e2} IN (${t2.slice(s2, r2 + s2)})`), s2 += r2;
  return o2.join(" OR ");
}
async function S$g(e2, t2, r2, a2) {
  const l2 = r2.layerId.toString(), { layerInfo: u2, relation: p2, relatedFields: c2, outStatistics: f2, url: d2, sourceSpatialReference: m2 } = t2, h2 = y$A({ originRelationship: p2, relationships: u2.relationships, layerId: l2 });
  if (h2.relationshipTableId && h2.keyFieldInRelationshipTable) {
    const t3 = (await F$7(e2, h2, r2, a2))[e2.attributes[r2.objectIdField]];
    if (!t3)
      return null;
    const o2 = t3.features.map((e3) => e3.attributes[u2.objectIdField]);
    if ((f2 == null ? void 0 : f2.length) > 0 && u2.supportsStatistics) {
      const e3 = new x$i();
      e3.where = I$e(u2.objectIdField, o2, 1e3), e3.outFields = c2, e3.outStatistics = f2, e3.sourceSpatialReference = m2;
      const r3 = { features: Promise.resolve(t3), statsFeatures: s$P(d2, e3) };
      return E$v(r3);
    }
  }
  const g2 = h2 == null ? void 0 : h2.keyField;
  if (g2) {
    const r3 = ie$3(U$8(u2.fields, g2)), l3 = j$h(e2.attributes, p2.keyField), c3 = r3 ? `${g2}=${l3}` : `${g2}='${l3}'`, f3 = s$P(d2, new x$i({ where: c3, outFields: t2.relatedFields, sourceSpatialReference: m2 }), a2), y2 = t2.outStatistics && t2.outStatistics.length > 0 && u2.supportsStatistics ? s$P(d2, new x$i({ where: c3, outFields: t2.relatedFields, outStatistics: t2.outStatistics, sourceSpatialReference: m2 }), a2) : null, h3 = { features: f3 };
    return y2 && (h3.statsFeatures = y2), E$v(h3);
  }
  return null;
}
function w$m(t2, r2) {
  return U$k(t2, { query: { f: "json" }, signal: r2 && r2.signal });
}
function b$p({ relatedInfos: e2, layer: r2 }, o2) {
  const i2 = {};
  return e2.forEach((e3, s2) => {
    const { relation: n2 } = e3;
    if (!n2) {
      const e4 = new s$1Z("relation-required", "A relation is required on a layer to retrieve related records.");
      throw c$1b.error(e4), e4;
    }
    const { relatedTableId: a2 } = n2;
    if (typeof a2 != "number") {
      const e4 = new s$1Z("A related table ID is required on a layer to retrieve related records.");
      throw c$1b.error(e4), e4;
    }
    const l2 = `${r2.url}/${a2}`, u2 = f$K.get(l2), p2 = u2 || w$m(l2, o2);
    u2 || f$K.set(l2, p2), i2[s2] = p2;
  }), E$v(i2);
}
function R$9({ graphic: e2, relatedInfos: t2, layer: r2 }, o2) {
  const i2 = {};
  return t2.forEach((t3, s2) => {
    t3.layerInfo && (i2[s2] = S$g(e2, t3, r2, o2));
  }), E$v(i2);
}
function $$3({ relatedInfo: e2, fieldName: t2, fieldInfo: r2 }) {
  if (e2.relatedFields.push(t2), r2.statisticType) {
    const s2 = new m$O({ statisticType: r2.statisticType, onStatisticField: t2, outStatisticFieldName: t2 });
    e2.outStatistics.push(s2);
  }
}
function U$8(e2, t2) {
  if (e2 != null) {
    t2 = t2.toLowerCase();
    for (const r2 of e2)
      if (r2 && r2.name.toLowerCase() === t2)
        return r2;
  }
  return null;
}
const y$z = { chartAnimation: true };
let I$d = class extends m$1L {
  constructor(t2) {
    super(t2), this.abilities = __spreadValues({}, y$z), this.activeMediaInfoIndex = 0, this.attributes = null, this.description = null, this.fieldInfoMap = null, this.formattedAttributes = null, this.expressionAttributes = null, this.layer = null, this.mediaInfos = null, this.popupTemplate = null, this.relatedInfos = null, this.title = null;
  }
  castAbilities(t2) {
    return __spreadValues(__spreadValues({}, y$z), t2);
  }
  get activeMediaInfo() {
    return this.formattedMediaInfos[this.activeMediaInfoIndex] || null;
  }
  get formattedMediaInfos() {
    return this._formatMediaInfos() || [];
  }
  get formattedMediaInfoCount() {
    return this.formattedMediaInfos.length;
  }
  setActiveMedia(t2) {
    this._setContentElementMedia(t2);
  }
  next() {
    this._pageContentElementMedia(1);
  }
  previous() {
    this._pageContentElementMedia(-1);
  }
  _setContentElementMedia(t2) {
    const { formattedMediaInfoCount: e2 } = this, i2 = (t2 + e2) % e2;
    this.activeMediaInfoIndex = i2;
  }
  _pageContentElementMedia(t2) {
    const { activeMediaInfoIndex: e2 } = this, i2 = e2 + t2;
    this._setContentElementMedia(i2);
  }
  _formatMediaInfos() {
    const { attributes: t2, mediaInfos: e2, formattedAttributes: i2, expressionAttributes: o2, fieldInfoMap: r2, layer: a2 } = this;
    return e2 == null ? void 0 : e2.map((e3) => {
      const s2 = e3 == null ? void 0 : e3.clone();
      if (!s2)
        return null;
      if (s2.title = $$7({ attributes: t2, fieldInfoMap: r2, globalAttributes: i2, expressionAttributes: o2, layer: a2, text: s2.title }), s2.caption = $$7({ attributes: t2, fieldInfoMap: r2, globalAttributes: i2, expressionAttributes: o2, layer: a2, text: s2.caption }), s2.altText = $$7({ attributes: t2, fieldInfoMap: r2, globalAttributes: i2, expressionAttributes: o2, layer: a2, text: s2.altText }), s2.type === "image") {
        const { value: t3 } = s2;
        return this._setImageValue({ value: t3, formattedAttributes: i2, layer: a2 }), s2.value.sourceURL ? s2 : void 0;
      }
      if (s2.type === "pie-chart" || s2.type === "line-chart" || s2.type === "column-chart" || s2.type === "bar-chart") {
        const { value: e4 } = s2;
        return this._setChartValue({ value: e4, chartType: s2.type, attributes: t2, formattedAttributes: i2, layer: a2, expressionAttributes: o2 }), s2;
      }
      return null;
    }).filter(Boolean);
  }
  _setImageValue(t2) {
    const { fieldInfoMap: e2 } = this, { value: i2, formattedAttributes: o2, layer: r2 } = t2, { linkURL: a2, sourceURL: s2 } = i2;
    if (s2) {
      const t3 = P$e(s2, r2);
      i2.sourceURL = S$n({ formattedAttributes: o2, template: t3, fieldInfoMap: e2 });
    }
    if (a2) {
      const t3 = P$e(a2, r2);
      i2.linkURL = S$n({ formattedAttributes: o2, template: t3, fieldInfoMap: e2 });
    }
  }
  _setChartValue(t2) {
    const { value: e2, attributes: i2, formattedAttributes: o2, chartType: r2, layer: a2, expressionAttributes: s2 } = t2, { popupTemplate: l2, relatedInfos: n2 } = this, { fields: p2, normalizeField: c2 } = e2;
    e2.fields = L$f(p2, a2), c2 && (e2.normalizeField = D$b(c2, a2));
    if (!p2.some((t3) => !!(o2[t3] != null || le(t3) && n2.size)))
      return;
    const m2 = l2 == null ? void 0 : l2.fieldInfos;
    p2.forEach((t3) => {
      if (le(t3))
        return void (e2.series = [...e2.series, ...this._getRelatedChartInfos({ fieldInfos: m2, fieldName: t3, formattedAttributes: o2, chartType: r2, value: e2 })]);
      const a3 = this._getChartOption({ value: e2, attributes: i2, chartType: r2, formattedAttributes: o2, expressionAttributes: s2, fieldName: t3, fieldInfos: m2 });
      e2.series.push(a3);
    });
  }
  _getRelatedChartInfos(t2) {
    var _a2;
    const { fieldInfos: e2, fieldName: i2, formattedAttributes: o2, chartType: r2, value: a2 } = t2, s2 = [], l2 = d$A(i2), { layerId: n2, fieldName: p2 } = l2, d2 = (_a2 = this.relatedInfos) == null ? void 0 : _a2.get(n2.toString());
    if (!d2)
      return s2;
    const { relatedFeatures: u2, relation: f2 } = d2;
    if (!f2 || !u2)
      return s2;
    const { cardinality: c2 } = f2;
    u2.forEach((t3) => {
      const { attributes: l3 } = t3;
      l3 && Object.keys(l3).forEach((t4) => {
        t4 === p2 && s2.push(this._getChartOption({ value: a2, attributes: l3, formattedAttributes: o2, fieldName: i2, chartType: r2, relatedFieldName: t4, fieldInfos: e2 }));
      });
    });
    return c2 === "one-to-many" || c2 === "many-to-many" ? s2 : [s2[0]];
  }
  _getTooltip({ label: t2, value: e2, chartType: i2 }) {
    return i2 === "pie-chart" ? `${t2}` : `${t2}: ${e2}`;
  }
  _getChartOption(t2) {
    var _a2, _b2, _c2, _d2, _e3, _f2;
    const { value: e2, attributes: i2, formattedAttributes: o2, expressionAttributes: r2, fieldName: l2, relatedFieldName: n2, fieldInfos: p2, chartType: d2 } = t2, { layer: y2, fieldInfoMap: I2 } = this, { normalizeField: v2, tooltipField: M2 } = e2, A2 = v2 ? le(v2) ? i2[d$A(v2).fieldName] : i2[v2] : null, g2 = C$g(l2) && r2 && r2[l2] !== void 0 ? r2[l2] : n2 && i2[n2] !== void 0 ? i2[n2] : i2[l2] !== void 0 ? i2[l2] : o2[l2], x2 = new i$1$({ fieldName: l2, value: g2 === void 0 ? null : g2 && A2 ? g2 / A2 : g2 });
    if (le(l2)) {
      const t3 = I2.get(l2.toLowerCase()), e3 = I2.get(M2.toLowerCase()), i3 = (_a2 = t3 == null ? void 0 : t3.fieldName) != null ? _a2 : l2, r3 = (_e3 = (_d2 = (_c2 = o2[(_b2 = e3 == null ? void 0 : e3.fieldName) != null ? _b2 : M2]) != null ? _c2 : t3 == null ? void 0 : t3.label) != null ? _d2 : t3 == null ? void 0 : t3.fieldName) != null ? _e3 : n2, a2 = o2[i3];
      return x2.tooltip = this._getTooltip({ label: r3, value: a2, chartType: d2 }), x2;
    }
    const _2 = B$9(p2, l2), C2 = D$b(l2, y2), T2 = M2 && o2[M2] !== void 0 ? o2[M2] : q$7(_2 || new c$2q({ fieldName: C2 }), (_f2 = this.popupTemplate) == null ? void 0 : _f2.expressionInfos), N2 = o2[C2];
    return x2.tooltip = this._getTooltip({ label: T2, value: N2, chartType: d2 }), x2;
  }
};
e$1W([y$1o()], I$d.prototype, "abilities", void 0), e$1W([s$1N("abilities")], I$d.prototype, "castAbilities", null), e$1W([y$1o()], I$d.prototype, "activeMediaInfoIndex", void 0), e$1W([y$1o({ readOnly: true })], I$d.prototype, "activeMediaInfo", null), e$1W([y$1o()], I$d.prototype, "attributes", void 0), e$1W([y$1o()], I$d.prototype, "description", void 0), e$1W([y$1o()], I$d.prototype, "fieldInfoMap", void 0), e$1W([y$1o()], I$d.prototype, "formattedAttributes", void 0), e$1W([y$1o()], I$d.prototype, "expressionAttributes", void 0), e$1W([y$1o({ readOnly: true })], I$d.prototype, "formattedMediaInfos", null), e$1W([y$1o()], I$d.prototype, "layer", void 0), e$1W([y$1o({ readOnly: true })], I$d.prototype, "formattedMediaInfoCount", null), e$1W([y$1o()], I$d.prototype, "mediaInfos", void 0), e$1W([y$1o()], I$d.prototype, "popupTemplate", void 0), e$1W([y$1o()], I$d.prototype, "relatedInfos", void 0), e$1W([y$1o()], I$d.prototype, "title", void 0), I$d = e$1W([n$2f("esri.widgets.Feature.FeatureMedia.FeatureMediaViewModel")], I$d);
const v$o = I$d;
var f$J = ["#ffffff", "#858585", "#ffbebe", "#ffebbe", "#ffebaf", "#ffffbe", "#e9ffbe", "#d3ffbe", "#beffe8", "#bee8ff", "#bed2ff", "#e8beff", "#ffbee8", "#ebebeb", "#707070", "#ff7f7f", "#ffa77f", "#ffd37f", "#ffff73", "#d1ff73", "#a3ff73", "#73ffdf", "#73dfff", "#73b2ff", "#df73ff", "#ff73df", "#d6d6d6", "#5c5c5c", "#ff0000", "#ff5500", "#ffaa00", "#ffff00", "#aaff00", "#55ff00", "#00ffc5", "#00c5ff", "#0070ff", "#c500ff", "#ff00c5", "#c2c2c2", "#474747", "#e60000", "#e64c00", "#e69800", "#e6e600", "#98e600", "#4ce600", "#00e6a9", "#00a9e6", "#005ce6", "#a900e6", "#e600a9", "#adadad", "#242424", "#a80000", "#a83800", "#a87000", "#a8a800", "#70a800", "#38a800", "#00a884", "#0084a8", "#004da8", "#8400a8", "#a80084", "#999999", "#1a1a1a", "#730000", "#732600", "#734c00", "#737300", "#4c7300", "#267300", "#00734c", "#004c73", "#002673", "#4c0073", "#73004"], b$o = [].concat(f$J.slice(30, 39), f$J.slice(28, 30).reverse()), e$H = [{ name: "default", colors: b$o }, { name: "cat-dark", colors: ["#ed5151", "#149ece", "#a7c636", "#9e559c", "#fc921f", "#ffde3e", "#f789d8", "#b7814a", "#3caf99", "#6b6bd6", "#b54779", "#7f7f7f"] }, { name: "tropical-bliss", colors: ["#fce138", "#ff9399", "#fcd27e", "#f1983c", "#a553b7", "#b1a9d0", "#6ecffc", "#4c81cd", "#fc6f84", "#fc3e5a", "#6af689", "#48885c"] }, { name: "desert-blooms", colors: ["#102432", "#144d59", "#ffc730", "#ed9310", "#a64f1b", "#661510", "#d9351a", "#b31515", "#4a0932", "#8c213f", "#18382e", "#2c6954"] }, { name: "under-the-sea", colors: ["#bf9727", "#607100", "#00734c", "#704489", "#01acca", "#024e76", "#f09100", "#ea311f", "#c6004b", "#7570b3", "#666666", "#333333"] }, { name: "vibrant-rainbow", colors: ["#fffb00", "#f5cb11", "#9fd40c", "#46e39c", "#32b8a6", "#7ff2fa", "#ac08cc", "#dd33ff", "#eb7200", "#e8a784", "#bf2e2e", "#6c7000"] }, { name: "ocean-bay", colors: ["#191921", "#11495c", "#78b1c2", "#454f4b", "#8f8f82", "#9be0c0", "#87b051", "#f7ec88", "#ebdcc1", "#dbb658", "#c43541", "#75351e"] }, { name: "prairie-summer", colors: ["#332424", "#751555", "#d47013", "#d68989", "#211173", "#82aad6", "#7bfaeb", "#6ec9a8", "#6b6408", "#eada40", "#ccc54a", "#1fc235"] }, { name: "pastel-chalk", colors: ["#fffd99", "#f5e6a4", "#c1d48c", "#b8e3d0", "#a0b8b5", "#cbf7fa", "#d791f2", "#dfc1eb", "#f2b983", "#e8c4b2", "#bf8e8e", "#94995c"] }, { name: "seq-yellow-orange-red-bright", colors: ["#910000", "#b1260b", "#c0370f", "#e05919", "#ef6a1d", "#ff7b22", "#ffa143", "#ffb454", "#ffda74", "#ffed85"] }, { name: "seq-reds-bright", colors: ["#57453b", "#7b4238", "#9f4036", "#c23d33", "#d7483c", "#ec5244", "#f3696c", "#f9816c", "#ffc4ae", "#fff0dc"] }, { name: "seq-purples-bright", colors: ["#4e465c", "#5a4a78", "#695291", "#775baa", "#8663c3", "#946bdc", "#aa89e8", "#c1a6f3", "#d7c4ff", "#e6e1ff"] }, { name: "seq-blues-bright", colors: ["#404d54", "#435c6c", "#48799d", "#4b88b6", "#4d96ce", "#50a5e7", "#74bbed", "#98d0f3", "#bce6f9", "#e6faff"] }, { name: "seq-greens-bright", colors: ["#39544c", "#386757", "#368165", "#359b73", "#33b581", "#4bc392", "#64d2a2", "#7ce0b3", "#cbf6d9", "#f4ffea"] }, { name: "seq-browns-bright", colors: ["#524834", "#715b38", "#8f6e3c", "#ae8140", "#cc9444", "#eba748", "#eeb664", "#f0c47f", "#f9e0b7", "#fff8eb"] }];
const n$13 = "en-us", h$w = new Map([["ar", () => import("./ar.js").then((t2) => t2.a)], ["bg-bg", () => import("./bg_BG.js").then((t2) => t2.b)], ["bs-ba", () => import("./bs_BA.js").then((t2) => t2.b)], ["ca-es", () => import("./ca_ES.js").then((t2) => t2.c)], ["cs-cz", () => import("./cs_CZ.js").then((t2) => t2.c)], ["da-dk", () => import("./da_DK.js").then((t2) => t2.d)], ["de-de", () => import("./de_DE.js").then((t2) => t2.d)], ["de-ch", () => import("./de_CH.js").then((t2) => t2.d)], ["el-gr", () => import("./el_GR.js").then((t2) => t2.e)], ["en-us", () => import("./en_US.js").then((t2) => t2.e)], ["en-ca", () => import("./en_CA.js").then((t2) => t2.e)], ["es-es", () => import("./es_ES.js").then((t2) => t2.e)], ["et-ee", () => import("./et_EE.js").then((t2) => t2.e)], ["fi-fi", () => import("./fi_FI.js").then((t2) => t2.f)], ["fr-fr", () => import("./fr_FR.js").then((t2) => t2.f)], ["he-il", () => import("./he_IL.js").then((t2) => t2.h)], ["hr-hr", () => import("./hr_HR.js").then((t2) => t2.h)], ["hu-hu", () => import("./hu_HU.js").then((t2) => t2.h)], ["id-id", () => import("./id_ID.js").then((t2) => t2.i)], ["it-it", () => import("./it_IT.js").then((t2) => t2.i)], ["ja-jp", () => import("./ja_JP.js").then((t2) => t2.j)], ["ko-kr", () => import("./ko_KR.js").then((t2) => t2.k)], ["lt-lt", () => import("./lt_LT.js").then((t2) => t2.l)], ["lv-lv", () => import("./lv_LV.js").then((t2) => t2.l)], ["nb-no", () => import("./nb_NO.js").then((t2) => t2.n)], ["nl-nl", () => import("./nl_NL.js").then((t2) => t2.n)], ["pl-pl", () => import("./pl_PL.js").then((t2) => t2.p)], ["pt-br", () => import("./pt_BR.js").then((t2) => t2.p)], ["pt-pt", () => import("./pt_PT.js").then((t2) => t2.p)], ["ro-ro", () => import("./ro_RO.js").then((t2) => t2.r)], ["ru-ru", () => import("./ru_RU.js").then((t2) => t2.r)], ["sk-sk", () => import("./sk_SK.js").then((t2) => t2.s)], ["sl-sl", () => import("./sl_SL.js").then((t2) => t2.s)], ["sr-rs", () => import("./sr_RS.js").then((t2) => t2.s)], ["sv-se", () => import("./sv_SE.js").then((t2) => t2.s)], ["th-th", () => import("./th_TH.js").then((t2) => t2.t)], ["tr-tr", () => import("./tr_TR.js").then((t2) => t2.t)], ["uk-ua", () => import("./uk_UA.js").then((t2) => t2.u)], ["vi-vn", () => import("./vi_VN.js").then((t2) => t2.v)], ["zh-cn", () => import("./zh_Hans.js").then((t2) => t2.z)], ["zh-hk", () => import("./zh_Hant.js").then((t2) => t2.z)], ["zh-tw", () => import("./zh_Hant.js").then((t2) => t2.z)]]);
function e$G(t2) {
  const s2 = t2.split("-")[0].toLowerCase();
  let n2 = null;
  for (const e2 of h$w.keys())
    if (e2.startsWith(s2)) {
      n2 = e2;
      break;
    }
  return n2;
}
function r$z(t2) {
  return t2 ? h$w.has(t2.toLowerCase()) ? t2.toLowerCase() : e$G(t2) || n$13 : n$13;
}
let o$I, i$18;
async function c$1a(t2 = l$1Q()) {
  if (t2 = r$z(t2), o$I && t2 === i$18)
    return o$I;
  o$I = import("./index2.js").then((t3) => t3.i), i$18 = t2;
  try {
    const [s2, n2] = await Promise.all([o$I, h$w.get(i$18)()]);
    i$18 === t2 && (s2.am4core.options.defaultLocale = n2.default), s2.am4core.options.suppressWarnings = true, s2.am4core.options.autoDispose = true;
  } catch {
    return o$I = null, i$18 = null, null;
  }
  return o$I;
}
function u$P(s2, n2 = "default") {
  const h2 = e$H.find((t2) => t2.name === n2);
  return h2 ? h2.colors.map((t2) => s2.color(t2)) : null;
}
const M$6 = { base: "esri-feature-media", mediaContainer: "esri-feature-media__container", mediaItemContainer: "esri-feature-media__item-container", mediaItem: "esri-feature-media__item", mediaItemTitle: "esri-feature-media__item-title", mediaItemCaption: "esri-feature-media__item-caption", mediaPrevious: "esri-feature-media__previous", mediaPreviousIconLTR: "esri-feature-media__previous-icon", mediaPreviousIconRTL: "esri-feature-media__previous-icon--rtl", mediaNext: "esri-feature-media__next", mediaNextIconLTR: "esri-feature-media__next-icon", mediaNextIconRTL: "esri-feature-media__next-icon--rtl", mediaChart: "esri-feature-media__chart", mediaButton: "esri-feature-media__button", mediaIcon: "esri-feature-media__icon", iconLeftTriangleArrow: "esri-icon-left-triangle-arrow", iconRightTriangleArrow: "esri-icon-right-triangle-arrow" }, I$c = 0.05, _$h = 0.95, w$l = 15, g$s = "color", y$y = "tooltip", T$9 = "value", b$n = "default-line-value";
let C$c = class extends M$d {
  constructor(e2, t2) {
    super(e2, t2), this._refreshTimer = null, this._refreshIntervalInfo = null, this._featureElementInfo = null, this.viewModel = new v$o(), this.messages = null, this._getChartDependencies = async (e3) => {
      const t3 = await c$1a(), { destroyed: i2, viewModel: r2 } = this;
      if (i2 || !r2 || !e3)
        return;
      const { activeMediaInfo: s2 } = r2, a2 = await this._getRendererColors(t3);
      this._renderChart({ chartDiv: e3, mediaInfo: s2, chartsModule: t3, colorMap: a2 });
    };
  }
  initialize() {
    this._featureElementInfo = new l$15(), this.addHandles([l$1f(() => {
      var _a2, _b2;
      return [(_a2 = this.viewModel) == null ? void 0 : _a2.activeMediaInfo, (_b2 = this.viewModel) == null ? void 0 : _b2.activeMediaInfoIndex];
    }, () => this._setupMediaRefreshTimer(), h$S), l$1f(() => {
      var _a2, _b2;
      return [(_a2 = this.viewModel) == null ? void 0 : _a2.description, (_b2 = this.viewModel) == null ? void 0 : _b2.title];
    }, () => this._setupFeatureElementInfo(), h$S)]);
  }
  destroy() {
    this._clearMediaRefreshTimer(), this._featureElementInfo.destroy();
  }
  get attributes() {
    return this.viewModel.attributes;
  }
  set attributes(e2) {
    this.viewModel.attributes = e2;
  }
  get activeMediaInfoIndex() {
    return this.viewModel.activeMediaInfoIndex;
  }
  set activeMediaInfoIndex(e2) {
    this.viewModel.activeMediaInfoIndex = e2;
  }
  get description() {
    return this.viewModel.description;
  }
  set description(e2) {
    this.viewModel.description = e2;
  }
  get fieldInfoMap() {
    return this.viewModel.fieldInfoMap;
  }
  set fieldInfoMap(e2) {
    this.viewModel.fieldInfoMap = e2;
  }
  get layer() {
    return this.viewModel.layer;
  }
  set layer(e2) {
    this.viewModel.layer = e2;
  }
  get mediaInfos() {
    return this.viewModel.mediaInfos;
  }
  set mediaInfos(e2) {
    this.viewModel.mediaInfos = e2;
  }
  get popupTemplate() {
    return this.viewModel.popupTemplate;
  }
  set popupTemplate(e2) {
    this.viewModel.popupTemplate = e2;
  }
  get relatedInfos() {
    return this.viewModel.relatedInfos;
  }
  set relatedInfos(e2) {
    this.viewModel.relatedInfos = e2;
  }
  get title() {
    return this.viewModel.title;
  }
  set title(e2) {
    this.viewModel.title = e2;
  }
  render() {
    var _a2;
    return n$1k("div", { bind: this, class: M$6.base, onkeyup: this._handleMediaKeyup }, (_a2 = this._featureElementInfo) == null ? void 0 : _a2.render(), this.renderMedia());
  }
  renderMedia() {
    const { formattedMediaInfoCount: e2 } = this.viewModel;
    return e2 ? n$1k("div", { key: "media-element-container", class: M$6.mediaContainer }, this.renderMediaPageButton("previous"), this.renderMediaInfo(), this.renderMediaPageButton("next")) : null;
  }
  renderImageMediaInfo(e2) {
    const { _refreshIntervalInfo: t2 } = this, { activeMediaInfoIndex: i2, formattedMediaInfoCount: r2 } = this.viewModel, { value: s2, refreshInterval: a2, altText: o2, title: n2, type: l2 } = e2, { sourceURL: d2, linkURL: m2 } = s2, u2 = x$p(m2) ? "_blank" : "_self", p2 = u2 === "_blank" ? "noreferrer" : "", h2 = a2 ? t2 : null, v2 = h2 ? h2.timestamp : 0, M2 = h2 ? h2.sourceURL : d2, I2 = n$1k("img", { alt: o2 || n2, key: `media-${l2}-${i2}-${r2}-${v2}`, src: M2 }), _2 = m2 ? n$1k("a", { title: n2, href: m2, rel: p2, target: u2 }, I2) : null;
    return _2 || I2;
  }
  renderChartMediaInfo(e2) {
    const { activeMediaInfoIndex: t2, formattedMediaInfoCount: i2 } = this.viewModel;
    return n$1k("div", { key: `media-${e2.type}-${t2}-${i2}`, bind: this, class: M$6.mediaChart, afterCreate: this._getChartDependencies });
  }
  renderMediaInfoType() {
    const { activeMediaInfo: e2 } = this.viewModel;
    return e2 ? e2.type === "image" ? this.renderImageMediaInfo(e2) : e2.type.includes("chart") ? this.renderChartMediaInfo(e2) : null : null;
  }
  renderMediaInfo() {
    const { activeMediaInfo: e2 } = this.viewModel;
    if (!e2)
      return null;
    const t2 = e2.title ? n$1k("div", { key: "media-title", class: M$6.mediaItemTitle, innerHTML: e2.title }) : null, i2 = e2.caption ? n$1k("div", { key: "media-caption", class: M$6.mediaItemCaption, innerHTML: e2.caption }) : null;
    return n$1k("div", { key: "media-container", class: M$6.mediaItemContainer }, n$1k("div", { key: "media-item-container", class: M$6.mediaItem }, this.renderMediaInfoType()), t2, i2);
  }
  renderMediaPageButton(e2) {
    if (this.viewModel.formattedMediaInfoCount < 2)
      return null;
    const t2 = e2 === "previous", i2 = t2 ? this.messages.previous : this.messages.next, r2 = t2 ? this.classes(M$6.mediaButton, M$6.mediaPrevious) : this.classes(M$6.mediaButton, M$6.mediaNext), s2 = t2 ? this.classes(M$6.mediaIcon, M$6.mediaPreviousIconLTR, M$6.iconLeftTriangleArrow) : this.classes(M$6.mediaIcon, M$6.mediaNextIconLTR, M$6.iconRightTriangleArrow), a2 = t2 ? this.classes(M$6.mediaIcon, M$6.mediaPreviousIconRTL, M$6.iconRightTriangleArrow) : this.classes(M$6.mediaIcon, M$6.mediaNextIconRTL, M$6.iconLeftTriangleArrow), o2 = t2 ? "media-previous" : "media-next", n2 = t2 ? this._previous : this._next;
    return n$1k("button", { type: "button", key: o2, title: i2, "aria-label": i2, tabIndex: 0, class: r2, bind: this, onclick: n2 }, n$1k("span", { "aria-hidden": "true", class: s2 }), n$1k("span", { "aria-hidden": "true", class: a2 }));
  }
  _setupFeatureElementInfo() {
    const { description: e2, title: t2 } = this;
    this._featureElementInfo.set({ description: e2, title: t2 });
  }
  _next() {
    this.viewModel.next();
  }
  _previous() {
    this.viewModel.previous();
  }
  async _getRendererColors(e2) {
    var _a2, _b2;
    const { am4core: t2 } = e2, i2 = new Map(), r2 = (_b2 = (_a2 = this.viewModel) == null ? void 0 : _a2.layer) == null ? void 0 : _b2.renderer, s2 = "default";
    if (!r2)
      return i2;
    const a2 = await b$u(r2);
    a2.delete(s2);
    return Array.from(a2.values()).every((e3) => (e3 == null ? void 0 : e3.length) === 1) ? (i2.set(b$n, t2.color({ r: 50, g: 50, b: 50, a: 1 })), Array.from(a2.keys()).forEach((e3) => {
      e3 && i2.set(e3, t2.color(a2.get(e3)[0].toCss(true)));
    }), i2) : i2;
  }
  _handleMediaKeyup(e2) {
    const i2 = i$2k(e2);
    i2 === "ArrowLeft" && (e2.stopPropagation(), this.viewModel.previous()), i2 === "ArrowRight" && (e2.stopPropagation(), this.viewModel.next());
  }
  _renderChart(e2) {
    const { abilities: t2 } = this.viewModel, { chartsModule: i2, chartDiv: r2, mediaInfo: s2, colorMap: a2 } = e2, { value: o2, type: n2 } = s2, { am4core: l2 } = i2, d2 = u$P(l2);
    function c2(e3) {
      e3 instanceof l2.ColorSet && d2 && (e3.list = d2);
    }
    r$K() && l2.useTheme(i2.am4themes_dark);
    const m2 = window.matchMedia("(prefers-reduced-motion: reduce)");
    t2.chartAnimation && !m2.matches ? l2.useTheme(i2.am4themes_animated) : l2.unuseTheme(i2.am4themes_animated), l2.useTheme(c2);
    const p2 = n2 === "pie-chart" ? this._createPieChart(e2) : this._createXYChart(e2);
    r2.setAttribute("aria-label", s2.altText || s2.title), p2.data = o2.series.map((e3) => ({ [y$y]: e3.tooltip, [T$9]: e3.value, [g$s]: a2.get(e3.fieldName) })).filter((e3) => n2 !== "pie-chart" || e3.value > 0);
  }
  _customizeChartTooltip(e2, t2) {
    e2.label.wrap = true, e2.label.maxWidth = 200, e2.autoTextColor = false, e2.getFillFromObject = false, e2.label.fill = t2.color("#ffffff"), e2.background.fill = t2.color({ r: 0, g: 0, b: 0, a: 0.7 });
  }
  _createPieChart(e2) {
    const { chartDiv: t2, chartsModule: i2 } = e2, { am4core: r2, am4charts: s2 } = i2, a2 = r2.create(t2, s2.PieChart);
    a2.rtl = f$U(this.container);
    const o2 = a2.series.push(new s2.PieSeries());
    return o2.labels.template.disabled = true, o2.ticks.template.disabled = true, o2.dataFields.value = T$9, o2.dataFields.category = y$y, this._customizeChartTooltip(o2.tooltip, r2), o2.slices.template.propertyFields.fill = g$s, o2.slices.template.propertyFields.stroke = g$s, a2;
  }
  _getMinSeriesValue(e2) {
    let t2 = 0;
    return e2.forEach((e3) => t2 = Math.min(e3.value, t2)), t2;
  }
  _createColumnChart(e2, t2) {
    const { chartsModule: i2, mediaInfo: r2 } = t2, { value: s2 } = r2, { am4core: a2, am4charts: o2 } = i2, n2 = e2.xAxes.push(new o2.CategoryAxis());
    n2.dataFields.category = y$y, n2.renderer.labels.template.disabled = true, this._customizeChartTooltip(n2.tooltip, a2), n2.tooltip.events.on("sizechanged", () => {
      n2.tooltip.dy = -n2.tooltip.contentHeight;
    });
    const l2 = e2.yAxes.push(new o2.ValueAxis()), d2 = l2.renderer.labels.template;
    l2.renderer.minLabelPosition = I$c, l2.renderer.maxLabelPosition = _$h, l2.min = this._getMinSeriesValue(s2.series), this._customizeChartTooltip(l2.tooltip, a2), d2.wrap = true;
    const c2 = e2.series.push(new o2.ColumnSeries());
    c2.dataFields.valueY = T$9, c2.dataFields.categoryX = y$y, c2.columns.template.propertyFields.fill = g$s, c2.columns.template.propertyFields.stroke = g$s, e2.cursor = new o2.XYCursor(), s2.series.length > w$l && (e2.scrollbarX = new a2.Scrollbar());
  }
  _createBarChart(e2, t2) {
    const { chartsModule: i2, mediaInfo: r2 } = t2, { value: s2 } = r2, { am4core: a2, am4charts: o2 } = i2, n2 = e2.yAxes.push(new o2.CategoryAxis());
    n2.dataFields.category = y$y, n2.renderer.inversed = true, n2.renderer.labels.template.disabled = true, this._customizeChartTooltip(n2.tooltip, a2), n2.tooltip.events.on("sizechanged", () => {
      n2.tooltip.dx = n2.tooltip.contentWidth;
    });
    const l2 = e2.xAxes.push(new o2.ValueAxis()), d2 = l2.renderer.labels.template;
    l2.renderer.minLabelPosition = I$c, l2.renderer.maxLabelPosition = _$h, l2.min = this._getMinSeriesValue(s2.series), this._customizeChartTooltip(l2.tooltip, a2), d2.wrap = true;
    const c2 = e2.series.push(new o2.ColumnSeries());
    c2.dataFields.valueX = T$9, c2.dataFields.categoryY = y$y, c2.columns.template.propertyFields.fill = g$s, c2.columns.template.propertyFields.stroke = g$s, e2.cursor = new o2.XYCursor(), s2.series.length > w$l && (e2.scrollbarY = new a2.Scrollbar());
  }
  _createLineChart(e2, t2) {
    const { chartsModule: i2, mediaInfo: r2, colorMap: s2 } = t2, { value: a2 } = r2, { am4core: o2, am4charts: n2 } = i2, l2 = e2.xAxes.push(new n2.CategoryAxis());
    l2.dataFields.category = y$y, l2.renderer.labels.template.disabled = true, this._customizeChartTooltip(l2.tooltip, o2), l2.tooltip.events.on("sizechanged", () => {
      l2.tooltip.dy = -l2.tooltip.contentHeight;
    });
    const d2 = e2.yAxes.push(new n2.ValueAxis()), c2 = d2.renderer.labels.template;
    d2.renderer.minLabelPosition = I$c, d2.renderer.maxLabelPosition = _$h, d2.min = this._getMinSeriesValue(a2.series), this._customizeChartTooltip(d2.tooltip, o2), c2.wrap = true;
    const m2 = e2.series.push(new n2.LineSeries());
    m2.dataFields.categoryX = y$y, m2.dataFields.valueY = T$9, m2.strokeWidth = 1;
    const u2 = s2.get(b$n);
    u2 && (m2.stroke = u2);
    const p2 = m2.bullets.push(new n2.CircleBullet());
    p2.propertyFields.fill = g$s, p2.propertyFields.stroke = g$s, e2.cursor = new n2.XYCursor(), a2.series.length > w$l && (e2.scrollbarX = new o2.Scrollbar());
  }
  _createXYChart(e2) {
    const { chartDiv: t2, chartsModule: i2, mediaInfo: r2 } = e2, { type: s2 } = r2, { am4core: a2, am4charts: o2 } = i2, n2 = a2.create(t2, o2.XYChart);
    return n2.rtl = f$U(this.container), s2 === "column-chart" && this._createColumnChart(n2, e2), s2 === "bar-chart" && this._createBarChart(n2, e2), s2 === "line-chart" && this._createLineChart(n2, e2), n2;
  }
  _clearMediaRefreshTimer() {
    const { _refreshTimer: e2 } = this;
    e2 && (clearTimeout(e2), this._refreshTimer = null);
  }
  _updateMediaInfoTimestamp(e2) {
    const t2 = Date.now();
    this._refreshIntervalInfo = { timestamp: t2, sourceURL: this._getImageSource(e2, t2) }, this.scheduleRender();
  }
  _setupMediaRefreshTimer() {
    this._clearMediaRefreshTimer();
    const { activeMediaInfo: e2 } = this.viewModel;
    e2 && e2.type === "image" && e2.refreshInterval && this._setRefreshTimeout(e2);
  }
  _setRefreshTimeout(e2) {
    const { refreshInterval: t2, value: i2 } = e2;
    if (!t2)
      return;
    const r2 = 6e4 * t2;
    this._updateMediaInfoTimestamp(i2.sourceURL);
    const s2 = setInterval(() => {
      this._updateMediaInfoTimestamp(i2.sourceURL);
    }, r2);
    this._refreshTimer = s2;
  }
  _getImageSource(e2, t2) {
    const i2 = e2.includes("?") ? "&" : "?", [r2, s2 = ""] = e2.split("#");
    return `${r2}${i2}timestamp=${t2}${s2 ? "#" : ""}${s2}`;
  }
};
e$1W([y$1o()], C$c.prototype, "attributes", null), e$1W([y$1o()], C$c.prototype, "activeMediaInfoIndex", null), e$1W([y$1o()], C$c.prototype, "description", null), e$1W([y$1o()], C$c.prototype, "fieldInfoMap", null), e$1W([y$1o()], C$c.prototype, "layer", null), e$1W([y$1o()], C$c.prototype, "mediaInfos", null), e$1W([y$1o()], C$c.prototype, "popupTemplate", null), e$1W([y$1o()], C$c.prototype, "relatedInfos", null), e$1W([y$1o()], C$c.prototype, "title", null), e$1W([y$1o({ type: v$o })], C$c.prototype, "viewModel", void 0), e$1W([y$1o(), e$W("esri/widgets/Feature/t9n/Feature")], C$c.prototype, "messages", void 0), C$c = e$1W([n$2f("esri.widgets.Feature.FeatureMedia")], C$c);
const x$g = C$c;
var t$L;
let p$1s = t$L = class extends l$1_ {
  constructor(r2) {
    super(r2), this.minValue = 0, this.maxValue = 0;
  }
  clone() {
    return new t$L({ minValue: this.minValue, maxValue: this.maxValue });
  }
};
e$1W([y$1o({ type: Number, json: { write: true } })], p$1s.prototype, "minValue", void 0), e$1W([y$1o({ type: Number, json: { write: true } })], p$1s.prototype, "maxValue", void 0), p$1s = t$L = e$1W([n$2f("esri.renderer.support.AuthoringInfoClassBreakInfo")], p$1s);
var n$12;
let p$1r = n$12 = class extends l$1_ {
  constructor(o2) {
    super(o2), this.field = "", this.normalizationField = "", this.label = "", this.classBreakInfos = [];
  }
  clone() {
    return new n$12({ field: this.field, normalizationField: this.normalizationField, label: this.label, classBreakInfos: y$1r(this.classBreakInfos) });
  }
};
e$1W([y$1o({ type: String, json: { write: true } })], p$1r.prototype, "field", void 0), e$1W([y$1o({ type: String, json: { write: true } })], p$1r.prototype, "normalizationField", void 0), e$1W([y$1o({ type: String, json: { write: true } })], p$1r.prototype, "label", void 0), e$1W([y$1o({ type: [p$1s], json: { write: true } })], p$1r.prototype, "classBreakInfos", void 0), p$1r = n$12 = e$1W([n$2f("esri.renderers.support.AuthoringInfoFieldInfo")], p$1r);
var n$11;
const l$Y = new s$1F({ percentTotal: "percent-of-total", ratio: "ratio", percent: "percent" }), p$1q = new s$1F({ sizeInfo: "size", colorInfo: "color", transparencyInfo: "opacity", rotationInfo: "rotation" }), a$1f = { key: (e2) => typeof e2 == "number" ? "number" : "string", typeMap: { number: Number, string: String }, base: null }, u$O = ["high-to-low", "above-and-below", "centered-on", "extremes"], m$L = [...new Set([...["high-to-low", "above-and-below", "centered-on", "extremes", "90-10", "above", "below"], ...["high-to-low", "above-and-below", "90-10", "above", "below"]])], y$x = ["seconds", "minutes", "hours", "days", "months", "years"];
let d$z = n$11 = class extends l$1_ {
  constructor(e2) {
    super(e2), this.endTime = null, this.field = null, this.maxSliderValue = null, this.minSliderValue = null, this.startTime = null, this.type = null, this.units = null;
  }
  castEndTime(e2) {
    return typeof e2 == "string" || typeof e2 == "number" ? e2 : null;
  }
  castStartTime(e2) {
    return typeof e2 == "string" || typeof e2 == "number" ? e2 : null;
  }
  get style() {
    return this.type === "color" ? this._get("style") : null;
  }
  set style(e2) {
    this._set("style", e2);
  }
  get theme() {
    return this.type === "color" || this.type === "size" ? this._get("theme") || "high-to-low" : null;
  }
  set theme(e2) {
    this._set("theme", e2);
  }
  clone() {
    return new n$11({ endTime: this.endTime, field: this.field, maxSliderValue: this.maxSliderValue, minSliderValue: this.minSliderValue, startTime: this.startTime, style: this.style, theme: this.theme, type: this.type, units: this.units });
  }
};
e$1W([y$1o({ types: a$1f, json: { write: true } })], d$z.prototype, "endTime", void 0), e$1W([s$1N("endTime")], d$z.prototype, "castEndTime", null), e$1W([y$1o({ type: String, json: { write: true } })], d$z.prototype, "field", void 0), e$1W([y$1o({ type: Number, json: { write: true } })], d$z.prototype, "maxSliderValue", void 0), e$1W([y$1o({ type: Number, json: { write: true } })], d$z.prototype, "minSliderValue", void 0), e$1W([y$1o({ types: a$1f, json: { write: true } })], d$z.prototype, "startTime", void 0), e$1W([s$1N("startTime")], d$z.prototype, "castStartTime", null), e$1W([y$1o({ type: l$Y.apiValues, value: null, json: { type: l$Y.jsonValues, read: l$Y.read, write: l$Y.write } })], d$z.prototype, "style", null), e$1W([y$1o({ type: m$L, value: null, json: { type: m$L, origins: { "web-scene": { type: u$O, write: { writer: (e2, t2) => {
  u$O.includes(e2) && (t2.theme = e2);
} } } }, write: true } })], d$z.prototype, "theme", null), e$1W([y$1o({ type: p$1q.apiValues, json: { type: p$1q.jsonValues, read: p$1q.read, write: p$1q.write } })], d$z.prototype, "type", void 0), e$1W([y$1o({ type: y$x, json: { type: y$x, write: true } })], d$z.prototype, "units", void 0), d$z = n$11 = e$1W([n$2f("esri.renderers.support.AuthoringInfoVisualVariable")], d$z);
const c$19 = d$z;
let e$F = class extends l$1_ {
  constructor(r2) {
    super(r2), this.type = null;
  }
};
e$1W([y$1o({ readOnly: true, json: { read: false, write: true } })], e$F.prototype, "type", void 0), e$F = e$1W([n$2f("esri.rest.support.ColorRamp")], e$F);
const p$1p = e$F;
var m$K;
let c$18 = m$K = class extends p$1p {
  constructor(o2) {
    super(o2), this.algorithm = null, this.fromColor = null, this.toColor = null, this.type = "algorithmic";
  }
  clone() {
    return new m$K({ fromColor: y$1r(this.fromColor), toColor: y$1r(this.toColor), algorithm: this.algorithm });
  }
};
e$1W([r$1a({ esriCIELabAlgorithm: "cie-lab", esriHSVAlgorithm: "hsv", esriLabLChAlgorithm: "lab-lch" })], c$18.prototype, "algorithm", void 0), e$1W([y$1o({ type: l$1D, json: { type: [T$r], write: true } })], c$18.prototype, "fromColor", void 0), e$1W([y$1o({ type: l$1D, json: { type: [T$r], write: true } })], c$18.prototype, "toColor", void 0), e$1W([y$1o({ type: ["algorithmic"] })], c$18.prototype, "type", void 0), c$18 = m$K = e$1W([n$2f("esri.rest.support.AlgorithmicColorRamp")], c$18);
const a$1e = c$18;
var c$17;
let m$J = c$17 = class extends p$1p {
  constructor(o2) {
    super(o2), this.colorRamps = null, this.type = "multipart";
  }
  clone() {
    return new c$17({ colorRamps: y$1r(this.colorRamps) });
  }
};
e$1W([y$1o({ type: [a$1e], json: { write: true } })], m$J.prototype, "colorRamps", void 0), e$1W([y$1o({ type: ["multipart"] })], m$J.prototype, "type", void 0), m$J = c$17 = e$1W([n$2f("esri.rest.support.MultipartColorRamp")], m$J);
const a$1d = m$J;
const m$I = { key: "type", base: p$1p, typeMap: { algorithmic: a$1e, multipart: a$1d } };
function p$1o(o2) {
  return o2 && o2.type ? o2.type === "algorithmic" ? a$1e.fromJSON(o2) : o2.type === "multipart" ? a$1d.fromJSON(o2) : null : null;
}
var c$16;
const h$v = new s$1F({ esriClassifyDefinedInterval: "defined-interval", esriClassifyEqualInterval: "equal-interval", esriClassifyManual: "manual", esriClassifyNaturalBreaks: "natural-breaks", esriClassifyQuantile: "quantile", esriClassifyStandardDeviation: "standard-deviation" }), y$w = new s$1F({ pieChart: "pie-chart", classedSize: "class-breaks-size", classedColor: "class-breaks-color", univariateColorSize: "univariate-color-size", relationship: "relationship", predominance: "predominance", dotDensity: "dot-density", flow: "flow" }), m$H = new s$1F({ classedSize: "class-breaks-size", classedColor: "class-breaks-color", univariateColorSize: "univariate-color-size", relationship: "relationship", predominance: "predominance", dotDensity: "dot-density" }), f$I = ["inches", "feet", "yards", "miles", "nautical-miles", "millimeters", "centimeters", "decimeters", "meters", "kilometers", "decimal-degrees"], v$n = ["high-to-low", "above-and-below", "above", "below", "90-10"], w$k = ["flow-line", "wave-front"], b$m = ["caret", "circle-caret", "arrow", "circle-arrow", "plus-minus", "circle-plus-minus", "square", "circle", "triangle", "happy-sad", "thumb", "custom"];
let g$r = c$16 = class extends l$1_ {
  constructor(e2) {
    super(e2), this.colorRamp = null, this.fadeRatio = null, this.isAutoGenerated = false, this.lengthUnit = null, this.maxSliderValue = null, this.minSliderValue = null, this.visualVariables = null;
  }
  get classificationMethod() {
    const e2 = this._get("classificationMethod"), t2 = this.type;
    return t2 && t2 !== "relationship" ? t2 === "class-breaks-size" || t2 === "class-breaks-color" ? e2 || "manual" : null : e2;
  }
  set classificationMethod(e2) {
    this._set("classificationMethod", e2);
  }
  readColorRamp(e2) {
    return e2 ? p$1o(e2) : void 0;
  }
  get fields() {
    return this.type && this.type !== "predominance" ? null : this._get("fields");
  }
  set fields(e2) {
    this._set("fields", e2);
  }
  get field1() {
    return this.type && this.type !== "relationship" ? null : this._get("field1");
  }
  set field1(e2) {
    this._set("field1", e2);
  }
  get field2() {
    return this.type && this.type !== "relationship" ? null : this._get("field2");
  }
  set field2(e2) {
    this._set("field2", e2);
  }
  get flowTheme() {
    return this.type === "flow" ? this._get("flowTheme") : null;
  }
  set flowTheme(e2) {
    this._set("flowTheme", e2);
  }
  get focus() {
    return this.type && this.type !== "relationship" ? null : this._get("focus");
  }
  set focus(e2) {
    this._set("focus", e2);
  }
  get numClasses() {
    return this.type && this.type !== "relationship" ? null : this._get("numClasses");
  }
  set numClasses(e2) {
    this._set("numClasses", e2);
  }
  get statistics() {
    return this.type === "univariate-color-size" && this.univariateTheme === "above-and-below" ? this._get("statistics") : null;
  }
  set statistics(e2) {
    this._set("statistics", e2);
  }
  get standardDeviationInterval() {
    const e2 = this.type;
    return e2 && e2 !== "relationship" && e2 !== "class-breaks-size" && e2 !== "class-breaks-color" || this.classificationMethod && this.classificationMethod !== "standard-deviation" ? null : this._get("standardDeviationInterval");
  }
  set standardDeviationInterval(e2) {
    this._set("standardDeviationInterval", e2);
  }
  get type() {
    return this._get("type");
  }
  set type(e2) {
    let t2 = e2;
    e2 === "classed-size" ? t2 = "class-breaks-size" : e2 === "classed-color" && (t2 = "class-breaks-color"), this._set("type", t2);
  }
  get univariateSymbolStyle() {
    return this.type === "univariate-color-size" && this.univariateTheme === "above-and-below" ? this._get("univariateSymbolStyle") : null;
  }
  set univariateSymbolStyle(e2) {
    this._set("univariateSymbolStyle", e2);
  }
  get univariateTheme() {
    return this.type === "univariate-color-size" ? this._get("univariateTheme") : null;
  }
  set univariateTheme(e2) {
    this._set("univariateTheme", e2);
  }
  clone() {
    return new c$16({ classificationMethod: this.classificationMethod, colorRamp: y$1r(this.colorRamp), fadeRatio: y$1r(this.fadeRatio), fields: this.fields && this.fields.slice(0), field1: y$1r(this.field1), field2: y$1r(this.field2), isAutoGenerated: this.isAutoGenerated, focus: this.focus, numClasses: this.numClasses, maxSliderValue: this.maxSliderValue, minSliderValue: this.minSliderValue, lengthUnit: this.lengthUnit, statistics: this.statistics, standardDeviationInterval: this.standardDeviationInterval, type: this.type, visualVariables: this.visualVariables && this.visualVariables.map((e2) => e2.clone()), univariateSymbolStyle: this.univariateSymbolStyle, univariateTheme: this.univariateTheme, flowTheme: this.flowTheme });
  }
};
e$1W([y$1o({ type: h$v.apiValues, value: null, json: { type: h$v.jsonValues, read: h$v.read, write: h$v.write, origins: { "web-document": { default: "manual", type: h$v.jsonValues, read: h$v.read, write: h$v.write } } } })], g$r.prototype, "classificationMethod", null), e$1W([y$1o({ types: m$I, json: { write: true } })], g$r.prototype, "colorRamp", void 0), e$1W([o$1H("colorRamp")], g$r.prototype, "readColorRamp", null), e$1W([y$1o({ json: { write: true, origins: { "web-scene": { write: false, read: false } } } })], g$r.prototype, "fadeRatio", void 0), e$1W([y$1o({ type: [String], value: null, json: { write: true } })], g$r.prototype, "fields", null), e$1W([y$1o({ type: p$1r, value: null, json: { write: true } })], g$r.prototype, "field1", null), e$1W([y$1o({ type: p$1r, value: null, json: { write: true } })], g$r.prototype, "field2", null), e$1W([y$1o({ type: w$k, value: null, json: { write: true, origins: { "web-scene": { write: false } } } })], g$r.prototype, "flowTheme", null), e$1W([y$1o({ type: ["HH", "HL", "LH", "LL"], value: null, json: { write: true } })], g$r.prototype, "focus", null), e$1W([y$1o({ type: Boolean, json: { write: true, default: false, origins: { "web-scene": { write: false } } } })], g$r.prototype, "isAutoGenerated", void 0), e$1W([y$1o({ type: Number, value: null, json: { type: T$r, write: true } })], g$r.prototype, "numClasses", null), e$1W([y$1o({ type: f$I, json: { type: f$I, read: false, write: false, origins: { "web-scene": { read: true, write: true } } } })], g$r.prototype, "lengthUnit", void 0), e$1W([y$1o({ type: Number, json: { write: true, origins: { "web-scene": { write: false, read: false } } } })], g$r.prototype, "maxSliderValue", void 0), e$1W([y$1o({ type: Number, json: { write: true, origins: { "web-scene": { write: false, read: false } } } })], g$r.prototype, "minSliderValue", void 0), e$1W([y$1o({ type: Object, value: null, json: { write: true, origins: { "web-scene": { write: false, read: false } } } })], g$r.prototype, "statistics", null), e$1W([y$1o({ type: [0.25, 0.33, 0.5, 1], value: null, json: { type: [0.25, 0.33, 0.5, 1], write: true } })], g$r.prototype, "standardDeviationInterval", null), e$1W([y$1o({ type: y$w.apiValues, value: null, json: { type: y$w.jsonValues, read: y$w.read, write: y$w.write, origins: { "web-scene": { type: m$H.jsonValues, write: { writer: m$H.write, overridePolicy: (e2) => ({ enabled: e2 !== "flow" }) } } } } })], g$r.prototype, "type", null), e$1W([y$1o({ type: [c$19], json: { write: true } })], g$r.prototype, "visualVariables", void 0), e$1W([y$1o({ type: b$m, value: null, json: { write: true, origins: { "web-scene": { write: false } } } })], g$r.prototype, "univariateSymbolStyle", null), e$1W([y$1o({ type: v$n, value: null, json: { write: true, origins: { "web-scene": { write: false } } } })], g$r.prototype, "univariateTheme", null), g$r = c$16 = e$1W([n$2f("esri.renderers.support.AuthoringInfo")], g$r);
const j$g = g$r;
const n$10 = new s$1F({ simple: "simple", uniqueValue: "unique-value", classBreaks: "class-breaks", heatmap: "heatmap", dotDensity: "dot-density", dictionary: "dictionary", pieChart: "pie-chart" }, { ignoreUnknown: true });
let a$1c = class extends l$1_ {
  constructor(r2) {
    super(r2), this.authoringInfo = null, this.type = null;
  }
  async getRequiredFields(r2) {
    if (!this.collectRequiredFields)
      return [];
    const e2 = new Set();
    return await this.collectRequiredFields(e2, r2), Array.from(e2).sort();
  }
  getSymbol(r2, e2) {
  }
  async getSymbolAsync(r2, e2) {
  }
  getSymbols() {
    return [];
  }
  getAttributeHash() {
    return JSON.stringify(this);
  }
  getMeshHash() {
    return JSON.stringify(this);
  }
};
e$1W([y$1o({ type: j$g, json: { write: true } })], a$1c.prototype, "authoringInfo", void 0), e$1W([y$1o({ type: n$10.apiValues, readOnly: true, json: { type: n$10.jsonValues, read: false, write: { writer: n$10.write, ignoreOrigin: true } } })], a$1c.prototype, "type", void 0), a$1c = e$1W([n$2f("esri.renderers.Renderer")], a$1c);
const p$1n = a$1c;
function e$E(e2) {
  var _a2, _b2, _c2;
  return (_c2 = (_b2 = (_a2 = e2.match(t$K)) == null ? void 0 : _a2[1]) == null ? void 0 : _b2.replace(/\\'/g, "'")) != null ? _c2 : null;
}
const t$K = /^hash\(\$feature\['((\\'|[^'])+)'\]\) \* 8\.381e-8$/;
var s$O;
let p$1m = s$O = class extends l$1_ {
  constructor() {
    super(...arguments), this.title = null;
  }
  clone() {
    return new s$O({ title: this.title });
  }
};
e$1W([y$1o({ type: String, json: { write: true } })], p$1m.prototype, "title", void 0), p$1m = s$O = e$1W([n$2f("esri.renderers.support.LegendOptions")], p$1m);
var t$J;
let p$1l = t$J = class extends p$1m {
  constructor() {
    super(...arguments), this.showLegend = null;
  }
  clone() {
    return new t$J({ title: this.title, showLegend: this.showLegend });
  }
};
e$1W([y$1o({ type: Boolean, json: { write: true } })], p$1l.prototype, "showLegend", void 0), p$1l = t$J = e$1W([n$2f("esri.renderers.visualVariables.support.VisualVariableLegendOptions")], p$1l);
const i$17 = p$1l;
const a$1b = new s$1F({ colorInfo: "color", transparencyInfo: "opacity", rotationInfo: "rotation", sizeInfo: "size" });
let u$N = class extends l$1_ {
  constructor(e2) {
    super(e2), this.index = null, this.type = null, this.field = null, this.valueExpression = null, this.valueExpressionTitle = null, this.legendOptions = null;
  }
  castField(e2) {
    return e2 == null ? e2 : typeof e2 == "function" ? (s$22.getLogger(this.declaredClass).error(".field: field must be a string value"), null) : u$1W(e2);
  }
  get arcadeRequired() {
    return !!this.valueExpression;
  }
  clone() {
  }
  getAttributeHash() {
    return `${this.type}-${this.field}-${this.valueExpression}`;
  }
};
e$1W([y$1o()], u$N.prototype, "index", void 0), e$1W([y$1o({ type: a$1b.apiValues, readOnly: true, json: { read: a$1b.read, write: a$1b.write } })], u$N.prototype, "type", void 0), e$1W([y$1o({ type: String, json: { write: true } })], u$N.prototype, "field", void 0), e$1W([s$1N("field")], u$N.prototype, "castField", null), e$1W([y$1o({ type: String, json: { write: true } })], u$N.prototype, "valueExpression", void 0), e$1W([y$1o({ type: String, json: { write: true } })], u$N.prototype, "valueExpressionTitle", void 0), e$1W([y$1o({ readOnly: true })], u$N.prototype, "arcadeRequired", null), e$1W([y$1o({ type: i$17, json: { write: true } })], u$N.prototype, "legendOptions", void 0), u$N = e$1W([n$2f("esri.renderers.visualVariables.VisualVariable")], u$N);
const c$15 = u$N;
var i$16;
let p$1k = i$16 = class extends c$15 {
  constructor(t2) {
    super(t2), this.type = "color", this.normalizationField = null;
  }
  get cache() {
    return { ipData: this._interpolateData(), hasExpression: !!this.valueExpression, compiledFunc: null };
  }
  set stops(t2) {
    t2 && Array.isArray(t2) && (t2 = t2.filter((t3) => !!t3)).sort((t3, s2) => t3.value - s2.value), this._set("stops", t2);
  }
  clone() {
    return new i$16({ field: this.field, normalizationField: this.normalizationField, valueExpression: this.valueExpression, valueExpressionTitle: this.valueExpressionTitle, stops: this.stops && this.stops.map((t2) => t2.clone()), legendOptions: this.legendOptions && this.legendOptions.clone() });
  }
  getAttributeHash() {
    return `${super.getAttributeHash()}-${this.normalizationField}`;
  }
  _interpolateData() {
    return this.stops && this.stops.map((t2) => t2.value || 0);
  }
};
e$1W([y$1o({ readOnly: true })], p$1k.prototype, "cache", null), e$1W([y$1o({ type: ["color"], json: { type: ["colorInfo"] } })], p$1k.prototype, "type", void 0), e$1W([y$1o({ type: String, json: { write: true } })], p$1k.prototype, "normalizationField", void 0), e$1W([y$1o({ type: [a$1q], json: { write: true } })], p$1k.prototype, "stops", null), p$1k = i$16 = e$1W([n$2f("esri.renderers.visualVariables.ColorVariable")], p$1k);
const a$1a = p$1k;
var l$X;
let u$M = l$X = class extends l$1_ {
  constructor(r2) {
    super(r2), this.label = null, this.opacity = null, this.value = null;
  }
  readOpacity(r2, t2) {
    return r$$(t2.transparency);
  }
  writeOpacity(r2, t2, o2) {
    t2[o2] = n$1T(r2);
  }
  clone() {
    return new l$X({ label: this.label, opacity: this.opacity, value: this.value });
  }
};
e$1W([y$1o({ type: String, json: { write: true } })], u$M.prototype, "label", void 0), e$1W([y$1o({ type: Number, json: { type: T$r, write: { target: "transparency" } } })], u$M.prototype, "opacity", void 0), e$1W([o$1H("opacity", ["transparency"])], u$M.prototype, "readOpacity", null), e$1W([r$1h("opacity")], u$M.prototype, "writeOpacity", null), e$1W([y$1o({ type: Number, json: { write: true } })], u$M.prototype, "value", void 0), u$M = l$X = e$1W([n$2f("esri.renderers.visualVariables.support.OpacityStop")], u$M);
const y$v = u$M;
var i$15;
let p$1j = i$15 = class extends c$15 {
  constructor(t2) {
    super(t2), this.type = "opacity", this.normalizationField = null;
  }
  get cache() {
    return { ipData: this._interpolateData(), hasExpression: !!this.valueExpression, compiledFunc: null };
  }
  set stops(t2) {
    t2 && Array.isArray(t2) && (t2 = t2.filter((t3) => !!t3)).sort((t3, s2) => t3.value - s2.value), this._set("stops", t2);
  }
  clone() {
    return new i$15({ field: this.field, normalizationField: this.normalizationField, valueExpression: this.valueExpression, valueExpressionTitle: this.valueExpressionTitle, stops: this.stops && this.stops.map((t2) => t2.clone()), legendOptions: this.legendOptions && this.legendOptions.clone() });
  }
  getAttributeHash() {
    return `${super.getAttributeHash()}-${this.normalizationField}`;
  }
  _interpolateData() {
    return this.stops && this.stops.map((t2) => t2.value || 0);
  }
};
e$1W([y$1o({ readOnly: true })], p$1j.prototype, "cache", null), e$1W([y$1o({ type: ["opacity"], json: { type: ["transparencyInfo"] } })], p$1j.prototype, "type", void 0), e$1W([y$1o({ type: String, json: { write: true } })], p$1j.prototype, "normalizationField", void 0), e$1W([y$1o({ type: [y$v], json: { write: true } })], p$1j.prototype, "stops", null), p$1j = i$15 = e$1W([n$2f("esri.renderers.visualVariables.OpacityVariable")], p$1j);
const a$19 = p$1j;
var p$1i;
let a$18 = p$1i = class extends c$15 {
  constructor(e2) {
    super(e2), this.axis = null, this.type = "rotation", this.rotationType = "geographic", this.valueExpressionTitle = null;
  }
  get cache() {
    return { hasExpression: !!this.valueExpression, compiledFunc: null };
  }
  writeValueExpressionTitleWebScene(e2, s2, o2, r2) {
    if (r2 && r2.messages) {
      const e3 = `visualVariables[${this.index}]`;
      r2.messages.push(new s$1Z("property:unsupported", this.type + "VisualVariable.valueExpressionTitle is not supported in Web Scene. Please remove this property to save the Web Scene.", { instance: this, propertyName: e3 + ".valueExpressionTitle", context: r2 }));
    }
  }
  clone() {
    return new p$1i({ axis: this.axis, rotationType: this.rotationType, field: this.field, valueExpression: this.valueExpression, valueExpressionTitle: this.valueExpressionTitle, legendOptions: this.legendOptions && this.legendOptions.clone() });
  }
};
e$1W([y$1o({ readOnly: true })], a$18.prototype, "cache", null), e$1W([y$1o({ type: ["heading", "tilt", "roll"], json: { origins: { "web-scene": { default: "heading", write: true } } } })], a$18.prototype, "axis", void 0), e$1W([y$1o({ type: ["rotation"], json: { type: ["rotationInfo"] } })], a$18.prototype, "type", void 0), e$1W([y$1o({ type: ["geographic", "arithmetic"], json: { write: true, origins: { "web-document": { write: true, default: "geographic" } } } })], a$18.prototype, "rotationType", void 0), e$1W([y$1o({ type: String, json: { write: true } })], a$18.prototype, "valueExpressionTitle", void 0), e$1W([r$1h("web-scene", "valueExpressionTitle")], a$18.prototype, "writeValueExpressionTitleWebScene", null), a$18 = p$1i = e$1W([n$2f("esri.renderers.visualVariables.RotationVariable")], a$18);
const n$$ = a$18;
var p$1h;
let i$14 = p$1h = class extends l$1_ {
  constructor(r2) {
    super(r2), this.label = null, this.size = null, this.value = null;
  }
  clone() {
    return new p$1h({ label: this.label, size: this.size, value: this.value });
  }
};
e$1W([y$1o({ type: String, json: { write: true } })], i$14.prototype, "label", void 0), e$1W([y$1o({ type: Number, cast: o$1j, json: { write: true } })], i$14.prototype, "size", void 0), e$1W([y$1o({ type: Number, json: { write: true } })], i$14.prototype, "value", void 0), i$14 = p$1h = e$1W([n$2f("esri.renderers.visualVariables.support.SizeStop")], i$14);
const l$W = i$14;
var t$I;
let i$13 = t$I = class extends i$17 {
  constructor() {
    super(...arguments), this.customValues = null;
  }
  clone() {
    return new t$I({ title: this.title, showLegend: this.showLegend, customValues: this.customValues && this.customValues.slice(0) });
  }
};
e$1W([y$1o({ type: [Number], json: { write: true } })], i$13.prototype, "customValues", void 0), i$13 = t$I = e$1W([n$2f("esri.renderers.visualVariables.support.SizeVariableLegendOptions")], i$13);
const a$17 = i$13;
var n$_, i$12;
function e$D(n2) {
  return n2 && n2.declaredClass === "esri.renderers.visualVariables.SizeVariable";
}
function l$V(n2) {
  return n2 != null && !isNaN(n2) && isFinite(n2);
}
function t$H(i2) {
  return i2.valueExpression ? n$_.Expression : i2.field && typeof i2.field == "string" ? n$_.Field : n$_.Unknown;
}
function a$16(e2, l2) {
  const a2 = l2 || t$H(e2), o2 = e2.valueUnit || "unknown";
  return a2 === n$_.Unknown ? i$12.Constant : e2.stops ? i$12.Stops : e2.minSize != null && e2.maxSize != null && e2.minDataValue != null && e2.maxDataValue != null ? i$12.ClampedLinear : o2 === "unknown" ? e2.minSize != null && e2.minDataValue != null ? e2.minSize && e2.minDataValue ? i$12.Proportional : i$12.Additive : i$12.Identity : i$12.RealWorldSize;
}
!function(n2) {
  n2.Unknown = "unknown", n2.Expression = "expression", n2.Field = "field";
}(n$_ || (n$_ = {})), function(n2) {
  n2.Unknown = "unknown", n2.Stops = "stops", n2.ClampedLinear = "clamped-linear", n2.Proportional = "proportional", n2.Additive = "additive", n2.Constant = "constant", n2.Identity = "identity", n2.RealWorldSize = "real-world-size";
}(i$12 || (i$12 = {}));
function n$Z(n2) {
}
function o$H(n2) {
  return () => n2;
}
const m$G = { inches: E$k(1, "meters", "inches"), feet: E$k(1, "meters", "feet"), "us-feet": E$k(1, "meters", "us-feet"), yards: E$k(1, "meters", "yards"), miles: E$k(1, "meters", "miles"), "nautical-miles": E$k(1, "meters", "nautical-miles"), millimeters: E$k(1, "meters", "millimeters"), centimeters: E$k(1, "meters", "centimeters"), decimeters: E$k(1, "meters", "decimeters"), meters: E$k(1, "meters", "meters"), kilometers: E$k(1, "meters", "kilometers"), "decimal-degrees": 1 / Y$5(1, "meters", s$1M.radius) };
const f$H = s$22.getLogger("esri.renderers.visualVariables.support.visualVariableUtils"), p$1g = new g$J(), d$y = Math.PI, v$m = /^\s*(return\s+)?\$view\.scale\s*(;)?\s*$/i;
function b$l(a2, r2, i2) {
  const s2 = "visualVariables" in a2 && a2.visualVariables ? a2.visualVariables.find((e2) => e2.type === "color") : a2;
  if (!s2)
    return;
  if (s2.declaredClass !== "esri.renderers.visualVariables.ColorVariable")
    return void f$H.warn("The visualVariable should be an instance of esri.renderers.visualVariables.ColorVariable");
  const l2 = typeof r2 == "number", o2 = l2 ? null : r2, c2 = o2 && o2.attributes;
  let u2 = l2 ? r2 : null;
  const p2 = s2.field, { ipData: d2, hasExpression: v2 } = s2.cache;
  let b2 = s2.cache.compiledFunc;
  if (!p2 && !v2) {
    const e2 = s2.stops;
    return e2 && e2[0] && e2[0].color;
  }
  if (typeof u2 != "number")
    if (v2) {
      if (t$1W(i2) || t$1W(i2.arcade))
        return void f$H.error("Use of arcade expressions requires an arcade context");
      const e2 = { viewingMode: i2.viewingMode, scale: i2.scale, spatialReference: i2.spatialReference }, a3 = i2.arcade.arcadeUtils, r3 = a3.getViewInfo(e2), t2 = a3.createExecContext(o2, r3);
      if (!b2) {
        const e3 = a3.createSyntaxTree(s2.valueExpression);
        b2 = a3.createFunction(e3), s2.cache.compiledFunc = b2;
      }
      u2 = a3.executeFunction(b2, t2);
    } else
      c2 && (u2 = c2[p2]);
  const h2 = s2.normalizationField, m2 = c2 != null && h2 != null ? parseFloat(c2[h2]) : void 0;
  if (u2 != null && (!h2 || l2 || !isNaN(m2) && m2 !== 0)) {
    isNaN(m2) || l2 || (u2 /= m2);
    const a3 = R$8(u2, d2);
    if (a3) {
      const r3 = a3[0], n2 = a3[1], l3 = r3 === n2 ? s2.stops[r3].color : l$1D.blendColors(s2.stops[r3].color, s2.stops[n2].color, a3[2], r$1t(i2) ? i2.color : void 0);
      return new l$1D(l3);
    }
  }
}
function h$u(e2, a2, r2) {
  const i2 = "visualVariables" in e2 && e2.visualVariables ? e2.visualVariables.find((e3) => e3.type === "opacity") : e2;
  if (!i2)
    return;
  if (i2.declaredClass !== "esri.renderers.visualVariables.OpacityVariable")
    return void f$H.warn("The visualVariable should be an instance of esri.renderers.visualVariables.OpacityVariable");
  const t2 = typeof a2 == "number", s2 = t2 ? null : a2, l2 = s2 && s2.attributes;
  let o2 = t2 ? a2 : null;
  const c2 = i2.field, { ipData: u2, hasExpression: p2 } = i2.cache;
  let d2 = i2.cache.compiledFunc;
  if (!c2 && !p2) {
    const e3 = i2.stops;
    return e3 && e3[0] && e3[0].opacity;
  }
  if (typeof o2 != "number")
    if (p2) {
      if (t$1W(r2) || t$1W(r2.arcade))
        return void f$H.error("Use of arcade expressions requires an arcade context");
      const e3 = { viewingMode: r2.viewingMode, scale: r2.scale, spatialReference: r2.spatialReference }, a3 = r2.arcade.arcadeUtils, t3 = a3.getViewInfo(e3), l3 = a3.createExecContext(s2, t3);
      if (!d2) {
        const e4 = a3.createSyntaxTree(i2.valueExpression);
        d2 = a3.createFunction(e4), i2.cache.compiledFunc = d2;
      }
      o2 = a3.executeFunction(d2, l3);
    } else
      l2 && (o2 = l2[c2]);
  const v2 = i2.normalizationField, b2 = l2 != null && v2 != null ? parseFloat(l2[v2]) : void 0;
  if (o2 != null && (!v2 || t2 || !isNaN(b2) && b2 !== 0)) {
    isNaN(b2) || t2 || (o2 /= b2);
    const e3 = R$8(o2, u2);
    if (e3) {
      const a3 = e3[0], r3 = e3[1];
      if (a3 === r3)
        return i2.stops[a3].opacity;
      {
        const n2 = i2.stops[a3].opacity;
        return n2 + (i2.stops[r3].opacity - n2) * e3[2];
      }
    }
  }
}
function m$F(e2, a2, r2) {
  const i2 = "visualVariables" in e2 && e2.visualVariables ? e2.visualVariables.find((e3) => e3.type === "rotation") : e2;
  if (!i2)
    return;
  if (i2.declaredClass !== "esri.renderers.visualVariables.RotationVariable")
    return void f$H.warn("The visualVariable should be an instance of esri.renderers.visualVariables.RotationVariable");
  const t2 = i2.axis || "heading", s2 = t2 === "heading" && i2.rotationType === "arithmetic" ? 90 : 0, l2 = t2 === "heading" && i2.rotationType === "arithmetic" ? -1 : 1, o2 = typeof a2 == "number" ? null : a2, c2 = o2 && o2.attributes, u2 = i2.field, { hasExpression: p2 } = i2.cache;
  let d2 = i2.cache.compiledFunc, v2 = 0;
  if (!u2 && !p2)
    return v2;
  if (p2) {
    if (t$1W(r2) || t$1W(r2.arcade))
      return void f$H.error("Use of arcade expressions requires an arcade context");
    const e3 = { viewingMode: r2.viewingMode, scale: r2.scale, spatialReference: r2.spatialReference }, a3 = r2.arcade.arcadeUtils, t3 = a3.getViewInfo(e3), s3 = a3.createExecContext(o2, t3);
    if (!d2) {
      const e4 = a3.createSyntaxTree(i2.valueExpression);
      d2 = a3.createFunction(e4), i2.cache.compiledFunc = d2;
    }
    v2 = a3.executeFunction(d2, s3);
  } else
    c2 && (v2 = c2[u2] || 0);
  return v2 = typeof v2 != "number" || isNaN(v2) ? null : s2 + l2 * v2, v2;
}
function V$5(e2, a2, r2) {
  const i2 = typeof a2 == "number", s2 = i2 ? null : a2, l2 = s2 && s2.attributes;
  let c2 = i2 ? a2 : null;
  const { isScaleDriven: p2 } = e2.cache;
  let d2 = e2.cache.compiledFunc;
  if (p2) {
    const a3 = r$1t(r2) ? r2.scale : void 0, i3 = r$1t(r2) ? r2.view : void 0;
    c2 = a3 == null || i3 === "3d" ? x$f(e2) : a3;
  } else if (!i2)
    switch (e2.inputValueType) {
      case n$_.Expression: {
        if (t$1W(r2) || t$1W(r2.arcade))
          return void f$H.error("Use of arcade expressions requires an arcade context");
        const a3 = { viewingMode: r2.viewingMode, scale: r2.scale, spatialReference: r2.spatialReference }, i3 = r2.arcade.arcadeUtils, t2 = i3.getViewInfo(a3), l3 = i3.createExecContext(s2, t2);
        if (!d2) {
          const a4 = i3.createSyntaxTree(e2.valueExpression);
          d2 = i3.createFunction(a4), e2.cache.compiledFunc = d2;
        }
        c2 = i3.executeFunction(d2, l3);
        break;
      }
      case n$_.Field:
        l2 && (c2 = l2[e2.field]);
        break;
      case n$_.Unknown:
        c2 = null;
    }
  if (!l$V(c2))
    return null;
  if (i2 || !e2.normalizationField)
    return c2;
  const v2 = l2 ? parseFloat(l2[e2.normalizationField]) : null;
  return l$V(v2) && v2 !== 0 ? c2 / v2 : null;
}
function x$f(e2) {
  let a2 = null, r2 = null;
  const i2 = e2.stops;
  return i2 ? (a2 = i2[0].value, r2 = i2[i2.length - 1].value) : (a2 = e2.minDataValue || 0, r2 = e2.maxDataValue || 0), (a2 + r2) / 2;
}
function y$u(e2, a2, r2) {
  const i2 = "visualVariables" in e2 && e2.visualVariables ? e2.visualVariables.find((e3) => e3.type === "size") : e2;
  if (!i2)
    return;
  if (i2.declaredClass !== "esri.renderers.visualVariables.SizeVariable")
    return void f$H.warn("The visualVariable should be an instance of esri.renderers.visualVariables.SizeVariable");
  const n2 = M$5(V$5(i2, a2, r2), i2, a2, r2, i2.cache.ipData);
  return n2 == null || isNaN(n2) ? 0 : n2;
}
function w$j(e2, a2, r2) {
  return e2 == null ? null : e$D(e2) ? y$u(e2, a2, r2) : l$V(e2) ? e2 : null;
}
function g$q(e2, a2, r2) {
  return l$V(r2) && e2 > r2 ? r2 : l$V(a2) && e2 < a2 ? a2 : e2;
}
function z$c(e2, a2, r2, i2) {
  var _a2;
  return e2 + ((_a2 = w$j(a2.minSize, r2, i2) || a2.minDataValue) != null ? _a2 : 0);
}
function F$6(e2, a2, r2) {
  const i2 = e2.stops;
  let n2 = i2 && i2.length && i2[0].size;
  return n2 == null && (n2 = e2.minSize), w$j(n2, a2, r2);
}
function S$f(e2, a2, r2, i2) {
  const n2 = (e2 - a2.minDataValue) / (a2.maxDataValue - a2.minDataValue), s2 = w$j(a2.minSize, r2, i2), l2 = w$j(a2.maxSize, r2, i2), o2 = r$1t(i2) ? i2.shape : void 0;
  if (e2 <= a2.minDataValue)
    return s2;
  if (e2 >= a2.maxDataValue)
    return l2;
  if (s2 == null || l2 == null)
    return null;
  if (a2.scaleBy === "area" && o2) {
    const e3 = o2 === "circle", a3 = e3 ? d$y * (s2 / 2) ** 2 : s2 * s2, r3 = a3 + n2 * ((e3 ? d$y * (l2 / 2) ** 2 : l2 * l2) - a3);
    return e3 ? 2 * Math.sqrt(r3 / d$y) : Math.sqrt(r3);
  }
  return s2 + n2 * (l2 - s2);
}
function E$b(e2, a2, r2, i2) {
  const n2 = r$1t(i2) ? i2.shape : void 0, s2 = e2 / a2.minDataValue, l2 = w$j(a2.minSize, r2, i2), o2 = w$j(a2.maxSize, r2, i2);
  let c2 = null;
  return c2 = n2 === "circle" ? 2 * Math.sqrt(s2 * (l2 / 2) ** 2) : n2 === "square" || n2 === "diamond" || n2 === "image" ? Math.sqrt(s2 * l2 ** 2) : s2 * l2, g$q(c2, l2, o2);
}
function U$7(e2, a2, r2, i2, n2) {
  var _a2, _b2, _c2;
  const [t2, s2, l2] = R$8(e2, n2);
  if (t2 === s2)
    return w$j((_a2 = a2.stops) == null ? void 0 : _a2[t2].size, r2, i2);
  {
    const e3 = w$j((_b2 = a2.stops) == null ? void 0 : _b2[t2].size, r2, i2);
    return e3 + (w$j((_c2 = a2.stops) == null ? void 0 : _c2[s2].size, r2, i2) - e3) * l2;
  }
}
function C$b(e2, a2, r2, i2) {
  const n2 = (r$1t(i2) && i2.resolution ? i2.resolution : 1) * m$G[a2.valueUnit], l2 = w$j(a2.minSize, r2, i2), o2 = w$j(a2.maxSize, r2, i2), { valueRepresentation: c2 } = a2;
  let u2 = null;
  return u2 = c2 === "area" ? 2 * Math.sqrt(e2 / d$y) / n2 : c2 === "radius" || c2 === "distance" ? 2 * e2 / n2 : e2 / n2, g$q(u2, l2, o2);
}
function D$7(e2) {
  return e2;
}
function M$5(e2, a2, r2, i2, n2) {
  switch (a2.transformationType) {
    case i$12.Additive:
      return z$c(e2, a2, r2, i2);
    case i$12.Constant:
      return F$6(a2, r2, i2);
    case i$12.ClampedLinear:
      return S$f(e2, a2, r2, i2);
    case i$12.Proportional:
      return E$b(e2, a2, r2, i2);
    case i$12.Stops:
      return U$7(e2, a2, r2, i2, n2);
    case i$12.RealWorldSize:
      return C$b(e2, a2, r2, i2);
    case i$12.Identity:
      return D$7(e2);
    case i$12.Unknown:
      return null;
  }
}
function k$6(e2, a2, r2) {
  const { isScaleDriven: i2 } = e2.cache;
  if (!(i2 && r2 === "3d" || a2))
    return null;
  const n2 = { scale: a2, view: r2 };
  let t2 = w$j(e2.minSize, p$1g, n2), s2 = w$j(e2.maxSize, p$1g, n2);
  if (t2 != null || s2 != null) {
    if (t2 > s2) {
      const e3 = s2;
      s2 = t2, t2 = e3;
    }
    return { minSize: t2, maxSize: s2 };
  }
}
function N$4(e2, a2, r2) {
  if (!e2.visualVariables)
    return;
  const i2 = [], n2 = [], t2 = [], s2 = [], l2 = [];
  for (const o2 of e2.visualVariables)
    switch (o2.type) {
      case "color":
        n2.push(o2);
        break;
      case "opacity":
        t2.push(o2);
        break;
      case "rotation":
        l2.push(o2);
        break;
      case "size":
        s2.push(o2);
    }
  return n2.forEach((e3) => {
    const n3 = b$l(e3, a2, r2);
    i2.push({ variable: e3, value: n3 });
  }), t2.forEach((e3) => {
    const n3 = h$u(e3, a2, r2);
    i2.push({ variable: e3, value: n3 });
  }), l2.forEach((e3) => {
    const n3 = m$F(e3, a2, r2);
    i2.push({ variable: e3, value: n3 });
  }), s2.forEach((e3) => {
    const n3 = y$u(e3, a2, r2);
    i2.push({ variable: e3, value: n3 });
  }), i2.filter((e3) => e3.value != null);
}
function R$8(e2, a2) {
  if (!a2)
    return;
  let r2 = 0, i2 = a2.length - 1;
  return a2.some((a3, n2) => e2 < a3 ? (i2 = n2, true) : (r2 = n2, false)), [r2, i2, (e2 - a2[r2]) / (a2[i2] - a2[r2])];
}
function T$8(e2, a2, i2) {
  const n2 = ["proportional", "proportional", "proportional"];
  for (const t2 of e2) {
    const e3 = t2.useSymbolValue ? "symbol-value" : y$u(t2, a2, i2);
    switch (t2.axis) {
      case "width":
        n2[0] = e3;
        break;
      case "depth":
        n2[1] = e3;
        break;
      case "height":
        n2[2] = e3;
        break;
      case "width-and-depth":
        n2[0] = e3, n2[1] = e3;
        break;
      case "all":
      case void 0:
      case null:
        n2[0] = e3, n2[1] = e3, n2[2] = e3;
        break;
      default:
        n$Z(t2.axis);
    }
  }
  return n2;
}
var visualVariableUtils = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  getAllSizes: T$8,
  getColor: b$l,
  getOpacity: h$u,
  getRotationAngle: m$F,
  getSize: y$u,
  getSizeForValue: M$5,
  getSizeFromNumberOrVariable: w$j,
  getSizeRangeAtScale: k$6,
  getVisualVariableValues: N$4,
  viewScaleRE: v$m
});
var z$b;
const v$l = new s$1F({ width: "width", depth: "depth", height: "height", widthAndDepth: "width-and-depth", all: "all" }), g$p = new s$1F({ unknown: "unknown", inch: "inches", foot: "feet", yard: "yards", mile: "miles", "nautical-mile": "nautical-miles", millimeter: "millimeters", centimeter: "centimeters", decimeter: "decimeters", meter: "meters", kilometer: "kilometers", "decimal-degree": "decimal-degrees" });
function w$i(e2) {
  if (e2 != null)
    return typeof e2 == "string" || typeof e2 == "number" ? o$1j(e2) : e2.type === "size" ? e$D(e2) ? e2 : (delete (e2 = __spreadValues({}, e2)).type, new V$4(e2)) : void 0;
}
function f$G(e2, t2, i2) {
  if (typeof e2 != "object")
    return e2;
  const s2 = new V$4();
  return s2.read(e2, i2), s2;
}
let V$4 = z$b = class extends c$15 {
  constructor(e2) {
    super(e2), this.axis = null, this.legendOptions = null, this.normalizationField = null, this.scaleBy = null, this.target = null, this.type = "size", this.useSymbolValue = null, this.valueExpression = null, this.valueRepresentation = null, this.valueUnit = null;
  }
  get cache() {
    return { ipData: this._interpolateData(), hasExpression: !!this.valueExpression, compiledFunc: null, isScaleDriven: this.valueExpression != null && v$m.test(this.valueExpression) };
  }
  set expression(e2) {
    s$22.getLogger(this.declaredClass).warn("'expression' is deprecated since version 4.2. Use 'valueExpression' instead. The only supported expression is 'view.scale'."), e2 === "view.scale" ? (this.valueExpression = "$view.scale", this._set("expression", e2)) : this._set("expression", null);
  }
  set index(e2) {
    e$D(this.maxSize) && (this.maxSize.index = `visualVariables[${e2}].maxSize`), e$D(this.minSize) && (this.minSize.index = `visualVariables[${e2}].minSize`), this._set("index", e2);
  }
  get inputValueType() {
    return t$H(this);
  }
  set maxDataValue(e2) {
    e2 && this.stops && (s$22.getLogger(this.declaredClass).warn("cannot set maxDataValue when stops is not null."), e2 = null), this._set("maxDataValue", e2);
  }
  set maxSize(e2) {
    e2 && this.stops && (s$22.getLogger(this.declaredClass).warn("cannot set maxSize when stops is not null."), e2 = null), this._set("maxSize", e2);
  }
  castMaxSize(e2) {
    return w$i(e2);
  }
  readMaxSize(e2, t2, i2) {
    return f$G(e2, t2, i2);
  }
  set minDataValue(e2) {
    e2 && this.stops && (s$22.getLogger(this.declaredClass).warn("cannot set minDataValue when stops is not null."), e2 = null), this._set("minDataValue", e2);
  }
  set minSize(e2) {
    e2 && this.stops && (s$22.getLogger(this.declaredClass).warn("cannot set minSize when stops is not null."), e2 = null), this._set("minSize", e2);
  }
  castMinSize(e2) {
    return w$i(e2);
  }
  readMinSize(e2, t2, i2) {
    return f$G(e2, t2, i2);
  }
  get arcadeRequired() {
    return !!this.valueExpression || (this.minSize != null && typeof this.minSize == "object" && this.minSize.arcadeRequired || this.maxSize != null && typeof this.maxSize == "object" && this.maxSize.arcadeRequired);
  }
  set stops(e2) {
    this.minDataValue == null && this.maxDataValue == null && this.minSize == null && this.maxSize == null ? e2 && Array.isArray(e2) && (e2 = e2.filter((e3) => !!e3)).sort((e3, t2) => e3.value - t2.value) : e2 && (s$22.getLogger(this.declaredClass).warn("cannot set stops when one of minDataValue, maxDataValue, minSize or maxSize is not null."), e2 = null), this._set("stops", e2);
  }
  get transformationType() {
    return a$16(this, this.inputValueType);
  }
  readValueExpression(e2, t2) {
    return e2 || t2.expression && "$view.scale";
  }
  writeValueExpressionWebScene(e2, i2, s2, r2) {
    if (e2 === "$view.scale") {
      if (r2 && r2.messages) {
        const e3 = this.index, i3 = typeof e3 == "string" ? e3 : `visualVariables[${e3}]`;
        r2.messages.push(new s$1Z("property:unsupported", this.type + "VisualVariable.valueExpression = '$view.scale' is not supported in Web Scene. Please remove this property to save the Web Scene.", { instance: this, propertyName: i3 + ".valueExpression", context: r2 }));
      }
    } else
      i2[s2] = e2;
  }
  readValueUnit(e2) {
    return e2 ? g$p.read(e2) : null;
  }
  clone() {
    return new z$b({ axis: this.axis, field: this.field, valueExpression: this.valueExpression, valueExpressionTitle: this.valueExpressionTitle, maxDataValue: this.maxDataValue, maxSize: e$D(this.maxSize) ? this.maxSize.clone() : this.maxSize, minDataValue: this.minDataValue, minSize: e$D(this.minSize) ? this.minSize.clone() : this.minSize, normalizationField: this.normalizationField, stops: this.stops && this.stops.map((e2) => e2.clone()), target: this.target, useSymbolValue: this.useSymbolValue, valueRepresentation: this.valueRepresentation, valueUnit: this.valueUnit, legendOptions: this.legendOptions && this.legendOptions.clone() });
  }
  flipSizes() {
    if (this.transformationType === i$12.ClampedLinear) {
      const { minSize: e2, maxSize: t2 } = this;
      return this.minSize = t2, this.maxSize = e2, this;
    }
    if (this.transformationType === i$12.Stops) {
      const e2 = this.stops;
      if (!e2)
        return this;
      const t2 = e2.map((e3) => e3.size).reverse(), i2 = e2.length;
      for (let s2 = 0; s2 < i2; s2++)
        e2[s2].size = t2[s2];
      return this;
    }
    return this;
  }
  getAttributeHash() {
    return `${super.getAttributeHash()}-${this.target}-${this.normalizationField}`;
  }
  _interpolateData() {
    return this.stops && this.stops.map((e2) => e2.value || 0);
  }
};
e$1W([y$1o({ readOnly: true })], V$4.prototype, "cache", null), e$1W([y$1o({ type: v$l.apiValues, json: { type: v$l.jsonValues, origins: { "web-map": { read: false } }, read: v$l.read, write: v$l.write } })], V$4.prototype, "axis", void 0), e$1W([y$1o({ type: String, value: null, json: { read: false } })], V$4.prototype, "expression", null), e$1W([y$1o()], V$4.prototype, "index", null), e$1W([y$1o({ type: String, readOnly: true })], V$4.prototype, "inputValueType", null), e$1W([y$1o({ type: a$17, json: { write: true } })], V$4.prototype, "legendOptions", void 0), e$1W([y$1o({ type: Number, value: null, json: { write: true } })], V$4.prototype, "maxDataValue", null), e$1W([y$1o({ type: Number, value: null, json: { write: true } })], V$4.prototype, "maxSize", null), e$1W([s$1N("maxSize")], V$4.prototype, "castMaxSize", null), e$1W([o$1H("maxSize")], V$4.prototype, "readMaxSize", null), e$1W([y$1o({ type: Number, value: null, json: { write: true } })], V$4.prototype, "minDataValue", null), e$1W([y$1o({ type: Number, value: null, json: { write: true } })], V$4.prototype, "minSize", null), e$1W([s$1N("minSize")], V$4.prototype, "castMinSize", null), e$1W([o$1H("minSize")], V$4.prototype, "readMinSize", null), e$1W([y$1o({ type: String, json: { write: true } })], V$4.prototype, "normalizationField", void 0), e$1W([y$1o({ readOnly: true })], V$4.prototype, "arcadeRequired", null), e$1W([y$1o({ type: String })], V$4.prototype, "scaleBy", void 0), e$1W([y$1o({ type: [l$W], value: null, json: { write: true } })], V$4.prototype, "stops", null), e$1W([y$1o({ type: ["outline"], json: { write: true } })], V$4.prototype, "target", void 0), e$1W([y$1o({ type: String, readOnly: true })], V$4.prototype, "transformationType", null), e$1W([y$1o({ type: ["size"], json: { type: ["sizeInfo"] } })], V$4.prototype, "type", void 0), e$1W([y$1o({ type: Boolean, json: { write: true, origins: { "web-map": { read: false } } } })], V$4.prototype, "useSymbolValue", void 0), e$1W([y$1o({ type: String, json: { write: true } })], V$4.prototype, "valueExpression", void 0), e$1W([o$1H("valueExpression", ["valueExpression", "expression"])], V$4.prototype, "readValueExpression", null), e$1W([r$1h("web-scene", "valueExpression")], V$4.prototype, "writeValueExpressionWebScene", null), e$1W([y$1o({ type: ["radius", "diameter", "area", "width", "distance"], json: { write: true } })], V$4.prototype, "valueRepresentation", void 0), e$1W([y$1o({ type: g$p.apiValues, json: { write: g$p.write, origins: { "web-map": { read: false }, "web-scene": { write: true } } } })], V$4.prototype, "valueUnit", void 0), e$1W([o$1H("valueUnit")], V$4.prototype, "readValueUnit", null), V$4 = z$b = e$1W([n$2f("esri.renderers.visualVariables.SizeVariable")], V$4);
const j$f = V$4;
const u$L = { color: a$1a, size: j$f, opacity: a$19, rotation: n$$ }, b$k = new s$1F({ colorInfo: "color", transparencyInfo: "opacity", rotationInfo: "rotation", sizeInfo: "size" }), h$t = /^\[([^\]]+)\]$/i;
let V$3 = class extends m$1L {
  constructor() {
    super(...arguments), this.colorVariables = null, this.opacityVariables = null, this.rotationVariables = null, this.sizeVariables = null;
  }
  set visualVariables(r2) {
    if (this._resetVariables(), (r2 = r2 && r2.filter((r3) => !!r3)) && r2.length) {
      for (const s2 of r2)
        switch (s2.type) {
          case "color":
            this.colorVariables.push(s2);
            break;
          case "opacity":
            this.opacityVariables.push(s2);
            break;
          case "rotation":
            this.rotationVariables.push(s2);
            break;
          case "size":
            this.sizeVariables.push(s2);
        }
      if (this.sizeVariables.length) {
        this.sizeVariables.some((r3) => !!r3.target) && r2.sort((r3, s2) => {
          let e2 = null;
          return e2 = r3.target === s2.target ? 0 : r3.target ? 1 : -1, e2;
        });
      }
      for (let s2 = 0; s2 < r2.length; s2++) {
        r2[s2].index = s2;
      }
      this._set("visualVariables", r2);
    } else
      this._set("visualVariables", r2);
  }
  readVariables(r2, s2, e2) {
    const { rotationExpression: a2, rotationType: i2 } = s2, l2 = a2 && a2.match(h$t), n2 = l2 && l2[1];
    if (n2 && (r2 || (r2 = []), r2.push({ type: "rotationInfo", rotationType: i2, field: n2 })), r2)
      return r2.map((r3) => {
        const s3 = b$k.read(r3.type), a3 = u$L[s3];
        a3 || (s$22.getLogger(this.declaredClass).warn(`Unknown variable type: ${s3}`), e2 && e2.messages && e2.messages.push(new t$1Q("visual-variable:unsupported", `visualVariable of type '${s3}' is not supported`, { definition: r3, context: e2 })));
        const i3 = new a3();
        return i3.read(r3, e2), i3;
      });
  }
  writeVariables(r2, s2) {
    const e2 = [];
    for (const o2 of r2) {
      const r3 = o2.toJSON(s2);
      r3 && e2.push(r3);
    }
    return e2;
  }
  _resetVariables() {
    this.colorVariables = [], this.opacityVariables = [], this.rotationVariables = [], this.sizeVariables = [];
  }
};
e$1W([y$1o()], V$3.prototype, "visualVariables", null), V$3 = e$1W([n$2f("esri.renderers.visualVariables.VisualVariableFactory")], V$3);
const f$F = V$3;
const v$k = { base: c$15, key: "type", typeMap: { opacity: a$19, color: a$1a, rotation: n$$, size: j$f } }, y$t = (a2) => {
  let u2 = class extends a2 {
    constructor() {
      super(...arguments), this._vvFactory = new f$F();
    }
    set visualVariables(r2) {
      this._vvFactory.visualVariables = r2, this._set("visualVariables", this._vvFactory.visualVariables);
    }
    readVisualVariables(r2, a3, s2) {
      return this._vvFactory.readVariables(r2, a3, s2);
    }
    writeVisualVariables(r2, a3, s2, i2) {
      a3[s2] = this._vvFactory.writeVariables(r2, i2);
    }
    get arcadeRequiredForVisualVariables() {
      if (!this.visualVariables)
        return false;
      for (const r2 of this.visualVariables)
        if (r2.arcadeRequired)
          return true;
      return false;
    }
    hasVisualVariables(r2, a3) {
      return r2 ? this.getVisualVariablesForType(r2, a3).length > 0 : this.getVisualVariablesForType("size", a3).length > 0 || this.getVisualVariablesForType("color", a3).length > 0 || this.getVisualVariablesForType("opacity", a3).length > 0 || this.getVisualVariablesForType("rotation", a3).length > 0;
    }
    getVisualVariablesForType(r2, a3) {
      const s2 = this.visualVariables;
      return s2 ? s2.filter((s3) => s3.type === r2 && (typeof a3 == "string" ? s3.target === a3 : a3 !== false || !s3.target)) : [];
    }
    async collectVVRequiredFields(r2, a3) {
      let s2 = [];
      this.visualVariables && (s2 = s2.concat(this.visualVariables));
      for (const i2 of s2)
        i2 && (i2.field && w$H(r2, a3, i2.field), i2.normalizationField && w$H(r2, a3, i2.normalizationField), i2.valueExpression && (f$E(i2.valueExpression, r2, a3) || await S$C(r2, a3, i2.valueExpression)));
    }
  };
  return e$1W([y$1o({ types: [v$k], value: null, json: { write: true } })], u2.prototype, "visualVariables", null), e$1W([o$1H("visualVariables", ["visualVariables", "rotationType", "rotationExpression"])], u2.prototype, "readVisualVariables", null), e$1W([r$1h("visualVariables")], u2.prototype, "writeVisualVariables", null), u2 = e$1W([n$2f("esri.renderers.mixins.VisualVariablesMixin")], u2), u2;
};
function f$E(r2, s2, i2) {
  const e2 = e$E(r2);
  return !!r$1t(e2) && (w$H(s2, i2, e2), true);
}
const a$15 = { retainId: false, ignoreDrivers: false, hasLabelingContext: true };
function S$e(S2, c2 = a$15) {
  var _a2, _b2;
  if (!S2)
    return { symbol: null };
  const { retainId: u2 = a$15.retainId, ignoreDrivers: d2 = a$15.ignoreDrivers, hasLabelingContext: j2 = a$15.hasLabelingContext, retainCIM: g2 = a$15.retainCIM } = c2;
  let D2 = null;
  if (c$1N(S2) || S2 instanceof f$11)
    D2 = S2.clone();
  else if (S2.type === "cim") {
    const o2 = (_b2 = (_a2 = S2.data) == null ? void 0 : _a2.symbol) == null ? void 0 : _b2.type;
    if (o2 !== "CIMPointSymbol")
      return { error: new s$1Z("symbol-conversion:unsupported-cim-symbol", `CIM symbol of type '${o2 || "unknown"}' is unsupported in 3D`, { symbol: S2 }) };
    D2 = g2 ? S2.clone() : h$X.fromCIMSymbol(S2);
  } else if (S2 instanceof m$1q)
    D2 = b$G.fromSimpleLineSymbol(S2);
  else if (S2 instanceof y$Z)
    D2 = h$X.fromSimpleMarkerSymbol(S2);
  else if (S2 instanceof n$1C)
    D2 = h$X.fromPictureMarkerSymbol(S2);
  else if (S2 instanceof S$t)
    D2 = c2.geometryType && c2.geometryType === "mesh" ? c$1R.fromSimpleFillSymbol(S2) : S$u.fromSimpleFillSymbol(S2);
  else {
    if (!(S2 instanceof m$17))
      return { error: new s$1Z("symbol-conversion:unsupported-2d-symbol", `2D symbol of type '${S2.type || S2.declaredClass}' is unsupported in 3D`, { symbol: S2 }) };
    D2 = j2 ? b$H.fromTextSymbol(S2) : h$X.fromTextSymbol(S2);
  }
  if (u2 && D2 && D2.type !== "cim" && (D2.id = S2.id), d2 && c$1N(D2))
    for (let o2 = 0; o2 < D2.symbolLayers.length; ++o2)
      D2.symbolLayers.getItemAt(o2)._ignoreDrivers = true;
  return { symbol: D2 };
}
const l$U = ["building-scene", "integrated-mesh", "point-cloud", "scene"];
function m$E(e2, o2, t2, s2) {
  const r2 = a$14(e2, {}, { context: s2, isLabelSymbol: false });
  r$1t(r2) && (o2[t2] = r2);
}
function c$14(e2, o2, t2, s2) {
  const r2 = a$14(e2, {}, { context: s2, isLabelSymbol: true });
  r$1t(r2) && (o2[t2] = r2);
}
function b$j(e2) {
  return e2 instanceof k$k || e2 instanceof f$11;
}
function a$14(e2, s2, i2) {
  var _a2;
  if (t$1W(e2))
    return null;
  const { context: m2, isLabelSymbol: c2 } = i2, a2 = m2 == null ? void 0 : m2.origin, p2 = m2 == null ? void 0 : m2.messages;
  if (a2 === "web-scene" && !b$j(e2)) {
    const t2 = S$e(e2, { retainCIM: true, hasLabelingContext: c2 });
    return r$1t(t2.symbol) ? t2.symbol.write(s2, m2) : (p2 == null ? void 0 : p2.push(new s$1Z("symbol:unsupported", `Symbols of type '${e2.declaredClass}' are not supported in scenes. Use 3D symbology instead when working with WebScene and SceneView`, { symbol: e2, context: m2, error: t2.error })), null);
  }
  const y2 = (_a2 = m2 == null ? void 0 : m2.layer) == null ? void 0 : _a2.type;
  return a2 !== "web-map" && (a2 !== "portal-item" || y2 && l$U.includes(y2)) || !b$j(e2) ? e2.write(s2, m2) : (p2 == null ? void 0 : p2.push(new s$1Z("symbol:unsupported", `Symbols of type '${e2.declaredClass}' are not supported in web maps and portal items. Use 2D symbology and CIMSymbol instead when working with MapView`, { symbol: e2, context: m2 })), null);
}
function p$1f(o2, n2) {
  return k$j(o2, null, n2);
}
const l$T = { types: M$i, json: { write: { writer: m$E }, origins: { "web-scene": { types: h$U, write: { writer: m$E }, read: { reader: s$1W({ types: h$U }) } } } } }, y$s = { types: { base: a$20, key: "type", typeMap: { "simple-fill": j$v.typeMap["simple-fill"], "picture-fill": j$v.typeMap["picture-fill"], "polygon-3d": j$v.typeMap["polygon-3d"] } }, json: { write: { writer: m$E }, origins: { "web-scene": { type: S$u, write: { writer: m$E } } } } }, m$D = { cast: (e2) => e2 == null || typeof e2 == "string" || typeof e2 == "number" ? e2 : `${e2}`, json: { type: String, write: { writer: (e2, r2) => {
  r2.value = e2 == null ? void 0 : e2.toString();
} } } };
var i$11;
let l$S = i$11 = class extends l$1_ {
  constructor(s2) {
    super(s2), this.description = null, this.label = null, this.minValue = null, this.maxValue = 0, this.symbol = null;
  }
  clone() {
    return new i$11({ description: this.description, label: this.label, minValue: this.minValue, maxValue: this.maxValue, symbol: this.symbol ? this.symbol.clone() : null });
  }
  getMeshHash() {
    const s2 = JSON.stringify(this.symbol);
    return `${this.minValue}.${this.maxValue}.${s2}`;
  }
};
e$1W([y$1o({ type: String, json: { write: true } })], l$S.prototype, "description", void 0), e$1W([y$1o({ type: String, json: { write: true } })], l$S.prototype, "label", void 0), e$1W([y$1o({ type: Number, json: { read: { source: "classMinValue" }, write: { target: "classMinValue" } } })], l$S.prototype, "minValue", void 0), e$1W([y$1o({ type: Number, json: { read: { source: "classMaxValue" }, write: { target: "classMaxValue" } } })], l$S.prototype, "maxValue", void 0), e$1W([y$1o(l$T)], l$S.prototype, "symbol", void 0), l$S = i$11 = e$1W([n$2f("esri.renderers.support.ClassBreakInfo")], l$S);
const a$13 = l$S;
var V$2;
const E$a = "log", j$e = "percent-of-total", z$a = "field", w$h = new s$1F({ esriNormalizeByLog: E$a, esriNormalizeByPercentOfTotal: j$e, esriNormalizeByField: z$a }), T$7 = b$U(a$13);
let C$a = V$2 = class extends y$t(p$1n) {
  constructor(e2) {
    super(e2), this._compiledValueExpression = { valueExpression: null, compiledFunction: null }, this.backgroundFillSymbol = null, this.classBreakInfos = null, this.defaultLabel = null, this.defaultSymbol = null, this.field = null, this.isMaxInclusive = true, this.legendOptions = null, this.normalizationField = null, this.normalizationTotal = null, this.type = "class-breaks", this.valueExpression = null, this.valueExpressionTitle = null, this._set("classBreakInfos", []);
  }
  readClassBreakInfos(e2, s2, t2) {
    if (!Array.isArray(e2))
      return;
    let o2 = s2.minValue;
    return e2.map((e3) => {
      const s3 = new a$13();
      return s3.read(e3, t2), s3.minValue == null && (s3.minValue = o2), s3.maxValue == null && (s3.maxValue = s3.minValue), o2 = s3.maxValue, s3;
    });
  }
  writeClassBreakInfos(e2, s2, t2, o2) {
    const i2 = e2.map((e3) => e3.write({}, o2));
    this._areClassBreaksConsecutive() && i2.forEach((e3) => delete e3.classMinValue), s2[t2] = i2;
  }
  castField(e2) {
    return e2 == null ? e2 : typeof e2 == "function" ? (s$22.getLogger(this.declaredClass).error(".field: field must be a string value"), null) : u$1W(e2);
  }
  get minValue() {
    return this.classBreakInfos && this.classBreakInfos[0] && this.classBreakInfos[0].minValue || 0;
  }
  get normalizationType() {
    let e2 = this._get("normalizationType");
    const s2 = !!this.normalizationField, t2 = this.normalizationTotal != null;
    return s2 || t2 ? (e2 = s2 && z$a || t2 && j$e || null, s2 && t2 && s$22.getLogger(this.declaredClass).warn("warning: both normalizationField and normalizationTotal are set!")) : e2 !== z$a && e2 !== j$e || (e2 = null), e2;
  }
  set normalizationType(e2) {
    this._set("normalizationType", e2);
  }
  addClassBreakInfo(e2, t2, i2) {
    let r2 = null;
    r2 = typeof e2 == "number" ? new a$13({ minValue: e2, maxValue: t2, symbol: g$K(i2) }) : T$7(y$1r(e2)), this.classBreakInfos.push(r2), this.classBreakInfos.length === 1 && this.notifyChange("minValue");
  }
  removeClassBreakInfo(e2, s2) {
    const t2 = this.classBreakInfos.length;
    for (let o2 = 0; o2 < t2; o2++) {
      const t3 = [this.classBreakInfos[o2].minValue, this.classBreakInfos[o2].maxValue];
      if (t3[0] === e2 && t3[1] === s2) {
        this.classBreakInfos.splice(o2, 1);
        break;
      }
    }
  }
  getBreakIndex(e2, s2) {
    return this.valueExpression && (t$1W(s2) || t$1W(s2.arcade)) && s$22.getLogger(this.declaredClass).warn(""), this.valueExpression ? this._getBreakIndexForExpression(e2, s2) : this._getBreakIndexForField(e2);
  }
  async getClassBreakInfo(e2, s2) {
    let t2 = s2;
    this.valueExpression && (t$1W(s2) || t$1W(s2.arcade)) && (t2 = __spreadProps(__spreadValues({}, t2), { arcade: await i$26() }));
    const o2 = this.getBreakIndex(e2, t2);
    return o2 !== -1 ? this.classBreakInfos[o2] : null;
  }
  getSymbol(e2, s2) {
    if (this.valueExpression && (t$1W(s2) || t$1W(s2.arcade)))
      return void s$22.getLogger(this.declaredClass).error("#getSymbol()", "Please use getSymbolAsync if valueExpression is used");
    const t2 = this.getBreakIndex(e2, s2);
    return t2 > -1 ? this.classBreakInfos[t2].symbol : this.defaultSymbol;
  }
  async getSymbolAsync(e2, s2) {
    let t2 = s2;
    if (this.valueExpression && (t$1W(s2) || t$1W(s2.arcade))) {
      const e3 = await i$26(), { arcadeUtils: s3 } = e3;
      s3.hasGeometryOperations(this.valueExpression) && await s3.enableGeometryOperations(), t2 = __spreadProps(__spreadValues({}, t2), { arcade: e3 });
    }
    const o2 = this.getBreakIndex(e2, t2);
    return o2 > -1 ? this.classBreakInfos[o2].symbol : this.defaultSymbol;
  }
  getSymbols() {
    const e2 = [];
    return this.classBreakInfos.forEach((s2) => {
      s2.symbol && e2.push(s2.symbol);
    }), this.defaultSymbol && e2.push(this.defaultSymbol), e2;
  }
  getAttributeHash() {
    return this.visualVariables && this.visualVariables.reduce((e2, s2) => e2 + s2.getAttributeHash(), "");
  }
  getMeshHash() {
    const e2 = JSON.stringify(this.backgroundFillSymbol), s2 = JSON.stringify(this.defaultSymbol), t2 = `${this.normalizationField}.${this.normalizationType}.${this.normalizationTotal}`;
    return `${e2}.${s2}.${this.classBreakInfos.reduce((e3, s3) => e3 + s3.getMeshHash(), "")}.${t2}.${this.field}.${this.valueExpression}`;
  }
  get arcadeRequired() {
    return this.arcadeRequiredForVisualVariables || !!this.valueExpression;
  }
  clone() {
    return new V$2({ field: this.field, backgroundFillSymbol: this.backgroundFillSymbol && this.backgroundFillSymbol.clone(), defaultLabel: this.defaultLabel, defaultSymbol: this.defaultSymbol && this.defaultSymbol.clone(), valueExpression: this.valueExpression, valueExpressionTitle: this.valueExpressionTitle, classBreakInfos: y$1r(this.classBreakInfos), isMaxInclusive: this.isMaxInclusive, normalizationField: this.normalizationField, normalizationTotal: this.normalizationTotal, normalizationType: this.normalizationType, visualVariables: y$1r(this.visualVariables), legendOptions: y$1r(this.legendOptions), authoringInfo: this.authoringInfo && this.authoringInfo.clone() });
  }
  async collectRequiredFields(e2, s2) {
    const t2 = [this.collectVVRequiredFields(e2, s2), this.collectSymbolFields(e2, s2)];
    await Promise.all(t2);
  }
  async collectSymbolFields(e2, s2) {
    const t2 = [...this.getSymbols().map((t3) => t3.collectRequiredFields(e2, s2)), S$C(e2, s2, this.valueExpression)];
    w$H(e2, s2, this.field), w$H(e2, s2, this.normalizationField), await Promise.all(t2);
  }
  _getBreakIndexForExpression(e2, s2) {
    const { viewingMode: t2, scale: o2, spatialReference: i2, arcade: r2 } = i$2y(s2, {}), { valueExpression: n2 } = this;
    let u2 = this._compiledValueExpression.valueExpression === n2 ? this._compiledValueExpression.compiledFunction : null;
    const c2 = e$1U(r2).arcadeUtils;
    if (!u2) {
      const e3 = c2.createSyntaxTree(n2);
      u2 = c2.createFunction(e3), this._compiledValueExpression.compiledFunction = u2;
    }
    this._compiledValueExpression.valueExpression = n2;
    const p2 = c2.executeFunction(u2, c2.createExecContext(e2, c2.getViewInfo({ viewingMode: t2, scale: o2, spatialReference: i2 })));
    return this._getBreakIndexfromInfos(p2);
  }
  _getBreakIndexForField(e2) {
    const s2 = this.field, t2 = e2.attributes, o2 = this.normalizationType;
    let i2 = parseFloat(t2[s2]);
    if (o2) {
      const e3 = this.normalizationTotal, s3 = parseFloat(this.normalizationField ? t2[this.normalizationField] : void 0);
      if (o2 === E$a)
        i2 = Math.log(i2) * Math.LOG10E;
      else if (o2 !== j$e || e3 == null || isNaN(e3)) {
        if (o2 === z$a && !isNaN(s3)) {
          if (isNaN(i2) || isNaN(s3))
            return -1;
          i2 /= s3;
        }
      } else
        i2 = i2 / e3 * 100;
    }
    return this._getBreakIndexfromInfos(i2);
  }
  _getBreakIndexfromInfos(e2) {
    const s2 = this.isMaxInclusive;
    if (e2 != null && typeof e2 == "number" && !isNaN(e2))
      for (let t2 = 0; t2 < this.classBreakInfos.length; t2++) {
        const o2 = [this.classBreakInfos[t2].minValue, this.classBreakInfos[t2].maxValue];
        if (o2[0] <= e2 && (s2 ? e2 <= o2[1] : e2 < o2[1]))
          return t2;
      }
    return -1;
  }
  _areClassBreaksConsecutive() {
    const e2 = this.classBreakInfos, s2 = e2.length;
    for (let t2 = 1; t2 < s2; t2++)
      if (e2[t2 - 1].maxValue !== e2[t2].minValue)
        return false;
    return true;
  }
};
e$1W([y$1o(y$s)], C$a.prototype, "backgroundFillSymbol", void 0), e$1W([y$1o({ type: [a$13] })], C$a.prototype, "classBreakInfos", void 0), e$1W([o$1H("classBreakInfos")], C$a.prototype, "readClassBreakInfos", null), e$1W([r$1h("classBreakInfos")], C$a.prototype, "writeClassBreakInfos", null), e$1W([y$1o({ type: String, json: { write: true } })], C$a.prototype, "defaultLabel", void 0), e$1W([y$1o(l$T)], C$a.prototype, "defaultSymbol", void 0), e$1W([y$1o({ type: String, json: { write: true } })], C$a.prototype, "field", void 0), e$1W([s$1N("field")], C$a.prototype, "castField", null), e$1W([y$1o({ type: Boolean })], C$a.prototype, "isMaxInclusive", void 0), e$1W([y$1o({ type: p$1m, json: { write: true } })], C$a.prototype, "legendOptions", void 0), e$1W([y$1o({ type: Number, readOnly: true, value: null, json: { read: false, write: { overridePolicy() {
  return this.classBreakInfos.length !== 0 && this._areClassBreaksConsecutive() ? { enabled: true } : { enabled: false };
} } } })], C$a.prototype, "minValue", null), e$1W([y$1o({ type: String, json: { write: true } })], C$a.prototype, "normalizationField", void 0), e$1W([y$1o({ type: Number, cast: (e2) => a$2w(e2), json: { write: true } })], C$a.prototype, "normalizationTotal", void 0), e$1W([y$1o({ type: w$h.apiValues, value: null, json: { type: w$h.jsonValues, read: w$h.read, write: w$h.write } })], C$a.prototype, "normalizationType", null), e$1W([r$1a({ classBreaks: "class-breaks" })], C$a.prototype, "type", void 0), e$1W([y$1o({ type: String, json: { write: true } })], C$a.prototype, "valueExpression", void 0), e$1W([y$1o({ type: String, json: { write: true } })], C$a.prototype, "valueExpressionTitle", void 0), C$a = V$2 = e$1W([n$2f("esri.renderers.ClassBreaksRenderer")], C$a);
const _$g = C$a;
class e$C {
  constructor(e2, s2) {
    this._storage = new h$F(), this._storage.maxSize = e2, s2 && this._storage.registerRemoveFunc("", s2);
  }
  put(t2, e2, s2) {
    this._storage.put(t2, e2, s2, 1);
  }
  pop(t2) {
    return this._storage.pop(t2);
  }
  get(t2) {
    return this._storage.get(t2);
  }
  clear() {
    this._storage.clearAll();
  }
  destroy() {
    this._storage.destroy();
  }
  get maxSize() {
    return this._storage.maxSize;
  }
  set maxSize(t2) {
    this._storage.maxSize = t2;
  }
}
const h$s = "esri.renderers.support.DictionaryLoader", y$r = { type: "CIMSimpleLineCallout", lineSymbol: { type: "CIMLineSymbol", symbolLayers: [{ type: "CIMSolidStroke", width: 0.5, color: [0, 0, 0, 255] }] } };
class u$K {
  constructor(e2, t2, s2) {
    this.config = null, this.fieldMap = null, this.url = null, this._ongoingRequests = new Map(), this._symbolCache = new e$C(100), this._dictionaryPromise = null, this.url = e2, this.config = t2, this.fieldMap = s2;
  }
  getSymbolFields() {
    return this._symbolFields;
  }
  async getSymbolAsync(t2, s2) {
    let o2;
    this._dictionaryPromise || (this._dictionaryPromise = this.fetchResources(s2));
    try {
      o2 = await this._dictionaryPromise;
    } catch (g2) {
      if (j$K(g2))
        return this._dictionaryPromise = null, null;
    }
    const i2 = {};
    if (this.fieldMap)
      for (const e2 of this._symbolFields) {
        const s3 = this.fieldMap[e2];
        if (s3 && t2.attributes[s3] != null) {
          const o3 = "" + t2.attributes[s3];
          i2[e2] = o3;
        } else
          i2[e2] = "";
      }
    const n2 = o2 == null ? void 0 : o2(i2, s2);
    if (!n2 || typeof n2 != "string")
      return null;
    const c2 = c$2T(n2).toString(), m2 = this._symbolCache.get(c2);
    if (m2)
      return m2.catch(() => {
        this._symbolCache.pop(c2);
      }), m2;
    const f2 = n2.split(";"), h2 = [], y2 = [];
    for (const r2 of f2)
      if (r2)
        if (r2.includes("po:")) {
          const t3 = r2.substr(3).split("|");
          if (t3.length === 3) {
            const s3 = t3[0], o3 = t3[1];
            let i3 = t3[2];
            if (o3 === "DashTemplate")
              i3 = i3.split(" ").map((e2) => Number(e2));
            else if (o3 === "Color") {
              const t4 = new l$1D(i3).toRgba();
              i3 = [t4[0], t4[1], t4[2], 255 * t4[3]];
            } else
              i3 = Number(i3);
            y2.push({ primitiveName: s3, propertyName: o3, value: i3 });
          }
        } else if (r2.includes("|")) {
          for (const e2 of r2.split("|"))
            if (this._itemNames.has(e2)) {
              h2.push(e2);
              break;
            }
        } else
          this._itemNames.has(r2) && h2.push(r2);
    const u2 = !r$1t(t2.geometry) || !t2.geometry.hasZ && t2.geometry.type === "point", p2 = this._cimPartsToCIMSymbol(h2, y2, u2, s2);
    return this._symbolCache.put(c2, p2, 1), p2;
  }
  async fetchResources(e2) {
    if (this._dictionaryPromise)
      return this._dictionaryPromise;
    if (!this.url)
      return void s$22.getLogger(h$s).error("no valid URL!");
    const i2 = U$k(this.url + "/resources/styles/dictionary-info.json", { responseType: "json", query: { f: "json" }, signal: r$1t(e2) ? e2.signal : null }), [{ data: l2 }] = await Promise.all([i2, i$26()]);
    if (!l2)
      throw this._dictionaryPromise = null, new s$1Z("esri.renderers.DictionaryRenderer", "Bad dictionary data!");
    const a2 = l2.expression, f2 = l2.authoringInfo;
    this._refSymbolUrlTemplate = this.url + "/" + l2.cimRefTemplateUrl, this._itemNames = new Set(l2.itemsNames), this._symbolFields = f2.symbol;
    const y2 = {};
    if (this.config) {
      const e3 = this.config;
      for (const t2 in e3)
        y2[t2] = e3[t2];
    }
    if (f2.configuration)
      for (const t2 of f2.configuration)
        y2.hasOwnProperty(t2.name) || (y2[t2.name] = t2.value);
    const u2 = [];
    if (r$1t(e2) && e2.fields && this.fieldMap)
      for (const t2 of this._symbolFields) {
        const s2 = this.fieldMap[t2], o2 = e2.fields.filter((e3) => e3.name === s2);
        o2.length > 0 && u2.push(__spreadProps(__spreadValues({}, o2[0]), { name: t2 }));
      }
    const p2 = u$1C(a2, r$1t(e2) ? e2.spatialReference : null, u2, y2).then((e3) => {
      const t2 = { scale: 0 };
      return (s2, o2) => {
        if (t$1W(e3))
          return null;
        const i3 = e3.repurposeFeature({ geometry: null, attributes: s2 });
        return t2.scale = r$1t(o2) ? o2.scale : void 0, e3.evaluate({ $feature: i3, $view: t2 });
      };
    }).catch((e3) => (s$22.getLogger(h$s).error("Creating dictinoary expression failed:", e3), null));
    return this._dictionaryPromise = p2, p2;
  }
  async _cimPartsToCIMSymbol(e2, t2, s2, o2) {
    const i2 = new Array(e2.length);
    for (let l2 = 0; l2 < e2.length; l2++)
      i2[l2] = this._getSymbolPart(e2[l2], o2);
    const r2 = await Promise.all(i2), n2 = this.fieldMap;
    if (n2)
      for (const l2 of r2)
        p$1e(l2, n2);
    return new d$1h({ data: this._combineSymbolParts(r2, t2, s2) });
  }
  async _getSymbolPart(e2, s2) {
    if (this._ongoingRequests.has(e2))
      return this._ongoingRequests.get(e2).then((e3) => e3.data);
    const o2 = this._refSymbolUrlTemplate.replace(/\{itemName\}/gi, e2), i2 = U$k(o2, __spreadValues({ responseType: "json", query: { f: "json" } }, s2));
    this._ongoingRequests.set(e2, i2);
    try {
      return (await i2).data;
    } catch (r2) {
      throw this._ongoingRequests.delete(e2), r2;
    }
  }
  _combineSymbolParts(e2, t2, s2) {
    if (!e2 || e2.length === 0)
      return null;
    const o2 = __spreadValues({}, e2[0]);
    if (e2.length > 1) {
      o2.symbolLayers = [];
      for (const t3 of e2) {
        const e3 = t3;
        o2.symbolLayers.unshift(...e3.symbolLayers);
      }
    }
    return s2 && (o2.callout = y$r), { type: "CIMSymbolReference", symbol: o2, primitiveOverrides: t2 };
  }
}
function p$1e(e2, t2) {
  if (!e2)
    return;
  const s2 = e2.symbolLayers;
  if (!s2)
    return;
  let o2 = s2.length;
  for (; o2--; ) {
    const e3 = s2[o2];
    if (e3 && e3.enable !== false && e3.type === "CIMVectorMarker")
      g$o(e3, t2);
  }
}
function g$o(e2, t2) {
  const s2 = e2.markerGraphics;
  if (s2)
    for (const o2 of s2) {
      if (!o2)
        continue;
      const e3 = o2.symbol;
      if (e3)
        switch (e3.type) {
          case "CIMPointSymbol":
          case "CIMLineSymbol":
          case "CIMPolygonSymbol":
            p$1e(e3, t2);
            break;
          case "CIMTextSymbol":
            e3.fieldMap = t2;
        }
    }
}
var DictionaryLoader = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  DictionaryLoader: u$K
});
var p$1d;
let c$13 = p$1d = class extends y$t(p$1n) {
  constructor(e2) {
    super(e2), this.config = null, this.fieldMap = null, this.scaleExpression = null, this.scaleExpressionTitle = null, this.url = null, this.type = "dictionary";
  }
  get _loader() {
    return new u$K(this.url, this.config, this.fieldMap);
  }
  writeData(e2, r2) {
    e2 && (r2.scalingExpressionInfo = { expression: e2, returnType: "number" });
  }
  writeVisualVariables(e2, r2, s2, i2) {
    (i2 == null ? void 0 : i2.origin) || super.writeVisualVariables(e2, r2, s2, i2);
  }
  clone() {
    return new p$1d({ config: y$1r(this.config), scaleExpression: this.scaleExpression, scaleExpressionTitle: this.scaleExpressionTitle, fieldMap: y$1r(this.fieldMap), url: y$1r(this.url), visualVariables: y$1r(this.visualVariables) });
  }
  async getSymbolAsync(e2, r2) {
    return this._loader.getSymbolAsync(e2, r2);
  }
  async collectRequiredFields(e2, r2) {
    await this.collectVVRequiredFields(e2, r2), this.scaleExpression && await S$C(e2, r2, this.scaleExpression);
    for (const s2 in this.fieldMap) {
      const i2 = this.fieldMap[s2];
      r2.has(i2) && e2.add(i2);
    }
  }
  get arcadeRequired() {
    return true;
  }
  getSymbol() {
    return null;
  }
  getSymbols() {
    return [];
  }
  getAttributeHash() {
    return this.visualVariables && this.visualVariables.reduce((e2, r2) => e2 + r2.getAttributeHash(), "");
  }
  getMeshHash() {
    return `${this.url}-${JSON.stringify(this.fieldMap)}`;
  }
  getSymbolFields() {
    return this._loader.getSymbolFields();
  }
};
e$1W([y$1o({ type: u$K })], c$13.prototype, "_loader", null), e$1W([y$1o({ type: Object, json: { read: { source: "configuration" }, write: { target: "configuration" } } })], c$13.prototype, "config", void 0), e$1W([y$1o({ type: Object, json: { write: true } })], c$13.prototype, "fieldMap", void 0), e$1W([y$1o({ type: String, json: { read: { source: "scalingExpressionInfo.expression" }, write: true } })], c$13.prototype, "scaleExpression", void 0), e$1W([r$1h("scaleExpression")], c$13.prototype, "writeData", null), e$1W([y$1o({ type: String, json: { read: { source: "scalingExpressionInfo.title" }, write: { target: "scalingExpressionInfo.title", overridePolicy(e2) {
  return { enabled: !!e2 && !!this.scaleExpression };
} } } })], c$13.prototype, "scaleExpressionTitle", void 0), e$1W([y$1o({ type: String, json: { write: true } })], c$13.prototype, "url", void 0), e$1W([r$1h("visualVariables")], c$13.prototype, "writeVisualVariables", null), c$13 = p$1d = e$1W([n$2f("esri.renderers.DictionaryRenderer")], c$13);
const u$J = c$13;
var n$Y;
let u$I = n$Y = class extends l$1_ {
  constructor(e2) {
    super(e2), this.color = null, this.field = null, this.label = null, this.valueExpression = null, this.valueExpressionTitle = null;
  }
  castField(e2) {
    return e2 == null ? e2 : typeof e2 == "function" ? (s$22.getLogger(this.declaredClass).error(".field: field must be a string value"), null) : u$1W(e2);
  }
  getAttributeHash() {
    return `${this.field}-${this.valueExpression}`;
  }
  clone() {
    return new n$Y({ color: this.color && this.color.clone(), field: this.field, label: this.label, valueExpression: this.valueExpression, valueExpressionTitle: this.valueExpressionTitle });
  }
};
e$1W([y$1o({ type: l$1D, json: { type: [Number], write: true } })], u$I.prototype, "color", void 0), e$1W([y$1o({ type: String, json: { write: true } })], u$I.prototype, "field", void 0), e$1W([s$1N("field")], u$I.prototype, "castField", null), e$1W([y$1o({ type: String, json: { write: true } })], u$I.prototype, "label", void 0), e$1W([y$1o({ type: String, json: { write: true } })], u$I.prototype, "valueExpression", void 0), e$1W([y$1o({ type: String, json: { write: true } })], u$I.prototype, "valueExpressionTitle", void 0), u$I = n$Y = e$1W([n$2f("esri.renderers.support.AttributeColorInfo")], u$I);
const a$12 = u$I;
var e$B;
let p$1c = e$B = class extends l$1_ {
  constructor() {
    super(...arguments), this.unit = null;
  }
  clone() {
    return new e$B({ unit: this.unit });
  }
};
e$1W([y$1o({ type: String, json: { write: true } })], p$1c.prototype, "unit", void 0), p$1c = e$B = e$1W([n$2f("esri.renderers.support.DotDensityLegendOptions")], p$1c);
const c$12 = p$1c;
var h$r;
let m$C = h$r = class extends y$t(p$1n) {
  constructor(t2) {
    super(t2), this.attributes = null, this.backgroundColor = new l$1D([0, 0, 0, 0]), this.dotBlendingEnabled = true, this.dotShape = "square", this.dotSize = 1, this.legendOptions = null, this.outline = new m$1q(), this.dotValue = null, this.referenceScale = null, this.seed = 1, this.type = "dot-density";
  }
  calculateDotValue(t2) {
    if (this.referenceScale == null)
      return this.dotValue;
    const e2 = t2 / this.referenceScale * this.dotValue;
    return e2 < 1 ? 1 : e2;
  }
  getSymbol() {
    return new S$t({ outline: this.outline });
  }
  async getSymbolAsync() {
    return this.getSymbol();
  }
  getSymbols() {
    return [this.getSymbol()];
  }
  getAttributeHash() {
    var _a2, _b2;
    return (_b2 = (_a2 = this.attributes) == null ? void 0 : _a2.reduce((t2, e2) => t2 + e2.getAttributeHash(), "")) != null ? _b2 : "";
  }
  getMeshHash() {
    return JSON.stringify(this.outline);
  }
  clone() {
    return new h$r({ attributes: y$1r(this.attributes), backgroundColor: y$1r(this.backgroundColor), dotBlendingEnabled: y$1r(this.dotBlendingEnabled), dotShape: y$1r(this.dotShape), dotSize: y$1r(this.dotSize), dotValue: y$1r(this.dotValue), legendOptions: y$1r(this.legendOptions), outline: y$1r(this.outline), referenceScale: y$1r(this.referenceScale), visualVariables: y$1r(this.visualVariables), authoringInfo: this.authoringInfo && this.authoringInfo.clone() });
  }
  getControllerHash() {
    var _a2;
    const t2 = (_a2 = this.attributes) == null ? void 0 : _a2.map((t3) => t3.field || t3.valueExpression || "");
    return `${t2}-${this.outline && JSON.stringify(this.outline.toJSON()) || ""}`;
  }
  async collectRequiredFields(t2, e2) {
    var _a2;
    await this.collectVVRequiredFields(t2, e2);
    for (const o2 of (_a2 = this.attributes) != null ? _a2 : [])
      o2.valueExpression && await S$C(t2, e2, o2.valueExpression), o2.field && t2.add(o2.field);
  }
};
e$1W([y$1o({ type: [a$12], json: { write: true } })], m$C.prototype, "attributes", void 0), e$1W([y$1o({ type: l$1D, json: { write: true } })], m$C.prototype, "backgroundColor", void 0), e$1W([y$1o({ type: Boolean, json: { write: true } })], m$C.prototype, "dotBlendingEnabled", void 0), e$1W([y$1o({ type: String, json: { write: false } })], m$C.prototype, "dotShape", void 0), e$1W([y$1o({ type: Number, json: { write: true } })], m$C.prototype, "dotSize", void 0), e$1W([y$1o({ type: c$12, json: { write: true } })], m$C.prototype, "legendOptions", void 0), e$1W([y$1o({ type: m$1q, json: { default: null, write: true } })], m$C.prototype, "outline", void 0), e$1W([y$1o({ type: Number, json: { write: true } })], m$C.prototype, "dotValue", void 0), e$1W([y$1o({ type: Number, json: { write: true } })], m$C.prototype, "referenceScale", void 0), e$1W([y$1o({ type: Number, json: { write: true } })], m$C.prototype, "seed", void 0), e$1W([r$1a({ dotDensity: "dot-density" })], m$C.prototype, "type", void 0), m$C = h$r = e$1W([n$2f("esri.renderers.DotDensityRenderer")], m$C);
const y$q = m$C;
let p$1b = class extends i$28(l$1_) {
  constructor() {
    super(...arguments), this.minLabel = null, this.maxLabel = null, this.title = null;
  }
};
e$1W([y$1o({ type: String, json: { write: true } })], p$1b.prototype, "minLabel", void 0), e$1W([y$1o({ type: String, json: { write: true } })], p$1b.prototype, "maxLabel", void 0), e$1W([y$1o({ type: String, json: { write: true } })], p$1b.prototype, "title", void 0), p$1b = e$1W([n$2f("esri.renderers.support.HeatmapLegendOptions")], p$1b);
function n$X() {
  return [0, 0, 0, 0];
}
function t$G(n2) {
  return [n2[0], n2[1], n2[2], n2[3]];
}
function r$y(n2, t2, r2, e2) {
  return [n2, t2, r2, e2];
}
function e$A(t2) {
  const r2 = n$X(), e2 = Math.min(4, t2.length);
  for (let n2 = 0; n2 < e2; ++n2)
    r2[n2] = t2[n2];
  return r2;
}
function u$H(n2, t2) {
  return new Float64Array(n2, t2, 4);
}
function a$11() {
  return n$X();
}
function o$G() {
  return r$y(1, 1, 1, 1);
}
function s$N() {
  return r$y(1, 0, 0, 0);
}
function i$10() {
  return r$y(0, 1, 0, 0);
}
function c$11() {
  return r$y(0, 0, 1, 0);
}
function f$D() {
  return r$y(0, 0, 0, 1);
}
const l$R = a$11(), _$f = o$G(), N$3 = s$N(), O$7 = i$10(), T$6 = c$11(), U$6 = f$D();
Object.freeze(Object.defineProperty({ __proto__: null, create: n$X, clone: t$G, fromValues: r$y, fromArray: e$A, createView: u$H, zeros: a$11, ones: o$G, unitX: s$N, unitY: i$10, unitZ: c$11, unitW: f$D, ZEROS: l$R, ONES: _$f, UNIT_X: N$3, UNIT_Y: O$7, UNIT_Z: T$6, UNIT_W: U$6 }, Symbol.toStringTag, { value: "Module" }));
const a$10 = 2.4;
function i$$(t2) {
  return e$1h(t2 * a$10);
}
function c$10(t2) {
  return u$1r(t2) / a$10;
}
function f$C(r2, n2, e2, a2) {
  let { color: i2, ratio: c2 } = n2, { color: f2, ratio: u2 } = e2;
  if (u2 === c2) {
    const t2 = 1e-6;
    u2 === 1 ? c2 -= t2 : u2 += t2;
  }
  const s2 = a$21((a2 - c2) / (u2 - c2), 0, 1);
  j$C(r2, i2.toArray(), f2.toArray(), s2);
}
function u$G(t2) {
  const r2 = 512, n2 = new Uint8ClampedArray(4 * r2);
  if (t2 = t2.filter(({ ratio: t3 }) => t3 >= 0 && t3 <= 1).sort((t3, r3) => t3.ratio - r3.ratio).map(({ color: t3, ratio: r3 }) => ({ color: t3, ratio: Math.max(r3, 1e-3) })), t2.length < 1)
    return n2;
  let o2 = t2[0], a2 = t2[0], i2 = 1;
  const c2 = n$X();
  for (let e2 = 0; e2 < r2; e2++) {
    const u2 = (e2 + 0.5) / r2;
    for (; u2 > a2.ratio && i2 < t2.length; )
      o2 = a2, a2 = t2[i2++];
    f$C(c2, o2, a2, u2), n2.set(c2, 4 * e2);
  }
  return n2;
}
function s$M(t2, r2, o2, e2) {
  const { radius: a2, fieldOffset: i2, field: c2 } = r2, f2 = Math.round(u$1r(a2)), u2 = new Float64Array(o2 * e2);
  let s2, l2 = Number.NEGATIVE_INFINITY;
  const h2 = d$x(c2, i2), y2 = new Set();
  for (const n2 of t2) {
    const t3 = n2.getCursor();
    for (; t3.next(); ) {
      const r3 = t3.getObjectId();
      if (y2.has(r3))
        continue;
      y2.add(r3);
      const n3 = t3.readLegacyPointGeometry(), a3 = 128;
      if (n3.x < -a3 || n3.x >= o2 + a3 || n3.y < -a3 || n3.y > e2 + a3)
        continue;
      const i3 = +h2(t3), c3 = Math.max(0, Math.round(n3.x) - f2), d2 = Math.max(0, Math.round(n3.y) - f2), g2 = Math.min(e2, Math.round(n3.y) + f2), A2 = Math.min(o2, Math.round(n3.x) + f2);
      for (let t4 = d2; t4 < g2; t4++)
        for (let r4 = c3; r4 < A2; r4++) {
          const e3 = t4 * o2 + r4, a4 = m$B(n3.x - r4, n3.y - t4, f2);
          s2 = u2[e3] += a4 * i3, s2 > l2 && (l2 = s2);
        }
    }
  }
  return { matrix: u2.buffer, max: l2 };
}
function l$Q(t2, r2, n2, o2, e2, a2) {
  t2.canvas.width = t2.canvas.height = r2, t2.clearRect(0, 0, r2, r2);
  const i2 = t2.getImageData(0, 0, r2, r2);
  n2 && o2 && i2.data.set(new Uint8ClampedArray(h$q(r2, n2, o2, e2, a2))), t2.putImageData(i2, 0, 0);
}
function h$q(r2, n2, o2, e2, a2) {
  const i2 = new Uint32Array(r2 * r2), c2 = "buffer" in n2 ? n2 : new Float64Array(n2), f2 = "buffer" in o2 ? new Uint32Array(o2.buffer) : new Uint32Array(new Uint8Array(o2).buffer), u2 = f2.length / (a2 - e2);
  for (let s2 = 0; s2 < c2.length; s2++) {
    const r3 = c2[s2], n3 = Math.floor((r3 - e2) * u2);
    i2[s2] = f2[a$21(n3, 0, f2.length - 1)];
  }
  return i2.buffer;
}
function m$B(t2, r2, n2) {
  const o2 = Math.sqrt(t2 ** 2 + r2 ** 2) / n2;
  return o2 > 1 ? 0 : 3 / (Math.PI * n2 ** 2) * (1 - o2 ** 2) ** 2;
}
function y$p(t2, r2) {
  return typeof t2 == "function" ? t2 : t2 ? typeof r2 == "string" ? (r3) => -1 * +r3[t2] : (n2) => +n2[t2] + r2 : () => 1;
}
function d$x(t2, r2) {
  return t2 != null ? typeof r2 == "string" ? (r3) => -1 * +r3.readAttribute(t2) : (n2) => +n2.readAttribute(t2) + r2 : (t3) => 1;
}
var j$d;
const D$6 = "esri.renderers.HeatmapRenderer", I$b = s$22.getLogger(D$6);
function S$d(e2) {
  if (e2 != null) {
    const { maxDensity: t2, minDensity: i2, radius: s2 } = e2;
    if (t2 != null || i2 != null || s2 != null) {
      const _a2 = e2, { blurRadius: t3, maxPixelIntensity: i3, minPixelIntensity: s3 } = _a2, r2 = __objRest(_a2, ["blurRadius", "maxPixelIntensity", "minPixelIntensity"]);
      return r2;
    }
  }
  return e2;
}
let v$j = j$d = class extends p$1n {
  constructor(e2) {
    super(e2), this.authoringInfo = null, this.colorStops = [new a$1n({ ratio: 0, color: new l$1D("rgba(255, 140, 0, 0)") }), new a$1n({ ratio: 0.75, color: new l$1D("rgba(255, 140, 0, 1)") }), new a$1n({ ratio: 0.9, color: new l$1D("rgba(255, 0,   0, 1)") })], this.field = null, this.fieldOffset = 0, this.legendOptions = null, this.maxDensity = 0.04, this.minDensity = 0, this.radius = 18, this.referenceScale = 0, this.type = "heatmap", this.valueExpression = null, this.valueExpressionTitle = null, this._warnedProps = { blurRadius: false, maxPixelIntensity: false, minPixelIntensity: false };
  }
  normalizeCtorArgs(e2) {
    return S$d(e2);
  }
  get blurRadius() {
    return c$10(this.radius);
  }
  set blurRadius(e2) {
    const t2 = this.maxPixelIntensity, i2 = this.minPixelIntensity;
    this._set("radius", i$$(e2)), this._warnAboutDeprecatedGaussianBlurProp("blurRadius", "radius"), this._set("maxDensity", t2 * this._pixelIntensityToDensity), this._set("minDensity", i2 * this._pixelIntensityToDensity);
  }
  get maxPixelIntensity() {
    return this.maxDensity / this._pixelIntensityToDensity;
  }
  set maxPixelIntensity(e2) {
    this._set("maxDensity", e2 * this._pixelIntensityToDensity), this._warnAboutDeprecatedGaussianBlurProp("maxPixelIntensity", "maxDensity");
  }
  get minPixelIntensity() {
    return this.minDensity / this._pixelIntensityToDensity;
  }
  set minPixelIntensity(e2) {
    this._set("minDensity", e2 * this._pixelIntensityToDensity), this._warnAboutDeprecatedGaussianBlurProp("minPixelIntensity", "minDensity");
  }
  get _pixelIntensityToDensity() {
    return 24 / (a$10 ** 2 * this.blurRadius ** 4);
  }
  _warnAboutDeprecatedGaussianBlurProp(e2, t2) {
    if (this._warnedProps[e2])
      return;
    e$1Q(this).getDefaultOrigin() === "user" && (this._warnedProps[e2] = true, v$R(() => {
      t$1E(I$b, e2, { replacement: `${String(t2)} (suggested value: ${this._get(t2)})`, version: "4.24" });
    }));
  }
  read(e2, t2) {
    e2 = S$d(e2), super.read(e2, t2);
  }
  getSymbol() {
    return new y$Z();
  }
  async getSymbolAsync() {
    return this.getSymbol();
  }
  getSymbols() {
    return [this.getSymbol()];
  }
  async collectRequiredFields(e2, t2) {
    const i2 = this.field, s2 = this.valueExpression;
    i2 && typeof i2 == "string" && await w$H(e2, t2, i2), s2 && typeof s2 == "string" && await S$C(e2, t2, s2);
  }
  getAttributeHash() {
    return null;
  }
  getMeshHash() {
    return `${JSON.stringify(this.colorStops)}.${this.blurRadius}.${this.field}`;
  }
  clone() {
    return new j$d({ authoringInfo: this.authoringInfo && this.authoringInfo.clone(), colorStops: y$1r(this.colorStops), field: this.field, legendOptions: y$1r(this.legendOptions), maxDensity: this.maxDensity, minDensity: this.minDensity, radius: this.radius, referenceScale: this.referenceScale, valueExpression: this.valueExpression, valueExpressionTitle: this.valueExpressionTitle });
  }
};
e$1W([y$1o({ type: j$g, json: { write: true, origins: { "web-scene": { write: false, read: false } } } })], v$j.prototype, "authoringInfo", void 0), e$1W([y$1o({ type: Number, json: { origins: { "portal-item": { write: true }, "web-map": { write: true } } } })], v$j.prototype, "blurRadius", null), e$1W([y$1o({ type: [a$1n], json: { write: true } })], v$j.prototype, "colorStops", void 0), e$1W([y$1o({ type: String, json: { write: true } })], v$j.prototype, "field", void 0), e$1W([y$1o({ type: Number, json: { write: { overridePolicy: (e2, t2, i2) => ({ enabled: i2 == null }) }, origins: { "web-scene": { write: false } } } })], v$j.prototype, "fieldOffset", void 0), e$1W([y$1o({ type: p$1b, json: { write: true } })], v$j.prototype, "legendOptions", void 0), e$1W([y$1o({ type: Number, json: { write: true } })], v$j.prototype, "maxDensity", void 0), e$1W([y$1o({ type: Number, json: { origins: { "portal-item": { write: true }, "web-map": { write: true } } } })], v$j.prototype, "maxPixelIntensity", null), e$1W([y$1o({ type: Number, json: { write: true } })], v$j.prototype, "minDensity", void 0), e$1W([y$1o({ type: Number, json: { origins: { "portal-item": { write: true }, "web-map": { write: true } } } })], v$j.prototype, "minPixelIntensity", null), e$1W([y$1o({ type: Number, cast: o$1j, json: { write: true } })], v$j.prototype, "radius", void 0), e$1W([y$1o({ type: Number, range: { min: 0 }, json: { default: 0, write: true } })], v$j.prototype, "referenceScale", void 0), e$1W([r$1a({ heatmap: "heatmap" })], v$j.prototype, "type", void 0), e$1W([y$1o({ type: String, json: { write: true, origins: { "web-document": { write: false }, "portal-item": { write: false } } } })], v$j.prototype, "valueExpression", void 0), e$1W([y$1o({ type: String })], v$j.prototype, "valueExpressionTitle", void 0), e$1W([y$1o({ readOnly: true })], v$j.prototype, "_pixelIntensityToDensity", null), v$j = j$d = e$1W([n$2f(D$6)], v$j);
const P$a = v$j;
let i$_ = class extends i$28(l$1_) {
  constructor() {
    super(...arguments), this.color = new l$1D([0, 0, 0, 0]), this.label = null, this.threshold = 0;
  }
};
e$1W([y$1o({ type: l$1D, json: { write: true } })], i$_.prototype, "color", void 0), e$1W([y$1o({ type: String, json: { write: true } })], i$_.prototype, "label", void 0), e$1W([y$1o({ type: Number, range: { min: 0, max: 1 }, json: { write: true } })], i$_.prototype, "threshold", void 0), i$_ = e$1W([n$2f("esri.renderers.support.OthersCategory")], i$_);
let p$1a = class extends i$28(l$1_) {
  constructor() {
    super(...arguments), this.title = null;
  }
};
e$1W([y$1o({ type: String, json: { write: true } })], p$1a.prototype, "title", void 0), p$1a = e$1W([n$2f("esri.renderers.support.PieChartLegendOptions")], p$1a);
let f$B = class extends y$t(i$28(p$1n)) {
  constructor(t2) {
    super(t2), this.attributes = null, this.backgroundFillSymbol = null, this.defaultColor = new l$1D([0, 0, 0, 0]), this.defaultLabel = null, this.holePercentage = 0, this.othersCategory = new i$_(), this.legendOptions = null, this.outline = null, this.size = 12, this.type = "pie-chart";
  }
  getSymbol() {
    var _a2;
    return new y$Z({ size: this.size ? this.size / 2 + (((_a2 = this.outline) == null ? void 0 : _a2.width) || 0) : 0 });
  }
  async getSymbolAsync() {
    return this.getSymbol();
  }
  getSymbols() {
    return [this.getSymbol(), this.backgroundFillSymbol].filter(r$1t);
  }
  getAttributeHash() {
    return this.visualVariables && this.visualVariables.reduce((t2, e2) => t2 + e2.getAttributeHash(), "");
  }
  getMeshHash() {
    return this.getSymbols().reduce((t2, e2) => t2 + JSON.stringify(e2), "");
  }
  async collectRequiredFields(t2, e2) {
    await this.collectVVRequiredFields(t2, e2);
    for (const o2 of this.attributes)
      o2.valueExpression && await S$C(t2, e2, o2.valueExpression), o2.field && t2.add(o2.field);
  }
};
e$1W([y$1o({ type: [a$12], json: { write: true } })], f$B.prototype, "attributes", void 0), e$1W([y$1o({ type: S$t, json: { default: null, write: true } })], f$B.prototype, "backgroundFillSymbol", void 0), e$1W([y$1o({ type: l$1D, json: { write: true } })], f$B.prototype, "defaultColor", void 0), e$1W([y$1o({ type: String, json: { write: true } })], f$B.prototype, "defaultLabel", void 0), e$1W([y$1o({ type: Number, range: { min: 0, max: 1 }, json: { write: true } })], f$B.prototype, "holePercentage", void 0), e$1W([y$1o({ type: i$_, json: { write: true } })], f$B.prototype, "othersCategory", void 0), e$1W([y$1o({ type: p$1a, json: { write: true } })], f$B.prototype, "legendOptions", void 0), e$1W([y$1o({ type: m$1q, json: { default: null, write: true } })], f$B.prototype, "outline", void 0), e$1W([y$1o({ type: Number, cast: o$1j, json: { write: true } })], f$B.prototype, "size", void 0), e$1W([r$1a({ pieChart: "pie-chart" })], f$B.prototype, "type", void 0), f$B = e$1W([n$2f("esri.renderers.PieChartRenderer")], f$B);
const j$c = f$B;
var c$$;
let n$W = c$$ = class extends y$t(p$1n) {
  constructor(e2) {
    super(e2), this.description = null, this.label = null, this.symbol = null, this.type = "simple";
  }
  async collectRequiredFields(e2, s2) {
    await Promise.all([this.collectSymbolFields(e2, s2), this.collectVVRequiredFields(e2, s2)]);
  }
  async collectSymbolFields(e2, s2) {
    await Promise.all(this.getSymbols().map((r2) => r2.collectRequiredFields(e2, s2)));
  }
  getSymbol(e2, s2) {
    return this.symbol;
  }
  async getSymbolAsync(e2, s2) {
    return this.symbol;
  }
  getSymbols() {
    return this.symbol ? [this.symbol] : [];
  }
  getAttributeHash() {
    return this.visualVariables && this.visualVariables.reduce((e2, s2) => e2 + s2.getAttributeHash(), "");
  }
  getMeshHash() {
    return this.getSymbols().reduce((e2, s2) => e2 + JSON.stringify(s2), "");
  }
  get arcadeRequired() {
    return this.arcadeRequiredForVisualVariables;
  }
  clone() {
    return new c$$({ description: this.description, label: this.label, symbol: this.symbol && this.symbol.clone(), visualVariables: y$1r(this.visualVariables), authoringInfo: this.authoringInfo && this.authoringInfo.clone() });
  }
};
e$1W([y$1o({ type: String, json: { write: true } })], n$W.prototype, "description", void 0), e$1W([y$1o({ type: String, json: { write: true } })], n$W.prototype, "label", void 0), e$1W([y$1o(l$T)], n$W.prototype, "symbol", void 0), e$1W([r$1a({ simple: "simple" })], n$W.prototype, "type", void 0), n$W = c$$ = e$1W([n$2f("esri.renderers.SimpleRenderer")], n$W);
const p$19 = n$W;
const f$A = ["esri.Color", "esri.portal.Portal", "esri.symbols.support.Symbol3DAnchorPosition2D", "esri.symbols.support.Symbol3DAnchorPosition3D"];
function i$Z(t2) {
  return t2 instanceof m$1L;
}
function c$_(e2) {
  return e2 instanceof j$F ? Object.keys(e2.items) : i$Z(e2) ? e$1Q(e2).keys() : e2 ? Object.keys(e2) : [];
}
function l$P(e2, n2) {
  return e2 instanceof j$F ? e2.items[n2] : e2[n2];
}
function u$F(e2, t2) {
  return !(!Array.isArray(e2) || !Array.isArray(t2)) && e2.length !== t2.length;
}
function s$L(e2) {
  return e2 ? e2.declaredClass : null;
}
function p$18(e2, t2) {
  const n2 = e2.diff;
  if (n2 && typeof n2 == "function")
    return n2(e2, t2);
  const r2 = c$_(e2), a2 = c$_(t2);
  if (r2.length === 0 && a2.length === 0)
    return;
  if (!r2.length || !a2.length || u$F(e2, t2))
    return { type: "complete", oldValue: e2, newValue: t2 };
  const y2 = a2.filter((e3) => !r2.includes(e3)), m2 = r2.filter((e3) => !a2.includes(e3)), d2 = r2.filter((n3) => a2.includes(n3) && l$P(e2, n3) !== l$P(t2, n3)).concat(y2, m2).sort(), b2 = s$L(e2);
  if (b2 && f$A.includes(b2) && d2.length)
    return { type: "complete", oldValue: e2, newValue: t2 };
  let h2;
  const g2 = i$Z(e2) && i$Z(t2);
  for (const f2 of d2) {
    const r3 = l$P(e2, f2), i2 = l$P(t2, f2);
    let c2;
    if ((g2 || typeof r3 != "function" && typeof i2 != "function") && (r3 !== i2 && (r3 != null || i2 != null))) {
      if (n2 && n2[f2] && typeof n2[f2] == "function")
        c2 = n2[f2](r3, i2);
      else if (r3 instanceof Date && i2 instanceof Date) {
        if (r3.getTime() === i2.getTime())
          continue;
        c2 = { type: "complete", oldValue: r3, newValue: i2 };
      } else
        c2 = typeof r3 == "object" && typeof i2 == "object" && s$L(r3) === s$L(i2) ? p$18(r3, i2) : { type: "complete", oldValue: r3, newValue: i2 };
      r$1t(c2) && (r$1t(h2) ? h2.diff[f2] = c2 : h2 = { type: "partial", diff: { [f2]: c2 } });
    }
  }
  return h2;
}
function a$$(e2, t2) {
  if (t$1W(e2))
    return false;
  const o2 = t2.split(".");
  let r2 = e2;
  for (const n2 of o2) {
    if (r2.type === "complete")
      return true;
    if (r2.type !== "partial")
      return false;
    {
      const e3 = r2.diff[n2];
      if (!e3)
        return false;
      r2 = e3;
    }
  }
  return true;
}
function y$o(e2, t2) {
  for (const n2 of t2)
    if (a$$(e2, n2))
      return true;
  return false;
}
function m$A(e2, t2) {
  if (!(typeof e2 == "function" || typeof t2 == "function" || t$1W(e2) && t$1W(t2)))
    return t$1W(e2) || t$1W(t2) || typeof e2 == "object" && typeof t2 == "object" && s$L(e2) !== s$L(t2) ? { type: "complete", oldValue: e2, newValue: t2 } : p$18(e2, t2);
}
let u$E = class extends i$28(l$1_) {
  constructor(o2) {
    super(o2), this.value = null, this.value2 = null, this.value3 = null;
  }
};
e$1W([y$1o(m$D)], u$E.prototype, "value", void 0), e$1W([y$1o(m$D)], u$E.prototype, "value2", void 0), e$1W([y$1o(m$D)], u$E.prototype, "value3", void 0), u$E = e$1W([n$2f("esri.renderers.support.UniqueValue")], u$E);
const c$Z = u$E;
let n$V = class extends i$28(l$1_) {
  constructor(r2) {
    super(r2), this.description = null, this.label = null, this.symbol = null, this.values = null;
  }
  castValues(r2) {
    if (r2 == null)
      return null;
    const o2 = typeof (r2 = Array.isArray(r2) ? r2 : [r2])[0];
    return o2 === "string" || o2 === "number" ? r2.map((r3) => new c$Z({ value: r3 })) : o2 === "object" ? r2[0] instanceof c$Z ? r2 : r2.map((r3) => new c$Z(r3)) : null;
  }
};
e$1W([y$1o({ type: String, json: { write: true } })], n$V.prototype, "description", void 0), e$1W([y$1o({ type: String, json: { write: true } })], n$V.prototype, "label", void 0), e$1W([y$1o(l$T)], n$V.prototype, "symbol", void 0), e$1W([y$1o({ type: [c$Z], json: { type: [[String]], read: { reader: (r2) => r2 ? r2.map((r3) => new c$Z({ value: r3[0], value2: r3[1], value3: r3[2] })) : null }, write: { writer: (r2, o2) => {
  const e2 = [];
  for (const s2 of r2) {
    const r3 = [s2.value, s2.value2, s2.value3].filter(r$1t).map((r4) => r4.toString());
    e2.push(r3);
  }
  o2.values = e2;
} } } })], n$V.prototype, "values", void 0), e$1W([s$1N("values")], n$V.prototype, "castValues", null), n$V = e$1W([n$2f("esri.renderers.support.UniqueValueClass")], n$V);
const u$D = n$V;
let c$Y = class extends i$28(l$1_) {
  constructor(r2) {
    super(r2), this.heading = null, this.classes = null;
  }
};
e$1W([y$1o({ type: String, json: { write: true } })], c$Y.prototype, "heading", void 0), e$1W([y$1o({ type: [u$D], json: { write: true } })], c$Y.prototype, "classes", void 0), c$Y = e$1W([n$2f("esri.renderers.support.UniqueValueGroup")], c$Y);
const i$Y = c$Y;
var l$O;
let p$17 = l$O = class extends l$1_ {
  constructor(o2) {
    super(o2), this.description = null, this.label = null, this.symbol = null, this.value = null;
  }
  clone() {
    return new l$O({ value: this.value, description: this.description, label: this.label, symbol: this.symbol ? this.symbol.clone() : null });
  }
  getMeshHash() {
    const o2 = JSON.stringify(this.symbol && this.symbol.toJSON());
    return `${this.value}.${o2}`;
  }
};
e$1W([y$1o({ type: String, json: { write: true } })], p$17.prototype, "description", void 0), e$1W([y$1o({ type: String, json: { write: true } })], p$17.prototype, "label", void 0), e$1W([y$1o(l$T)], p$17.prototype, "symbol", void 0), e$1W([y$1o(m$D)], p$17.prototype, "value", void 0), p$17 = l$O = e$1W([n$2f("esri.renderers.support.UniqueValueInfo")], p$17);
const n$U = p$17;
const e$z = () => !!has("enable-feature:force-wosr"), t$F = () => !!has("enable-feature:SceneLayer-editing");
const u$C = {};
async function f$z(e2, r2) {
  try {
    return { data: (await b$i(e2, r2)).data, baseUrl: Ot(e2), styleUrl: e2 };
  } catch (t2) {
    return w$O(t2), null;
  }
}
function i$X(e2, r2, o2) {
  const s2 = r$1t(r2.portal) ? r2.portal : j$y.getDefault();
  let n2;
  const a2 = `${s2.url} - ${s2.user && s2.user.username} - ${e2}`;
  return u$C[a2] || (u$C[a2] = y$n(e2, s2, o2).then((e3) => (n2 = e3, e3.fetchData())).then((r3) => {
    var _a2;
    return { data: r3, baseUrl: (_a2 = n2.itemUrl) != null ? _a2 : "", styleName: e2 };
  })), u$C[a2];
}
function y$n(e2, t2, o2) {
  return t2.load(o2).then(() => {
    const r2 = new d$16({ disableExtraQuery: true, query: `owner:${j$b} AND type:${h$p} AND typekeywords:"${e2}"` });
    return t2.queryItems(r2, o2);
  }).then(({ results: t3 }) => {
    var _a2;
    let s2 = null;
    const n2 = e2.toLowerCase();
    if (t3 && Array.isArray(t3))
      for (const e3 of t3) {
        const r2 = (_a2 = e3.typeKeywords) == null ? void 0 : _a2.some((e4) => e4.toLowerCase() === n2);
        if (r2 && e3.type === h$p && e3.owner === j$b) {
          s2 = e3;
          break;
        }
      }
    if (!s2)
      throw new s$1Z("symbolstyleutils:style-not-found", `The style '${e2}' could not be found`, { styleName: e2 });
    return s2.load(o2);
  });
}
function c$X(e2, o2, s2) {
  return e2 && r$1t(e2.styleUrl) ? f$z(e2.styleUrl, s2) : e2 && r$1t(e2.styleName) ? i$X(e2.styleName, o2, s2) : Promise.reject(new s$1Z("symbolstyleutils:style-url-and-name-missing", "Either styleUrl or styleName is required to resolve a style"));
}
function p$16(e2) {
  return e2 === null || e2.type === "CIMSymbolReference" ? e2 : { type: "CIMSymbolReference", symbol: e2 };
}
function d$w(e2, r2) {
  if (r2 === "cimRef")
    return e2.cimRef;
  if (e2.formatInfos && !e$z()) {
    for (const t2 of e2.formatInfos)
      if (t2.type === "gltf")
        return t2.href;
  }
  return e2.webRef;
}
function b$i(r2, t2) {
  const o2 = __spreadValues({ responseType: "json", query: { f: "json" } }, t2);
  return U$k(F$g(r2), o2);
}
const j$b = "esri_en", h$p = "Style", w$g = "https://cdn.arcgis.com/sharing/rest/content/items/220936cc6ed342c9937abd8f180e7d1e/resources/styles/cim/{SymbolName}.json?f=json";
var R$7;
const P$9 = "esri.renderers.UniqueValueRenderer", $$2 = s$22.getLogger(P$9), z$9 = "uvInfos-watcher", k$5 = "uvGroups-watcher", A$5 = ",", H$4 = b$U(n$U);
function L$b(e2) {
  const { field1: t2, field2: s2, field3: i2, fieldDelimiter: o2, uniqueValueInfos: l2, valueExpression: r2 } = e2, u2 = !(!t2 || !s2);
  return [{ classes: (l2 != null ? l2 : []).map((e3) => {
    var _a2;
    const { symbol: l3, label: n2, value: a2, description: p2 } = e3, [f2, d2, c2] = u2 ? ((_a2 = a2 == null ? void 0 : a2.toString()) == null ? void 0 : _a2.split(o2 || "")) || [] : [a2], h2 = [];
    return (t2 || r2) && h2.push(f2), s2 && h2.push(d2), i2 && h2.push(c2), { symbol: l3, label: n2, values: [h2], description: p2 };
  }) }];
}
let T$5 = R$7 = class extends y$t(p$1n) {
  constructor(e2) {
    super(e2), this._valueInfoMap = {}, this._isDefaultSymbolDerived = false, this._isInfosSource = null, this.type = "unique-value", this.backgroundFillSymbol = null, this.valueExpressionTitle = null, this.legendOptions = null, this.defaultLabel = null, this.portal = null, this.styleOrigin = null, this.diff = { uniqueValueInfos(e3, t2) {
      if (!e3 && !t2)
        return;
      if (!e3 || !t2)
        return { type: "complete", oldValue: e3, newValue: t2 };
      let s2 = false;
      const i2 = { type: "collection", added: [], removed: [], changed: [], unchanged: [] };
      for (let o2 = 0; o2 < t2.length; o2++) {
        const l2 = e3.find((e4) => e4.value === t2[o2].value);
        l2 ? m$A(l2, t2[o2]) ? (i2.changed.push({ type: "complete", oldValue: l2, newValue: t2[o2] }), s2 = true) : i2.unchanged.push({ oldValue: l2, newValue: t2[o2] }) : (i2.added.push(t2[o2]), s2 = true);
      }
      for (let o2 = 0; o2 < e3.length; o2++) {
        t2.find((t3) => t3.value === e3[o2].value) || (i2.removed.push(e3[o2]), s2 = true);
      }
      return s2 ? i2 : void 0;
    } }, this._set("uniqueValueInfos", []), this._set("uniqueValueGroups", []);
  }
  get _cache() {
    return { compiledFunc: null };
  }
  set field(e2) {
    this._set("field", e2), this._updateFieldDelimiter(), this._updateUniqueValues();
  }
  castField(e2) {
    return e2 == null || typeof e2 == "function" ? e2 : u$1W(e2);
  }
  writeField(e2, t2, i2, o2) {
    typeof e2 == "string" ? t2[i2] = e2 : o2 && o2.messages ? o2.messages.push(new s$1Z("property:unsupported", "UniqueValueRenderer.field set to a function cannot be written to JSON")) : $$2.error(".field: cannot write field to JSON since it's not a string value");
  }
  set field2(e2) {
    this._set("field2", e2), this._updateFieldDelimiter(), this._updateUniqueValues();
  }
  set field3(e2) {
    this._set("field3", e2), this._updateUniqueValues();
  }
  set valueExpression(e2) {
    this._set("valueExpression", e2), this._updateUniqueValues();
  }
  set defaultSymbol(e2) {
    this._isDefaultSymbolDerived = false, this._set("defaultSymbol", e2);
  }
  set fieldDelimiter(e2) {
    this._set("fieldDelimiter", e2), this._updateUniqueValues();
  }
  readPortal(e2, t2, s2) {
    return s2.portal || j$y.getDefault();
  }
  readStyleOrigin(e2, t2, s2) {
    if (t2.styleName)
      return Object.freeze({ styleName: t2.styleName });
    if (t2.styleUrl) {
      const e3 = c$1_(t2.styleUrl, s2);
      return Object.freeze({ styleUrl: e3 });
    }
  }
  writeStyleOrigin(e2, t2, s2, i2) {
    e2.styleName ? t2.styleName = e2.styleName : e2.styleUrl && (t2.styleUrl = m$1j(e2.styleUrl, i2));
  }
  set uniqueValueGroups(e2) {
    this.styleOrigin ? $$2.error("#uniqueValueGroups=", "Cannot modify unique value groups of a UniqueValueRenderer created from a web style") : (this._set("uniqueValueGroups", e2), this._updateInfosFromGroups(), this._isInfosSource = false, this._watchUniqueValueGroups());
  }
  set uniqueValueInfos(e2) {
    this.styleOrigin ? $$2.error("#uniqueValueInfos=", "Cannot modify unique value infos of a UniqueValueRenderer created from a web style") : (this._set("uniqueValueInfos", e2), this._updateValueInfoMap(), this._updateGroupsFromInfos(), this._isInfosSource = true, this._watchUniqueValueInfos());
  }
  addUniqueValueInfo(e2, s2) {
    var _a2;
    if (this.styleOrigin)
      return void $$2.error("#addUniqueValueInfo()", "Cannot modify unique value infos of a UniqueValueRenderer created from a web style");
    let i2;
    i2 = typeof e2 == "object" ? H$4(e2) : new n$U({ value: e2, symbol: g$K(s2) }), (_a2 = this.uniqueValueInfos) == null ? void 0 : _a2.push(i2), this._valueInfoMap[i2.value] = i2, this._updateGroupsFromInfos(), this._isInfosSource = true, this._watchUniqueValueInfos();
  }
  removeUniqueValueInfo(e2) {
    if (this.styleOrigin)
      return void $$2.error("#removeUniqueValueInfo()", "Cannot modify unique value infos of a UniqueValueRenderer created from a web style");
    const t2 = this.uniqueValueInfos;
    if (t2)
      for (let s2 = 0; s2 < t2.length; s2++) {
        if (t2[s2].value === e2 + "") {
          delete this._valueInfoMap[e2], t2.splice(s2, 1);
          break;
        }
      }
    this._updateGroupsFromInfos(), this._isInfosSource = true, this._watchUniqueValueInfos();
  }
  async getUniqueValueInfo(e2, t2) {
    let s2 = t2;
    return this.valueExpression && (t$1W(t2) || t$1W(t2.arcade)) && (s2 = __spreadProps(__spreadValues({}, s2), { arcade: await i$26() })), this._getUniqueValueInfo(e2, s2);
  }
  getSymbol(e2, t2) {
    if (this.valueExpression && (t$1W(t2) || t$1W(t2.arcade)))
      return void $$2.error("#getSymbol()", "Please use getSymbolAsync if valueExpression is used");
    const s2 = this._getUniqueValueInfo(e2, t2);
    return s2 && s2.symbol || this.defaultSymbol;
  }
  async getSymbolAsync(e2, t2) {
    let s2 = t2;
    if (this.valueExpression && (t$1W(s2) || t$1W(s2.arcade))) {
      const e3 = await i$26(), { arcadeUtils: t3 } = e3;
      t3.hasGeometryOperations(this.valueExpression) && await t3.enableGeometryOperations(), s2 = __spreadProps(__spreadValues({}, s2), { arcade: e3 });
    }
    const i2 = this._getUniqueValueInfo(e2, s2);
    return i2 && i2.symbol || this.defaultSymbol;
  }
  getSymbols() {
    var _a2;
    const e2 = [];
    for (const t2 of (_a2 = this.uniqueValueInfos) != null ? _a2 : [])
      t2.symbol && e2.push(t2.symbol);
    return this.defaultSymbol && e2.push(this.defaultSymbol), e2;
  }
  getAttributeHash() {
    return this.visualVariables && this.visualVariables.reduce((e2, t2) => e2 + t2.getAttributeHash(), "");
  }
  getMeshHash() {
    var _a2;
    const e2 = JSON.stringify(this.backgroundFillSymbol), t2 = JSON.stringify(this.defaultSymbol), s2 = (_a2 = this.uniqueValueInfos) == null ? void 0 : _a2.reduce((e3, t3) => e3 + t3.getMeshHash(), "");
    return `${e2}.${t2}.${s2}.${`${this.field}.${this.field2}.${this.field3}.${this.fieldDelimiter}`}.${this.valueExpression}`;
  }
  clone() {
    const e2 = new R$7({ field: this.field, field2: this.field2, field3: this.field3, defaultLabel: this.defaultLabel, defaultSymbol: y$1r(this.defaultSymbol), valueExpression: this.valueExpression, valueExpressionTitle: this.valueExpressionTitle, fieldDelimiter: this.fieldDelimiter, visualVariables: y$1r(this.visualVariables), legendOptions: y$1r(this.legendOptions), authoringInfo: this.authoringInfo && this.authoringInfo.clone(), backgroundFillSymbol: y$1r(this.backgroundFillSymbol) });
    this._isDefaultSymbolDerived && (e2._isDefaultSymbolDerived = true), e2._set("portal", this.portal);
    const t2 = y$1r(this.uniqueValueInfos), s2 = y$1r(this.uniqueValueGroups);
    return this.styleOrigin && (e2._set("styleOrigin", Object.freeze(y$1r(this.styleOrigin))), Object.freeze(t2), Object.freeze(s2)), e2._set("uniqueValueInfos", t2), e2._updateValueInfoMap(), e2._set("uniqueValueGroups", s2), e2._isInfosSource = this._isInfosSource, e2._watchUniqueValueInfosAndGroups(), e2;
  }
  get arcadeRequired() {
    return this.arcadeRequiredForVisualVariables || !!this.valueExpression;
  }
  async collectRequiredFields(e2, t2) {
    const s2 = [this.collectVVRequiredFields(e2, t2), this.collectSymbolFields(e2, t2)];
    await Promise.all(s2);
  }
  async collectSymbolFields(e2, t2) {
    const s2 = [...this.getSymbols().map((s3) => s3.collectRequiredFields(e2, t2)), S$C(e2, t2, this.valueExpression)];
    w$H(e2, t2, this.field), w$H(e2, t2, this.field2), w$H(e2, t2, this.field3), await Promise.all(s2);
  }
  populateFromStyle() {
    return c$X(this.styleOrigin, { portal: this.portal }).then((e2) => {
      var _a2;
      const t2 = [];
      return this._valueInfoMap = {}, e2 && e2.data && Array.isArray(e2.data.items) && e2.data.items.forEach((s2) => {
        const i2 = new f$11({ styleUrl: e2.styleUrl, styleName: e2.styleName, portal: this.portal, name: s2.name });
        this.defaultSymbol || s2.name !== e2.data.defaultItem || (this.defaultSymbol = i2, this._isDefaultSymbolDerived = true);
        const o2 = new n$U({ value: s2.name, symbol: i2 });
        t2.push(o2), this._valueInfoMap[s2.name] = o2;
      }), this._set("uniqueValueInfos", Object.freeze(t2)), this._updateGroupsFromInfos(true), this._isInfosSource = null, this._watchUniqueValueInfos(), !this.defaultSymbol && ((_a2 = this.uniqueValueInfos) == null ? void 0 : _a2.length) && (this.defaultSymbol = this.uniqueValueInfos[0].symbol, this._isDefaultSymbolDerived = true), this;
    });
  }
  _updateFieldDelimiter() {
    this.field && this.field2 && !this.fieldDelimiter && this._set("fieldDelimiter", A$5);
  }
  _updateUniqueValues() {
    this._isInfosSource != null && (this._isInfosSource ? this._updateGroupsFromInfos() : this._updateInfosFromGroups());
  }
  _updateValueInfoMap() {
    this._valueInfoMap = {};
    const { uniqueValueInfos: e2 } = this;
    if (e2)
      for (const t2 of e2)
        this._valueInfoMap[t2.value + ""] = t2;
  }
  _watchUniqueValueInfosAndGroups() {
    this._watchUniqueValueInfos(), this._watchUniqueValueGroups();
  }
  _watchUniqueValueInfos() {
    this.removeHandles(z$9);
    const { uniqueValueInfos: e2 } = this;
    if (e2) {
      const t2 = [];
      for (const s2 of e2)
        t2.push(l$1f(() => ({ symbol: s2.symbol, value: s2.value, label: s2.label, description: s2.description }), (e3, t3) => {
          e3 !== t3 && (this._updateGroupsFromInfos(), this._isInfosSource = true);
        }, { sync: true }));
      this.addHandles(t2, z$9);
    }
  }
  _watchUniqueValueGroups() {
    this.removeHandles(k$5);
    const { uniqueValueGroups: e2 } = this;
    if (e2) {
      const t2 = [];
      for (const s2 of e2) {
        t2.push(l$1f(() => ({ classes: s2.classes }), (e3, t3) => {
          e3 !== t3 && (this._updateInfosFromGroups(), this._isInfosSource = false);
        }, { sync: true }));
        for (const e3 of s2.classes)
          t2.push(l$1f(() => ({ symbol: e3.symbol, values: e3.values, label: e3.label, description: e3.description }), (e4, t3) => {
            e4 !== t3 && (this._updateInfosFromGroups(), this._isInfosSource = false);
          }, { sync: true }));
      }
      this.addHandles(t2, k$5);
    }
  }
  _updateInfosFromGroups() {
    var _a2;
    if (!this.uniqueValueGroups)
      return this._set("uniqueValueInfos", null), this._updateValueInfoMap(), void this._watchUniqueValueInfos();
    const e2 = [], { field: t2, field2: s2, field3: i2, fieldDelimiter: o2, uniqueValueGroups: l2, valueExpression: r2 } = this;
    if (!t2 && !r2)
      return this._set("uniqueValueInfos", e2), this._updateValueInfoMap(), void this._watchUniqueValueInfos();
    const u2 = !(!t2 || !s2);
    for (const n2 of l2)
      for (const t3 of (_a2 = n2.classes) != null ? _a2 : []) {
        const { symbol: l3, label: r3, values: n3, description: a2 } = t3;
        for (const t4 of n3 != null ? n3 : []) {
          const { value: n4, value2: p2, value3: f2 } = t4, d2 = [n4];
          s2 && d2.push(p2), i2 && d2.push(f2);
          const c2 = u2 ? d2.join(o2 || "") : d2[0];
          e2.push(new n$U({ symbol: l3, label: r3, value: c2, description: a2 }));
        }
      }
    this._set("uniqueValueInfos", e2), this._updateValueInfoMap(), this._watchUniqueValueInfos();
  }
  _updateGroupsFromInfos(e2 = false) {
    if (!this.uniqueValueInfos)
      return this._set("uniqueValueGroups", null), void this._watchUniqueValueGroups();
    const { field: t2, field2: s2, valueExpression: i2, fieldDelimiter: o2, uniqueValueInfos: l2 } = this;
    if (!t2 && !i2 || !l2.length)
      return this._set("uniqueValueGroups", []), void this._watchUniqueValueGroups();
    const r2 = !(!t2 || !s2), u2 = l2.map((e3) => {
      var _a2;
      const { symbol: t3, label: s3, value: i3, description: l3 } = e3, [u3, n3, a2] = r2 ? ((_a2 = i3 == null ? void 0 : i3.toString()) == null ? void 0 : _a2.split(o2 || "")) || [] : [i3];
      return new u$D({ symbol: t3, label: s3, description: l3, values: [new c$Z({ value: u3, value2: n3, value3: a2 })] });
    }), n2 = [new i$Y({ classes: u2 })];
    e2 && Object.freeze(n2), this._set("uniqueValueGroups", n2), this._watchUniqueValueGroups();
  }
  _getUniqueValueInfo(e2, t2) {
    return this.valueExpression ? this._getUnqiueValueInfoForExpression(e2, t2) : this._getUnqiueValueInfoForFields(e2);
  }
  _getUnqiueValueInfoForExpression(e2, t2) {
    const { viewingMode: s2, scale: i2, spatialReference: o2, arcade: l2 } = i$2y(t2, {});
    let n2 = this._cache.compiledFunc;
    const a2 = e$1U(l2).arcadeUtils;
    if (!n2) {
      const e3 = a2.createSyntaxTree(this.valueExpression);
      n2 = a2.createFunction(e3), this._cache.compiledFunc = n2;
    }
    const p2 = a2.executeFunction(n2, a2.createExecContext(e2, a2.getViewInfo({ viewingMode: s2, scale: i2, spatialReference: o2 })));
    return this._valueInfoMap[p2 + ""];
  }
  _getUnqiueValueInfoForFields(e2) {
    const t2 = this.field, s2 = e2.attributes;
    let i2;
    if (typeof t2 != "function" && this.field2) {
      const e3 = this.field2, o2 = this.field3, l2 = [];
      t2 && l2.push(s2[t2]), e3 && l2.push(s2[e3]), o2 && l2.push(s2[o2]), i2 = l2.join(this.fieldDelimiter || "");
    } else
      typeof t2 == "function" ? i2 = t2(e2) : t2 && (i2 = s2[t2]);
    return this._valueInfoMap[i2 + ""];
  }
  static fromPortalStyle(e2, t2) {
    const s2 = new R$7(t2 && t2.properties);
    s2._set("styleOrigin", Object.freeze({ styleName: e2 })), s2._set("portal", t2 && t2.portal || j$y.getDefault());
    const i2 = s2.populateFromStyle();
    return i2.catch((t3) => {
      $$2.error(`#fromPortalStyle('${e2}'[, ...])`, "Failed to create unique value renderer from style name", t3);
    }), i2;
  }
  static fromStyleUrl(e2, t2) {
    const s2 = new R$7(t2 && t2.properties);
    s2._set("styleOrigin", Object.freeze({ styleUrl: e2 }));
    const i2 = s2.populateFromStyle();
    return i2.catch((t3) => {
      $$2.error(`#fromStyleUrl('${e2}'[, ...])`, "Failed to create unique value renderer from style URL", t3);
    }), i2;
  }
};
e$1W([y$1o({ readOnly: true })], T$5.prototype, "_cache", null), e$1W([r$1a({ uniqueValue: "unique-value" })], T$5.prototype, "type", void 0), e$1W([y$1o(y$s)], T$5.prototype, "backgroundFillSymbol", void 0), e$1W([y$1o({ value: null, json: { type: String, read: { source: "field1" }, write: { target: "field1" } } })], T$5.prototype, "field", null), e$1W([s$1N("field")], T$5.prototype, "castField", null), e$1W([r$1h("field")], T$5.prototype, "writeField", null), e$1W([y$1o({ type: String, value: null, json: { write: true } })], T$5.prototype, "field2", null), e$1W([y$1o({ type: String, value: null, json: { write: true } })], T$5.prototype, "field3", null), e$1W([y$1o({ type: String, value: null, json: { write: true } })], T$5.prototype, "valueExpression", null), e$1W([y$1o({ type: String, json: { write: true } })], T$5.prototype, "valueExpressionTitle", void 0), e$1W([y$1o({ type: p$1m, json: { write: true } })], T$5.prototype, "legendOptions", void 0), e$1W([y$1o({ type: String, json: { write: true } })], T$5.prototype, "defaultLabel", void 0), e$1W([y$1o(n$2n(__spreadValues({}, l$T), { json: { write: { overridePolicy() {
  return { enabled: !this._isDefaultSymbolDerived };
} }, origins: { "web-scene": { write: { overridePolicy() {
  return { enabled: !this._isDefaultSymbolDerived };
} } } } } }))], T$5.prototype, "defaultSymbol", null), e$1W([y$1o({ type: String, value: null, json: { write: true } })], T$5.prototype, "fieldDelimiter", null), e$1W([y$1o({ type: j$y, readOnly: true })], T$5.prototype, "portal", void 0), e$1W([o$1H("portal", ["styleName"])], T$5.prototype, "readPortal", null), e$1W([y$1o({ readOnly: true, json: { write: { enabled: false, overridePolicy: () => ({ enabled: true }) } } })], T$5.prototype, "styleOrigin", void 0), e$1W([o$1H("styleOrigin", ["styleName", "styleUrl"])], T$5.prototype, "readStyleOrigin", null), e$1W([r$1h("styleOrigin", { styleName: { type: String }, styleUrl: { type: String } })], T$5.prototype, "writeStyleOrigin", null), e$1W([y$1o({ type: [i$Y], json: { read: { source: ["uniqueValueGroups", "uniqueValueInfos"], reader: (e2, t2, s2) => (t2.uniqueValueGroups || L$b(t2)).map((e3) => i$Y.fromJSON(e3, s2)) }, write: { overridePolicy() {
  return this.styleOrigin ? { enabled: false } : { enabled: true };
} } } })], T$5.prototype, "uniqueValueGroups", null), e$1W([y$1o({ type: [n$U], json: { read: false, write: { overridePolicy() {
  return this.styleOrigin ? { enabled: false } : { enabled: true };
} } } })], T$5.prototype, "uniqueValueInfos", null), T$5 = R$7 = e$1W([n$2f(P$9)], T$5);
const C$9 = T$5;
const p$15 = { key: "type", base: p$1n, typeMap: { heatmap: P$a, simple: p$19, "unique-value": C$9, "class-breaks": _$g, "dot-density": y$q, dictionary: u$J, "pie-chart": j$c }, errorContext: "renderer" }, n$T = { key: "type", base: p$1n, typeMap: { simple: p$19, "unique-value": C$9, "class-breaks": _$g, heatmap: P$a }, errorContext: "renderer" };
function t$E(e2, r2) {
  return o$F(e2, null, r2);
}
const s$K = s$1W({ types: p$15 });
function o$F(r2, n2, t2) {
  return r2 ? r2 && (r2.styleName || r2.styleUrl) && r2.type !== "uniqueValue" ? (t2 && t2.messages && t2.messages.push(new t$1Q("renderer:unsupported", "Only UniqueValueRenderer can be referenced from a web style, but found '" + r2.type + "'", { definition: r2, context: t2 })), null) : s$K(r2, n2, t2) : null;
}
class i$W {
  constructor() {
    this._propertyOriginMap = new Map(), this._originStores = new Array(E$w), this._values = new Map(), this.multipleOriginsSupported = true;
  }
  clone(s2) {
    const o2 = new i$W(), n2 = this._originStores[r$1m.DEFAULTS];
    n2 && n2.forEach((s3, e2) => {
      o2.set(e2, y$1r(s3), r$1m.DEFAULTS);
    });
    for (let i2 = r$1m.SERVICE; i2 < E$w; i2++) {
      const e2 = this._originStores[i2];
      e2 && e2.forEach((e3, r2) => {
        s2 && s2.has(r2) || o2.set(r2, y$1r(e3), i2);
      });
    }
    return o2;
  }
  get(t2, s2) {
    const e2 = s2 === void 0 ? this._values : this._originStores[s2];
    return e2 ? e2.get(t2) : void 0;
  }
  keys(t2) {
    const s2 = t2 == null ? this._values : this._originStores[t2];
    return s2 ? [...s2.keys()] : [];
  }
  set(t2, e2, i2 = r$1m.USER) {
    let o2 = this._originStores[i2];
    if (o2 || (o2 = new Map(), this._originStores[i2] = o2), o2.set(t2, e2), !this._values.has(t2) || x$N(this._propertyOriginMap.get(t2)) <= i2) {
      const s2 = this._values.get(t2);
      return this._values.set(t2, e2), this._propertyOriginMap.set(t2, i2), s2 !== e2;
    }
    return false;
  }
  delete(t2, s2 = r$1m.USER) {
    const e2 = this._originStores[s2];
    if (!e2)
      return;
    const i2 = e2.get(t2);
    if (e2.delete(t2), this._values.has(t2) && this._propertyOriginMap.get(t2) === s2) {
      this._values.delete(t2);
      for (let e3 = s2 - 1; e3 >= 0; e3--) {
        const s3 = this._originStores[e3];
        if (s3 && s3.has(t2)) {
          this._values.set(t2, s3.get(t2)), this._propertyOriginMap.set(t2, e3);
          break;
        }
      }
    }
    return i2;
  }
  has(t2, s2) {
    const e2 = s2 === void 0 ? this._values : this._originStores[s2];
    return !!e2 && e2.has(t2);
  }
  revert(t2, s2) {
    for (; s2 > 0 && !this.has(t2, s2); )
      --s2;
    const e2 = this._originStores[s2], r2 = e2 && e2.get(t2), i2 = this._values.get(t2);
    return this._values.set(t2, r2), this._propertyOriginMap.set(t2, s2), i2 !== r2;
  }
  originOf(t2) {
    return this._propertyOriginMap.get(t2) || r$1m.DEFAULTS;
  }
  forEach(t2) {
    this._values.forEach(t2);
  }
}
const a$_ = (t2) => {
  let a2 = class extends t2 {
    constructor(...r2) {
      super(...r2);
      const t3 = x$N(e$1Q(this)), i2 = t3.store, c2 = new i$W();
      t3.store = c2, e$1C(t3, i2, c2);
    }
    read(r2, t3) {
      u$1O(this, r2, t3);
    }
    getAtOrigin(r2, t3) {
      const s2 = m$z(this), o2 = t$1L(t3);
      if (typeof r2 == "string")
        return s2.get(r2, o2);
      const e2 = {};
      return r2.forEach((r3) => {
        e2[r3] = s2.get(r3, o2);
      }), e2;
    }
    originOf(r2) {
      return n$2d(this.originIdOf(r2));
    }
    originIdOf(r2) {
      return m$z(this).originOf(r2);
    }
    revert(r2, t3) {
      const s2 = m$z(this), o2 = t$1L(t3), e2 = e$1Q(this);
      let c2;
      c2 = typeof r2 == "string" ? r2 === "*" ? s2.keys(o2) : [r2] : r2, c2.forEach((r3) => {
        e2.invalidate(r3), s2.revert(r3, o2), e2.commit(r3);
      });
    }
  };
  return a2 = e$1W([n$2f("esri.core.ReadOnlyMultiOriginJSONSupport")], a2), a2;
};
function m$z(r2) {
  return e$1Q(r2).store;
}
let f$y = class extends a$_(m$1L) {
};
f$y = e$1W([n$2f("esri.core.ReadOnlyMultiOriginJSONSupport")], f$y);
const u$B = (t2) => {
  let s2 = class extends t2 {
    constructor(...r2) {
      super(...r2);
    }
    clear(r2, t3 = "user") {
      return l$N(this).delete(r2, t$1L(t3));
    }
    write(r2 = {}, t3) {
      return c$2G(this, r2 = r2 || {}, t3), r2;
    }
    setAtOrigin(r2, t3, s3) {
      e$1Q(this).setAtOrigin(r2, t3, t$1L(s3));
    }
    removeOrigin(r2) {
      const t3 = l$N(this), s3 = t$1L(r2), i2 = t3.keys(s3);
      for (const e2 of i2)
        t3.originOf(e2) === s3 && t3.set(e2, t3.get(e2, s3), r$1m.USER);
    }
    updateOrigin(r2, t3) {
      const s3 = l$N(this), o2 = t$1L(t3), c2 = this.get(r2);
      for (let e2 = o2 + 1; e2 < E$w; ++e2)
        s3.delete(r2, e2);
      s3.set(r2, c2, o2);
    }
    toJSON(r2) {
      return this.write({}, r2);
    }
  };
  return s2 = e$1W([n$2f("esri.core.WriteableMultiOriginJSONSupport")], s2), s2.prototype.toJSON.isDefaultToJSON = true, s2;
};
function l$N(r2) {
  return e$1Q(r2).store;
}
const O$6 = (t2) => {
  let e2 = class extends u$B(a$_(t2)) {
    constructor(...r2) {
      super(...r2);
    }
  };
  return e2 = e$1W([n$2f("esri.core.MultiOriginJSONSupport")], e2), e2;
};
let S$c = class extends O$6(m$1L) {
};
S$c = e$1W([n$2f("esri.core.MultiOriginJSONSupport")], S$c);
async function r$x(e2, r2) {
  const { WhereClause: t2 } = await import("./WhereClause.js");
  return t2.create(e2, r2);
}
function t$D(r2, t2) {
  return r$1t(r2) ? r$1t(t2) ? `(${r2}) AND (${t2})` : r2 : t2;
}
var s$J;
let p$14 = s$J = class extends l$1_ {
  constructor(e2) {
    super(e2), this.expression = null, this.name = null, this.returnType = "boolean", this.title = null;
  }
  clone() {
    return new s$J({ name: this.name, title: this.title, expression: this.expression, returnType: this.returnType });
  }
};
e$1W([y$1o({ type: String, json: { write: true } })], p$14.prototype, "expression", void 0), e$1W([y$1o({ type: String, json: { write: true } })], p$14.prototype, "name", void 0), e$1W([y$1o({ type: ["boolean", "date", "number", "string"], json: { write: true } })], p$14.prototype, "returnType", void 0), e$1W([y$1o({ type: String, json: { write: true } })], p$14.prototype, "title", void 0), p$14 = s$J = e$1W([n$2f("esri.form.ExpressionInfo")], p$14);
const i$V = p$14;
let e$y = class extends l$1_ {
  constructor(t2) {
    super(t2), this.description = null, this.label = null, this.type = null, this.visibilityExpression = null;
  }
};
e$1W([y$1o({ type: String, json: { write: true } })], e$y.prototype, "description", void 0), e$1W([y$1o({ type: String, json: { write: true } })], e$y.prototype, "label", void 0), e$1W([y$1o()], e$y.prototype, "type", void 0), e$1W([y$1o({ type: String, json: { write: true } })], e$y.prototype, "visibilityExpression", void 0), e$y = e$1W([n$2f("esri.form.elements.Element")], e$y);
const i$U = e$y;
var s$I;
let p$13 = s$I = class extends l$1_ {
  constructor(t2) {
    super(t2), this.type = null;
  }
  clone() {
    return new s$I({ type: this.type });
  }
};
e$1W([y$1o({ type: ["attachment", "audio", "document", "image", "signature", "video"], json: { write: true } })], p$13.prototype, "type", void 0), p$13 = s$I = e$1W([n$2f("esri.form.elements.inputs.AttachmentInput")], p$13);
const c$W = p$13;
var i$T;
let p$12 = i$T = class extends i$U {
  constructor(t2) {
    super(t2), this.attachmentKeyword = null, this.editable = true, this.input = null, this.type = "attachment";
  }
  clone() {
    return new i$T({ attachmentKeyword: this.attachmentKeyword, description: this.description, editable: this.editable, input: this.input, label: this.label, visibilityExpression: this.visibilityExpression });
  }
};
e$1W([y$1o({ type: String, json: { write: true } })], p$12.prototype, "attachmentKeyword", void 0), e$1W([y$1o({ type: Boolean, json: { write: true } })], p$12.prototype, "editable", void 0), e$1W([y$1o({ type: c$W, json: { read: { source: "inputType" }, write: { target: "inputType" } } })], p$12.prototype, "input", void 0), e$1W([y$1o({ type: ["attachment"], json: { read: false, write: true } })], p$12.prototype, "type", void 0), p$12 = i$T = e$1W([n$2f("esri.form.elements.AttachmentElement")], p$12);
const n$S = p$12;
let e$x = class extends l$1_ {
  constructor(r2) {
    super(r2), this.type = null;
  }
};
e$1W([y$1o()], e$x.prototype, "type", void 0), e$x = e$1W([n$2f("esri.form.elements.inputs.Input")], e$x);
const p$11 = e$x;
let s$H = class extends p$11 {
  constructor(r2) {
    super(r2), this.maxLength = null, this.minLength = 0;
  }
};
e$1W([y$1o({ type: Number, json: { write: true } })], s$H.prototype, "maxLength", void 0), e$1W([y$1o({ type: Number, json: { write: true } })], s$H.prototype, "minLength", void 0), s$H = e$1W([n$2f("esri.form.elements.inputs.TextInput")], s$H);
const p$10 = s$H;
var o$E;
let c$V = o$E = class extends p$10 {
  constructor(r2) {
    super(r2), this.type = "barcode-scanner";
  }
  clone() {
    return new o$E({ maxLength: this.maxLength, minLength: this.minLength });
  }
};
e$1W([y$1o({ type: ["barcode-scanner"], json: { read: false, write: true } })], c$V.prototype, "type", void 0), c$V = o$E = e$1W([n$2f("esri.form.elements.inputs.BarcodeScannerInput")], c$V);
const n$R = c$V;
var s$G;
let p$$ = s$G = class extends p$11 {
  constructor(o2) {
    super(o2), this.noValueOptionLabel = null, this.showNoValueOption = true, this.type = "combo-box";
  }
  clone() {
    return new s$G({ showNoValueOption: this.showNoValueOption, noValueOptionLabel: this.noValueOptionLabel });
  }
};
e$1W([y$1o({ type: String, json: { write: true } })], p$$.prototype, "noValueOptionLabel", void 0), e$1W([y$1o({ type: Boolean, json: { write: true } })], p$$.prototype, "showNoValueOption", void 0), e$1W([y$1o({ type: ["combo-box"], json: { read: false, write: true } })], p$$.prototype, "type", void 0), p$$ = s$G = e$1W([n$2f("esri.form.elements.inputs.ComboBoxInput")], p$$);
const i$S = p$$;
var s$F;
function n$Q(e2) {
  return e2 != null ? new Date(e2) : null;
}
function a$Z(e2) {
  return e2 ? e2.getTime() : null;
}
let m$y = s$F = class extends p$11 {
  constructor(e2) {
    super(e2), this.includeTime = false, this.max = null, this.min = null, this.type = "datetime-picker";
  }
  readMax(e2, r2) {
    return n$Q(r2.max);
  }
  writeMax(e2, r2) {
    r2.max = a$Z(e2);
  }
  readMin(e2, r2) {
    return n$Q(r2.min);
  }
  writeMin(e2, r2) {
    r2.min = a$Z(e2);
  }
  clone() {
    return new s$F({ includeTime: this.includeTime, max: this.max, min: this.min, type: this.type });
  }
};
e$1W([y$1o({ type: Boolean, json: { write: true } })], m$y.prototype, "includeTime", void 0), e$1W([y$1o({ type: Date, json: { type: Number, write: true } })], m$y.prototype, "max", void 0), e$1W([o$1H("max")], m$y.prototype, "readMax", null), e$1W([r$1h("max")], m$y.prototype, "writeMax", null), e$1W([y$1o({ type: Date, json: { type: Number, write: true } })], m$y.prototype, "min", void 0), e$1W([o$1H("min")], m$y.prototype, "readMin", null), e$1W([r$1h("min")], m$y.prototype, "writeMin", null), e$1W([y$1o({ type: ["datetime-picker"], json: { read: false, write: true } })], m$y.prototype, "type", void 0), m$y = s$F = e$1W([n$2f("esri.form.elements.inputs.DateTimePickerInput")], m$y);
const c$U = m$y;
var s$E;
let p$_ = s$E = class extends p$11 {
  constructor(o2) {
    super(o2), this.noValueOptionLabel = null, this.showNoValueOption = true, this.type = "radio-buttons";
  }
  clone() {
    return new s$E({ noValueOptionLabel: this.noValueOptionLabel, showNoValueOption: this.showNoValueOption });
  }
};
e$1W([y$1o({ type: String, json: { write: true } })], p$_.prototype, "noValueOptionLabel", void 0), e$1W([y$1o({ type: Boolean, json: { write: true } })], p$_.prototype, "showNoValueOption", void 0), e$1W([y$1o({ type: ["radio-buttons"], json: { read: false, write: true } })], p$_.prototype, "type", void 0), p$_ = s$E = e$1W([n$2f("esri.form.elements.inputs.RadioButtonsInput")], p$_);
const i$R = p$_;
var s$D;
let p$Z = s$D = class extends p$11 {
  constructor(o2) {
    super(o2), this.offValue = null, this.onValue = null, this.type = "switch";
  }
  clone() {
    return new s$D({ offValue: this.offValue, onValue: this.onValue });
  }
};
e$1W([y$1o({ type: [String, Number], json: { write: true } })], p$Z.prototype, "offValue", void 0), e$1W([y$1o({ type: [String, Number], json: { write: true } })], p$Z.prototype, "onValue", void 0), e$1W([y$1o({ type: ["switch"], json: { read: false, write: true } })], p$Z.prototype, "type", void 0), p$Z = s$D = e$1W([n$2f("esri.form.elements.inputs.SwitchInput")], p$Z);
const i$Q = p$Z;
var o$D;
let p$Y = o$D = class extends p$10 {
  constructor(t2) {
    super(t2), this.type = "text-area";
  }
  clone() {
    return new o$D({ maxLength: this.maxLength, minLength: this.minLength });
  }
};
e$1W([y$1o({ type: ["text-area"], json: { read: false, write: true } })], p$Y.prototype, "type", void 0), p$Y = o$D = e$1W([n$2f("esri.form.elements.inputs.TextAreaInput")], p$Y);
const a$Y = p$Y;
var s$C;
let p$X = s$C = class extends p$10 {
  constructor(t2) {
    super(t2), this.type = "text-box";
  }
  clone() {
    return new s$C({ maxLength: this.maxLength, minLength: this.minLength });
  }
};
e$1W([y$1o({ type: ["text-box"], json: { read: false, write: true } })], p$X.prototype, "type", void 0), p$X = s$C = e$1W([n$2f("esri.form.elements.inputs.TextBoxInput")], p$X);
const c$T = p$X;
const m$x = { base: p$11, key: "type", typeMap: { "barcode-scanner": n$R, "combo-box": i$S, "datetime-picker": c$U, "radio-buttons": i$R, switch: i$Q, "text-area": a$Y, "text-box": c$T } };
var n$P;
let l$M = n$P = class extends i$U {
  constructor(e2) {
    super(e2), this.domain = null, this.editable = true, this.editableExpression = null, this.fieldName = null, this.hint = null, this.input = null, this.requiredExpression = null, this.type = "field", this.valueExpression = null;
  }
  clone() {
    return new n$P({ description: this.description, domain: this.domain, editable: this.editable, editableExpression: this.editableExpression, fieldName: this.fieldName, hint: this.hint, input: this.input, label: this.label, requiredExpression: this.requiredExpression, valueExpression: this.valueExpression, visibilityExpression: this.visibilityExpression });
  }
};
e$1W([y$1o({ types: n$1a, json: { read: { reader: t$Q }, write: true } })], l$M.prototype, "domain", void 0), e$1W([y$1o({ type: Boolean, json: { write: true } })], l$M.prototype, "editable", void 0), e$1W([y$1o({ type: String, json: { write: true } })], l$M.prototype, "editableExpression", void 0), e$1W([y$1o({ type: String, json: { write: true } })], l$M.prototype, "fieldName", void 0), e$1W([y$1o({ type: String, json: { write: true } })], l$M.prototype, "hint", void 0), e$1W([y$1o({ types: m$x, json: { read: { source: "inputType" }, write: { target: "inputType" } } })], l$M.prototype, "input", void 0), e$1W([y$1o({ type: String, json: { write: true } })], l$M.prototype, "requiredExpression", void 0), e$1W([y$1o({ type: String, json: { read: false, write: true } })], l$M.prototype, "type", void 0), e$1W([y$1o({ type: String, json: { write: true } })], l$M.prototype, "valueExpression", void 0), l$M = n$P = e$1W([n$2f("esri.form.elements.FieldElement")], l$M);
const a$X = l$M;
var p$W;
let l$L = p$W = class extends i$U {
  constructor(e2) {
    super(e2), this.displayCount = null, this.displayType = "list", this.editable = true, this.orderByFields = null, this.relationshipId = null, this.type = "relationship";
  }
  clone() {
    return new p$W({ description: this.description, displayCount: this.displayCount, displayType: this.displayType, editable: this.editable, label: this.label, orderByFields: y$1r(this.orderByFields), relationshipId: this.relationshipId, visibilityExpression: this.visibilityExpression });
  }
};
e$1W([y$1o({ type: Number, json: { write: true } })], l$L.prototype, "displayCount", void 0), e$1W([y$1o({ type: ["list"], json: { write: true } })], l$L.prototype, "displayType", void 0), e$1W([y$1o({ type: Boolean, json: { write: true } })], l$L.prototype, "editable", void 0), e$1W([y$1o({ type: [c$2l], json: { write: true } })], l$L.prototype, "orderByFields", void 0), e$1W([y$1o({ type: Number, json: { write: true } })], l$L.prototype, "relationshipId", void 0), e$1W([y$1o({ type: ["relationship"], json: { read: false, write: true } })], l$L.prototype, "type", void 0), l$L = p$W = e$1W([n$2f("esri.form.elements.RelationshipElement")], l$L);
const d$v = l$L;
function n$O(t2) {
  return { typesWithGroup: { base: i$U, key: "type", typeMap: { attachment: n$S, field: a$X, group: t2, relationship: d$v } }, typesWithoutGroup: { base: i$U, key: "type", typeMap: { attachment: n$S, field: a$X, relationship: d$v } } };
}
function i$P(t2, e2, p2 = true) {
  if (!t2)
    return null;
  const r2 = p2 ? e2.typesWithGroup.typeMap : e2.typesWithoutGroup.typeMap;
  return t2.filter((t3) => r2[t3.type]).map((t3) => r2[t3.type].fromJSON(t3));
}
function u$A(t2, e2, p2 = true) {
  if (!t2)
    return null;
  const r2 = p2 ? e2.typesWithGroup.typeMap : e2.typesWithoutGroup.typeMap;
  return t2.filter((t3) => r2[t3.type]).map((t3) => t3.toJSON());
}
function s$B(e2, p2, r2 = true) {
  return e2 ? e2.map((e3) => S$H(r2 ? p2.typesWithGroup : p2.typesWithoutGroup, e3)) : null;
}
var d$u;
let u$z = d$u = class extends i$U {
  constructor(e2) {
    super(e2), this.elements = null, this.initialState = "expanded", this.type = "group";
  }
  castElements(e2) {
    return s$B(e2, f$x, false);
  }
  readElements(e2, t2) {
    return i$P(t2.formElements, f$x, false);
  }
  writeElements(e2, t2) {
    t2.formElements = u$A(e2, f$x, false);
  }
  clone() {
    return new d$u({ description: this.description, elements: y$1r(this.elements), initialState: this.initialState, label: this.label, visibilityExpression: this.visibilityExpression });
  }
};
e$1W([y$1o({ json: { write: true } })], u$z.prototype, "elements", void 0), e$1W([s$1N("elements")], u$z.prototype, "castElements", null), e$1W([o$1H("elements", ["formElements"])], u$z.prototype, "readElements", null), e$1W([r$1h("elements")], u$z.prototype, "writeElements", null), e$1W([y$1o({ type: ["collapsed", "expanded"], json: { write: true } })], u$z.prototype, "initialState", void 0), e$1W([y$1o({ type: String, json: { read: false, write: true } })], u$z.prototype, "type", void 0), u$z = d$u = e$1W([n$2f("esri.form.elements.GroupElement")], u$z);
const f$x = n$O(u$z), y$m = u$z;
var f$w;
const j$a = n$O(y$m);
let h$o = f$w = class extends l$1_ {
  constructor(e2) {
    super(e2), this.description = null, this.elements = null, this.expressionInfos = null, this.preserveFieldValuesWhenHidden = false, this.title = null;
  }
  castElements(e2) {
    return s$B(e2, j$a);
  }
  readElements(e2, t2) {
    return i$P(t2.formElements, j$a);
  }
  writeElements(e2, t2) {
    t2.formElements = u$A(e2, j$a);
  }
  clone() {
    return new f$w({ description: this.description, expressionInfos: y$1r(this.expressionInfos), elements: y$1r(this.elements), title: this.title, preserveFieldValuesWhenHidden: this.preserveFieldValuesWhenHidden });
  }
};
e$1W([y$1o({ type: String, json: { write: true } })], h$o.prototype, "description", void 0), e$1W([y$1o({ json: { write: true } })], h$o.prototype, "elements", void 0), e$1W([s$1N("elements")], h$o.prototype, "castElements", null), e$1W([o$1H("elements", ["formElements"])], h$o.prototype, "readElements", null), e$1W([r$1h("elements")], h$o.prototype, "writeElements", null), e$1W([y$1o({ type: [i$V], json: { write: true } })], h$o.prototype, "expressionInfos", void 0), e$1W([y$1o({ type: Boolean, json: { default: false, write: true } })], h$o.prototype, "preserveFieldValuesWhenHidden", void 0), e$1W([y$1o({ type: String, json: { write: true } })], h$o.prototype, "title", void 0), h$o = f$w = e$1W([n$2f("esri.form.FormTemplate")], h$o);
const y$l = h$o;
async function o$C(o2) {
  const a2 = "portalItem" in o2 ? o2 : { portalItem: o2 }, e2 = await import("./portalLayers.js");
  try {
    return await e2.fromItem(a2);
  } catch (p2) {
    const o3 = a2 && a2.portalItem, e3 = o3 && o3.id || "unset", l2 = o3 && o3.portal && o3.portal.url || s$23.portalUrl;
    throw s$22.getLogger("esri.layers.support.fromPortalItem").error("#fromPortalItem()", "Failed to create layer from portal item (portal: '" + l2 + "', id: '" + e3 + "')", p2), p2;
  }
}
let m$w = 0, h$n = class extends n$26.EventedMixin(s$1u(m$1g)) {
  constructor() {
    super(...arguments), this.attributionDataUrl = null, this.fullExtent = new w$J(-180, -90, 180, 90, k$p.WGS84), this.id = Date.now().toString(16) + "-layer-" + m$w++, this.legendEnabled = true, this.listMode = "show", this.opacity = 1, this.parent = null, this.popupEnabled = true, this.attributionVisible = true, this.spatialReference = k$p.WGS84, this.title = null, this.type = null, this.url = null, this.visible = true;
  }
  static async fromArcGISServerUrl(t2) {
    const e2 = typeof t2 == "string" ? { url: t2 } : t2;
    return (await import("./arcgisLayers.js")).fromUrl(e2);
  }
  static fromPortalItem(t2) {
    return o$C(t2);
  }
  initialize() {
    this.when().catch((t2) => {
      var _a2, _b2;
      j$K(t2) || s$22.getLogger(this.declaredClass).error("#load()", `Failed to load layer (title: '${(_a2 = this.title) != null ? _a2 : "no title"}', id: '${(_b2 = this.id) != null ? _b2 : "no id"}')`, { error: t2 });
    });
  }
  destroy() {
    if (this.parent) {
      const t2 = this, e2 = this.parent;
      "layers" in e2 && e2.layers.includes(t2) ? e2.layers.remove(t2) : "tables" in e2 && e2.tables.includes(t2) ? e2.tables.remove(t2) : "baseLayers" in e2 && e2.baseLayers.includes(t2) ? e2.baseLayers.remove(t2) : "baseLayers" in e2 && e2.referenceLayers.includes(t2) && e2.referenceLayers.remove(t2);
    }
  }
  get hasAttributionData() {
    return this.attributionDataUrl != null;
  }
  get parsedUrl() {
    return j$B(this.url);
  }
  async fetchAttributionData() {
    const t2 = this.attributionDataUrl;
    if (this.hasAttributionData && t2) {
      return (await U$k(t2, { query: { f: "json" }, responseType: "json" })).data;
    }
    throw new s$1Z("layer:no-attribution-data", "Layer does not have attribution data");
  }
};
e$1W([y$1o({ type: String })], h$n.prototype, "attributionDataUrl", void 0), e$1W([y$1o({ type: w$J })], h$n.prototype, "fullExtent", void 0), e$1W([y$1o({ readOnly: true })], h$n.prototype, "hasAttributionData", null), e$1W([y$1o({ type: String, clonable: false })], h$n.prototype, "id", void 0), e$1W([y$1o({ type: Boolean, nonNullable: true })], h$n.prototype, "legendEnabled", void 0), e$1W([y$1o({ type: ["show", "hide", "hide-children"] })], h$n.prototype, "listMode", void 0), e$1W([y$1o({ type: Number, range: { min: 0, max: 1 }, nonNullable: true })], h$n.prototype, "opacity", void 0), e$1W([y$1o({ clonable: false })], h$n.prototype, "parent", void 0), e$1W([y$1o({ readOnly: true })], h$n.prototype, "parsedUrl", null), e$1W([y$1o({ type: Boolean })], h$n.prototype, "popupEnabled", void 0), e$1W([y$1o({ type: Boolean })], h$n.prototype, "attributionVisible", void 0), e$1W([y$1o({ type: k$p })], h$n.prototype, "spatialReference", void 0), e$1W([y$1o({ type: String })], h$n.prototype, "title", void 0), e$1W([y$1o({ readOnly: true, json: { read: false } })], h$n.prototype, "type", void 0), e$1W([y$1o()], h$n.prototype, "url", void 0), e$1W([y$1o({ type: Boolean, nonNullable: true })], h$n.prototype, "visible", void 0), h$n = e$1W([n$2f("esri.layers.Layer")], h$n);
const b$h = h$n;
function t$C(e2, n2, o2) {
  if (e2.hasM == null || e2.hasZ)
    for (const t2 of n2)
      for (const e3 of t2)
        e3.length > 2 && (e3[2] *= o2);
}
function i$O(e2, o2, t2) {
  if (!e2 && !o2 || !t2)
    return;
  const i2 = L$h(t2);
  s$A(e2, t2, i2), s$A(o2, t2, i2);
}
function s$A(e2, n2, o2) {
  if (e2)
    for (const t2 of e2)
      f$v(t2.geometry, n2, o2);
}
function f$v(i2, s2, f2) {
  if (t$1W(i2) || !i2.spatialReference || E$u(i2.spatialReference, s2))
    return;
  const r2 = L$h(i2.spatialReference) / f2;
  if (r2 !== 1) {
    if ("x" in i2)
      i2.z != null && (i2.z *= r2);
    else if ("rings" in i2)
      t$C(i2, i2.rings, r2);
    else if ("paths" in i2)
      t$C(i2, i2.paths, r2);
    else if ("points" in i2 && (i2.hasM == null || i2.hasZ))
      for (const e2 of i2.points)
        e2.length > 2 && (e2[2] *= r2);
  }
}
let b$g = 0;
const T$4 = "esri.layers.graphics.sources.MemorySource", F$5 = s$22.getLogger(T$4);
let G$5 = class extends m$1g.LoadableMixin(m$1h(a$1s(j$F))) {
  constructor(e2) {
    super(e2), this._idToClientGraphic = null, this.type = "memory";
  }
  load(e2) {
    const t2 = r$1t(e2) ? e2.signal : null;
    return this.addResolvingPromise(this._startWorker(t2)), Promise.resolve(this);
  }
  destroy() {
    var _a2;
    (_a2 = this._connection) == null ? void 0 : _a2.close(), this._connection = null;
  }
  get _workerGeometryType() {
    var _a2;
    const e2 = (_a2 = this.layer) == null ? void 0 : _a2.geometryType;
    return e2 ? this._geometryTypeRequiresClientGraphicMapping(e2) ? "polygon" : e2 : null;
  }
  applyEdits(e2) {
    return this.load().then(() => this._applyEdits(e2));
  }
  openPorts() {
    return this.load().then(() => this._connection.openPorts());
  }
  async queryFeatures(e2, t2 = {}) {
    await this.load(t2);
    const r2 = await this._connection.invoke("queryFeatures", e2 ? e2.toJSON() : null, t2);
    r$A(e2, this.layer.spatialReference, r2);
    const s2 = x$j.fromJSON(r2);
    if (!this._requiresClientGraphicMapping())
      return s2;
    const o2 = this.layer.objectIdField;
    for (const i2 of s2.features) {
      const e3 = i2.attributes[o2], t3 = this._idToClientGraphic.get(e3);
      t3 && (i2.geometry = t3.geometry);
    }
    return s2.geometryType = this.layer.geometryType, s2;
  }
  async queryFeaturesJSON(e2, t2 = {}) {
    if (this._requiresClientGraphicMapping())
      throw new s$1Z("query-features-json:unsupported", "Cannot query in JSON format for client only geometry types (mesh and extent)");
    await this.load(t2);
    const r2 = await this._connection.invoke("queryFeatures", e2 ? e2.toJSON() : null, t2);
    return r$A(e2, this.layer.spatialReference, r2), r2;
  }
  queryFeatureCount(e2, t2 = {}) {
    return this.load(t2).then(() => this._connection.invoke("queryFeatureCount", e2 ? e2.toJSON() : null, t2));
  }
  queryObjectIds(e2, t2 = {}) {
    return this.load(t2).then(() => this._connection.invoke("queryObjectIds", e2 ? e2.toJSON() : null, t2));
  }
  queryExtent(e2, t2 = {}) {
    return this.load(t2).then(() => this._connection.invoke("queryExtent", e2 ? e2.toJSON() : null, t2)).then((e3) => ({ count: e3.count, extent: w$J.fromJSON(e3.extent) }));
  }
  querySnapping(e2, t2 = {}) {
    return this.load(t2).then(() => this._connection.invoke("querySnapping", e2, t2));
  }
  async _applyEdits(e2) {
    if (!this._connection)
      throw new s$1Z("feature-layer-source:edit-failure", "Memory source not loaded");
    const t2 = this.layer.objectIdField;
    let r2 = null;
    const o2 = [], i2 = [];
    await Promise.all([this._prepareClientMapping(e2.addFeatures, null), this._prepareClientMapping(e2.updateFeatures, null)]);
    const n2 = (e3) => "objectId" in e3 && e3.objectId != null ? e3.objectId : "attributes" in e3 && e3.attributes[t2] != null ? e3.attributes[t2] : null;
    if (e2.addFeatures && (r2 = this._prepareAddFeatures(e2.addFeatures)), e2.deleteFeatures)
      for (const s2 of e2.deleteFeatures) {
        const e3 = n2(s2);
        e3 != null && o2.push(e3);
      }
    const a2 = e2.updateFeatures && this._idToClientGraphic ? new Map() : null;
    if (e2.updateFeatures) {
      for (const s2 of e2.updateFeatures)
        if (i2.push(this._serializeFeature(s2)), a2) {
          const e3 = n2(s2);
          e3 != null && a2.set(e3, s2);
        }
    }
    i$O(r2 ? r2.features : null, i2, this.layer.spatialReference);
    const { fullExtent: l2, featureEditResults: u2 } = await this._connection.invoke("applyEdits", { adds: r2 ? r2.features : [], updates: i2, deletes: o2 });
    return this.fullExtent = l2, r2 && r2.finish(u2.uidToObjectId), this._updateClientGraphicIds(a2, u2), this._createEditsResult(u2);
  }
  async _prepareClientMapping(e2, t2) {
    if (this._layerOrSourceGeometryType !== "mesh" || t$1W(e2))
      return;
    const r2 = [];
    for (const { geometry: s2 } of e2)
      !r$1t(s2) || s2.type !== "mesh" || s2.hasExtent || s2.loaded || r2.push(s2.load({ signal: t2 }));
    r2.length && await Promise.all(r2);
  }
  _updateClientGraphicIds(e2, t2) {
    if (this._idToClientGraphic) {
      if (e2)
        for (const r2 of t2.updateResults) {
          if (!r2.success)
            continue;
          const t3 = e2.get(r2.objectId);
          t3 != null && this._addIdToClientGraphic(t3);
        }
      for (const e3 of t2.deleteResults)
        e3.success && this._idToClientGraphic.delete(e3.objectId);
    }
  }
  _createEditsResult(e2) {
    return { addFeatureResults: e2.addResults ? e2.addResults.map(this._createFeatureEditResult, this) : [], updateFeatureResults: e2.updateResults ? e2.updateResults.map(this._createFeatureEditResult, this) : [], deleteFeatureResults: e2.deleteResults ? e2.deleteResults.map(this._createFeatureEditResult, this) : [], addAttachmentResults: [], updateAttachmentResults: [], deleteAttachmentResults: [] };
  }
  _createFeatureEditResult(e2) {
    const t2 = e2.success === true ? null : e2.error || { code: void 0, description: void 0 };
    return { objectId: e2.objectId, globalId: e2.globalId, error: t2 ? new s$1Z("feature-layer-source:edit-failure", t2.description, { code: t2.code }) : null };
  }
  _prepareAddFeatures(e2) {
    const t2 = new Map(), r2 = new Array(e2.length);
    let s2 = null;
    for (let i2 = 0; i2 < e2.length; i2++) {
      const o3 = e2[i2], n2 = this._serializeFeature(o3);
      !s2 && r$1t(o3.geometry) && (s2 = o3.geometry.type), r2[i2] = n2, t2.set(`${n2.uid}`, o3);
    }
    const o2 = this;
    return { features: r2, inferredGeometryType: s2, finish(e3) {
      const r3 = o2.sourceJSON.objectIdField;
      for (const s3 in e3) {
        const i2 = e3[s3], n2 = t2.get(s3);
        n2 && (n2.attributes || (n2.attributes = {}), i2 === -1 ? delete n2.attributes[r3] : n2.attributes[r3] = i2, o2._addIdToClientGraphic(n2));
      }
    } };
  }
  _addIdToClientGraphic(e2) {
    if (!this._idToClientGraphic)
      return;
    const t2 = this.sourceJSON.objectIdField, r2 = e2.attributes && e2.attributes[t2];
    r2 != null && this._idToClientGraphic.set(r2, e2);
  }
  get _layerOrSourceGeometryType() {
    var _a2, _b2, _c2;
    return (_c2 = (_a2 = this.layer) == null ? void 0 : _a2.geometryType) != null ? _c2 : (_b2 = this.sourceJSON) == null ? void 0 : _b2.geometryType;
  }
  _requiresClientGraphicMapping() {
    return this._geometryTypeRequiresClientGraphicMapping(this._layerOrSourceGeometryType);
  }
  _geometryRequiresClientGraphicMapping(e2) {
    return this._geometryTypeRequiresClientGraphicMapping(e2.type);
  }
  _geometryTypeRequiresClientGraphicMapping(e2) {
    return e2 === "mesh" || e2 === "multipatch" || e2 === "extent";
  }
  _serializeFeature(e2) {
    const { attributes: t2 } = e2, r2 = this._geometryForSerialization(e2), s2 = (b$g++).toString();
    return r2 ? { uid: s2, geometry: r2.toJSON(), attributes: t2 } : { uid: s2, attributes: t2 };
  }
  _geometryForSerialization(e2) {
    const { geometry: t2 } = e2;
    if (t$1W(t2))
      return null;
    if (this._geometryRequiresClientGraphicMapping(t2)) {
      return t2.extent ? v$O.fromExtent(t2.extent) : null;
    }
    return t2;
  }
  async _startWorker(e2) {
    this._connection = await u$12("MemorySourceWorker", { strategy: has("feature-layers-workers") ? "dedicated" : "local", signal: e2 });
    const { fields: t2, spatialReference: r2, objectIdField: s2, hasM: o2, hasZ: i2, timeInfo: n2 } = this.layer, a2 = this.layer.originOf("spatialReference") === "defaults";
    await this._prepareClientMapping(this.items, e2);
    const l2 = this._prepareAddFeatures(this.items);
    this.handles.add(this.on("before-changes", (e3) => {
      F$5.error("Source modifications will not propagate after layer has been loaded. Please use .applyEdits() instead"), e3.preventDefault();
    }));
    const u2 = { features: l2.features, fields: t2 && t2.map((e3) => e3.toJSON()), geometryType: t$1u.toJSON(this._workerGeometryType), hasM: this._layerOrSourceGeometryType !== "mesh" && o2, hasZ: this._layerOrSourceGeometryType === "mesh" || i2, objectIdField: s2, spatialReference: a2 ? null : r2 && r2.toJSON(), timeInfo: n2 ? n2.toJSON() : null }, c2 = await this._connection.invoke("load", u2, { signal: e2 });
    for (const p2 of c2.warnings)
      F$5.warn(p2.message, { layer: this.layer, warning: p2 });
    c2.featureErrors.length && F$5.warn(`Encountered ${c2.featureErrors.length} validation errors while loading features`, c2.featureErrors);
    const d2 = c2.layerDefinition;
    this._geometryTypeRequiresClientGraphicMapping(l2.inferredGeometryType) && (d2.geometryType = t$1u.toJSON(l2.inferredGeometryType)), this.sourceJSON = d2, this._requiresClientGraphicMapping() && (this._idToClientGraphic = new Map()), l2.finish(c2.assignedObjectIds);
  }
};
e$1W([n$25({ Type: g$J, ensureType: b$U(g$J) })], G$5.prototype, "itemType", void 0), e$1W([y$1o()], G$5.prototype, "type", void 0), e$1W([y$1o({ constructOnly: true })], G$5.prototype, "layer", void 0), e$1W([y$1o({ readOnly: true })], G$5.prototype, "_workerGeometryType", null), e$1W([y$1o()], G$5.prototype, "sourceJSON", void 0), G$5 = e$1W([n$2f(T$4)], G$5);
function t$B(e2) {
  return "portalItem" in e2;
}
const i$N = (i2) => {
  let o2 = class extends i2 {
    get apiKey() {
      var _a2;
      return this._isOverridden("apiKey") ? this._get("apiKey") : t$B(this) ? (_a2 = this.portalItem) == null ? void 0 : _a2.apiKey : null;
    }
    set apiKey(e2) {
      e2 != null ? this._override("apiKey", e2) : (this._clearOverride("apiKey"), this.clear("apiKey", "user"));
    }
  };
  return e$1W([y$1o({ type: String })], o2.prototype, "apiKey", null), o2 = e$1W([n$2f("esri.layers.mixins.APIKeyMixin")], o2), o2;
};
const c$S = { mapserver: "MapServer", imageserver: "ImageServer", featureserver: "FeatureServer", sceneserver: "SceneServer", streamserver: "StreamServer", vectortileserver: "VectorTileServer" }, a$W = Object.values(c$S), f$u = new RegExp(`^((?:https?:)?\\/\\/\\S+?\\/rest\\/services\\/(.+?)\\/(${a$W.join("|")}))(?:\\/(?:layers\\/)?(\\d+))?`, "i"), v$i = new RegExp(`^((?:https?:)?\\/\\/\\S+?\\/([^\\/\\n]+)\\/(${a$W.join("|")}))(?:\\/(?:layers\\/)?(\\d+))?`, "i"), p$V = /(.*?)\/(?:layers\/)?(\d+)\/?$/i;
function d$t(e2) {
  return !!f$u.test(e2);
}
function m$v(r2) {
  if (t$1W(r2))
    return null;
  const n2 = j$B(r2), s2 = n2.path.match(f$u) || n2.path.match(v$i);
  if (!s2)
    return null;
  const [, l2, u2, i2, o2] = s2, a2 = u2.indexOf("/");
  return { title: h$m(a2 !== -1 ? u2.slice(a2 + 1) : u2), serverType: c$S[i2.toLowerCase()], sublayer: o2 != null && o2 !== "" ? parseInt(o2, 10) : null, url: { path: l2 } };
}
function w$f(e2) {
  const r2 = j$B(e2).path.match(p$V);
  return r2 ? { serviceUrl: r2[1], sublayerId: Number(r2[2]) } : null;
}
function h$m(e2) {
  return (e2 = e2.replace(/\s*[/_]+\s*/g, " "))[0].toUpperCase() + e2.slice(1);
}
function y$k(e2, t2) {
  const n2 = [];
  if (e2) {
    const t3 = m$v(e2);
    r$1t(t3) && t3.title && n2.push(t3.title);
  }
  if (t2) {
    const e3 = h$m(t2);
    n2.push(e3);
  }
  if (n2.length === 2) {
    if (n2[0].toLowerCase().includes(n2[1].toLowerCase()))
      return n2[0];
    if (n2[1].toLowerCase().includes(n2[0].toLowerCase()))
      return n2[1];
  }
  return n2.join(" - ");
}
function g$n(e2) {
  if (!e2)
    return false;
  const r2 = ".arcgis.com/", t2 = "//services", n2 = "//tiles", s2 = "//features", l2 = (e2 = e2.toLowerCase()).includes(r2), u2 = e2.includes(t2) || e2.includes(n2) || e2.includes(s2);
  return l2 && u2;
}
function S$b(e2, r2) {
  return e2 ? Ct(At$1(e2, r2)) : e2;
}
function L$a(e2) {
  let { url: l2 } = e2;
  if (!l2)
    return { url: l2 };
  l2 = At$1(l2, e2.logger);
  const u2 = j$B(l2), i2 = m$v(u2.path);
  let o2;
  if (r$1t(i2))
    i2.sublayer != null && e2.layer.layerId == null && (o2 = i2.sublayer), l2 = i2.url.path;
  else if (e2.nonStandardUrlAllowed) {
    const e3 = w$f(u2.path);
    r$1t(e3) && (l2 = e3.serviceUrl, o2 = e3.sublayerId);
  }
  return { url: Ct(l2), layerId: o2 };
}
function b$f(e2, r2, t2, n2, s2) {
  f$18(r2, n2, "url", s2), n2.url && e2.layerId != null && (n2.url = G$c(n2.url, t2, e2.layerId.toString()));
}
function I$a(e2) {
  if (!e2)
    return false;
  const r2 = e2.toLowerCase(), t2 = r2.includes("/services/"), n2 = r2.includes("/mapserver/wmsserver"), s2 = r2.includes("/imageserver/wmsserver"), l2 = r2.includes("/wmsserver");
  return t2 && (n2 || s2 || l2);
}
const p$U = (p2) => {
  let c2 = class extends p2 {
    get title() {
      if (this._get("title") && this.originOf("title") !== "defaults")
        return this._get("title");
      if (this.url) {
        const t2 = m$v(this.url);
        if (r$1t(t2) && t2.title)
          return t2.title;
      }
      return this._get("title") || "";
    }
    set title(t2) {
      this._set("title", t2);
    }
    set url(t2) {
      this._set("url", S$b(t2, s$22.getLogger(this.declaredClass)));
    }
  };
  return e$1W([y$1o()], c2.prototype, "title", null), e$1W([y$1o({ type: String })], c2.prototype, "url", null), c2 = e$1W([n$2f("esri.layers.mixins.ArcGISService")], c2), c2;
};
const i$M = { read: { reader: n$1d }, write: { allowNull: true, writer: a$1o } }, n$N = (t2) => {
  let s2 = class extends t2 {
    constructor() {
      super(...arguments), this.blendMode = "normal", this.effect = null;
    }
  };
  return e$1W([y$1o({ type: ["average", "color-burn", "color-dodge", "color", "darken", "destination-atop", "destination-in", "destination-out", "destination-over", "difference", "exclusion", "hard-light", "hue", "invert", "lighten", "lighter", "luminosity", "minus", "multiply", "normal", "overlay", "plus", "reflect", "saturation", "screen", "soft-light", "source-atop", "source-in", "source-out", "vivid-light", "xor"], nonNullable: true, json: { read: false, write: false, origins: { "web-map": { read: true, write: true }, "portal-item": { read: true, write: true } } } })], s2.prototype, "blendMode", void 0), e$1W([y$1o({ json: { read: false, write: false, origins: { "web-map": i$M, "portal-item": i$M } } })], s2.prototype, "effect", void 0), s2 = e$1W([n$2f("esri.layers.mixins.BlendLayer")], s2), s2;
};
const o$B = (o2) => {
  let t2 = class extends o2 {
    constructor() {
      super(...arguments), this.customParameters = null;
    }
  };
  return e$1W([y$1o({ type: Object, json: { write: { overridePolicy: (r2) => ({ enabled: !!(r2 && Object.keys(r2).length > 0) }) } } })], t2.prototype, "customParameters", void 0), t2 = e$1W([n$2f("esri.layers.mixins.CustomParametersMixin")], t2), t2;
};
const d$s = new n$26.EventEmitter(), i$L = "esri.layers.mixins.EditBusLayer", l$K = Symbol(i$L);
function o$A(e2) {
  return e2 != null && typeof e2 == "object" && l$K in e2;
}
const a$V = (t2) => {
  var o2;
  let a2 = class extends t2 {
    constructor(...e2) {
      super(...e2), this[o2] = true, this.when().then(() => {
        this.own([d$s.on("edits", (e3) => {
          var _a2, _b2, _c2;
          const t3 = "layer" in e3 ? e3.layer : null, r2 = "layer" in e3 ? (_a2 = e3.layer) == null ? void 0 : _a2.url : e3.serviceUrl, d2 = "layer" in e3 ? (_b2 = e3.layer) == null ? void 0 : _b2.layerId : e3.layerId, i2 = e3.event;
          if (t3 === this || r2 !== this.url)
            return;
          if (d2 != null && this.layerId != null && d2 === this.layerId)
            return void this.emit("edits", y$1r(i2));
          const l2 = (_c2 = i2.editedFeatures) == null ? void 0 : _c2.find(({ layerId: e4 }) => e4 === this.layerId);
          if (l2) {
            const { adds: e4, updates: t4, deletes: r3 } = l2.editedFeatures, d3 = { edits: null, addedAttachments: [], deletedAttachments: [], updatedAttachments: [], addedFeatures: e4 ? e4.map(({ attributes: e5 }) => ({ objectId: this.objectIdField && e5[this.objectIdField], globalId: this.globalIdField && e5[this.globalIdField] })) : [], deletedFeatures: r3 ? r3.map(({ attributes: e5 }) => ({ objectId: this.objectIdField && e5[this.objectIdField], globalId: this.globalIdField && e5[this.globalIdField] })) : [], updatedFeatures: t4 ? t4.map(({ current: { attributes: e5 } }) => ({ objectId: this.objectIdField && e5[this.objectIdField], globalId: this.globalIdField && e5[this.globalIdField] })) : [], editedFeatures: y$1r(i2.editedFeatures) };
            this.emit("edits", d3);
          }
        })]);
      }, () => {
      });
    }
  };
  return o2 = l$K, a2 = e$1W([n$2f(i$L)], a2), a2;
};
var c$R;
const m$u = new s$1F({ esriSpatialRelIntersects: "intersects", esriSpatialRelContains: "contains", esriSpatialRelCrosses: "crosses", esriSpatialRelDisjoint: "disjoint", esriSpatialRelEnvelopeIntersects: "envelope-intersects", esriSpatialRelIndexIntersects: "index-intersects", esriSpatialRelOverlaps: "overlaps", esriSpatialRelTouches: "touches", esriSpatialRelWithin: "within", esriSpatialRelRelation: "relation" }), u$y = new s$1F({ esriSRUnit_Meter: "meters", esriSRUnit_Kilometer: "kilometers", esriSRUnit_Foot: "feet", esriSRUnit_StatuteMile: "miles", esriSRUnit_NauticalMile: "nautical-miles", esriSRUnit_USNauticalMile: "us-nautical-miles" });
let d$r = c$R = class extends l$1_ {
  constructor(e2) {
    super(e2), this.where = null, this.geometry = null, this.spatialRelationship = "intersects", this.distance = void 0, this.objectIds = null, this.units = null, this.timeExtent = null;
  }
  createQuery(e2 = {}) {
    const { where: t2, geometry: i2, spatialRelationship: r2, timeExtent: s2, objectIds: n2, units: a2, distance: l2 } = this;
    return new x$i(__spreadValues({ geometry: y$1r(i2), objectIds: y$1r(n2), spatialRelationship: r2, timeExtent: y$1r(s2), where: t2, units: a2, distance: l2 }, e2));
  }
  clone() {
    const { where: e2, geometry: t2, spatialRelationship: i2, timeExtent: r2, objectIds: s2, units: n2, distance: a2 } = this;
    return new c$R({ geometry: y$1r(t2), objectIds: y$1r(s2), spatialRelationship: i2, timeExtent: y$1r(r2), where: e2, units: n2, distance: a2 });
  }
};
e$1W([y$1o({ type: String, json: { write: true } })], d$r.prototype, "where", void 0), e$1W([y$1o({ types: i$29, json: { write: true } })], d$r.prototype, "geometry", void 0), e$1W([y$1o({ type: m$u.apiValues, json: { name: "spatialRel", read: { reader: m$u.read }, write: { allowNull: false, writer: m$u.write, overridePolicy() {
  return { enabled: r$1t(this.geometry) };
} } } })], d$r.prototype, "spatialRelationship", void 0), e$1W([y$1o({ type: Number, json: { write: { overridePolicy(e2) {
  return { enabled: e2 != null && this.geometry != null };
} } } })], d$r.prototype, "distance", void 0), e$1W([y$1o({ type: [Number], json: { write: true } })], d$r.prototype, "objectIds", void 0), e$1W([y$1o({ type: u$y.apiValues, json: { read: u$y.read, write: { writer: u$y.write, overridePolicy(e2) {
  return { enabled: e2 != null && this.geometry != null };
} } } })], d$r.prototype, "units", void 0), e$1W([y$1o({ type: T$b, json: { write: true } })], d$r.prototype, "timeExtent", void 0), d$r = c$R = e$1W([n$2f("esri.layers.support.FeatureFilter")], d$r);
const y$j = d$r;
var d$q;
const n$M = { read: { reader: n$1d }, write: { writer: a$1o, overridePolicy() {
  return { allowNull: this.excludedEffect != null, isRequired: this.excludedEffect == null };
} } }, a$U = { read: { reader: n$1d }, write: { writer: a$1o, overridePolicy() {
  return { allowNull: this.includedEffect != null, isRequired: this.includedEffect == null };
} } }, p$T = { name: "showExcludedLabels", default: true };
let m$t = d$q = class extends l$1_ {
  constructor(e2) {
    super(e2), this.filter = null, this.includedEffect = null, this.excludedEffect = null, this.excludedLabelsVisible = false;
  }
  write(e2, t2) {
    var _a2, _b2;
    const l2 = super.write(e2, t2);
    if (t2 == null ? void 0 : t2.origin) {
      if (l2.filter) {
        const e3 = Object.keys(l2.filter);
        if (e3.length > 1 || e3[0] !== "where")
          return (_a2 = t2.messages) == null ? void 0 : _a2.push(new s$1Z("web-document-write:unsupported-feature-effect", "Invalid feature effect 'filter'. A filter can only contain a 'where' property", { layer: t2.layer, effect: this })), null;
      }
      if ("showExcludedLabels" in l2)
        return (_b2 = t2.messages) == null ? void 0 : _b2.push(new s$1Z("web-document-write:unsupported-feature-effect", "Invalid value for property 'excludedLabelsVisible' which should always be 'true'", { layer: t2.layer, effect: this })), null;
    }
    return l2;
  }
  clone() {
    return new d$q({ filter: r$1t(this.filter) ? this.filter.clone() : null, includedEffect: this.includedEffect, excludedEffect: this.excludedEffect, excludedLabelsVisible: this.excludedLabelsVisible });
  }
};
e$1W([y$1o({ type: y$j, json: { write: { allowNull: true, writer(e2, r2, t2, l2) {
  const s2 = e2 == null ? void 0 : e2.write({}, l2);
  s2 && Object.keys(s2).length !== 0 ? o$1X(t2, s2, r2) : o$1X(t2, null, r2);
} } } })], m$t.prototype, "filter", void 0), e$1W([y$1o({ json: { write: true, origins: { "web-map": n$M, "portal-item": n$M } } })], m$t.prototype, "includedEffect", void 0), e$1W([y$1o({ json: { write: true, origins: { "web-map": a$U, "portal-item": a$U } } })], m$t.prototype, "excludedEffect", void 0), e$1W([y$1o({ type: Boolean, json: { write: true, name: "showExcludedLabels", origins: { "web-map": p$T, "portal-item": p$T } } })], m$t.prototype, "excludedLabelsVisible", void 0), m$t = d$q = e$1W([n$2f("esri.layers.support.FeatureEffect")], m$t);
const w$e = m$t;
const s$z = { write: { allowNull: true } }, p$S = (p2) => {
  let c2 = class extends p2 {
    constructor() {
      super(...arguments), this.featureEffect = null;
    }
  };
  return e$1W([y$1o({ type: w$e, json: { origins: { "web-map": s$z, "portal-item": s$z } } })], c2.prototype, "featureEffect", void 0), c2 = e$1W([n$2f("esri.layers.mixins.FeatureEffectLayer")], c2), c2;
};
var d$p;
const p$R = o$1w()({ orthometric: "gravity-related-height", gravity_related_height: "gravity-related-height", ellipsoidal: "ellipsoidal" }), u$x = p$R.jsonValues.slice();
v$W(u$x, "orthometric");
const g$m = o$1w()({ meter: "meters", foot: "feet", "us-foot": "us-feet", "clarke-foot": "clarke-feet", "clarke-yard": "clarke-yards", "clarke-link": "clarke-links", "sears-yard": "sears-yards", "sears-foot": "sears-feet", "sears-chain": "sears-chains", "benoit-1895-b-chain": "benoit-1895-b-chains", "indian-yard": "indian-yards", "indian-1937-yard": "indian-1937-yards", "gold-coast-foot": "gold-coast-feet", "sears-1922-truncated-chain": "sears-1922-truncated-chains", "50-kilometers": "50-kilometers", "150-kilometers": "150-kilometers" });
let m$s = d$p = class extends l$1_ {
  constructor(e2) {
    super(e2), this.heightModel = "gravity-related-height", this.heightUnit = "meters", this.vertCRS = null;
  }
  writeHeightModel(e2, t2, r2) {
    return p$R.write(e2, t2, r2);
  }
  readHeightModel(e2, t2, r2) {
    const o2 = p$R.read(e2);
    return o2 || (r2 && r2.messages && r2.messages.push(f$t(e2, { context: r2 })), null);
  }
  readHeightUnit(e2, t2, r2) {
    const o2 = g$m.read(e2);
    return o2 || (r2 && r2.messages && r2.messages.push(y$i(e2, { context: r2 })), null);
  }
  readHeightUnitService(e2, t2, r2) {
    const o2 = G$8(e2) || g$m.read(e2);
    return o2 || (r2 && r2.messages && r2.messages.push(y$i(e2, { context: r2 })), null);
  }
  readVertCRS(e2, t2) {
    return t2.vertCRS || t2.ellipsoid || t2.geoid;
  }
  clone() {
    return new d$p({ heightModel: this.heightModel, heightUnit: this.heightUnit, vertCRS: this.vertCRS });
  }
  equals(e2) {
    return !!e2 && (this === e2 || this.heightModel === e2.heightModel && this.heightUnit === e2.heightUnit && this.vertCRS === e2.vertCRS);
  }
  static deriveUnitFromSR(e2, t2) {
    const r2 = W$6(t2);
    return new d$p({ heightModel: e2.heightModel, heightUnit: r2, vertCRS: e2.vertCRS });
  }
  write(e2, t2) {
    return t2 = __spreadValues({ origin: "web-scene" }, t2), super.write(e2, t2);
  }
  static fromJSON(e2) {
    if (!e2)
      return null;
    const t2 = new d$p();
    return t2.read(e2, { origin: "web-scene" }), t2;
  }
};
function y$i(e2, t2) {
  return new t$1Q("height-unit:unsupported", `Height unit of value '${e2}' is not supported`, t2);
}
function f$t(e2, t2) {
  return new t$1Q("height-model:unsupported", `Height model of value '${e2}' is not supported`, t2);
}
e$1W([y$1o({ type: p$R.apiValues, constructOnly: true, json: { origins: { "web-scene": { type: u$x, default: "ellipsoidal" } } } })], m$s.prototype, "heightModel", void 0), e$1W([r$1h("web-scene", "heightModel")], m$s.prototype, "writeHeightModel", null), e$1W([o$1H(["web-scene", "service"], "heightModel")], m$s.prototype, "readHeightModel", null), e$1W([y$1o({ type: g$m.apiValues, constructOnly: true, json: { origins: { "web-scene": { type: g$m.jsonValues, write: g$m.write } } } })], m$s.prototype, "heightUnit", void 0), e$1W([o$1H("web-scene", "heightUnit")], m$s.prototype, "readHeightUnit", null), e$1W([o$1H("service", "heightUnit")], m$s.prototype, "readHeightUnitService", null), e$1W([y$1o({ type: String, constructOnly: true, json: { origins: { "web-scene": { write: true } } } })], m$s.prototype, "vertCRS", void 0), e$1W([o$1H("service", "vertCRS", ["vertCRS", "ellipsoid", "geoid"])], m$s.prototype, "readVertCRS", null), m$s = d$p = e$1W([n$2f("esri.geometry.HeightModelInfo")], m$s);
const v$h = m$s;
function a$T(t2) {
  if (!t2)
    return t2;
  const { start: i2, end: o2 } = t2;
  return new T$b({ start: r$1t(i2) ? n$16(i2, -i2.getTimezoneOffset(), "minutes") : i2, end: r$1t(o2) ? n$16(o2, -o2.getTimezoneOffset(), "minutes") : o2 });
}
function f$s(t2) {
  if (!t2)
    return t2;
  const { start: i2, end: o2 } = t2;
  return new T$b({ start: r$1t(i2) ? n$16(i2, i2.getTimezoneOffset(), "minutes") : i2, end: r$1t(o2) ? n$16(o2, o2.getTimezoneOffset(), "minutes") : o2 });
}
var i$K;
let p$Q = i$K = class extends l$1_ {
  constructor(r2) {
    super(r2);
  }
  async collectRequiredFields(r2, e2) {
    return S$C(r2, e2, this.expression);
  }
  clone() {
    return new i$K({ expression: this.expression, title: this.title });
  }
  equals(r2) {
    return this.expression === r2.expression && this.title === r2.title;
  }
};
e$1W([y$1o({ type: String, json: { write: true } })], p$Q.prototype, "expression", void 0), e$1W([y$1o({ type: String, json: { write: true } })], p$Q.prototype, "title", void 0), p$Q = i$K = e$1W([n$2f("esri.layers.support.FeatureExpressionInfo")], p$Q);
const c$Q = p$Q;
function r$w(n2) {
  return 1 / (m$G[n2] || 1);
}
function e$w() {
  const n2 = Object.keys(m$G);
  return n2.sort(), n2;
}
const o$z = e$w();
var m$r;
const d$o = o$1w()({ onTheGround: "on-the-ground", relativeToGround: "relative-to-ground", relativeToScene: "relative-to-scene", absoluteHeight: "absolute-height" }), c$P = new s$1F({ foot: "feet", kilometer: "kilometers", meter: "meters", mile: "miles", "us-foot": "us-feet", yard: "yards" });
let h$l = m$r = class extends l$1_ {
  constructor(e2) {
    super(e2), this.offset = null;
  }
  readFeatureExpressionInfo(e2, r2) {
    return e2 != null ? e2 : r2.featureExpression && r2.featureExpression.value === 0 ? { expression: "0" } : void 0;
  }
  writeFeatureExpressionInfo(e2, r2, o2, t2) {
    r2[o2] = e2.write({}, t2), e2.expression === "0" && (r2.featureExpression = { value: 0 });
  }
  get mode() {
    const { offset: e2, featureExpressionInfo: r2 } = this;
    return this._isOverridden("mode") ? this._get("mode") : r$1t(e2) || r2 ? "relative-to-ground" : "on-the-ground";
  }
  set mode(e2) {
    this._override("mode", e2);
  }
  set unit(e2) {
    this._set("unit", e2);
  }
  write(e2, r2) {
    return this.offset || this.mode || this.featureExpressionInfo || this.unit ? super.write(e2, r2) : null;
  }
  clone() {
    return new m$r({ mode: this.mode, offset: this.offset, featureExpressionInfo: this.featureExpressionInfo ? this.featureExpressionInfo.clone() : void 0, unit: this.unit });
  }
  equals(e2) {
    return this.mode === e2.mode && this.offset === e2.offset && this.unit === e2.unit && y$1u(this.featureExpressionInfo, e2.featureExpressionInfo);
  }
};
e$1W([y$1o({ type: c$Q, json: { write: true } })], h$l.prototype, "featureExpressionInfo", void 0), e$1W([o$1H("featureExpressionInfo", ["featureExpressionInfo", "featureExpression"])], h$l.prototype, "readFeatureExpressionInfo", null), e$1W([r$1h("featureExpressionInfo", { featureExpressionInfo: { type: c$Q }, "featureExpression.value": { type: [0] } })], h$l.prototype, "writeFeatureExpressionInfo", null), e$1W([y$1o({ type: d$o.apiValues, nonNullable: true, json: { type: d$o.jsonValues, read: d$o.read, write: { writer: d$o.write, isRequired: true } } })], h$l.prototype, "mode", null), e$1W([y$1o({ type: Number, json: { write: true } })], h$l.prototype, "offset", void 0), e$1W([y$1o({ type: o$z, json: { type: String, read: c$P.read, write: c$P.write } })], h$l.prototype, "unit", null), h$l = m$r = e$1W([n$2f("esri.layers.support.ElevationInfo")], h$l);
const x$e = h$l;
const l$J = { type: Boolean, value: true, json: { origins: { service: { read: false, write: false }, "web-map": { read: false, write: false } }, name: "screenSizePerspective", write: true } }, p$P = { type: Boolean, value: true, json: { name: "disablePopup", read: { reader: (e2, r2) => !r2.disablePopup }, write: { enabled: true, writer(e2, r2, i2) {
  r2[i2] = !e2;
} } } }, m$q = { type: Boolean, value: true, nonNullable: true, json: { name: "showLabels", write: true } }, f$r = { type: String, json: { origins: { "portal-item": { write: false } }, write: { isRequired: true, ignoreOrigin: true, writer: f$18 } } }, c$O = { type: Boolean, value: true, nonNullable: true, json: { origins: { service: { read: { enabled: false } } }, name: "showLegend", write: true } }, d$n = { value: null, type: x$e, json: { origins: { service: { name: "elevationInfo", write: true } }, name: "layerDefinition.elevationInfo", write: true } };
function y$h(e2) {
  return { type: e2, readOnly: true, json: { origins: { service: { read: true } }, read: false } };
}
const w$d = { type: Number, json: { origins: { "web-document": { write: true, read: true }, "portal-item": { write: true } } } }, u$w = __spreadProps(__spreadValues({}, w$d), { json: __spreadProps(__spreadValues({}, w$d.json), { origins: { "web-document": __spreadProps(__spreadValues({}, w$d.json.origins["web-document"]), { write: { enabled: true, target: { opacity: { type: Number }, "layerDefinition.drawingInfo.transparency": { type: Number } } } }) }, read: { source: ["layerDefinition.drawingInfo.transparency", "drawingInfo.transparency"], reader: (e2, r2, i2) => i2 && i2.origin !== "service" || !r2.drawingInfo || r2.drawingInfo.transparency === void 0 ? r2.layerDefinition && r2.layerDefinition.drawingInfo && r2.layerDefinition.drawingInfo.transparency !== void 0 ? r$$(r2.layerDefinition.drawingInfo.transparency) : void 0 : r$$(r2.drawingInfo.transparency) } }) }), g$l = { type: T$b, readOnly: true, get() {
  var _a2, _b2;
  if (!((_a2 = this.layer) == null ? void 0 : _a2.timeInfo))
    return null;
  const { datesInUnknownTimezone: e2, timeOffset: r2, useViewTime: i2 } = this.layer, n2 = (_b2 = this.view) == null ? void 0 : _b2.timeExtent;
  let a2 = this.layer.timeExtent;
  e2 && (a2 = f$s(a2));
  let s2 = i2 ? n2 && a2 ? n2.intersection(a2) : n2 || a2 : a2;
  if (!s2 || s2.isEmpty || s2.isAllTime)
    return s2;
  r2 && (s2 = s2.offset(-r2.value, r2.unit)), e2 && (s2 = a$T(s2));
  const l2 = this._get("timeExtent");
  return s2.equals(l2) ? l2 : s2;
} }, b$e = { type: w$J, readOnly: true, json: { origins: { service: { read: { source: ["fullExtent", "spatialReference"], reader: (e2, n2) => {
  const t2 = w$J.fromJSON(e2);
  return n2.spatialReference != null && typeof n2.spatialReference == "object" && (t2.spatialReference = k$p.fromJSON(n2.spatialReference)), t2;
} } } }, read: false } }, j$9 = { type: String, json: { origins: { service: { read: false }, "portal-item": { read: false } } } }, v$g = { type: Number, json: { origins: { service: { write: { enabled: false } } }, read: { source: "layerDefinition.minScale" }, write: { target: "layerDefinition.minScale" } } }, I$9 = { type: Number, json: { origins: { service: { write: { enabled: false } } }, read: { source: "layerDefinition.maxScale" }, write: { target: "layerDefinition.maxScale" } } }, D$5 = { json: { write: { ignoreOrigin: true }, origins: { "web-map": { read: false, write: false } } } };
let p$O = class extends i$28(l$1_) {
  constructor(o2) {
    super(o2);
  }
};
e$1W([y$1o({ constructOnly: true, json: { write: true } })], p$O.prototype, "name", void 0), e$1W([y$1o({ constructOnly: true, json: { write: true } })], p$O.prototype, "fields", void 0), e$1W([y$1o({ constructOnly: true, json: { write: true } })], p$O.prototype, "isAscending", void 0), e$1W([y$1o({ constructOnly: true, json: { write: true } })], p$O.prototype, "indexType", void 0), e$1W([y$1o({ constructOnly: true, json: { write: true } })], p$O.prototype, "isUnique", void 0), e$1W([y$1o({ constructOnly: true, json: { write: true } })], p$O.prototype, "description", void 0), p$O = e$1W([n$2f("esri.layers.support.FeatureIndex")], p$O);
const i$J = new s$1F({ esriGeometryPoint: "point", esriGeometryMultipoint: "multipoint", esriGeometryPolyline: "polyline", esriGeometryPolygon: "polygon", esriGeometryMultiPatch: "multipatch" }), c$N = { name: "supportsName", size: "supportsSize", contentType: "supportsContentType", keywords: "supportsKeywords", exifInfo: "supportsExifInfo" };
function l$I(t2, e2, r2) {
  return !!(t2 && t2.hasOwnProperty(e2) ? t2[e2] : r2);
}
function d$m(t2, e2, r2) {
  return t2 && t2.hasOwnProperty(e2) ? t2[e2] : r2;
}
function y$g(t2) {
  var _a2;
  const e2 = (_a2 = t2 == null ? void 0 : t2.supportedSpatialAggregationStatistics) == null ? void 0 : _a2.map((t3) => t3.toLowerCase());
  return { envelope: !!(e2 == null ? void 0 : e2.includes("envelopeaggregate")), centroid: !!(e2 == null ? void 0 : e2.includes("centroidaggregate")), convexHull: !!(e2 == null ? void 0 : e2.includes("convexhullaggregate")) };
}
function m$p(t2, e2) {
  var _a2;
  const r2 = (_a2 = t2 == null ? void 0 : t2.supportedOperationsWithCacheHint) == null ? void 0 : _a2.map((t3) => t3.toLowerCase());
  return !!(r2 == null ? void 0 : r2.includes(e2.toLowerCase()));
}
function h$k(t2, e2, r2) {
  return { analytics: f$q(e2), attachment: w$c(e2), data: g$k(e2), metadata: C$8(e2), operations: b$d(e2.capabilities || t2, e2, r2), query: A$4(e2, r2), queryRelated: R$6(e2), queryTopFeatures: S$a(e2), editing: Q$2(e2) };
}
function f$q(t2) {
  return { supportsCacheHint: m$p(t2.advancedQueryCapabilities, "queryAnalytics") };
}
function w$c(t2) {
  const e2 = t2.attachmentProperties, r2 = { supportsName: false, supportsSize: false, supportsContentType: false, supportsKeywords: false, supportsExifInfo: false, supportsCacheHint: m$p(t2.advancedQueryCapabilities, "queryAttachments"), supportsResize: l$I(t2, "supportsAttachmentsResizing", false) };
  return e2 && Array.isArray(e2) && e2.forEach((t3) => {
    const e3 = c$N[t3.name];
    e3 && (r2[e3] = !!t3.isEnabled);
  }), r2;
}
function g$k(t2) {
  return { isVersioned: l$I(t2, "isDataVersioned", false), supportsAttachment: l$I(t2, "hasAttachments", false), supportsM: l$I(t2, "hasM", false), supportsZ: l$I(t2, "hasZ", false) };
}
function C$8(t2) {
  return { supportsAdvancedFieldProperties: l$I(t2, "supportsFieldDescriptionProperty", false) };
}
function b$d(t2, e2, s2) {
  const a2 = t2 ? t2.toLowerCase().split(",").map((t3) => t3.trim()) : [], n2 = s2 ? m$v(s2) : null, p2 = a2.includes(r$1t(n2) && n2.serverType === "MapServer" ? "data" : "query"), u2 = a2.includes("editing") && !e2.datesInUnknownTimezone;
  let i2 = u2 && a2.includes("create"), c2 = u2 && a2.includes("delete"), d2 = u2 && a2.includes("update");
  const y2 = a2.includes("changetracking"), m2 = e2.advancedQueryCapabilities;
  return u2 && !(i2 || c2 || d2) && (i2 = c2 = d2 = true), { supportsCalculate: l$I(e2, "supportsCalculate", false), supportsTruncate: l$I(e2, "supportsTruncate", false), supportsValidateSql: l$I(e2, "supportsValidateSql", false), supportsAdd: i2, supportsDelete: c2, supportsEditing: u2, supportsChangeTracking: y2, supportsQuery: p2, supportsQueryAnalytics: l$I(m2, "supportsQueryAnalytic", false), supportsQueryAttachments: l$I(m2, "supportsQueryAttachments", false), supportsQueryTopFeatures: l$I(m2, "supportsTopFeaturesQuery", false), supportsResizeAttachments: l$I(e2, "supportsAttachmentsResizing", false), supportsSync: a2.includes("sync"), supportsUpdate: d2, supportsExceedsLimitStatistics: l$I(e2, "supportsExceedsLimitStatistics", false) };
}
function A$4(t2, e2) {
  const r2 = t2.advancedQueryCapabilities, s2 = t2.ownershipBasedAccessControlForFeatures, o2 = t2.archivingInfo, n2 = B$6(t2), p2 = e2 == null ? void 0 : e2.includes("MapServer"), u2 = !has("mapserver-pbf-enabled") && p2 && (n2 != null ? n2 : 0) < 10.81, i2 = g$n(e2), c2 = (t2.supportedQueryFormats || "").split(",").reduce((t3, e3) => {
    const r3 = e3.toLowerCase().trim();
    return r3 && t3.add(r3), t3;
  }, new Set());
  return { supportsStatistics: l$I(r2, "supportsStatistics", t2.supportsStatistics), supportsPercentileStatistics: l$I(r2, "supportsPercentileStatistics", false), supportsSpatialAggregationStatistics: l$I(r2, "supportsSpatialAggregationStatistics", false), supportedSpatialAggregationStatistics: y$g(r2), supportsCentroid: l$I(r2, "supportsReturningGeometryCentroid", false), supportsDistance: l$I(r2, "supportsQueryWithDistance", false), supportsDistinct: l$I(r2, "supportsDistinct", t2.supportsAdvancedQueries), supportsExtent: l$I(r2, "supportsReturningQueryExtent", false), supportsGeometryProperties: l$I(r2, "supportsReturningGeometryProperties", false), supportsHavingClause: l$I(r2, "supportsHavingClause", false), supportsOrderBy: l$I(r2, "supportsOrderBy", t2.supportsAdvancedQueries), supportsPagination: l$I(r2, "supportsPagination", false), supportsQuantization: l$I(t2, "supportsCoordinatesQuantization", false), supportsQuantizationEditMode: l$I(t2, "supportsQuantizationEditMode", false), supportsQueryGeometry: l$I(t2, "supportsReturningQueryGeometry", false), supportsResultType: l$I(r2, "supportsQueryWithResultType", false), supportsMaxRecordCountFactor: l$I(r2, "supportsMaxRecordCountFactor", false), supportsSqlExpression: l$I(r2, "supportsSqlExpression", false), supportsStandardizedQueriesOnly: l$I(t2, "useStandardizedQueries", false), supportsTopFeaturesQuery: l$I(r2, "supportsTopFeaturesQuery", false), supportsQueryByOthers: l$I(s2, "allowOthersToQuery", true), supportsHistoricMoment: l$I(o2, "supportsQueryWithHistoricMoment", false), supportsFormatPBF: !u2 && c2.has("pbf"), supportsDisjointSpatialRelationship: l$I(r2, "supportsDisjointSpatialRel", false), supportsCacheHint: l$I(r2, "supportsQueryWithCacheHint", false) || m$p(r2, "query"), supportsDefaultSpatialReference: l$I(r2, "supportsDefaultSR", false), supportsCompactGeometry: i2, supportsFullTextSearch: l$I(r2, "supportsFullTextSearch", false), maxRecordCountFactor: d$m(t2, "maxRecordCountFactor", void 0), maxRecordCount: d$m(t2, "maxRecordCount", void 0), standardMaxRecordCount: d$m(t2, "standardMaxRecordCount", void 0), tileMaxRecordCount: d$m(t2, "tileMaxRecordCount", void 0) };
}
function R$6(t2) {
  const e2 = t2.advancedQueryCapabilities, r2 = l$I(e2, "supportsAdvancedQueryRelated", false);
  return { supportsPagination: l$I(e2, "supportsQueryRelatedPagination", false), supportsCount: r2, supportsOrderBy: r2, supportsCacheHint: m$p(e2, "queryRelated") };
}
function S$a(t2) {
  return { supportsCacheHint: m$p(t2.advancedQueryCapabilities, "queryTopFilter") };
}
function Q$2(t2) {
  const e2 = t2.ownershipBasedAccessControlForFeatures;
  return { supportsGeometryUpdate: l$I(t2, "allowGeometryUpdates", true), supportsGlobalId: l$I(t2, "supportsApplyEditsWithGlobalIds", false), supportsReturnServiceEditsInSourceSpatialReference: l$I(t2, "supportsReturnServiceEditsInSourceSR", false), supportsRollbackOnFailure: l$I(t2, "supportsRollbackOnFailureParameter", false), supportsUpdateWithoutM: l$I(t2, "allowUpdateWithoutMValues", false), supportsUploadWithItemId: l$I(t2, "supportsAttachmentsByUploadId", false), supportsDeleteByAnonymous: l$I(e2, "allowAnonymousToDelete", true), supportsDeleteByOthers: l$I(e2, "allowOthersToDelete", true), supportsUpdateByAnonymous: l$I(e2, "allowAnonymousToUpdate", true), supportsUpdateByOthers: l$I(e2, "allowOthersToUpdate", true) };
}
async function F$4(e2, r2, s2, o2) {
  const { source: a2 } = await e2.load();
  if (await q$3(e2, r2, o2), !a2.addAttachment)
    throw new s$1Z(o2, "Layer source does not support addAttachment capability");
  return a2.addAttachment(r2, s2);
}
function q$3(e2, r2, s2) {
  const { attributes: o2 } = r2, { objectIdField: a2 } = e2;
  return e2.get("capabilities.data.supportsAttachment") ? r2 ? o2 ? a2 && o2[a2] ? Promise.resolve() : Promise.reject(new s$1Z(s2, `feature is missing the identifying attribute ${a2}`)) : Promise.reject(new s$1Z(s2, "'attributes' are required on a feature to query attachments")) : Promise.reject(new s$1Z(s2, "A feature is required to add/delete/update attachments")) : Promise.reject(new s$1Z(s2, "this layer doesn't support attachments"));
}
async function x$d(e2, r2, s2, o2, a2) {
  const { source: n2 } = await e2.load();
  if (await q$3(e2, r2, a2), !n2.updateAttachment)
    throw new s$1Z(a2, "Layer source does not support updateAttachment capability");
  return n2.updateAttachment(r2, s2, o2);
}
async function P$8(t2, e2, r2) {
  const s2 = await import("./editingSupport.js"), o2 = await t2.load();
  return s2.applyEdits(o2, o2.source, e2, r2);
}
async function O$5(e2, r2, s2, o2) {
  const { source: a2 } = await e2.load();
  if (await q$3(e2, r2, o2), !a2.deleteAttachments)
    throw new s$1Z(o2, "Layer source does not support deleteAttachments capability");
  return a2.deleteAttachments(r2, s2);
}
async function v$f(e2, r2, s2) {
  const { source: o2 } = await e2.load({ signal: r2 == null ? void 0 : r2.signal });
  if (!o2.fetchRecomputedExtents)
    throw new s$1Z(s2, "Layer source does not support fetchUpdates capability");
  return o2.fetchRecomputedExtents(r2);
}
async function E$9(e2, r2, s2, o2) {
  var _a2, _b2;
  r2 = c$1y.from(r2);
  const { source: a2, capabilities: p2 } = await e2.load();
  if (!((_a2 = p2 == null ? void 0 : p2.data) == null ? void 0 : _a2.supportsAttachment))
    throw new s$1Z(o2, "this layer doesn't support attachments");
  const { attachmentTypes: u2, objectIds: i2, globalIds: c2, num: l2, size: d2, start: y2, where: m2 } = r2;
  if (!((_b2 = p2 == null ? void 0 : p2.operations) == null ? void 0 : _b2.supportsQueryAttachments)) {
    const e3 = i2 && i2.length > 1, s3 = u2 && u2.length, a3 = c2 && c2.length, n2 = d2 && d2.length;
    if (e3 || s3 || a3 || n2 || l2 || y2 || m2)
      throw new s$1Z(o2, "when 'supportsQueryAttachments' is false, only objectIds of length 1 are supported", r2);
  }
  if (!(i2 == null ? void 0 : i2.length) && !m2)
    throw new s$1Z(o2, "'objectIds' or 'where' are required to perform attachment query", r2);
  if (!a2.queryAttachments)
    throw new s$1Z(o2, "Layer source does not support queryAttachments capability", r2);
  return a2.queryAttachments(r2);
}
async function I$8(e2, r2, s2, o2) {
  var _a2;
  const { source: a2 } = await e2.load();
  if (!a2.queryObjectIds)
    throw new s$1Z(o2, "Layer source does not support queryObjectIds capability");
  return a2.queryObjectIds((_a2 = x$i.from(r2)) != null ? _a2 : e2.createQuery(), s2);
}
async function T$3(e2, r2, s2, o2) {
  var _a2;
  const { source: a2 } = await e2.load();
  if (!a2.queryFeatureCount)
    throw new s$1Z(o2, "Layer source does not support queryFeatureCount capability");
  return a2.queryFeatureCount((_a2 = x$i.from(r2)) != null ? _a2 : e2.createQuery(), s2);
}
async function j$8(e2, r2, s2, o2) {
  var _a2;
  const { source: a2 } = await e2.load();
  if (!a2.queryExtent)
    throw new s$1Z(o2, "Layer source does not support queryExtent capability");
  return a2.queryExtent((_a2 = x$i.from(r2)) != null ? _a2 : e2.createQuery(), s2);
}
async function M$4(e2, r2, s2, o2) {
  const { source: a2 } = await e2.load();
  if (!a2.queryRelatedFeatures)
    throw new s$1Z(o2, "Layer source does not support queryRelatedFeatures capability");
  return a2.queryRelatedFeatures(d$B.from(r2), s2);
}
async function D$4(e2, r2, s2, o2) {
  const { source: a2 } = await e2.load();
  if (!a2.queryRelatedFeaturesCount)
    throw new s$1Z(o2, "Layer source does not support queryRelatedFeaturesCount capability");
  return a2.queryRelatedFeaturesCount(d$B.from(r2), s2);
}
async function G$4(t2) {
  const e2 = t2.source;
  if (e2 == null ? void 0 : e2.refresh)
    try {
      const { dataChanged: s2, updates: o2 } = await e2.refresh();
      if (r$1t(o2) && (t2.sourceJSON = __spreadValues(__spreadValues({}, t2.sourceJSON), o2), t2.read(o2, { origin: "service", url: t2.parsedUrl })), s2)
        return true;
    } catch {
    }
  if (t2.definitionExpression)
    try {
      return (await r$x(t2.definitionExpression, t2.fieldsIndex)).hasDateFunctions;
    } catch {
    }
  return false;
}
function L$9(t2) {
  const e2 = new x$i(), r2 = t2.get("capabilities.data"), s2 = t2.get("capabilities.query");
  e2.historicMoment = t2.historicMoment, e2.gdbVersion = t2.gdbVersion, e2.returnGeometry = true, s2 && (e2.compactGeometryEnabled = s2.supportsCompactGeometry, e2.defaultSpatialReferenceEnabled = s2.supportsDefaultSpatialReference), r2 && (r2.supportsZ && t2.returnZ != null && (e2.returnZ = t2.returnZ), r2.supportsM && t2.returnM != null && (e2.returnM = t2.returnM)), e2.outFields = ["*"];
  const { timeOffset: o2, timeExtent: a2 } = t2;
  return e2.timeExtent = o2 != null && a2 != null ? a2.offset(-o2.value, o2.unit) : a2 || null, e2.multipatchOption = t2.geometryType === "multipatch" ? "xyFootprint" : null, e2;
}
function z$8(t2) {
  const { globalIdField: e2, fields: r2 } = t2;
  if (e2)
    return e2;
  if (r2) {
    for (const s2 of r2)
      if (s2.type === "esriFieldTypeGlobalID")
        return s2.name;
  }
}
function U$5(t2) {
  const { objectIdField: e2, fields: r2 } = t2;
  if (e2)
    return e2;
  if (r2) {
    for (const s2 of r2)
      if (s2.type === "esriFieldTypeOID")
        return s2.name;
  }
}
function B$6(t2) {
  return t2.currentVersion ? t2.currentVersion : t2.hasOwnProperty("capabilities") || t2.hasOwnProperty("drawingInfo") || t2.hasOwnProperty("hasAttachments") || t2.hasOwnProperty("htmlPopupType") || t2.hasOwnProperty("relationships") || t2.hasOwnProperty("timeInfo") || t2.hasOwnProperty("typeIdField") || t2.hasOwnProperty("types") ? 10 : 9.3;
}
let a$S = class extends i$28(l$1_) {
  constructor(e2) {
    super(e2), this.shapeAreaField = null, this.shapeLengthField = null, this.units = null;
  }
};
e$1W([y$1o({ type: String, json: { read: { source: "shapeAreaFieldName" } } })], a$S.prototype, "shapeAreaField", void 0), e$1W([y$1o({ type: String, json: { read: { source: "shapeLengthFieldName" } } })], a$S.prototype, "shapeLengthField", void 0), e$1W([y$1o({ type: String, json: { read: (e2) => le$2.read(e2) || me$3.read(e2) } })], a$S.prototype, "units", void 0), a$S = e$1W([n$2f("esri.layers.support.GeometryFieldsInfo")], a$S);
const c$M = a$S;
var l$H;
let i$I = l$H = class extends l$1_ {
  constructor(o2) {
    super(o2), this.floorField = null, this.viewAllMode = false, this.viewAllLevelIds = new j$F();
  }
  clone() {
    return new l$H({ floorField: this.floorField, viewAllMode: this.viewAllMode, viewAllLevelIds: this.viewAllLevelIds });
  }
};
e$1W([y$1o({ type: String, json: { write: true } })], i$I.prototype, "floorField", void 0), e$1W([y$1o({ json: { read: false, write: false } })], i$I.prototype, "viewAllMode", void 0), e$1W([y$1o({ json: { read: false, write: false } })], i$I.prototype, "viewAllLevelIds", void 0), i$I = l$H = e$1W([n$2f("esri.layers.support.LayerFloorInfo")], i$I);
const p$N = i$I;
const n$L = new s$1F({ esriRelCardinalityOneToOne: "one-to-one", esriRelCardinalityOneToMany: "one-to-many", esriRelCardinalityManyToMany: "many-to-many" }), a$R = new s$1F({ esriRelRoleOrigin: "origin", esriRelRoleDestination: "destination" });
let l$G = class extends i$28(l$1_) {
  constructor(e2) {
    super(e2), this.cardinality = null, this.composite = null, this.id = null, this.keyField = null, this.keyFieldInRelationshipTable = null, this.name = null, this.relatedTableId = null, this.relationshipTableId = null, this.role = null;
  }
};
e$1W([y$1o({ json: { read: n$L.read, write: n$L.write } })], l$G.prototype, "cardinality", void 0), e$1W([y$1o({ json: { read: true, write: true } })], l$G.prototype, "composite", void 0), e$1W([y$1o({ json: { read: true, write: true } })], l$G.prototype, "id", void 0), e$1W([y$1o({ json: { read: true, write: true } })], l$G.prototype, "keyField", void 0), e$1W([y$1o({ json: { read: true, write: true } })], l$G.prototype, "keyFieldInRelationshipTable", void 0), e$1W([y$1o({ json: { read: true, write: true } })], l$G.prototype, "name", void 0), e$1W([y$1o({ json: { read: true, write: true } })], l$G.prototype, "relatedTableId", void 0), e$1W([y$1o({ json: { read: true, write: true } })], l$G.prototype, "relationshipTableId", void 0), e$1W([y$1o({ json: { read: a$R.read, write: a$R.write } })], l$G.prototype, "role", void 0), l$G = e$1W([n$2f("esri.layers.support.Relationship")], l$G);
const p$M = l$G;
const M$3 = (M2) => {
  let E2 = class extends M2 {
    constructor() {
      super(...arguments), this.capabilities = null, this.copyright = null, this.datesInUnknownTimezone = false, this.displayField = null, this.definitionExpression = null, this.editFieldsInfo = null, this.editingInfo = null, this.elevationInfo = null, this.floorInfo = null, this.fullExtent = null, this.gdbVersion = null, this.geometryFieldsInfo = null, this.geometryType = null, this.hasM = void 0, this.hasZ = void 0, this.heightModelInfo = null, this.historicMoment = null, this.isTable = false, this.layerId = void 0, this.minScale = 0, this.maxScale = 0, this.globalIdField = null, this.objectIdField = null, this.relationships = null, this.sourceJSON = null, this.returnM = void 0, this.returnZ = void 0, this.serviceDefinitionExpression = null, this.spatialReference = k$p.WGS84, this.subtypeField = null, this.trackIdField = null, this.indexes = new (j$F.ofType(p$O))(), this.userIsAdmin = false, this.version = void 0;
    }
    readCapabilitiesFromService(e2, o2) {
      return h$k(e2, o2, this.url);
    }
    readEditingInfo(e2, o2) {
      const { editingInfo: r2 } = o2;
      return r2 ? { lastEditDate: r2.lastEditDate != null ? new Date(r2.lastEditDate) : null } : null;
    }
    readIsTableFromService(e2, o2) {
      return o2.type === "Table";
    }
    readMinScale(e2, o2) {
      return o2.effectiveMinScale || e2 || 0;
    }
    readMaxScale(e2, o2) {
      return o2.effectiveMaxScale || e2 || 0;
    }
    readGlobalIdFieldFromService(e2, o2) {
      return z$8(o2);
    }
    readObjectIdFieldFromService(e2, o2) {
      return U$5(o2);
    }
    readServiceDefinitionExpression(e2, o2) {
      return o2.definitionQuery || o2.definitionExpression;
    }
    set url(e2) {
      const o2 = L$a({ layer: this, url: e2, nonStandardUrlAllowed: true, logger: s$22.getLogger(this.declaredClass) });
      this._set("url", o2.url), o2.layerId != null && this._set("layerId", o2.layerId);
    }
    writeUrl(e2, o2, r2, t2) {
      b$f(this, e2, null, o2, t2);
    }
    readVersion(e2, o2) {
      return B$6(o2);
    }
  };
  return e$1W([y$1o({ readOnly: true, json: { read: false, origins: { service: { read: { source: ["advancedQueryCapabilities", "allowGeometryUpdates", "allowUpdateWithoutMValues", "archivingInfo", "capabilities", "datesInUnknownTimezone", "hasAttachments", "hasM", "hasZ", "maxRecordCount", "maxRecordCountFactor", "ownershipBasedAccessControlForFeatures", "standardMaxRecordCount", "supportedQueryFormats", "supportsAdvancedQueries", "supportsApplyEditsWithGlobalIds", "supportsAttachmentsByUploadId", "supportsAttachmentsResizing", "supportsCalculate", "supportsCoordinatesQuantization", "supportsExceedsLimitStatistics", "supportsFieldDescriptionProperty", "supportsQuantizationEditMode", "supportsRollbackOnFailureParameter", "supportsStatistics", "supportsTruncate", "supportsValidateSql", "tileMaxRecordCount", "useStandardizedQueries"] } } } } })], E2.prototype, "capabilities", void 0), e$1W([o$1H("service", "capabilities")], E2.prototype, "readCapabilitiesFromService", null), e$1W([y$1o({ type: String, json: { origins: { service: { read: { source: "copyrightText" } } } } })], E2.prototype, "copyright", void 0), e$1W([y$1o({ type: Boolean })], E2.prototype, "datesInUnknownTimezone", void 0), e$1W([y$1o({ type: String, json: { origins: { service: { read: { source: "displayField" } } } } })], E2.prototype, "displayField", void 0), e$1W([y$1o({ type: String, json: { origins: { service: { read: false, write: false } }, name: "layerDefinition.definitionExpression", write: { enabled: true, allowNull: true } } })], E2.prototype, "definitionExpression", void 0), e$1W([y$1o({ readOnly: true })], E2.prototype, "editFieldsInfo", void 0), e$1W([y$1o({ readOnly: true })], E2.prototype, "editingInfo", void 0), e$1W([o$1H("editingInfo")], E2.prototype, "readEditingInfo", null), e$1W([y$1o((() => {
    const e2 = y$1r(d$n), o2 = e2.json.origins;
    return o2["web-map"] = { read: false, write: false }, o2["portal-item"] = { read: false, write: false }, e2;
  })())], E2.prototype, "elevationInfo", void 0), e$1W([y$1o({ type: p$N, json: { read: { source: "layerDefinition.floorInfo" }, write: { target: "layerDefinition.floorInfo" } } })], E2.prototype, "floorInfo", void 0), e$1W([y$1o({ type: w$J, json: { origins: { service: { read: { source: "extent" } } } } })], E2.prototype, "fullExtent", void 0), e$1W([y$1o()], E2.prototype, "gdbVersion", void 0), e$1W([y$1o({ readOnly: true, type: c$M, json: { read: { source: "geometryProperties" } } })], E2.prototype, "geometryFieldsInfo", void 0), e$1W([y$1o({ type: ["point", "polygon", "polyline", "multipoint", "multipatch", "mesh"], json: { origins: { service: { read: i$J.read } } } })], E2.prototype, "geometryType", void 0), e$1W([y$1o({ type: Boolean, json: { origins: { service: { read: true } } } })], E2.prototype, "hasM", void 0), e$1W([y$1o({ type: Boolean, json: { origins: { service: { read: true } } } })], E2.prototype, "hasZ", void 0), e$1W([y$1o({ readOnly: true, type: v$h })], E2.prototype, "heightModelInfo", void 0), e$1W([y$1o({ type: Date })], E2.prototype, "historicMoment", void 0), e$1W([y$1o({ readOnly: true })], E2.prototype, "isTable", void 0), e$1W([o$1H("service", "isTable", ["type"])], E2.prototype, "readIsTableFromService", null), e$1W([y$1o({ type: Number, json: { origins: { service: { read: { source: "id" } }, "portal-item": { read: false, write: { target: "id" } } }, read: false } })], E2.prototype, "layerId", void 0), e$1W([y$1o(v$g)], E2.prototype, "minScale", void 0), e$1W([o$1H("service", "minScale", ["minScale", "effectiveMinScale"])], E2.prototype, "readMinScale", null), e$1W([y$1o(I$9)], E2.prototype, "maxScale", void 0), e$1W([o$1H("service", "maxScale", ["maxScale", "effectiveMaxScale"])], E2.prototype, "readMaxScale", null), e$1W([y$1o({ type: String })], E2.prototype, "globalIdField", void 0), e$1W([o$1H("service", "globalIdField", ["globalIdField", "fields"])], E2.prototype, "readGlobalIdFieldFromService", null), e$1W([y$1o({ type: String })], E2.prototype, "objectIdField", void 0), e$1W([o$1H("service", "objectIdField", ["objectIdField", "fields"])], E2.prototype, "readObjectIdFieldFromService", null), e$1W([y$1o({ type: [p$M], readOnly: true })], E2.prototype, "relationships", void 0), e$1W([y$1o()], E2.prototype, "sourceJSON", void 0), e$1W([y$1o({ type: Boolean })], E2.prototype, "returnM", void 0), e$1W([y$1o({ type: Boolean })], E2.prototype, "returnZ", void 0), e$1W([y$1o({ readOnly: true })], E2.prototype, "serviceDefinitionExpression", void 0), e$1W([o$1H("service", "serviceDefinitionExpression", ["definitionQuery", "definitionExpression"])], E2.prototype, "readServiceDefinitionExpression", null), e$1W([y$1o({ type: k$p, json: { origins: { service: { read: { source: "extent.spatialReference" } } } } })], E2.prototype, "spatialReference", void 0), e$1W([y$1o({ type: String, readOnly: true, json: { origins: { service: { read: true } } } })], E2.prototype, "subtypeField", void 0), e$1W([y$1o({ type: String, json: { read: { source: "timeInfo.trackIdField" } } })], E2.prototype, "trackIdField", void 0), e$1W([y$1o({ readOnly: true, json: { write: false } })], E2.prototype, "serverGens", void 0), e$1W([y$1o({ type: j$F.ofType(p$O), readOnly: true })], E2.prototype, "indexes", void 0), e$1W([y$1o(f$r)], E2.prototype, "url", null), e$1W([r$1h("url")], E2.prototype, "writeUrl", null), e$1W([y$1o({ readOnly: true })], E2.prototype, "userIsAdmin", void 0), e$1W([y$1o({ json: { origins: { service: { read: true } }, read: false } })], E2.prototype, "version", void 0), e$1W([o$1H("service", "version", ["currentVersion", "capabilities", "drawingInfo", "hasAttachments", "htmlPopupType", "relationships", "timeInfo", "typeIdField", "types"])], E2.prototype, "readVersion", null), E2 = e$1W([n$2f("esri.layers.mixins.FeatureLayerBase")], E2), E2;
};
let p$L = class extends i$28(l$1_) {
  constructor(r2) {
    super(r2), this.expression = null, this.title = null, this.returnType = null;
  }
};
e$1W([y$1o({ type: String, json: { write: true } })], p$L.prototype, "expression", void 0), e$1W([y$1o({ type: String, json: { write: true } })], p$L.prototype, "title", void 0), e$1W([y$1o({ type: String, json: { write: true } })], p$L.prototype, "returnType", void 0), p$L = e$1W([n$2f("esri.layers.support.ExpressionInfo")], p$L);
const i$H = p$L;
var p$K;
let n$K = p$K = class extends l$1_ {
  constructor(t2) {
    super(t2), this.isAutoGenerated = false, this.name = null, this.alias = null, this.onStatisticField = null, this.onStatisticExpression = null, this.statisticType = null;
  }
  clone() {
    return new p$K({ name: this.name, alias: this.alias, isAutoGenerated: this.isAutoGenerated, onStatisticExpression: y$1r(this.onStatisticExpression), onStatisticField: this.onStatisticField, statisticType: this.statisticType });
  }
};
e$1W([y$1o({ type: Boolean, json: { write: true } })], n$K.prototype, "isAutoGenerated", void 0), e$1W([y$1o({ type: String, json: { write: true } })], n$K.prototype, "name", void 0), e$1W([y$1o({ type: String, json: { write: true } })], n$K.prototype, "alias", void 0), e$1W([y$1o({ type: String, json: { write: true } })], n$K.prototype, "onStatisticField", void 0), e$1W([y$1o({ type: i$H, json: { write: true } })], n$K.prototype, "onStatisticExpression", void 0), e$1W([y$1o({ type: String, json: { write: true } })], n$K.prototype, "statisticType", void 0), n$K = p$K = e$1W([n$2f("esri.layers.support.AggregateField")], n$K);
const a$Q = n$K;
let t$A = class extends l$1_ {
  constructor() {
    super(...arguments), this.type = null;
  }
};
e$1W([y$1o({ type: ["selection", "cluster", "binning"], readOnly: true, json: { read: false, write: true } })], t$A.prototype, "type", void 0), t$A = e$1W([n$2f("esri.layers.support.FeatureReduction")], t$A);
const n$J = "__begin__", r$v = "__end__", s$y = new RegExp(n$J, "ig"), t$z = new RegExp(r$v, "ig"), o$y = new RegExp("^" + n$J, "i"), i$G = new RegExp(r$v + "$", "i"), l$F = '"', a$P = l$F + " + ", c$L = " + " + l$F;
function p$J(e2) {
  return e2.replace(new RegExp("\\[", "g"), "{").replace(new RegExp("\\]", "g"), "}");
}
function u$v(e2) {
  return e2.replace(new RegExp("\\{", "g"), "[").replace(new RegExp("\\}", "g"), "]");
}
function x$c(e2) {
  const n2 = { expression: "", type: "none" };
  return e2.labelExpressionInfo ? e2.labelExpressionInfo.value ? (n2.expression = e2.labelExpressionInfo.value, n2.type = "conventional") : e2.labelExpressionInfo.expression && (n2.expression = e2.labelExpressionInfo.expression, n2.type = "arcade") : e2.labelExpression != null && (n2.expression = p$J(e2.labelExpression), n2.type = "conventional"), n2;
}
function f$p(e2) {
  const n2 = x$c(e2);
  if (!n2)
    return null;
  switch (n2.type) {
    case "conventional":
      return w$b(n2.expression);
    case "arcade":
      return n2.expression;
  }
  return null;
}
function g$j(e2) {
  const n2 = x$c(e2);
  if (!n2)
    return null;
  switch (n2.type) {
    case "conventional":
      return $$1(n2.expression);
    case "arcade":
      return _$e(n2.expression);
  }
  return null;
}
function w$b(p2) {
  let u2;
  return p2 ? (u2 = n$2m(p2, (e2) => n$J + '$feature["' + e2 + '"]' + r$v), u2 = o$y.test(u2) ? u2.replace(o$y, "") : l$F + u2, u2 = i$G.test(u2) ? u2.replace(i$G, "") : u2 + l$F, u2 = u2.replace(s$y, a$P).replace(t$z, c$L)) : u2 = '""', u2;
}
const E$8 = /^\s*\{([^}]+)\}\s*$/i;
function $$1(e2) {
  const n2 = e2.match(E$8);
  return n2 && n2[1].trim() || null;
}
const b$c = /^\s*(?:(?:\$feature\.(\w+))|(?:\$feature\[(["'])([\w\s]+)(\2)\]));?\s*$/i, m$o = /^\s*(?:(?:\$feature\.(\w+))|(?:\$feature\[(["'])([\w\s]+)(\2)\]));?\s*(?:DomainName\(\s*\$feature\s*,\s*(["'])(\1|\3)(\5)\s*\));?\s*$/i, R$5 = /^\s*(?:DomainName\(\s*\$feature\s*,\s*(["'])([\w\s]+)(\1)\s*\));?\s*$/i;
function _$e(e2) {
  if (!e2)
    return null;
  let n2 = b$c.exec(e2) || m$o.exec(e2);
  return n2 ? n2[1] || n2[3] : (n2 = R$5.exec(e2), n2 ? n2[2] : null);
}
var l$E;
let n$I = l$E = class extends l$1_ {
  constructor() {
    super(...arguments), this.expression = null, this.title = null, this.value = null;
  }
  readExpression(r2, e2) {
    return e2.value ? w$b(e2.value) : r2;
  }
  writeExpression(r2, e2, s2) {
    this.value != null && (r2 = w$b(this.value)), r2 != null && (e2[s2] = r2);
  }
  clone() {
    return new l$E({ expression: this.expression, title: this.title, value: this.value });
  }
};
e$1W([y$1o({ type: String, json: { write: { writerEnsuresNonNull: true } } })], n$I.prototype, "expression", void 0), e$1W([o$1H("expression", ["expression", "value"])], n$I.prototype, "readExpression", null), e$1W([r$1h("expression")], n$I.prototype, "writeExpression", null), e$1W([y$1o({ type: String, json: { write: true, origins: { "web-scene": { write: false } } } })], n$I.prototype, "title", void 0), e$1W([y$1o({ json: { read: false, write: false } })], n$I.prototype, "value", void 0), n$I = l$E = e$1W([n$2f("esri.layers.support.LabelExpressionInfo")], n$I);
const a$O = n$I;
const e$v = [252, 146, 31, 255], l$D = { type: "esriSMS", style: "esriSMSCircle", size: 6, color: e$v, outline: { type: "esriSLS", style: "esriSLSSolid", width: 0.75, color: [153, 153, 153, 255] } }, o$x = { type: "esriSLS", style: "esriSLSSolid", width: 0.75, color: e$v }, S$9 = { type: "esriSFS", style: "esriSFSSolid", color: [252, 146, 31, 196], outline: { type: "esriSLS", style: "esriSLSSolid", width: 0.75, color: [255, 255, 255, 191] } }, t$y = { type: "esriTS", color: [255, 255, 255, 255], font: { family: "arial-unicode-ms", size: 10, weight: "bold" }, horizontalAlignment: "center", kerning: true, haloColor: [0, 0, 0, 255], haloSize: 1, rotated: false, text: "", xoffset: 0, yoffset: 0, angle: 0 }, r$u = { type: "esriSMS", style: "esriSMSCircle", color: [0, 0, 0, 255], outline: null, size: 10.5 }, s$x = { type: "esriSLS", style: "esriSLSSolid", color: [0, 0, 0, 255], width: 1.5 }, y$f = { type: "esriSFS", style: "esriSFSSolid", color: [0, 0, 0, 255], outline: null };
const c$K = y$Z.fromJSON(l$D), u$u = m$1q.fromJSON(o$x), a$N = S$t.fromJSON(S$9), y$e = m$17.fromJSON(t$y);
const N$2 = y$Z.fromJSON(r$u), O$4 = m$1q.fromJSON(s$x), j$7 = S$t.fromJSON(y$f);
var y$d;
const d$l = new s$1F({ esriServerPointLabelPlacementAboveCenter: "above-center", esriServerPointLabelPlacementAboveLeft: "above-left", esriServerPointLabelPlacementAboveRight: "above-right", esriServerPointLabelPlacementBelowCenter: "below-center", esriServerPointLabelPlacementBelowLeft: "below-left", esriServerPointLabelPlacementBelowRight: "below-right", esriServerPointLabelPlacementCenterCenter: "center-center", esriServerPointLabelPlacementCenterLeft: "center-left", esriServerPointLabelPlacementCenterRight: "center-right", esriServerLinePlacementAboveAfter: "above-after", esriServerLinePlacementAboveAlong: "above-along", esriServerLinePlacementAboveBefore: "above-before", esriServerLinePlacementAboveStart: "above-start", esriServerLinePlacementAboveEnd: "above-end", esriServerLinePlacementBelowAfter: "below-after", esriServerLinePlacementBelowAlong: "below-along", esriServerLinePlacementBelowBefore: "below-before", esriServerLinePlacementBelowStart: "below-start", esriServerLinePlacementBelowEnd: "below-end", esriServerLinePlacementCenterAfter: "center-after", esriServerLinePlacementCenterAlong: "center-along", esriServerLinePlacementCenterBefore: "center-before", esriServerLinePlacementCenterStart: "center-start", esriServerLinePlacementCenterEnd: "center-end", esriServerPolygonPlacementAlwaysHorizontal: "always-horizontal" }, { ignoreUnknown: true });
function x$b(e2) {
  var _a2;
  return !e2 || e2.origin !== "service" && !(((_a2 = e2.layer) == null ? void 0 : _a2.type) === "map-image");
}
function L$8(e2) {
  return (e2 == null ? void 0 : e2.type) === "map-image";
}
function P$7(e2) {
  var _a2, _b2;
  return !!L$8(e2) && !!((_b2 = (_a2 = e2.capabilities) == null ? void 0 : _a2.exportMap) == null ? void 0 : _b2.supportsArcadeExpressionForLabeling);
}
function g$i(e2) {
  return x$b(e2) || P$7(e2.layer);
}
let E$7 = y$d = class extends l$1_ {
  constructor(e2) {
    super(e2), this.type = "label", this.name = null, this.allowOverrun = false, this.deconflictionStrategy = "static", this.labelExpression = null, this.labelExpressionInfo = null, this.labelPlacement = null, this.labelPosition = "curved", this.maxScale = 0, this.minScale = 0, this.repeatLabel = true, this.repeatLabelDistance = null, this.symbol = y$e, this.useCodedValues = void 0, this.where = null;
  }
  static evaluateWhere(e2, r2) {
    const t2 = (e3, r3, t3) => {
      switch (r3) {
        case "=":
          return e3 == t3;
        case "<>":
          return e3 != t3;
        case ">":
          return e3 > t3;
        case ">=":
          return e3 >= t3;
        case "<":
          return e3 < t3;
        case "<=":
          return e3 <= t3;
      }
      return false;
    };
    try {
      if (e2 == null)
        return true;
      const o2 = e2.split(" ");
      if (o2.length === 3)
        return t2(r2[o2[0]], o2[1], o2[2]);
      if (o2.length === 7) {
        const e3 = t2(r2[o2[0]], o2[1], o2[2]), n2 = o2[3], s2 = t2(r2[o2[4]], o2[5], o2[6]);
        switch (n2) {
          case "AND":
            return e3 && s2;
          case "OR":
            return e3 || s2;
        }
      }
      return false;
    } catch (o2) {
      console.log("Error.: can't parse = " + e2);
    }
  }
  readLabelExpression(e2, r2) {
    const t2 = r2.labelExpressionInfo;
    if (!t2 || !t2.value && !t2.expression)
      return e2;
  }
  writeLabelExpression(e2, r2, t2) {
    if (this.labelExpressionInfo) {
      if (this.labelExpressionInfo.value != null)
        e2 = u$v(this.labelExpressionInfo.value);
      else if (this.labelExpressionInfo.expression != null) {
        const r3 = _$e(this.labelExpressionInfo.expression);
        r3 && (e2 = "[" + r3 + "]");
      }
    }
    e2 != null && (r2[t2] = e2);
  }
  writeLabelExpressionInfo(e2, r2, t2, o2) {
    if (e2 == null && this.labelExpression != null && x$b(o2))
      e2 = new a$O({ expression: this.getLabelExpressionArcade() });
    else if (!e2)
      return;
    const n2 = e2.toJSON(o2);
    n2.expression && (r2[t2] = n2);
  }
  writeMaxScale(e2, r2) {
    (e2 || this.minScale) && (r2.maxScale = e2);
  }
  writeMinScale(e2, r2) {
    (e2 || this.maxScale) && (r2.minScale = e2);
  }
  getLabelExpression() {
    return x$c(this);
  }
  getLabelExpressionArcade() {
    return f$p(this);
  }
  getLabelExpressionSingleField() {
    return g$j(this);
  }
  hash() {
    return JSON.stringify(this);
  }
  clone() {
    return new y$d({ allowOverrun: this.allowOverrun, deconflictionStrategy: this.deconflictionStrategy, labelExpression: this.labelExpression, labelExpressionInfo: y$1r(this.labelExpressionInfo), labelPosition: this.labelPosition, labelPlacement: this.labelPlacement, maxScale: this.maxScale, minScale: this.minScale, name: this.name, repeatLabel: this.repeatLabel, repeatLabelDistance: this.repeatLabelDistance, symbol: y$1r(this.symbol), where: this.where, useCodedValues: this.useCodedValues });
  }
};
e$1W([y$1o({ type: String, json: { write: true } })], E$7.prototype, "name", void 0), e$1W([y$1o({ type: Boolean, json: { write: true, default: false, origins: { "web-scene": { write: false } } } })], E$7.prototype, "allowOverrun", void 0), e$1W([y$1o({ type: String, json: { write: true, default: "static", origins: { "web-scene": { write: false } } } })], E$7.prototype, "deconflictionStrategy", void 0), e$1W([y$1o({ type: String, json: { write: { overridePolicy(e2, r2, t2) {
  return this.labelExpressionInfo && (t2 == null ? void 0 : t2.origin) === "service" && P$7(t2.layer) ? { enabled: false } : { allowNull: true };
} } } })], E$7.prototype, "labelExpression", void 0), e$1W([o$1H("labelExpression")], E$7.prototype, "readLabelExpression", null), e$1W([r$1h("labelExpression")], E$7.prototype, "writeLabelExpression", null), e$1W([y$1o({ type: a$O, json: { write: { overridePolicy: (e2, r2, t2) => g$i(t2) ? { allowNull: true } : { enabled: false } } } })], E$7.prototype, "labelExpressionInfo", void 0), e$1W([r$1h("labelExpressionInfo")], E$7.prototype, "writeLabelExpressionInfo", null), e$1W([y$1o({ type: d$l.apiValues, json: { type: d$l.jsonValues, read: d$l.read, write: d$l.write } })], E$7.prototype, "labelPlacement", void 0), e$1W([y$1o({ type: ["curved", "parallel"], json: { write: true, origins: { "web-map": { write: false }, "web-scene": { write: false }, "portal-item": { write: false } } } })], E$7.prototype, "labelPosition", void 0), e$1W([y$1o({ type: Number })], E$7.prototype, "maxScale", void 0), e$1W([r$1h("maxScale")], E$7.prototype, "writeMaxScale", null), e$1W([y$1o({ type: Number })], E$7.prototype, "minScale", void 0), e$1W([r$1h("minScale")], E$7.prototype, "writeMinScale", null), e$1W([y$1o({ type: Boolean, json: { write: true, origins: { "web-scene": { write: false }, "portal-item": { write: false } } } })], E$7.prototype, "repeatLabel", void 0), e$1W([y$1o({ type: Number, cast: o$1j, json: { write: true, origins: { "web-scene": { write: false } } } })], E$7.prototype, "repeatLabelDistance", void 0), e$1W([y$1o({ types: P$i, json: { origins: { "web-scene": { types: F$e, write: c$14, default: null } }, write: c$14, default: null } })], E$7.prototype, "symbol", void 0), e$1W([y$1o({ type: Boolean, json: { write: true } })], E$7.prototype, "useCodedValues", void 0), e$1W([y$1o({ type: String, json: { write: true } })], E$7.prototype, "where", void 0), E$7 = y$d = e$1W([n$2f("esri.layers.support.LabelClass")], E$7);
const j$6 = E$7;
var v$e;
const w$a = s$1W({ types: M$i }), I$7 = "esri.layers.support.FeatureReductionBinning";
let S$8 = v$e = class extends t$A {
  constructor(e2) {
    super(e2), this.type = "binning", this.binType = "geohash", this.fixedBinLevel = 3, this.labelingInfo = null, this.labelsVisible = true, this.popupEnabled = true, this.popupTemplate = null, this.fields = [], this.renderer = null;
  }
  writeFields(e2, r2, o2) {
    const t2 = e2.filter((e3) => e3.statisticType !== "avg_angle").map((e3) => e3.toJSON());
    o$1X(o2, t2, r2);
  }
  readRenderer(e2, r2, i2) {
    var _a2, _b2;
    const p2 = (_a2 = r2.drawingInfo) == null ? void 0 : _a2.renderer;
    return p2 ? (_b2 = o$F(p2, r2, i2)) != null ? _b2 : void 0 : r2.defaultSymbol ? r2.types && r2.types.length ? new C$9({ defaultSymbol: w$a(r2.defaultSymbol, r2, i2), field: r2.typeIdField, uniqueValueInfos: r2.types.map((e3) => ({ id: e3.id, symbol: w$a(e3.symbol, e3, i2) })) }) : new p$19({ symbol: w$a(r2.defaultSymbol, r2, i2) }) : null;
  }
  clone() {
    return new v$e({ fields: y$1r(this.fields), fixedBinLevel: this.fixedBinLevel, labelingInfo: y$1r(this.labelingInfo), labelsVisible: this.labelsVisible, popupEnabled: this.popupEnabled, popupTemplate: y$1r(this.popupTemplate), renderer: y$1r(this.renderer) });
  }
};
e$1W([r$1a({ binning: "binning" })], S$8.prototype, "type", void 0), e$1W([r$1a({ geohash: "geohash" })], S$8.prototype, "binType", void 0), e$1W([y$1o({ type: Number, range: { min: 1, max: 9 }, json: { write: true } })], S$8.prototype, "fixedBinLevel", void 0), e$1W([y$1o({ type: [j$6], json: { read: { source: "drawingInfo.labelingInfo" }, write: { target: "drawingInfo.labelingInfo" } } })], S$8.prototype, "labelingInfo", void 0), e$1W([y$1o(m$q)], S$8.prototype, "labelsVisible", void 0), e$1W([y$1o(p$P)], S$8.prototype, "popupEnabled", void 0), e$1W([y$1o({ type: k$o, json: { name: "popupInfo", write: true } })], S$8.prototype, "popupTemplate", void 0), e$1W([y$1o({ type: [a$Q], json: { write: true } })], S$8.prototype, "fields", void 0), e$1W([r$1h("fields")], S$8.prototype, "writeFields", null), e$1W([y$1o({ types: p$15, json: { write: { target: "drawingInfo.renderer" } } })], S$8.prototype, "renderer", void 0), e$1W([o$1H("renderer", ["drawingInfo.renderer"])], S$8.prototype, "readRenderer", null), S$8 = v$e = e$1W([n$2f(I$7)], S$8);
const R$4 = S$8;
var w$9;
const I$6 = s$1W({ types: M$i }), v$d = "esri.layers.support.FeatureReductionCluster";
function R$3(e2) {
  var _a2;
  return e2.type === "simple" && !((_a2 = e2.visualVariables) == null ? void 0 : _a2.length);
}
let x$a = w$9 = class extends l$1_ {
  constructor(e2) {
    super(e2), this.type = "cluster", this.clusterRadius = o$1j("80px"), this.clusterMinSize = o$1j("12px"), this.clusterMaxSize = o$1j("50px"), this.popupEnabled = true, this.popupTemplate = null, this.renderer = null, this.symbol = null, this.labelingInfo = null, this.labelsVisible = true, this.fields = null;
  }
  readRenderer(e2, r2, i2) {
    var _a2, _b2, _c2;
    const p2 = (_a2 = r2.drawingInfo) == null ? void 0 : _a2.renderer;
    return ((_b2 = p2 == null ? void 0 : p2.authoringInfo) == null ? void 0 : _b2.isAutoGenerated) ? null : p2 ? R$3(p2) ? null : (_c2 = o$F(p2, r2, i2)) != null ? _c2 : void 0 : r2.defaultSymbol ? r2.types && r2.types.length ? new C$9({ defaultSymbol: I$6(r2.defaultSymbol, r2, i2), field: r2.typeIdField, uniqueValueInfos: r2.types.map((e3) => ({ id: e3.id, symbol: I$6(e3.symbol, e3, i2) })) }) : new p$19({ symbol: I$6(r2.defaultSymbol, r2, i2) }) : null;
  }
  readSymbol(e2, r2, o2) {
    var _a2, _b2, _c2;
    const t2 = (_a2 = r2.drawingInfo) == null ? void 0 : _a2.renderer;
    if ((_b2 = t2 == null ? void 0 : t2.authoringInfo) == null ? void 0 : _b2.isAutoGenerated)
      return null;
    if (t2 && R$3(t2)) {
      return (_c2 = o$F(t2, r2, o2)) == null ? void 0 : _c2.symbol;
    }
    return null;
  }
  writeSymbol(e2, r2, t2, s2) {
    var _a2, _b2;
    const i2 = (_b2 = (_a2 = this.renderer) == null ? void 0 : _a2.authoringInfo) == null ? void 0 : _b2.isAutoGenerated;
    if (!this.renderer || i2) {
      const t3 = new p$19({ symbol: e2 });
      r2.drawingInfo = { renderer: t3.write({}, s2) };
    }
  }
  writeFields(e2, r2, o2) {
    const t2 = e2.filter((e3) => e3.statisticType !== "avg_angle").map((e3) => e3.toJSON());
    o$1X(o2, t2, r2);
  }
  readFields(e2, r2, o2) {
    return e2.filter((e3) => !e3.isAutoGenerated).map((e3) => a$Q.fromJSON(e3));
  }
  clone() {
    return new w$9({ clusterRadius: this.clusterRadius, clusterMinSize: this.clusterMinSize, clusterMaxSize: this.clusterMaxSize, labelingInfo: y$1r(this.labelingInfo), labelsVisible: this.labelsVisible, fields: y$1r(this.fields), renderer: y$1r(this.renderer), symbol: y$1r(this.symbol), popupEnabled: this.popupEnabled, popupTemplate: y$1r(this.popupTemplate) });
  }
};
e$1W([y$1o({ type: ["cluster"], readOnly: true, json: { write: true } })], x$a.prototype, "type", void 0), e$1W([y$1o({ type: Number, cast: (e2) => e2 === "auto" ? e2 : o$1j(e2), json: { write: true } })], x$a.prototype, "clusterRadius", void 0), e$1W([y$1o({ type: Number, cast: o$1j, json: { write: true } })], x$a.prototype, "clusterMinSize", void 0), e$1W([y$1o({ type: Number, cast: o$1j, json: { write: true } })], x$a.prototype, "clusterMaxSize", void 0), e$1W([y$1o(p$P)], x$a.prototype, "popupEnabled", void 0), e$1W([y$1o({ type: k$o, json: { read: { source: "popupInfo" }, write: { target: "popupInfo" } } })], x$a.prototype, "popupTemplate", void 0), e$1W([y$1o({ types: p$15, json: { write: { target: "drawingInfo.renderer" } } })], x$a.prototype, "renderer", void 0), e$1W([o$1H("renderer", ["drawingInfo.renderer"])], x$a.prototype, "readRenderer", null), e$1W([y$1o({ types: D$e })], x$a.prototype, "symbol", void 0), e$1W([o$1H("symbol", ["drawingInfo.renderer"])], x$a.prototype, "readSymbol", null), e$1W([r$1h("symbol")], x$a.prototype, "writeSymbol", null), e$1W([y$1o({ type: [j$6], json: { read: { source: "drawingInfo.labelingInfo" }, write: { target: "drawingInfo.labelingInfo" } } })], x$a.prototype, "labelingInfo", void 0), e$1W([y$1o(m$q)], x$a.prototype, "labelsVisible", void 0), e$1W([y$1o({ type: [a$Q], json: { write: true } })], x$a.prototype, "fields", void 0), e$1W([r$1h("fields")], x$a.prototype, "writeFields", null), e$1W([o$1H("fields")], x$a.prototype, "readFields", null), x$a = w$9 = e$1W([n$2f(v$d)], x$a);
const z$7 = x$a;
var t$x;
let c$J = t$x = class extends t$A {
  constructor(r2) {
    super(r2), this.type = "selection";
  }
  clone() {
    return new t$x();
  }
};
e$1W([y$1o({ type: ["selection"] })], c$J.prototype, "type", void 0), c$J = t$x = e$1W([n$2f("esri.layers.support.FeatureReductionSelection")], c$J);
const p$I = c$J;
const o$w = { key: "type", base: t$A, typeMap: { cluster: z$7, binning: R$4 } }, r$t = { types: { key: "type", base: t$A, typeMap: { selection: p$I, cluster: z$7, binning: R$4 } }, json: { name: "layerDefinition.featureReduction", write: { allowNull: true }, origins: { "web-map": { types: o$w }, "portal-item": { types: o$w }, "web-scene": { types: { key: "type", base: t$A, typeMap: { selection: p$I } } } } } };
const n$H = { Base64: 0, Hex: 1, String: 2, Raw: 3 }, t$w = 8, r$s = (1 << t$w) - 1;
function e$u(n2, t2) {
  const r2 = (65535 & n2) + (65535 & t2);
  return (n2 >> 16) + (t2 >> 16) + (r2 >> 16) << 16 | 65535 & r2;
}
function o$v(n2) {
  const e2 = [];
  for (let o2 = 0, u2 = n2.length * t$w; o2 < u2; o2 += t$w)
    e2[o2 >> 5] |= (n2.charCodeAt(o2 / t$w) & r$s) << o2 % 32;
  return e2;
}
function u$t(n2) {
  const e2 = [];
  for (let o2 = 0, u2 = 32 * n2.length; o2 < u2; o2 += t$w)
    e2.push(String.fromCharCode(n2[o2 >> 5] >>> o2 % 32 & r$s));
  return e2.join("");
}
function c$I(n2) {
  const t2 = "0123456789abcdef", r2 = [];
  for (let e2 = 0, o2 = 4 * n2.length; e2 < o2; e2++)
    r2.push(t2.charAt(n2[e2 >> 2] >> e2 % 4 * 8 + 4 & 15) + t2.charAt(n2[e2 >> 2] >> e2 % 4 * 8 & 15));
  return r2.join("");
}
function f$o(n2) {
  const t2 = "=", r2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", e2 = [];
  for (let o2 = 0, u2 = 4 * n2.length; o2 < u2; o2 += 3) {
    const u3 = (n2[o2 >> 2] >> o2 % 4 * 8 & 255) << 16 | (n2[o2 + 1 >> 2] >> (o2 + 1) % 4 * 8 & 255) << 8 | n2[o2 + 2 >> 2] >> (o2 + 2) % 4 * 8 & 255;
    for (let c2 = 0; c2 < 4; c2++)
      8 * o2 + 6 * c2 > 32 * n2.length ? e2.push(t2) : e2.push(r2.charAt(u3 >> 6 * (3 - c2) & 63));
  }
  return e2.join("");
}
function s$w(n2, t2) {
  return n2 << t2 | n2 >>> 32 - t2;
}
function i$F(n2, t2, r2, o2, u2, c2) {
  return e$u(s$w(e$u(e$u(t2, n2), e$u(o2, c2)), u2), r2);
}
function h$j(n2, t2, r2, e2, o2, u2, c2) {
  return i$F(t2 & r2 | ~t2 & e2, n2, t2, o2, u2, c2);
}
function a$M(n2, t2, r2, e2, o2, u2, c2) {
  return i$F(t2 & e2 | r2 & ~e2, n2, t2, o2, u2, c2);
}
function l$C(n2, t2, r2, e2, o2, u2, c2) {
  return i$F(t2 ^ r2 ^ e2, n2, t2, o2, u2, c2);
}
function g$h(n2, t2, r2, e2, o2, u2, c2) {
  return i$F(r2 ^ (t2 | ~e2), n2, t2, o2, u2, c2);
}
function p$H(n2, t2) {
  n2[t2 >> 5] |= 128 << t2 % 32, n2[14 + (t2 + 64 >>> 9 << 4)] = t2;
  let r2 = 1732584193, o2 = -271733879, u2 = -1732584194, c2 = 271733878;
  for (let f2 = 0; f2 < n2.length; f2 += 16) {
    const t3 = r2, s2 = o2, i2 = u2, p2 = c2;
    r2 = h$j(r2, o2, u2, c2, n2[f2 + 0], 7, -680876936), c2 = h$j(c2, r2, o2, u2, n2[f2 + 1], 12, -389564586), u2 = h$j(u2, c2, r2, o2, n2[f2 + 2], 17, 606105819), o2 = h$j(o2, u2, c2, r2, n2[f2 + 3], 22, -1044525330), r2 = h$j(r2, o2, u2, c2, n2[f2 + 4], 7, -176418897), c2 = h$j(c2, r2, o2, u2, n2[f2 + 5], 12, 1200080426), u2 = h$j(u2, c2, r2, o2, n2[f2 + 6], 17, -1473231341), o2 = h$j(o2, u2, c2, r2, n2[f2 + 7], 22, -45705983), r2 = h$j(r2, o2, u2, c2, n2[f2 + 8], 7, 1770035416), c2 = h$j(c2, r2, o2, u2, n2[f2 + 9], 12, -1958414417), u2 = h$j(u2, c2, r2, o2, n2[f2 + 10], 17, -42063), o2 = h$j(o2, u2, c2, r2, n2[f2 + 11], 22, -1990404162), r2 = h$j(r2, o2, u2, c2, n2[f2 + 12], 7, 1804603682), c2 = h$j(c2, r2, o2, u2, n2[f2 + 13], 12, -40341101), u2 = h$j(u2, c2, r2, o2, n2[f2 + 14], 17, -1502002290), o2 = h$j(o2, u2, c2, r2, n2[f2 + 15], 22, 1236535329), r2 = a$M(r2, o2, u2, c2, n2[f2 + 1], 5, -165796510), c2 = a$M(c2, r2, o2, u2, n2[f2 + 6], 9, -1069501632), u2 = a$M(u2, c2, r2, o2, n2[f2 + 11], 14, 643717713), o2 = a$M(o2, u2, c2, r2, n2[f2 + 0], 20, -373897302), r2 = a$M(r2, o2, u2, c2, n2[f2 + 5], 5, -701558691), c2 = a$M(c2, r2, o2, u2, n2[f2 + 10], 9, 38016083), u2 = a$M(u2, c2, r2, o2, n2[f2 + 15], 14, -660478335), o2 = a$M(o2, u2, c2, r2, n2[f2 + 4], 20, -405537848), r2 = a$M(r2, o2, u2, c2, n2[f2 + 9], 5, 568446438), c2 = a$M(c2, r2, o2, u2, n2[f2 + 14], 9, -1019803690), u2 = a$M(u2, c2, r2, o2, n2[f2 + 3], 14, -187363961), o2 = a$M(o2, u2, c2, r2, n2[f2 + 8], 20, 1163531501), r2 = a$M(r2, o2, u2, c2, n2[f2 + 13], 5, -1444681467), c2 = a$M(c2, r2, o2, u2, n2[f2 + 2], 9, -51403784), u2 = a$M(u2, c2, r2, o2, n2[f2 + 7], 14, 1735328473), o2 = a$M(o2, u2, c2, r2, n2[f2 + 12], 20, -1926607734), r2 = l$C(r2, o2, u2, c2, n2[f2 + 5], 4, -378558), c2 = l$C(c2, r2, o2, u2, n2[f2 + 8], 11, -2022574463), u2 = l$C(u2, c2, r2, o2, n2[f2 + 11], 16, 1839030562), o2 = l$C(o2, u2, c2, r2, n2[f2 + 14], 23, -35309556), r2 = l$C(r2, o2, u2, c2, n2[f2 + 1], 4, -1530992060), c2 = l$C(c2, r2, o2, u2, n2[f2 + 4], 11, 1272893353), u2 = l$C(u2, c2, r2, o2, n2[f2 + 7], 16, -155497632), o2 = l$C(o2, u2, c2, r2, n2[f2 + 10], 23, -1094730640), r2 = l$C(r2, o2, u2, c2, n2[f2 + 13], 4, 681279174), c2 = l$C(c2, r2, o2, u2, n2[f2 + 0], 11, -358537222), u2 = l$C(u2, c2, r2, o2, n2[f2 + 3], 16, -722521979), o2 = l$C(o2, u2, c2, r2, n2[f2 + 6], 23, 76029189), r2 = l$C(r2, o2, u2, c2, n2[f2 + 9], 4, -640364487), c2 = l$C(c2, r2, o2, u2, n2[f2 + 12], 11, -421815835), u2 = l$C(u2, c2, r2, o2, n2[f2 + 15], 16, 530742520), o2 = l$C(o2, u2, c2, r2, n2[f2 + 2], 23, -995338651), r2 = g$h(r2, o2, u2, c2, n2[f2 + 0], 6, -198630844), c2 = g$h(c2, r2, o2, u2, n2[f2 + 7], 10, 1126891415), u2 = g$h(u2, c2, r2, o2, n2[f2 + 14], 15, -1416354905), o2 = g$h(o2, u2, c2, r2, n2[f2 + 5], 21, -57434055), r2 = g$h(r2, o2, u2, c2, n2[f2 + 12], 6, 1700485571), c2 = g$h(c2, r2, o2, u2, n2[f2 + 3], 10, -1894986606), u2 = g$h(u2, c2, r2, o2, n2[f2 + 10], 15, -1051523), o2 = g$h(o2, u2, c2, r2, n2[f2 + 1], 21, -2054922799), r2 = g$h(r2, o2, u2, c2, n2[f2 + 8], 6, 1873313359), c2 = g$h(c2, r2, o2, u2, n2[f2 + 15], 10, -30611744), u2 = g$h(u2, c2, r2, o2, n2[f2 + 6], 15, -1560198380), o2 = g$h(o2, u2, c2, r2, n2[f2 + 13], 21, 1309151649), r2 = g$h(r2, o2, u2, c2, n2[f2 + 4], 6, -145523070), c2 = g$h(c2, r2, o2, u2, n2[f2 + 11], 10, -1120210379), u2 = g$h(u2, c2, r2, o2, n2[f2 + 2], 15, 718787259), o2 = g$h(o2, u2, c2, r2, n2[f2 + 9], 21, -343485551), r2 = e$u(r2, t3), o2 = e$u(o2, s2), u2 = e$u(u2, i2), c2 = e$u(c2, p2);
  }
  return [r2, o2, u2, c2];
}
function x$9(r2, e2 = n$H.Hex) {
  const s2 = e2 || n$H.Base64, i2 = p$H(o$v(r2), r2.length * t$w);
  switch (s2) {
    case n$H.Raw:
      return i2;
    case n$H.Hex:
      return c$I(i2);
    case n$H.String:
      return u$t(i2);
    case n$H.Base64:
      return f$o(i2);
  }
}
var l$B;
let n$G = l$B = class extends j$f {
  writeLevels(e2, s2, i2) {
    for (const t2 in e2) {
      const e3 = this.levels[t2];
      return void (s2.stops = e3);
    }
  }
  clone() {
    return new l$B({ axis: this.axis, field: this.field, valueExpression: this.valueExpression, valueExpressionTitle: this.valueExpressionTitle, maxDataValue: this.maxDataValue, maxSize: e$D(this.maxSize) ? this.maxSize.clone() : this.maxSize, minDataValue: this.minDataValue, minSize: e$D(this.minSize) ? this.minSize.clone() : this.minSize, normalizationField: this.normalizationField, stops: this.stops && this.stops.map((e2) => e2.clone()), target: this.target, useSymbolValue: this.useSymbolValue, valueRepresentation: this.valueRepresentation, valueUnit: this.valueUnit, legendOptions: this.legendOptions && this.legendOptions.clone(), levels: y$1r(this.levels) });
  }
};
e$1W([y$1o()], n$G.prototype, "levels", void 0), e$1W([r$1h("levels")], n$G.prototype, "writeLevels", null), n$G = l$B = e$1W([n$2f("esri.views.2d.engine.LevelDependentSizeVariable")], n$G);
const p$G = s$22.getLogger("esri.views.2d.layers.support.clusterUtils");
has.add("esri-cluster-arcade-enabled", true);
const c$H = has("esri-cluster-arcade-enabled"), d$k = (e2, r2, i2, n2, a2) => {
  const l2 = r2.clone();
  if (!g$g(l2))
    return l2;
  if (l2.authoringInfo || (l2.authoringInfo = new j$g()), l2.authoringInfo.isAutoGenerated = true, "visualVariables" in l2) {
    const r3 = (l2.visualVariables || []).filter((e3) => e3.valueExpression !== "$view.scale"), t2 = f$n(r3);
    r3.forEach((r4) => {
      r4.type === "rotation" ? r4.field ? r4.field = w$8(e2, r4.field, "avg_angle", "number") : r4.valueExpression && (r4.field = E$6(e2, r4.valueExpression, "avg_angle", "number"), r4.valueExpression = null) : r4.normalizationField ? (r4.field = w$8(e2, r4.field, "avg_norm", "number", r4.normalizationField), r4.normalizationField = null) : r4.field ? r4.field = w$8(e2, r4.field, "avg", "number") : r4.valueExpression && (r4.field = E$6(e2, r4.valueExpression, "avg", "number"), r4.valueExpression = null);
    }), t$1W(t2) && !v$c(r3) && a2 && (r3.push(b$b(i2, n2)), l2.dynamicClusterSize = true), l2.visualVariables = r3;
  }
  switch (l2.type) {
    case "simple":
      break;
    case "pie-chart":
      for (const r3 of l2.attributes)
        r3.field ? r3.field = w$8(e2, r3.field, "sum", "number") : r3.valueExpression && (r3.field = E$6(e2, r3.valueExpression, "sum", "number"), r3.valueExpression = null);
      break;
    case "unique-value":
      l2.field ? l2.field = w$8(e2, l2.field, "mode", "string") : l2.valueExpression && (l2.field = E$6(e2, l2.valueExpression, "mode", "string"), l2.valueExpression = null);
      break;
    case "class-breaks":
      l2.normalizationField ? (l2.field = w$8(e2, l2.field, "avg_norm", "number", l2.normalizationField), l2.normalizationField = null) : l2.field ? l2.field = w$8(e2, l2.field, "avg", "number") : l2.valueExpression && (l2.field = E$6(e2, l2.valueExpression, "avg", "number"), l2.valueExpression = null);
  }
  return l2;
}, f$n = (e2) => {
  for (const r2 of e2)
    if (r2.type === "size")
      return r2;
  return null;
};
function m$n(e2, r2, i2) {
  const n2 = e2.clone();
  let a2 = false;
  if ("visualVariables" in n2) {
    const e3 = (n2.visualVariables || []).filter((e4) => e4.valueExpression !== "$view.scale"), t2 = f$n(e3);
    t$1W(t2) && (n2.visualVariables || (n2.visualVariables = []), n2.visualVariables.push(b$b(r2, i2)), n2.dynamicClusterSize = true, a2 = true);
  }
  return { renderer: n2, didInject: a2 };
}
const v$c = (e2) => {
  for (const r2 of e2)
    if (r2.field === "cluster_count")
      return true;
  return false;
}, b$b = (e2, r2) => {
  const i2 = [new l$W({ value: 0, size: 0 }), new l$W({ value: 1 })];
  if (t$1W(r2))
    return new j$f({ field: "cluster_count", stops: [...i2, new l$W({ value: 2, size: 0 })] });
  const n2 = Object.keys(r2).reduce((s2, n3) => __spreadProps(__spreadValues({}, s2), { [n3]: [...i2, new l$W({ value: Math.max(2, r2[n3].minValue), size: e2.clusterMinSize }), new l$W({ value: Math.max(3, r2[n3].maxValue), size: e2.clusterMaxSize })] }), {});
  return new n$G({ field: "cluster_count", levels: n2 });
}, g$g = (r2) => {
  const s2 = (s3) => p$G.error(new s$1Z("Unsupported-renderer", s3, { renderer: r2 }));
  switch (r2.type) {
    case "unique-value":
      if (r2.field2 || r2.field3)
        return s2("FeatureReductionCluster does not support multi-field UniqueValueRenderers"), false;
      break;
    case "class-breaks":
      if (r2.normalizationField) {
        const e2 = r2.normalizationType;
        if (e2 !== "field")
          return s2(`FeatureReductionCluster does not support a normalizationType of ${e2}`), false;
        break;
      }
    case "simple":
    case "pie-chart":
      break;
    default:
      return s2(`FeatureReductionCluster does not support renderers of type ${r2.type}`), false;
  }
  if (!c$H) {
    if ("valueExpression" in r2 && r2.valueExpression)
      return s2("FeatureReductionCluster does not currently support renderer.valueExpression. Support will be added in a future release"), false;
    if (("visualVariables" in r2 && r2.visualVariables || []).some((e2) => !(!("valueExpression" in e2) || !e2.valueExpression)))
      return s2("FeatureReductionCluster does not currently support visualVariables with a valueExpression. Support will be added in a future release"), false;
  }
  return true;
};
function x$8(e2, r2, s2) {
  switch (e2) {
    case "sum":
      return `cluster_sum_${r2}`;
    case "avg":
    case "avg_angle":
      return `cluster_avg_${r2}`;
    case "mode":
      return `cluster_type_${r2}`;
    case "avg_norm": {
      const e3 = s2, n2 = "field", a2 = r2.toLowerCase() + ",norm:" + n2 + "," + e3.toLowerCase();
      return "cluster_avg_" + x$9(a2);
    }
  }
}
function E$6(e2, r2, s2, t2) {
  const l2 = x$9(r2), o2 = s2 === "mode" ? `cluster_type_${l2}` : s2 === "sum" ? `cluster_sum_${l2}` : `cluster_avg_${l2}`;
  return e2.some((e3) => e3.name === o2) || e2.push(new a$Q({ name: o2, isAutoGenerated: true, onStatisticExpression: new i$H({ expression: r2, returnType: t2 }), statisticType: s2 })), o2;
}
function w$8(e2, r2, s2, i2, t2) {
  if (r2 === "cluster_count" || e2.some((e3) => e3.name === r2))
    return r2;
  const l2 = x$8(s2, r2, t2);
  return e2.some((e3) => e3.name === l2) || (s2 === "avg_norm" ? e2.push(new a$Q({ name: l2, isAutoGenerated: true, onStatisticExpression: new i$H({ expression: `$feature.${r2} / $feature.${t2}`, returnType: i2 }), statisticType: "avg" })) : e2.push(new a$Q({ name: l2, isAutoGenerated: true, onStatisticField: r2, statisticType: s2 }))), l2;
}
const n$F = (n2) => {
  let u2 = class extends n2 {
    constructor(...e2) {
      super(...e2), this.own(this.watch("renderer", () => {
        if (this.featureReduction) {
          const e3 = this._normalizeFeatureReduction(this.featureReduction);
          this._set("featureReduction", e3);
        }
      }, true));
    }
    set featureReduction(e2) {
      const r2 = this._normalizeFeatureReduction(e2);
      this._set("featureReduction", r2);
    }
    set renderer(e2) {
    }
    _normalizeFeatureReduction(e2) {
      var _a2, _b2;
      if ((e2 == null ? void 0 : e2.type) !== "cluster")
        return e2;
      const r2 = e2.clone(), t2 = [new a$Q({ name: "cluster_count", isAutoGenerated: true, statisticType: "count" })], o2 = ((_a2 = r2.fields) != null ? _a2 : []).filter((e3) => !e3.isAutoGenerated);
      if (e2.renderer && !((_b2 = e2.renderer.authoringInfo) == null ? void 0 : _b2.isAutoGenerated))
        return r2.fields = [...t2, ...o2], r2;
      if (e2.symbol)
        return r2.fields = [...t2, ...o2], r2.renderer = null, r2;
      if (!this.renderer)
        return e2;
      const n3 = d$k(t2, this.renderer, e2, null, false);
      return r2.fields = [...t2, ...o2], r2.renderer = n3, r2;
    }
  };
  return e$1W([y$1o(r$t)], u2.prototype, "featureReduction", null), u2 = e$1W([n$2f("esri.layers.mixins.FeatureReductionLayer")], u2), u2;
};
const e$t = { "web-scene/operational-layers": { ArcGISDimensionLayer: true, ArcGISFeatureLayer: true, ArcGISImageServiceLayer: true, ArcGISMapServiceLayer: true, ArcGISSceneServiceLayer: true, ArcGISTiledElevationServiceLayer: true, ArcGISTiledImageServiceLayer: true, ArcGISTiledMapServiceLayer: true, BuildingSceneLayer: true, GroupLayer: true, IntegratedMeshLayer: true, OGCFeatureLayer: true, PointCloudLayer: true, WebTiledLayer: true, CSV: true, GeoJSON: true, VectorTileLayer: true, WFS: true, WMS: true, KML: true, RasterDataLayer: true, Voxel: true, LineOfSightLayer: true }, "web-scene/basemap": { ArcGISTiledImageServiceLayer: true, ArcGISTiledMapServiceLayer: true, WebTiledLayer: true, OpenStreetMap: true, VectorTileLayer: true, ArcGISImageServiceLayer: true, WMS: true, ArcGISMapServiceLayer: true }, "web-scene/ground": { ArcGISTiledElevationServiceLayer: true, RasterDataElevationLayer: true }, "web-map/operational-layers": { ArcGISAnnotationLayer: true, ArcGISDimensionLayer: true, ArcGISFeatureLayer: true, ArcGISImageServiceLayer: true, ArcGISImageServiceVectorLayer: true, ArcGISMapServiceLayer: true, ArcGISStreamLayer: true, ArcGISTiledImageServiceLayer: true, ArcGISTiledMapServiceLayer: true, BingMapsAerial: true, BingMapsHybrid: true, BingMapsRoad: true, CSV: true, GeoRSS: true, GeoJSON: true, GroupLayer: true, KML: true, OGCFeatureLayer: true, OrientedImageryLayer: true, SubtypeGroupLayer: true, VectorTileLayer: true, WFS: true, WMS: true, WebTiledLayer: true }, "web-map/basemap": { ArcGISImageServiceLayer: true, ArcGISImageServiceVectorLayer: true, ArcGISMapServiceLayer: true, ArcGISTiledImageServiceLayer: true, ArcGISTiledMapServiceLayer: true, OpenStreetMap: true, VectorTileLayer: true, WMS: true, WebTiledLayer: true, BingMapsAerial: true, BingMapsRoad: true, BingMapsHybrid: true }, "web-map/tables": { ArcGISFeatureLayer: true }, "portal-item/operational-layers": { ArcGISFeatureLayer: true, ArcGISSceneServiceLayer: true, PointCloudLayer: true, BuildingSceneLayer: true, IntegratedMeshLayer: true, OrientedImageryLayer: true } };
const c$G = (c2) => {
  let u2 = class extends c2 {
    constructor() {
      super(...arguments), this.title = null;
    }
    writeListMode(e2, r2, t2, o2) {
      (o2 && o2.layerContainerType === "ground" || e2 && g$$(this, t2, {}, o2)) && (r2[t2] = e2);
    }
    writeOperationalLayerType(e2, r2, t2, o2) {
      !e2 || o2 && o2.layerContainerType === "tables" || (r2.layerType = e2);
    }
    writeTitle(e2, r2) {
      r2.title = e2 != null ? e2 : "Layer";
    }
    read(e2, r2) {
      r2 && (r2.layer = this), d$1u(this, e2, (r3) => super.read(e2, r3), r2);
    }
    write(e2, o2) {
      var _a2, _b2;
      if (o2 == null ? void 0 : o2.origin) {
        const e3 = `${o2.origin}/${o2.layerContainerType || "operational-layers"}`, t2 = e$t[e3];
        let i3 = t2 && t2[this.operationalLayerType];
        if (this.operationalLayerType === "ArcGISTiledElevationServiceLayer" && e3 === "web-scene/operational-layers" && (i3 = false), this.operationalLayerType === "ArcGISDimensionLayer" && e3 === "web-map/operational-layers" && (i3 = false), !i3)
          return (_a2 = o2.messages) == null ? void 0 : _a2.push(new s$1Z("layer:unsupported", `Layers (${this.title}, ${this.id}) of type '${this.declaredClass}' are not supported in the context of '${e3}'`, { layer: this })), null;
      }
      const i2 = super.write(e2, __spreadProps(__spreadValues({}, o2), { layer: this })), s2 = !!o2 && !!o2.messages && !!o2.messages.filter((e3) => e3 instanceof s$1Z && e3.name === "web-document-write:property-required").length;
      return V$a(i2 == null ? void 0 : i2.url) ? ((_b2 = o2 == null ? void 0 : o2.messages) == null ? void 0 : _b2.push(new s$1Z("layer:invalid-url", `Layer (${this.title}, ${this.id}) of type '${this.declaredClass}' using a Blob URL cannot be written to web scenes and web maps`, { layer: this })), null) : !this.url && s2 ? null : i2;
    }
    beforeSave() {
    }
  };
  return e$1W([y$1o({ type: String, json: { write: { ignoreOrigin: true }, origins: { "web-scene": { write: { isRequired: true, ignoreOrigin: true } }, "portal-item": { write: false } } } })], u2.prototype, "id", void 0), e$1W([y$1o(D$5)], u2.prototype, "listMode", void 0), e$1W([r$1h("listMode")], u2.prototype, "writeListMode", null), e$1W([y$1o({ type: String, readOnly: true, json: { read: false, write: { target: "layerType", ignoreOrigin: true }, origins: { "portal-item": { write: false } } } })], u2.prototype, "operationalLayerType", void 0), e$1W([r$1h("operationalLayerType")], u2.prototype, "writeOperationalLayerType", null), e$1W([y$1o(w$d)], u2.prototype, "opacity", void 0), e$1W([y$1o({ type: String, json: { write: { ignoreOrigin: true, writerEnsuresNonNull: true }, origins: { "web-scene": { write: { isRequired: true, ignoreOrigin: true, writerEnsuresNonNull: true } }, "portal-item": { write: false } } }, value: "Layer" })], u2.prototype, "title", void 0), e$1W([r$1h("title"), r$1h(["web-scene"], "title")], u2.prototype, "writeTitle", null), e$1W([y$1o({ type: Boolean, json: { name: "visibility" } })], u2.prototype, "visible", void 0), u2 = e$1W([n$2f("esri.layers.mixins.OperationalLayer")], u2), u2;
};
var i$E;
const p$F = new s$1F({ asc: "ascending", desc: "descending" });
let n$E = i$E = class extends l$1_ {
  constructor(r2) {
    super(r2), this.field = null, this.valueExpression = null, this.order = "ascending";
  }
  clone() {
    return new i$E({ field: this.field, valueExpression: this.valueExpression, order: this.order });
  }
};
e$1W([y$1o({ type: String, json: { write: true } })], n$E.prototype, "field", void 0), e$1W([y$1o({ type: String, json: { write: true } })], n$E.prototype, "valueExpression", void 0), e$1W([y$1o({ type: p$F.apiValues, json: { read: p$F.read, write: p$F.write } })], n$E.prototype, "order", void 0), n$E = i$E = e$1W([n$2f("esri.layers.support.OrderByInfo")], n$E);
const c$F = n$E;
function i$D(r2, e2, o2) {
  if (!r2)
    return null;
  const t2 = r2.find((r3) => !!r3.field);
  if (!t2)
    return null;
  const i2 = new c$F();
  return i2.read(t2, o2), [i2];
}
function n$D(r2, o2, t2, s2) {
  const i2 = r2.find((r3) => !!r3.field);
  i2 && o$1X(t2, [i2.toJSON()], o2);
}
const c$E = (e2) => {
  let c2 = class extends e2 {
    constructor() {
      super(...arguments), this.orderBy = null;
    }
  };
  return e$1W([y$1o({ type: [c$F], json: { origins: { "web-scene": { write: false, read: false } }, read: { source: "layerDefinition.orderBy", reader: i$D }, write: { target: "layerDefinition.orderBy", writer: n$D } } })], c2.prototype, "orderBy", void 0), c2 = e$1W([n$2f("esri.layers.mixins.OrderedLayer")], c2), c2;
};
let h$i = class extends m$1L {
  constructor(t2) {
    super(t2), this.portalItem = null;
  }
  normalizeCtorArgs(t2) {
    return t2 && t2.portalItem && t2.path ? __spreadProps(__spreadValues({}, t2), { path: this._normalizePath(t2.path, t2.portalItem) }) : t2;
  }
  set path(t2) {
    r$1t(t2) && K$7(t2) ? s$22.getLogger(this.declaredClass).error("portalitemresource:invalid-path", "A portal item resource path must be relative") : this._set("path", t2);
  }
  _castPath(t2) {
    return this._normalizePath(t2, this.portalItem);
  }
  get url() {
    return this.portalItem && this.path ? `${this.portalItem.itemUrl}/resources/${this.path}` : null;
  }
  get itemRelativeUrl() {
    return this.portalItem && this.path ? `./resources/${this.path}` : null;
  }
  fetch(t2 = "json", r2) {
    const o2 = this.url;
    if (t$1W(o2))
      throw new s$1Z("portal-item-resource:fetch", "Portal item resource does not refer to a valid item or path");
    return this.portalItem.portal._request(o2, { responseType: t2, query: { token: this.portalItem.apiKey }, signal: q$i(r2, "signal") });
  }
  async update(t2, r2) {
    return (await import("./resourceUtils.js")).addOrUpdateResource(this, "update", t2, r2);
  }
  hasPath() {
    return r$1t(this.path);
  }
  _normalizePath(t2, r2) {
    return t$1W(t2) ? t2 : (t2 = t2.replace(/^\/+/, ""), r$1t(r2) && K$7(t2) && (t2 = _$v(t2, r2.itemUrl)), t2.replace(/^\/+/, "").replace(/^(\.\/)?resources\//, ""));
  }
};
e$1W([y$1o()], h$i.prototype, "portalItem", void 0), e$1W([y$1o({ type: String, value: null })], h$i.prototype, "path", null), e$1W([s$1N("path")], h$i.prototype, "_castPath", null), e$1W([y$1o({ type: String, readOnly: true })], h$i.prototype, "url", null), e$1W([y$1o({ type: String, readOnly: true })], h$i.prototype, "itemRelativeUrl", null), h$i = e$1W([n$2f("esri.portal.PortalItemResource")], h$i);
const n$C = h$i;
let e$s = class extends m$1L {
  constructor(r2) {
    super(r2), this.created = null, this.rating = null;
  }
};
e$1W([y$1o()], e$s.prototype, "created", void 0), e$1W([y$1o()], e$s.prototype, "rating", void 0), e$s = e$1W([n$2f("esri.portal.PortalRating")], e$s);
const c$D = e$s;
var f$m;
const b$a = new Set(["Map Service", "Feature Service", "Feature Collection", "Scene Service", "Image Service", "Stream Service", "Vector Tile Service", "GeoJson", "CSV", "KML", "WFS", "WMTS", "WMS", "Feed"]), k$4 = new Set(["KML", "GeoJson", "CSV"]);
let S$7 = f$m = class extends u$1N(m$1g) {
  constructor(e2) {
    super(e2), this.access = null, this.accessInformation = null, this.apiKey = null, this.applicationProxies = null, this.avgRating = null, this.categories = null, this.created = null, this.culture = null, this.description = null, this.extent = null, this.groupCategories = null, this.id = null, this.itemControl = null, this.licenseInfo = null, this.modified = null, this.name = null, this.numComments = null, this.numRatings = null, this.numViews = null, this.owner = null, this.ownerFolder = null, this.portal = null, this.screenshots = null, this.size = null, this.snippet = null, this.sourceJSON = null, this.spatialReference = null, this.tags = null, this.title = null, this.type = null, this.typeKeywords = null, this.url = null;
  }
  static from(e2) {
    return v$V(f$m, e2);
  }
  destroy() {
    this.portal = null;
  }
  get displayName() {
    const e2 = this.type, t2 = this.typeKeywords || [];
    let i2 = e2;
    return e2 === "Feature Service" || e2 === "Feature Collection" ? i2 = t2.includes("Table") ? "Table" : t2.includes("Route Layer") ? "Route Layer" : t2.includes("Markup") ? "Markup" : "Feature Layer" : e2 === "Image Service" ? i2 = t2.includes("Elevation 3D Layer") ? "Elevation Layer" : t2.includes("Tiled Imagery") ? "Tiled Imagery Layer" : "Imagery Layer" : e2 === "Scene Service" ? i2 = "Scene Layer" : e2 === "Video Service" ? i2 = "Video Layer" : e2 === "Scene Package" ? i2 = "Scene Layer Package" : e2 === "Stream Service" ? i2 = "Feature Layer" : e2 === "Geoprocessing Service" && this.portal && this.portal.isPortal ? i2 = t2.includes("Web Tool") ? "Tool" : "Geoprocessing Service" : e2 === "Geocoding Service" ? i2 = "Locator" : e2 === "Geoenrichment Service" ? i2 = "GeoEnrichment Service" : e2 === "Microsoft Powerpoint" ? i2 = "Microsoft PowerPoint" : e2 === "GeoJson" ? i2 = "GeoJSON" : e2 === "Globe Service" ? i2 = "Globe Layer" : e2 === "Vector Tile Service" ? i2 = "Tile Layer" : e2 === "netCDF" ? i2 = "NetCDF" : e2 === "Map Service" ? i2 = t2.includes("Spatiotemporal") || !t2.includes("Hosted Service") && !t2.includes("Tiled") || t2.includes("Relational") ? "Map Image Layer" : "Tile Layer" : e2 && e2.toLowerCase().includes("add in") ? i2 = e2.replace(/(add in)/gi, "Add-In") : e2 === "datastore catalog service" ? i2 = "Big Data File Share" : e2 === "Compact Tile Package" ? i2 = "Tile Package (tpkx)" : e2 === "OGCFeatureServer" ? i2 = "OGC Feature Layer" : e2 === "web mapping application" && t2.includes("configurableApp") && (i2 = "Instant App"), i2;
  }
  readExtent(e2) {
    return e2 && e2.length ? new w$J(e2[0][0], e2[0][1], e2[1][0], e2[1][1]) : null;
  }
  get iconUrl() {
    const e2 = this.type && this.type.toLowerCase() || "", i2 = this.typeKeywords || [], r2 = "esri/images/portal/", o2 = "16";
    let s2, a2 = false, n2 = false, l2 = false, p2 = false, c2 = false, d2 = false;
    return e2.indexOf("service") > 0 || e2 === "feature collection" || e2 === "kml" || e2 === "wms" || e2 === "wmts" || e2 === "wfs" ? (a2 = i2.includes("Hosted Service"), e2 === "feature service" || e2 === "feature collection" || e2 === "kml" || e2 === "wfs" ? (n2 = i2.includes("Table"), l2 = i2.includes("Route Layer"), p2 = i2.includes("Markup"), c2 = i2.includes("Spatiotemporal"), d2 = i2.includes("UtilityNetwork"), s2 = c2 && n2 ? "spatiotemporaltable" : n2 ? "table" : l2 ? "routelayer" : p2 ? "markup" : c2 ? "spatiotemporal" : a2 ? "featureshosted" : d2 ? "utilitynetwork" : "features") : s2 = e2 === "map service" || e2 === "wms" || e2 === "wmts" ? a2 || i2.includes("Tiled") || e2 === "wmts" ? "maptiles" : "mapimages" : e2 === "scene service" ? i2.includes("Line") ? "sceneweblayerline" : i2.includes("3DObject") ? "sceneweblayermultipatch" : i2.includes("Point") ? "sceneweblayerpoint" : i2.includes("IntegratedMesh") ? "sceneweblayermesh" : i2.includes("PointCloud") ? "sceneweblayerpointcloud" : i2.includes("Polygon") ? "sceneweblayerpolygon" : i2.includes("Building") ? "sceneweblayerbuilding" : i2.includes("Voxel") ? "sceneweblayervoxel" : "sceneweblayer" : e2 === "image service" ? i2.includes("Elevation 3D Layer") ? "elevationlayer" : i2.includes("Tiled Imagery") ? "tiledimagerylayer" : "imagery" : e2 === "stream service" ? "streamlayer" : e2 === "video service" ? "mediaservice" : e2 === "vector tile service" ? "vectortile" : e2 === "datastore catalog service" ? "datastorecollection" : e2 === "geocoding service" ? "geocodeservice" : e2 === "geoprocessing service" ? i2.includes("Web Tool") && this.portal && this.portal.isPortal ? "tool" : "layers" : e2 === "geodata service" ? "geodataservice" : "layers") : s2 = e2 === "web map" || e2 === "cityengine web scene" ? "maps" : e2 === "web scene" ? i2.includes("ViewingMode-Local") ? "webscenelocal" : "websceneglobal" : e2 === "web mapping application" && i2.includes("configurableApp") ? "instantapps" : e2 === "web mapping application" || e2 === "mobile application" || e2 === "application" || e2 === "operation view" || e2 === "desktop application" ? "apps" : e2 === "map document" || e2 === "map package" || e2 === "published map" || e2 === "scene document" || e2 === "globe document" || e2 === "basemap package" || e2 === "mobile basemap package" || e2 === "mobile map package" || e2 === "project package" || e2 === "project template" || e2 === "pro map" || e2 === "layout" || e2 === "layer" && i2.includes("ArcGIS Pro") || e2 === "explorer map" && i2.indexOf("Explorer Document") ? "mapsgray" : e2 === "service definition" || e2 === "csv" || e2 === "shapefile" || e2 === "cad drawing" || e2 === "geojson" || e2 === "360 vr experience" || e2 === "netcdf" || e2 === "administrative report" ? "datafiles" : e2 === "explorer add in" || e2 === "desktop add in" || e2 === "windows viewer add in" || e2 === "windows viewer configuration" ? "appsgray" : e2 === "arcgis pro add in" || e2 === "arcgis pro configuration" ? "addindesktop" : e2 === "rule package" || e2 === "file geodatabase" || e2 === "sqlite geodatabase" || e2 === "csv collection" || e2 === "kml collection" || e2 === "windows mobile package" || e2 === "map template" || e2 === "desktop application template" || e2 === "gml" || e2 === "arcpad package" || e2 === "code sample" || e2 === "form" || e2 === "document link" || e2 === "earth configuration" || e2 === "operations dashboard add in" || e2 === "rules package" || e2 === "image" || e2 === "workflow manager package" || e2 === "explorer map" && i2.includes("Explorer Mapping Application") || i2.includes("Document") ? "datafilesgray" : e2 === "network analysis service" || e2 === "geoprocessing service" || e2 === "geodata service" || e2 === "geometry service" || e2 === "geoprocessing package" || e2 === "locator package" || e2 === "geoprocessing sample" || e2 === "workflow manager service" ? "toolsgray" : e2 === "layer" || e2 === "layer package" || e2 === "explorer layer" ? "layersgray" : e2 === "scene package" ? "scenepackage" : e2 === "mobile scene package" ? "mobilescenepackage" : e2 === "tile package" || e2 === "compact tile package" ? "tilepackage" : e2 === "task file" ? "taskfile" : e2 === "report template" ? "report-template" : e2 === "statistical data collection" ? "statisticaldatacollection" : e2 === "insights workbook" ? "workbook" : e2 === "insights model" ? "insightsmodel" : e2 === "insights page" ? "insightspage" : e2 === "insights theme" ? "insightstheme" : e2 === "hub initiative" ? "hubinitiative" : e2 === "hubpage" ? "hubpage" : e2 === "hub event" ? "hubevent" : e2 === "hub site application" ? "hubsite" : e2 === "hub project" ? "hubproject" : e2 === "relational database connection" ? "relationaldatabaseconnection" : e2 === "big data file share" ? "datastorecollection" : e2 === "image collection" ? "imagecollection" : e2 === "style" ? "style" : e2 === "desktop style" ? "desktopstyle" : e2 === "dashboard" ? "dashboard" : e2 === "raster function template" ? "rasterprocessingtemplate" : e2 === "vector tile package" ? "vectortilepackage" : e2 === "ortho mapping project" ? "orthomappingproject" : e2 === "ortho mapping template" ? "orthomappingtemplate" : e2 === "solution" ? "solutions" : e2 === "geopackage" ? "geopackage" : e2 === "deep learning package" ? "deeplearningpackage" : e2 === "real time analytic" ? "realtimeanalytics" : e2 === "big data analytic" ? "bigdataanalytics" : e2 === "feed" ? "feed" : e2 === "excalibur imagery project" ? "excaliburimageryproject" : e2 === "notebook" ? "notebook" : e2 === "storymap" ? "storymap" : e2 === "survey123 add in" ? "survey123addin" : e2 === "mission" ? "mission" : e2 === "mission report" ? "missionreport" : e2 === "quickcapture project" ? "quickcaptureproject" : e2 === "pro report" ? "proreport" : e2 === "pro report template" ? "proreporttemplate" : e2 === "urban model" ? "urbanmodel" : e2 === "web experience" ? "experiencebuilder" : e2 === "web experience template" ? "webexperiencetemplate" : e2 === "experience builder widget" ? "experiencebuilderwidget" : e2 === "experience builder widget package" ? "experiencebuilderwidgetpackage" : e2 === "workflow" ? "workflow" : e2 === "insights script" ? "insightsscript" : e2 === "kernel gateway connection" ? "kernelgatewayconnection" : e2 === "hub initiative template" ? "hubinitiativetemplate" : e2 === "storymap theme" ? "storymaptheme" : e2 === "knowledge graph" ? "knowledgegraph" : e2 === "native application" ? "nativeapp" : e2 === "native application installer" ? "nativeappinstaller" : e2 === "link chart" ? "linkchart" : e2 === "investigation" ? "investigation" : e2 === "ogcfeatureserver" ? "features" : e2 === "pro project" ? "proproject" : e2 === "insights workbook package" ? "insightsworkbookpackage" : e2 === "apache parquet" ? "apacheparquet" : e2 === "notebook code snippets" || e2 === "notebook code snippet library" ? "notebookcodesnippets" : e2 === "suitability model" ? "suitabilitymodel" : e2 === "esri classifier definition" ? "classifierdefinition" : e2 === "esri classification schema" ? "classificationschema" : e2 === "insights data engineering workbook" ? "dataengineeringworkbook" : e2 === "insights data engineering model" ? "dataengineeringmodel" : e2 === "deep learning studio project" ? "deeplearningproject" : e2 === "discussion" ? "discussion" : "maps", s2 ? a$1G(r2 + s2 + o2 + ".png") : null;
  }
  get isLayer() {
    return this.type != null && b$a.has(this.type);
  }
  get itemPageUrl() {
    var _a2;
    const e2 = (_a2 = this.portal) == null ? void 0 : _a2.itemPageUrl;
    return e2 && this.id ? `${e2}?id=${this.id}` : null;
  }
  get itemUrl() {
    var _a2;
    const e2 = (_a2 = this.portal) == null ? void 0 : _a2.restUrl;
    return e2 && this.id ? `${e2}/content/items/${this.id}` : null;
  }
  get thumbnailUrl() {
    var _a2, _b2;
    const e2 = this.itemUrl, t2 = this.thumbnail;
    return e2 && t2 ? (_b2 = (_a2 = this.portal) == null ? void 0 : _a2._normalizeUrl(`${e2}/info/${t2}?f=json`)) != null ? _b2 : null : null;
  }
  get userItemUrl() {
    const e2 = this.get("portal.restUrl");
    if (!e2)
      return null;
    const t2 = this.owner || this.get("portal.user.username");
    if (!t2)
      return null;
    return `${e2}/content/users/${this.ownerFolder ? `${t2}/${this.ownerFolder}` : t2}/items/${this.id}`;
  }
  load(e2) {
    var _a2;
    const t2 = (_a2 = this.portal) != null ? _a2 : this.portal = j$y.getDefault(), i2 = t2.load(e2).then(() => this.sourceJSON ? this.sourceJSON : this.id && this.itemUrl ? t2._request(this.itemUrl, { signal: r$1t(e2) ? e2.signal : null, query: { token: this.apiKey } }) : {}).then((e3) => {
      this.sourceJSON = e3, this.read(e3);
    });
    return this.addResolvingPromise(i2), Promise.resolve(this);
  }
  async addRating(e2) {
    const t2 = { method: "post", query: {} };
    return e2 instanceof c$D && (e2 = e2.rating), e2 == null || isNaN(e2) || typeof e2 != "number" || (t2.query.rating = e2), this.portal ? (await this.portal._request(this.itemUrl + "/addRating", t2), new c$D({ rating: e2, created: new Date() })) : null;
  }
  clone() {
    const e2 = { access: this.access, accessInformation: this.accessInformation, applicationProxies: y$1r(this.applicationProxies), avgRating: this.avgRating, categories: y$1r(this.categories), created: y$1r(this.created), culture: this.culture, description: this.description, extent: y$1r(this.extent), groupCategories: y$1r(this.groupCategories), id: this.id, itemControl: this.itemControl, licenseInfo: this.licenseInfo, modified: y$1r(this.modified), name: this.name, numComments: this.numComments, numRatings: this.numRatings, numViews: this.numViews, owner: this.owner, ownerFolder: this.ownerFolder, portal: this.portal, screenshots: y$1r(this.screenshots), size: this.size, snippet: this.snippet, spatialReference: this.spatialReference, tags: y$1r(this.tags), thumbnail: this.thumbnail, title: this.title, type: this.type, typeKeywords: y$1r(this.typeKeywords), url: this.url };
    return this.loaded && (e2.loadStatus = "loaded"), new f$m({ sourceJSON: this.sourceJSON }).set(e2);
  }
  createPostQuery() {
    const e2 = this.toJSON();
    for (const i2 of ["tags", "typeKeywords", "categories"])
      e2[i2] && (e2[i2] = e2[i2].join(", "));
    const { extent: t2 } = e2;
    return t2 && (e2.extent = JSON.stringify(t2)), e2;
  }
  async deleteRating() {
    await f$1F(this.portal)._request(this.itemUrl + "/deleteRating", { method: "post" });
  }
  fetchData(e2 = "json", t2) {
    return f$1F(this.portal)._request(this.itemUrl + "/data", __spreadProps(__spreadValues({ responseType: e2 }, t2), { query: { token: this.apiKey } }));
  }
  async fetchRating(e2) {
    const t2 = await f$1F(this.portal)._request(this.itemUrl + "/rating", __spreadValues({ query: { token: this.apiKey } }, e2));
    return t2.rating != null ? (t2.created = new Date(t2.created), new c$D(t2)) : null;
  }
  fetchRelatedItems(e2, t2) {
    return f$1F(this.portal)._requestToTypedArray(this.itemUrl + "/relatedItems", __spreadValues({ query: __spreadProps(__spreadValues({}, e2), { token: this.apiKey }) }, t2), f$m);
  }
  getThumbnailUrl(e2) {
    let t2 = this.thumbnailUrl;
    return t2 && e2 && (t2 += `&w=${e2}`), t2;
  }
  reload() {
    var _a2;
    return f$1F(this.portal)._request((_a2 = this.itemUrl) != null ? _a2 : "", { cacheBust: true, query: { token: this.apiKey } }).then((e2) => (this.sourceJSON = e2, this.read(e2), this));
  }
  update(e2) {
    return this.id ? this.load().then(() => f$1F(this.portal)._signIn()).then(() => {
      const t2 = e2 && e2.data, i2 = { method: "post" };
      i2.query = this.createPostQuery();
      for (const e3 in i2.query)
        i2.query[e3] === null && (i2.query[e3] = "");
      return i2.query.clearEmptyFields = true, t2 != null && (typeof t2 == "string" ? i2.query.text = t2 : typeof t2 == "object" && (i2.query.text = JSON.stringify(t2))), this.portal._request(`${this.userItemUrl}/update`, i2).then(() => this.reload());
    }) : Promise.reject(new s$1Z("portal:item-does-not-exist", "The item does not exist yet and cannot be updated"));
  }
  updateThumbnail(e2) {
    return this.id ? this.load().then(() => this.portal._signIn()).then(() => {
      const t2 = e2.thumbnail, i2 = e2.filename, r2 = { method: "post" };
      if (typeof t2 == "string")
        X$6(t2) ? r2.query = { data: t2 } : r2.query = { url: Q$9(t2) }, r$1t(i2) && (r2.query.filename = i2);
      else {
        const e3 = new FormData();
        r$1t(i2) ? e3.append("file", t2, i2) : e3.append("file", t2), r2.body = e3;
      }
      return this.portal._request(`${this.userItemUrl}/updateThumbnail`, r2).then(() => this.reload());
    }) : Promise.reject(new s$1Z("portal:item-does-not-exist", "The item does not exist yet and cannot be updated"));
  }
  async fetchResources(e2 = {}, t2) {
    return (await import("./resourceUtils.js")).fetchResources(this, e2, t2);
  }
  async addResource(e2, t2, i2) {
    const r2 = await import("./resourceUtils.js");
    return e2.portalItem = this, r2.addOrUpdateResource(e2, "add", t2, i2);
  }
  async removeResource(e2, t2) {
    const r2 = await import("./resourceUtils.js");
    if (e2.portalItem && e2.portalItem.itemUrl !== this.itemUrl)
      throw new s$1Z("removeresource:portal-item-mismatch", "The portal item associated with the provided resource does not match the item");
    return r2.removeResource(this, e2, t2);
  }
  async removeAllResources(e2) {
    return (await import("./resourceUtils.js")).removeAllResources(this, e2);
  }
  resourceFromPath(e2) {
    return new n$C({ portalItem: this, path: e2 });
  }
  toJSON() {
    const e2 = this.extent, t2 = { accessInformation: this.accessInformation, categories: y$1r(this.categories), created: this.created && this.created.getTime(), description: this.description, extent: e2 && [[e2.xmin, e2.ymin], [e2.xmax, e2.ymax]], id: this.id, licenseInfo: this.licenseInfo, modified: this.modified && this.modified.getTime(), name: this.name, owner: this.owner, ownerFolder: this.ownerFolder, snippet: this.snippet, spatialReference: this.spatialReference, tags: y$1r(this.tags), thumbnail: this.thumbnail, title: this.title, type: this.type, typeKeywords: y$1r(this.typeKeywords), url: this.url };
    return p$31(t2);
  }
  static fromJSON(e2) {
    if (!e2)
      return null;
    if (e2.declaredClass)
      throw new Error("JSON object is already hydrated");
    return new f$m({ sourceJSON: e2 });
  }
  _getPostQuery() {
    const e2 = this.toJSON();
    for (const t2 in e2)
      t2 === "tags" && e2[t2] !== null && (e2[t2] = e2[t2].join(", ")), t2 === "typeKeywords" && e2[t2] !== null && (e2[t2] = e2[t2].join(", ")), t2 === "extent" && e2[t2] && (e2[t2] = JSON.stringify(e2[t2]));
    return e2;
  }
};
e$1W([y$1o({ type: ["private", "shared", "org", "public"] })], S$7.prototype, "access", void 0), e$1W([y$1o()], S$7.prototype, "accessInformation", void 0), e$1W([y$1o({ type: String })], S$7.prototype, "apiKey", void 0), e$1W([y$1o({ json: { read: { source: "appProxies" } } })], S$7.prototype, "applicationProxies", void 0), e$1W([y$1o()], S$7.prototype, "avgRating", void 0), e$1W([y$1o()], S$7.prototype, "categories", void 0), e$1W([y$1o({ type: Date })], S$7.prototype, "created", void 0), e$1W([y$1o()], S$7.prototype, "culture", void 0), e$1W([y$1o()], S$7.prototype, "description", void 0), e$1W([y$1o({ readOnly: true })], S$7.prototype, "displayName", null), e$1W([y$1o({ type: w$J })], S$7.prototype, "extent", void 0), e$1W([o$1H("extent")], S$7.prototype, "readExtent", null), e$1W([y$1o()], S$7.prototype, "groupCategories", void 0), e$1W([y$1o({ readOnly: true })], S$7.prototype, "iconUrl", null), e$1W([y$1o()], S$7.prototype, "id", void 0), e$1W([y$1o({ readOnly: true })], S$7.prototype, "isLayer", null), e$1W([y$1o()], S$7.prototype, "itemControl", void 0), e$1W([y$1o({ readOnly: true })], S$7.prototype, "itemPageUrl", null), e$1W([y$1o({ readOnly: true })], S$7.prototype, "itemUrl", null), e$1W([y$1o()], S$7.prototype, "licenseInfo", void 0), e$1W([y$1o({ type: Date })], S$7.prototype, "modified", void 0), e$1W([y$1o()], S$7.prototype, "name", void 0), e$1W([y$1o()], S$7.prototype, "numComments", void 0), e$1W([y$1o()], S$7.prototype, "numRatings", void 0), e$1W([y$1o()], S$7.prototype, "numViews", void 0), e$1W([y$1o()], S$7.prototype, "owner", void 0), e$1W([y$1o()], S$7.prototype, "ownerFolder", void 0), e$1W([y$1o({ type: j$y })], S$7.prototype, "portal", void 0), e$1W([y$1o()], S$7.prototype, "screenshots", void 0), e$1W([y$1o()], S$7.prototype, "size", void 0), e$1W([y$1o()], S$7.prototype, "snippet", void 0), e$1W([y$1o()], S$7.prototype, "sourceJSON", void 0), e$1W([y$1o({ type: String })], S$7.prototype, "spatialReference", void 0), e$1W([y$1o()], S$7.prototype, "tags", void 0), e$1W([y$1o()], S$7.prototype, "thumbnail", void 0), e$1W([y$1o({ readOnly: true })], S$7.prototype, "thumbnailUrl", null), e$1W([y$1o()], S$7.prototype, "title", void 0), e$1W([y$1o()], S$7.prototype, "type", void 0), e$1W([y$1o()], S$7.prototype, "typeKeywords", void 0), e$1W([y$1o({ type: String, json: { read(e2, t2) {
  var _a2;
  if (k$4.has(t2.type)) {
    const t3 = (_a2 = this.portal) == null ? void 0 : _a2.restUrl;
    e2 || (e2 = t3 && this.id ? `${t3}/content/items/${this.id}/data` : null);
  }
  return e2;
} } })], S$7.prototype, "url", void 0), e$1W([y$1o({ readOnly: true })], S$7.prototype, "userItemUrl", null), S$7 = f$m = e$1W([n$2f("esri.portal.PortalItem")], S$7);
const x$7 = S$7;
var PortalItem = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": x$7
});
const v$b = (v2) => {
  let U2 = class extends v2 {
    constructor() {
      super(...arguments), this.resourceReferences = { portalItem: null, paths: [] }, this.userHasEditingPrivileges = true;
    }
    destroy() {
      this.portalItem = s$26(this.portalItem);
    }
    set portalItem(t2) {
      t2 !== this._get("portalItem") && (this.removeOrigin("portal-item"), this._set("portalItem", t2));
    }
    readPortalItem(t2, e2, r2) {
      if (e2.itemId)
        return new x$7({ id: e2.itemId, portal: r2 && r2.portal });
    }
    writePortalItem(t2, e2) {
      t2 && t2.id && (e2.itemId = t2.id);
    }
    async loadFromPortal(t2, e2) {
      if (this.portalItem && this.portalItem.id)
        try {
          const r2 = await import("./layersLoader.js").then(function(n2) {
            return n2.l;
          });
          return f$1x(e2), await r2.load({ instance: this, supportedTypes: t2.supportedTypes, validateItem: t2.validateItem, supportsData: t2.supportsData, layerModuleTypeMap: t2.layerModuleTypeMap }, e2);
        } catch (r2) {
          throw j$K(r2) || s$22.getLogger(this.declaredClass).warn(`Failed to load layer (${this.title}, ${this.id}) portal item (${this.portalItem.id})
  ${r2}`), r2;
        }
    }
    async finishLoadEditablePortalLayer(t2) {
      this._set("userHasEditingPrivileges", await this._fetchUserHasEditingPrivileges(t2).catch((t3) => (w$O(t3), true)));
    }
    async _fetchUserHasEditingPrivileges(t2) {
      const r2 = this.url ? s$1k == null ? void 0 : s$1k.findCredential(this.url) : null;
      if (!r2)
        return true;
      const s2 = P$6.credential === r2 ? P$6.user : await this._fetchEditingUser(t2);
      return P$6.credential = r2, P$6.user = s2, t$1W(s2) || s2.privileges == null || s2.privileges.includes("features:user:edit");
    }
    async _fetchEditingUser(t2) {
      var _a2, _b2, _c2;
      const o2 = (_b2 = (_a2 = this.portalItem) == null ? void 0 : _a2.portal) == null ? void 0 : _b2.user;
      if (o2)
        return o2;
      const i2 = s$1k.findServerInfo((_c2 = this.url) != null ? _c2 : "");
      if (!(i2 == null ? void 0 : i2.owningSystemUrl))
        return null;
      const a2 = `${i2.owningSystemUrl}/sharing/rest`, l2 = j$y.getDefault();
      if (l2 && l2.loaded && F$g(l2.restUrl) === F$g(a2))
        return l2.user;
      const n2 = `${a2}/community/self`, m2 = r$1t(t2) ? t2.signal : null, c2 = await b$w(U$k(n2, { authMode: "no-prompt", query: { f: "json" }, signal: m2 }));
      return c2.ok ? p$24.fromJSON(c2.value.data) : null;
    }
    read(t2, e2) {
      e2 && (e2.layer = this), super.read(t2, e2);
    }
    write(t2, e2) {
      const r2 = e2 && e2.portal, s2 = this.portalItem && this.portalItem.id && (this.portalItem.portal || j$y.getDefault());
      return r2 && s2 && !N$c(s2.restUrl, r2.restUrl) ? (e2.messages && e2.messages.push(new s$1Z("layer:cross-portal", `The layer '${this.title} (${this.id})' cannot be persisted because it refers to an item on a different portal than the one being saved to. To save, set layer.portalItem to null or save to the same portal as the item associated with the layer`, { layer: this })), null) : super.write(t2, __spreadProps(__spreadValues({}, e2), { layer: this }));
    }
  };
  return e$1W([y$1o({ type: x$7 })], U2.prototype, "portalItem", null), e$1W([o$1H("web-document", "portalItem", ["itemId"])], U2.prototype, "readPortalItem", null), e$1W([r$1h("web-document", "portalItem", { itemId: { type: String } })], U2.prototype, "writePortalItem", null), e$1W([y$1o({ clonable: false })], U2.prototype, "resourceReferences", void 0), e$1W([y$1o({ readOnly: true })], U2.prototype, "userHasEditingPrivileges", void 0), U2 = e$1W([n$2f("esri.layers.mixins.PortalLayer")], U2), U2;
}, P$6 = { credential: null, user: null };
let e$r = class extends m$1L {
  constructor() {
    super(...arguments), this.updating = false, this.status = "unknown";
  }
};
e$1W([y$1o()], e$r.prototype, "updating", void 0), e$1W([y$1o()], e$r.prototype, "status", void 0), e$r = e$1W([n$2f("esri.layers.support.PublishingInfo")], e$r);
const p$E = e$r;
const o$u = "esri.layers.mixins.PublishableLayer";
const u$s = (i2) => {
  let n2 = class extends i2 {
    get publishingInfo() {
      if (this.destroyed)
        return null;
      const t2 = this._get("publishingInfo");
      if (t2)
        return t2;
      const s2 = new p$E();
      return this._checkPublishingStatus(s2), s2;
    }
    _checkPublishingStatus(t2) {
      const s2 = 250, e2 = 125;
      let r2 = 0;
      const o2 = async (s3) => {
        let n3;
        t2.updating = true;
        try {
          n3 = await this.fetchPublishingStatus();
        } catch (u2) {
          n3 = "unavailable";
        }
        n3 !== "published" && n3 !== "unavailable" || (t2.status === "publishing" && this.refresh(), i3.remove()), t2.status = n3, t2.updating = false, i3.removed || (r2 = setTimeout(o2, s3, s3 + e2));
      }, i3 = { removed: false, remove() {
        this.removed = true, clearTimeout(r2);
      } };
      this.when().catch(() => i3.remove()), o2(s2), this.own(i3);
    }
  };
  return e$1W([y$1o({ readOnly: true, clonable: false })], n2.prototype, "publishingInfo", null), n2 = e$1W([n$2f(o$u)], n2), n2;
};
const t$v = new j$F(), o$t = new WeakMap();
function n$B(e2) {
  c$C(e2) && t$v.push(e2);
}
function s$v(e2) {
  c$C(e2) && t$v.includes(e2) && t$v.remove(e2);
}
function c$C(e2) {
  return e2 != null && typeof e2 == "object" && "refreshInterval" in e2 && "refresh" in e2;
}
function i$C(e2, r2) {
  return Number.isFinite(e2) && Number.isFinite(r2) ? r2 <= 0 ? e2 : i$C(r2, e2 % r2) : 0;
}
let f$l = 0, a$L = 0;
function l$A() {
  var _a2;
  const e2 = Date.now();
  for (const r2 of t$v)
    if (r2.refreshInterval) {
      e2 - ((_a2 = o$t.get(r2)) != null ? _a2 : 0) + 5 >= 6e4 * r2.refreshInterval && (o$t.set(r2, e2), r2.refresh(e2));
    }
}
l$20(() => {
  const e2 = Date.now();
  let r2 = 0;
  for (const n2 of t$v)
    r2 = i$C(Math.round(6e4 * n2.refreshInterval), r2), n2.refreshInterval ? o$t.get(n2) || o$t.set(n2, e2) : o$t.delete(n2);
  if (r2 !== a$L) {
    if (a$L = r2, clearInterval(f$l), a$L === 0)
      return void (f$l = 0);
    f$l = setInterval(l$A, a$L);
  }
});
const p$D = (n2) => {
  let p2 = class extends n2 {
    constructor(...e2) {
      super(...e2), this.refreshInterval = 0, this.refreshTimestamp = 0, this._debounceHasDataChanged = x$L(() => this.hasDataChanged()), this.when().then(() => {
        n$B(this);
      }, () => {
      });
    }
    destroy() {
      s$v(this);
    }
    get refreshParameters() {
      return { _ts: this.refreshTimestamp || null };
    }
    refresh(e2 = Date.now()) {
      g$12(this._debounceHasDataChanged()).then((r2) => {
        r2 && this._set("refreshTimestamp", e2), this.emit("refresh", { dataChanged: r2 });
      }, (e3) => {
        s$22.getLogger(this.declaredClass).error(e3), this.emit("refresh", { dataChanged: false, error: e3 });
      });
    }
    async hasDataChanged() {
      return true;
    }
  };
  return e$1W([y$1o({ type: Number, cast: (e2) => e2 >= 0.1 ? e2 : e2 <= 0 ? 0 : 0.1, json: { write: true } })], p2.prototype, "refreshInterval", void 0), e$1W([y$1o({ readOnly: true })], p2.prototype, "refreshTimestamp", void 0), e$1W([y$1o()], p2.prototype, "refreshParameters", null), p2 = e$1W([n$2f("esri.layers.mixins.RefreshableLayer")], p2), p2;
};
const t$u = (t2) => {
  let l2 = class extends t2 {
    constructor() {
      super(...arguments), this.minScale = 0, this.maxScale = 0;
    }
    get effectiveScaleRange() {
      const e2 = { minScale: this.minScale, maxScale: this.maxScale }, a2 = this.parent;
      a2 && "effectiveScaleRange" in a2 && r$r(e2, a2.effectiveScaleRange);
      const c2 = this._get("effectiveScaleRange");
      return c2 && c2.minScale === e2.minScale && c2.maxScale === e2.maxScale ? c2 : e2;
    }
  };
  return e$1W([y$1o({ type: Number, nonNullable: true, json: { write: true } })], l2.prototype, "minScale", void 0), e$1W([y$1o({ type: Number, nonNullable: true, json: { write: true } })], l2.prototype, "maxScale", void 0), e$1W([y$1o({ readOnly: true })], l2.prototype, "effectiveScaleRange", null), l2 = e$1W([n$2f("esri.layers.mixins.ScaleRangeLayer")], l2), l2;
};
function r$r(e2, a2) {
  return e2.minScale = e2.minScale > 0 ? a2.minScale > 0 ? Math.min(e2.minScale, a2.minScale) : e2.minScale : a2.minScale, e2.maxScale = e2.maxScale > 0 ? a2.maxScale > 0 ? Math.max(e2.maxScale, a2.maxScale) : e2.maxScale : a2.maxScale, e2;
}
const e$q = o$1w()({ esriTimeUnitsMilliseconds: "milliseconds", esriTimeUnitsSeconds: "seconds", esriTimeUnitsMinutes: "minutes", esriTimeUnitsHours: "hours", esriTimeUnitsDays: "days", esriTimeUnitsWeeks: "weeks", esriTimeUnitsMonths: "months", esriTimeUnitsYears: "years", esriTimeUnitsDecades: "decades", esriTimeUnitsCenturies: "centuries", esriTimeUnitsUnknown: void 0 });
var p$C;
let a$K = p$C = class extends l$1_ {
  constructor(r2) {
    super(r2), this.value = 0, this.unit = "milliseconds";
  }
  toMilliseconds() {
    return g$w(this.value, this.unit, "milliseconds");
  }
  clone() {
    return new p$C({ value: this.value, unit: this.unit });
  }
};
e$1W([y$1o({ type: Number, json: { write: true }, nonNullable: true })], a$K.prototype, "value", void 0), e$1W([y$1o({ type: e$q.apiValues, json: { type: e$q.jsonValues, read: e$q.read, write: e$q.write }, nonNullable: true })], a$K.prototype, "unit", void 0), a$K = p$C = e$1W([n$2f("esri.TimeInterval")], a$K);
const l$z = a$K;
var i$B;
let a$J = i$B = class extends l$1_ {
  constructor(e2) {
    super(e2), this.respectsDaylightSaving = false, this.timezone = null;
  }
  readRespectsDaylightSaving(e2, t2) {
    return t2.respectsDaylightSaving !== void 0 ? t2.respectsDaylightSaving : t2.respectDaylightSaving !== void 0 && t2.respectDaylightSaving;
  }
  clone() {
    const { respectsDaylightSaving: e2, timezone: t2 } = this;
    return new i$B({ respectsDaylightSaving: e2, timezone: t2 });
  }
};
e$1W([y$1o({ type: Boolean, json: { write: true } })], a$J.prototype, "respectsDaylightSaving", void 0), e$1W([o$1H("respectsDaylightSaving", ["respectsDaylightSaving", "respectDaylightSaving"])], a$J.prototype, "readRespectsDaylightSaving", null), e$1W([y$1o({ type: String, json: { read: { source: "timeZone" }, write: { target: "timeZone" } } })], a$J.prototype, "timezone", void 0), a$J = i$B = e$1W([n$2f("esri.layers.support.TimeReference")], a$J);
const p$B = a$J;
var d$j;
let c$B = d$j = class extends l$1_ {
  constructor(e2) {
    super(e2), this.cumulative = false, this.endField = null, this.fullTimeExtent = null, this.hasLiveData = false, this.interval = null, this.startField = null, this.timeReference = null, this.trackIdField = null, this.useTime = true;
  }
  readFullTimeExtent(e2, r2) {
    if (!r2.timeExtent || !Array.isArray(r2.timeExtent) || r2.timeExtent.length !== 2)
      return null;
    const i2 = new Date(r2.timeExtent[0]), l2 = new Date(r2.timeExtent[1]);
    return new T$b({ start: i2, end: l2 });
  }
  writeFullTimeExtent(e2, t2) {
    e2 && r$1t(e2.start) && r$1t(e2.end) ? t2.timeExtent = [e2.start.getTime(), e2.end.getTime()] : t2.timeExtent = null;
  }
  readInterval(e2, t2) {
    return t2.timeInterval && t2.timeIntervalUnits ? new l$z({ value: t2.timeInterval, unit: e$q.fromJSON(t2.timeIntervalUnits) }) : t2.defaultTimeInterval && t2.defaultTimeIntervalUnits ? new l$z({ value: t2.defaultTimeInterval, unit: e$q.fromJSON(t2.defaultTimeIntervalUnits) }) : null;
  }
  writeInterval(e2, t2) {
    if (e2) {
      const r2 = e2.toJSON();
      t2.timeInterval = r2.value, t2.timeIntervalUnits = r2.unit;
    } else
      t2.timeInterval = null, t2.timeIntervalUnits = null;
  }
  clone() {
    const { cumulative: e2, endField: t2, hasLiveData: r2, interval: i2, startField: o2, timeReference: n2, fullTimeExtent: a2, trackIdField: s2, useTime: m2 } = this;
    return new d$j({ cumulative: e2, endField: t2, hasLiveData: r2, interval: i2, startField: o2, timeReference: y$1r(n2), fullTimeExtent: y$1r(a2), trackIdField: s2, useTime: m2 });
  }
};
e$1W([y$1o({ type: Boolean, json: { read: { source: "exportOptions.timeDataCumulative" }, write: { target: "exportOptions.timeDataCumulative" } } })], c$B.prototype, "cumulative", void 0), e$1W([y$1o({ type: String, json: { read: { source: "endTimeField" }, write: { target: "endTimeField", allowNull: true } } })], c$B.prototype, "endField", void 0), e$1W([y$1o({ type: T$b, json: { write: { enabled: true, allowNull: true } } })], c$B.prototype, "fullTimeExtent", void 0), e$1W([o$1H("fullTimeExtent", ["timeExtent"])], c$B.prototype, "readFullTimeExtent", null), e$1W([r$1h("fullTimeExtent")], c$B.prototype, "writeFullTimeExtent", null), e$1W([y$1o({ type: Boolean, json: { write: true } })], c$B.prototype, "hasLiveData", void 0), e$1W([y$1o({ type: l$z, json: { write: { enabled: true, allowNull: true } } })], c$B.prototype, "interval", void 0), e$1W([o$1H("interval", ["timeInterval", "timeIntervalUnits", "defaultTimeInterval", "defaultTimeIntervalUnits"])], c$B.prototype, "readInterval", null), e$1W([r$1h("interval")], c$B.prototype, "writeInterval", null), e$1W([y$1o({ type: String, json: { read: { source: "startTimeField" }, write: { target: "startTimeField", allowNull: true } } })], c$B.prototype, "startField", void 0), e$1W([y$1o({ type: p$B, json: { write: { enabled: true, allowNull: true } } })], c$B.prototype, "timeReference", void 0), e$1W([y$1o({ type: String, json: { write: { enabled: true, allowNull: true } } })], c$B.prototype, "trackIdField", void 0), e$1W([y$1o({ type: Boolean, json: { read: { source: "exportOptions.useTime" }, write: { target: "exportOptions.useTime" } } })], c$B.prototype, "useTime", void 0), c$B = d$j = e$1W([n$2f("esri.layers.support.TimeInfo")], c$B);
const v$a = c$B;
const a$I = (a2) => {
  let f2 = class extends a2 {
    constructor() {
      super(...arguments), this.timeExtent = null, this.timeOffset = null, this.useViewTime = true;
    }
    readOffset(e2, t2) {
      const o2 = t2.timeInfo.exportOptions;
      if (!o2)
        return null;
      const i2 = o2.timeOffset, s2 = e$q.fromJSON(o2.timeOffsetUnits);
      return i2 && s2 ? new l$z({ value: i2, unit: s2 }) : null;
    }
    set timeInfo(e2) {
      x$B(e2, this.fieldsIndex), this._set("timeInfo", e2);
    }
  };
  return e$1W([y$1o({ type: T$b, json: { write: false } })], f2.prototype, "timeExtent", void 0), e$1W([y$1o({ type: l$z })], f2.prototype, "timeOffset", void 0), e$1W([o$1H("service", "timeOffset", ["timeInfo.exportOptions"])], f2.prototype, "readOffset", null), e$1W([y$1o({ value: null, type: v$a, json: { write: true, origins: { "web-document": { read: false, write: false }, "portal-item": { read: false, write: false } } } })], f2.prototype, "timeInfo", null), e$1W([y$1o({ type: Boolean, json: { read: { source: "timeAnimation" }, write: { target: "timeAnimation" }, origins: { "web-scene": { read: false, write: false } } } })], f2.prototype, "useViewTime", void 0), f2 = e$1W([n$2f("esri.layers.mixins.TemporalLayer")], f2), f2;
};
const l$y = new s$1F({ esriFeatureEditToolAutoCompletePolygon: "auto-complete-polygon", esriFeatureEditToolCircle: "circle", esriFeatureEditToolEllipse: "ellipse", esriFeatureEditToolFreehand: "freehand", esriFeatureEditToolLine: "line", esriFeatureEditToolNone: "none", esriFeatureEditToolPoint: "point", esriFeatureEditToolPolygon: "polygon", esriFeatureEditToolRectangle: "rectangle", esriFeatureEditToolArrow: "arrow", esriFeatureEditToolTriangle: "triangle", esriFeatureEditToolLeftArrow: "left-arrow", esriFeatureEditToolRightArrow: "right-arrow", esriFeatureEditToolUpArrow: "up-arrow", esriFeatureEditToolDownArrow: "down-arrow" });
let a$H = class extends i$28(l$1_) {
  constructor(o2) {
    super(o2), this.name = null, this.description = null, this.drawingTool = null, this.prototype = null, this.thumbnail = null;
  }
};
e$1W([y$1o({ json: { write: true } })], a$H.prototype, "name", void 0), e$1W([y$1o({ json: { write: true } })], a$H.prototype, "description", void 0), e$1W([y$1o({ json: { read: l$y.read, write: l$y.write } })], a$H.prototype, "drawingTool", void 0), e$1W([y$1o({ json: { write: true } })], a$H.prototype, "prototype", void 0), e$1W([y$1o({ json: { write: true } })], a$H.prototype, "thumbnail", void 0), a$H = e$1W([n$2f("esri.layers.support.FeatureTemplate")], a$H);
const p$A = a$H;
let c$A = class extends i$28(l$1_) {
  constructor(o2) {
    super(o2), this.id = null, this.name = null, this.domains = null, this.templates = null;
  }
  readDomains(o2) {
    const r2 = {};
    for (const t2 of Object.keys(o2))
      r2[t2] = t$Q(o2[t2]);
    return r2;
  }
  writeDomains(o2, r2) {
    var _a2;
    const t2 = {};
    for (const s2 of Object.keys(o2))
      o2[s2] && (t2[s2] = (_a2 = o2[s2]) == null ? void 0 : _a2.toJSON());
    r2.domains = t2;
  }
};
e$1W([y$1o({ json: { write: true } })], c$A.prototype, "id", void 0), e$1W([y$1o({ json: { write: true } })], c$A.prototype, "name", void 0), e$1W([y$1o({ json: { write: true } })], c$A.prototype, "domains", void 0), e$1W([o$1H("domains")], c$A.prototype, "readDomains", null), e$1W([r$1h("domains")], c$A.prototype, "writeDomains", null), e$1W([y$1o({ type: [p$A], json: { write: true } })], c$A.prototype, "templates", void 0), c$A = e$1W([n$2f("esri.layers.support.FeatureType")], c$A);
const n$A = c$A;
function s$u(e2) {
  return e2.type === "date" || e2.type === "esriFieldTypeDate";
}
function l$x(e2) {
  return e2.type === "oid" || e2.type === "esriFieldTypeOID";
}
function d$i(e2) {
  return e2.type === "global-id" || e2.type === "esriFieldTypeGlobalID";
}
class r$q {
  constructor(i2 = []) {
    if (this.fields = [], this._fieldsMap = new Map(), this._normalizedFieldsMap = new Map(), this._dateFieldsSet = new Set(), this._numericFieldsSet = new Set(), this.dateFields = [], this.numericFields = [], this._requiredFields = null, !i2)
      return;
    this.fields = i2;
    const t2 = [];
    for (const r2 of i2) {
      const i3 = r2 && r2.name;
      if (i3) {
        const u2 = n$z(i3), h2 = a$G(i3);
        this._fieldsMap.set(i3, r2), this._fieldsMap.set(u2, r2), this._normalizedFieldsMap.set(h2, r2), t2.push(u2), s$u(r2) ? (this.dateFields.push(r2), this._dateFieldsSet.add(r2)) : ie$3(r2) && (this._numericFieldsSet.add(r2), this.numericFields.push(r2)), l$x(r2) || d$i(r2) || (r2.editable = r2.editable == null || !!r2.editable, r2.nullable = r2.nullable == null || !!r2.nullable);
      }
    }
    t2.sort(), this.uid = t2.join(",");
  }
  destroy() {
    this._fieldsMap.clear();
  }
  get requiredFields() {
    if (!this._requiredFields) {
      this._requiredFields = [];
      for (const e2 of this.fields)
        l$x(e2) || d$i(e2) || e2.nullable || M$o(e2) !== void 0 || this._requiredFields.push(e2);
    }
    return this._requiredFields;
  }
  has(e2) {
    return this.get(e2) != null;
  }
  get(e2) {
    var _a2;
    if (!e2)
      return;
    let i2 = this._fieldsMap.get(e2);
    return i2 || (i2 = (_a2 = this._fieldsMap.get(n$z(e2))) != null ? _a2 : this._normalizedFieldsMap.get(a$G(e2)), i2 && this._fieldsMap.set(e2, i2), i2);
  }
  isDateField(e2) {
    return this._dateFieldsSet.has(this.get(e2));
  }
  isNumericField(e2) {
    return this._numericFieldsSet.has(this.get(e2));
  }
  normalizeFieldName(e2) {
    var _a2;
    const i2 = this.get(e2);
    if (i2)
      return (_a2 = i2.name) != null ? _a2 : void 0;
  }
}
function n$z(e2) {
  return e2.trim().toLowerCase();
}
function a$G(e2) {
  return p$2M(e2).toLowerCase();
}
function s$t() {
  return { fields: { type: [y$H], value: null }, fieldsIndex: { readOnly: true, get() {
    return new r$q(this.fields || []);
  } }, outFields: { type: [String], json: { read: false }, set: function(e2) {
    this._userOutFields = e2, this.notifyChange("outFields");
  }, get: function() {
    var _a2;
    const i2 = this._userOutFields;
    if (!i2 || !i2.length)
      return null;
    if (i2.includes("*"))
      return ["*"];
    if (!this.fields)
      return i2;
    for (const t2 of i2) {
      const r2 = (_a2 = this.fieldsIndex) == null ? void 0 : _a2.has(t2);
      r2 || s$22.getLogger("esri.layers.support.fieldProperties").error("field-attributes-layer:invalid-field", `Invalid field ${t2} found in outFields`, { layer: this, outFields: i2 });
    }
    return T$n(this.fieldsIndex, i2);
  } } };
}
const n$y = s$22.getLogger("esri.layers.support.labelingInfo"), l$w = /\[([^\[\]]+)\]/gi;
function i$A(e2, r2, o2) {
  return e2 ? e2.map((e3) => {
    const n2 = new j$6();
    if (n2.read(e3, o2), n2.labelExpression) {
      const e4 = r2.fields || r2.layerDefinition && r2.layerDefinition.fields || this.fields;
      n2.labelExpression = n2.labelExpression.replace(l$w, (r3, o3) => `[${s$s(o3, e4)}]`);
    }
    return n2;
  }) : null;
}
function s$s(e2, r2) {
  if (!r2)
    return e2;
  const o2 = e2.toLowerCase();
  for (let t2 = 0; t2 < r2.length; t2++) {
    const e3 = r2[t2].name;
    if (e3.toLowerCase() === o2)
      return e3;
  }
  return e2;
}
const a$F = { esriGeometryPoint: ["above-right", "above-center", "above-left", "center-center", "center-left", "center-right", "below-center", "below-left", "below-right"], esriGeometryPolygon: ["always-horizontal"], esriGeometryPolyline: ["center-along"], esriGeometryMultipoint: null };
function c$z(e2, o2) {
  const t2 = y$1r(e2);
  return t2.some((e3) => f$k(e3, o2)) ? [] : t2;
}
function f$k(r2, o2) {
  const t2 = r2.labelPlacement, l2 = a$F[o2];
  if (!r2.symbol)
    return n$y.warn("No ILabelClass symbol specified."), true;
  if (!l2)
    return n$y.error(new s$1Z("labeling:unsupported-geometry-type", `Unable to create labels for layer, geometry type '${o2}' is not supported`)), true;
  if (!l2.includes(t2)) {
    const e2 = l2[0];
    t2 && n$y.warn(`Found invalid label placement type ${t2} for ${o2}. Defaulting to ${e2}`), r2.labelPlacement = e2;
  }
  return false;
}
const t$t = [];
function e$p(e2, r2) {
  var _a2, _b2;
  if (g$n((_a2 = e2.url) != null ? _a2 : ""))
    return true;
  const { wkid: o2 } = r2;
  for (const d2 of t$t) {
    if (((_b2 = e2.version) != null ? _b2 : 0) >= d2[0])
      return true;
    if (typeof d2[1] == "function" && (d2[1] = d2[1]()), d2[1].has(o2))
      return false;
  }
  return true;
}
t$t.push([10.91, () => {
  const d2 = new Set([9709, 9716, 9741, 9761, 9766]);
  for (let t2 = 9712; t2 <= 9713; t2++)
    d2.add(t2);
  for (let t2 = 9748; t2 <= 9749; t2++)
    d2.add(t2);
  for (let t2 = 20904; t2 <= 20932; t2++)
    d2.add(t2);
  for (let t2 = 21004; t2 <= 21032; t2++)
    d2.add(t2);
  for (let t2 = 21207; t2 <= 21264; t2++)
    d2.add(t2);
  for (let t2 = 21307; t2 <= 21364; t2++)
    d2.add(t2);
  for (let t2 = 102759; t2 <= 102760; t2++)
    d2.add(t2);
  for (let t2 = 102901; t2 <= 102955; t2++)
    d2.add(t2);
  return d2;
}]), t$t.push([10.9, () => {
  const d2 = new Set([9300, 9354, 9364, 9367, 9373, 9377, 9387, 9456, 9473, 9498, 9678, 9680, 29874, 103599, 103872, 104028]);
  for (let t2 = 9356; t2 <= 9360; t2++)
    d2.add(t2);
  for (let t2 = 9404; t2 <= 9407; t2++)
    d2.add(t2);
  for (let t2 = 9476; t2 <= 9482; t2++)
    d2.add(t2);
  for (let t2 = 9487; t2 <= 9494; t2++)
    d2.add(t2);
  for (let t2 = 9697; t2 <= 9699; t2++)
    d2.add(t2);
  return d2;
}]), t$t.push([10.81, () => {
  const d2 = new Set([9265, 9333, 103598, 103699]);
  for (let t2 = 9248; t2 <= 9254; t2++)
    d2.add(t2);
  for (let t2 = 9271; t2 <= 9273; t2++)
    d2.add(t2);
  for (let t2 = 9284; t2 <= 9285; t2++)
    d2.add(t2);
  for (let t2 = 21453; t2 <= 21463; t2++)
    d2.add(t2);
  return d2;
}]), t$t.push([10.8, () => {
  const d2 = new Set([8088, 8395, 8428, 8433, 8531, 8687, 8692, 8694, 8699, 8900, 9003, 9006, 9009, 9012, 9017, 9191]);
  for (let t2 = 8035; t2 <= 8036; t2++)
    d2.add(t2);
  for (let t2 = 8455; t2 <= 8456; t2++)
    d2.add(t2);
  for (let t2 = 8518; t2 <= 8529; t2++)
    d2.add(t2);
  for (let t2 = 8533; t2 <= 8536; t2++)
    d2.add(t2);
  for (let t2 = 8538; t2 <= 8540; t2++)
    d2.add(t2);
  for (let t2 = 8677; t2 <= 8679; t2++)
    d2.add(t2);
  for (let t2 = 8902; t2 <= 8903; t2++)
    d2.add(t2);
  for (let t2 = 8907; t2 <= 8910; t2++)
    d2.add(t2);
  for (let t2 = 8949; t2 <= 8951; t2++)
    d2.add(t2);
  for (let t2 = 8972; t2 <= 8987; t2++)
    d2.add(t2);
  for (let t2 = 9039; t2 <= 9040; t2++)
    d2.add(t2);
  for (let t2 = 9068; t2 <= 9069; t2++)
    d2.add(t2);
  for (let t2 = 9140; t2 <= 9141; t2++)
    d2.add(t2);
  for (let t2 = 9148; t2 <= 9150; t2++)
    d2.add(t2);
  for (let t2 = 9153; t2 <= 9159; t2++)
    d2.add(t2);
  for (let t2 = 9205; t2 <= 9218; t2++)
    d2.add(t2);
  for (let t2 = 9221; t2 <= 9222; t2++)
    d2.add(t2);
  for (let t2 = 54098; t2 <= 54101; t2++)
    d2.add(t2);
  return d2;
}]), t$t.push([10.71, () => {
  const d2 = new Set([6316]);
  for (let t2 = 8351; t2 <= 8353; t2++)
    d2.add(t2);
  for (let t2 = 9294; t2 <= 9297; t2++)
    d2.add(t2);
  for (let t2 = 103586; t2 <= 103594; t2++)
    d2.add(t2);
  for (let t2 = 103696; t2 <= 103698; t2++)
    d2.add(t2);
  return d2;
}]), t$t.push([10.7, () => {
  const d2 = new Set([8387, 8391, 8427, 8545, 8682, 8685, 8818, 31370, 104022, 104024, 104975]);
  for (let t2 = 8065; t2 <= 8068; t2++)
    d2.add(t2);
  for (let t2 = 8082; t2 <= 8083; t2++)
    d2.add(t2);
  for (let t2 = 8379; t2 <= 8385; t2++)
    d2.add(t2);
  for (let t2 = 8836; t2 <= 8840; t2++)
    d2.add(t2);
  for (let t2 = 8857; t2 <= 8860; t2++)
    d2.add(t2);
  for (let t2 = 53035; t2 <= 53037; t2++)
    d2.add(t2);
  for (let t2 = 54090; t2 <= 54091; t2++)
    d2.add(t2);
  for (let t2 = 102498; t2 <= 102499; t2++)
    d2.add(t2);
  return d2;
}]), t$t.push([10.61, () => new Set([102497])]), t$t.push([10.6, () => {
  const d2 = new Set([7803, 7805, 7887, 8086, 8232, 8237, 8240, 8246, 8249, 8252, 8255, 9019, 9391]);
  for (let t2 = 7755; t2 <= 7787; t2++)
    d2.add(t2);
  for (let t2 = 7791; t2 <= 7795; t2++)
    d2.add(t2);
  for (let t2 = 7799; t2 <= 7801; t2++)
    d2.add(t2);
  for (let t2 = 7825; t2 <= 7831; t2++)
    d2.add(t2);
  for (let t2 = 7877; t2 <= 7878; t2++)
    d2.add(t2);
  for (let t2 = 7882; t2 <= 7883; t2++)
    d2.add(t2);
  for (let t2 = 7991; t2 <= 7992; t2++)
    d2.add(t2);
  for (let t2 = 8042; t2 <= 8043; t2++)
    d2.add(t2);
  for (let t2 = 8058; t2 <= 8059; t2++)
    d2.add(t2);
  for (let t2 = 8311; t2 <= 8348; t2++)
    d2.add(t2);
  for (let t2 = 9060; t2 <= 9067; t2++)
    d2.add(t2);
  for (let t2 = 102562; t2 <= 102568; t2++)
    d2.add(t2);
  for (let t2 = 102799; t2 <= 102900; t2++)
    d2.add(t2);
  return d2;
}]), t$t.push([10.51, () => {
  const d2 = new Set([7683, 7881, 7886, 7899, 8888, 9e3]);
  for (let t2 = 8013; t2 <= 8032; t2++)
    d2.add(t2);
  for (let t2 = 9053; t2 <= 9057; t2++)
    d2.add(t2);
  for (let t2 = 104017; t2 <= 104018; t2++)
    d2.add(t2);
  for (let t2 = 104971; t2 <= 104974; t2++)
    d2.add(t2);
  return d2;
}]), t$t.push([10.5, () => {
  const d2 = new Set([6962, 7035, 7037, 7039, 7041, 7084, 7086, 7133, 7798, 102399]);
  for (let t2 = 4087; t2 <= 4088; t2++)
    d2.add(t2);
  for (let t2 = 5896; t2 <= 5899; t2++)
    d2.add(t2);
  for (let t2 = 7005; t2 <= 7007; t2++)
    d2.add(t2);
  for (let t2 = 7057; t2 <= 7070; t2++)
    d2.add(t2);
  for (let t2 = 7073; t2 <= 7082; t2++)
    d2.add(t2);
  for (let t2 = 7109; t2 <= 7128; t2++)
    d2.add(t2);
  for (let t2 = 7844; t2 <= 7859; t2++)
    d2.add(t2);
  return d2;
}]);
async function t$s(t2, i2, n2) {
  const s2 = t2 && t2.getAtOrigin && t2.getAtOrigin("renderer", i2.origin);
  if (s2 && s2.type === "unique-value" && s2.styleOrigin) {
    const a2 = await b$w(s2.populateFromStyle());
    if (f$1x(n2), a2.ok === false) {
      const e2 = a2.error;
      i2 && i2.messages && i2.messages.push(new t$1Q("renderer:style-reference", `Failed to create unique value renderer from style reference: ${e2.message}`, { error: e2, context: i2 })), t2.clear("renderer", i2 == null ? void 0 : i2.origin);
    }
  }
}
const l$v = ["oid", "global-id"], a$E = ["oid", "global-id", "guid"];
function p$z({ displayField: t2, editFieldsInfo: n2, fields: i2, objectIdField: o2, title: r2 }, s2) {
  if (!i2)
    return null;
  const l2 = g$f({ editFieldsInfo: n2, fields: i2, objectIdField: o2 }, s2);
  if (!l2.length)
    return null;
  const a2 = L$7({ titleBase: r2, fields: i2, displayField: t2 }), p2 = I$5();
  return new k$o({ title: a2, content: p2, fieldInfos: l2 });
}
const u$r = [/^fnode_$/i, /^tnode_$/i, /^lpoly_$/i, /^rpoly_$/i, /^poly_$/i, /^subclass$/i, /^subclass_$/i, /^rings_ok$/i, /^rings_nok$/i, /shape/i, /perimeter/i, /objectid/i, /_i$/i], c$y = (e2, { editFieldsInfo: t2, objectIdField: n2, visibleFieldNames: i2 }) => i2 ? i2.has(e2.name) : !F$3(e2.name, t2) && ((!n2 || e2.name !== n2) && (!l$v.includes(e2.type) && !u$r.some((t3) => t3.test(e2.name))));
function f$j(e2, t2) {
  const n2 = e2;
  return t2 && (e2 = e2.filter((e3) => !t2.includes(e3.type))), e2 === n2 && (e2 = e2.slice()), e2.sort(m$m), e2;
}
function m$m(e2, t2) {
  return e2.type === "oid" ? -1 : t2.type === "oid" ? 1 : _$d(e2) ? -1 : _$d(t2) ? 1 : (e2.alias || e2.name).toLocaleLowerCase().localeCompare((t2.alias || t2.name).toLocaleLowerCase());
}
function F$3(e2, t2) {
  if (!e2 || !t2)
    return false;
  const { creationDateField: n2, creatorField: i2, editDateField: o2, editorField: r2 } = t2;
  return [n2 && n2.toLowerCase(), i2 && i2.toLowerCase(), o2 && o2.toLowerCase(), r2 && r2.toLowerCase()].includes(e2.toLowerCase());
}
function b$9(e2, t2) {
  return e2.editable && !a$E.includes(e2.type) && !F$3(e2.name, t2);
}
function g$f({ editFieldsInfo: e2, fields: t2, objectIdField: n2 }, i2) {
  return f$j(t2 != null ? t2 : [], (i2 == null ? void 0 : i2.ignoreFieldTypes) || h$h).map((t3) => new c$2q({ fieldName: t3.name, isEditable: b$9(t3, e2), label: t3.alias, format: j$5(t3), visible: c$y(t3, { editFieldsInfo: e2, objectIdField: n2, visibleFieldNames: i2 == null ? void 0 : i2.visibleFieldNames }) }));
}
function j$5(e2) {
  switch (e2.type) {
    case "small-integer":
    case "integer":
    case "single":
      return new u$1x({ digitSeparator: true, places: 0 });
    case "double":
      return new u$1x({ digitSeparator: true, places: 2 });
    case "date":
      return new u$1x({ dateFormat: "long-month-day-year" });
    default:
      return e2.type === "string" && he$2(e2.name) ? new u$1x({ digitSeparator: true, places: 0 }) : null;
  }
}
function I$5() {
  return [new c$2p(), new i$25()];
}
function L$7(e2) {
  const t2 = E$r(e2), { titleBase: i2 } = e2;
  return t2 ? `${i2}: {${t2.trim()}}` : i2 != null ? i2 : "";
}
function _$d(e2) {
  if ((e2.name && e2.name.toLowerCase()) === "name")
    return true;
  return (e2.alias && e2.alias.toLowerCase()) === "name";
}
const h$h = ["geometry", "blob", "raster", "guid", "xml"];
const Ve$1 = "FeatureLayer", Qe = "esri.layers.FeatureLayer", Ne = s$22.getLogger(Qe);
function Ge(e2, r2) {
  return new s$1Z("layer:unsupported", `Layer (${e2.title}, ${e2.id}) of type '${e2.declaredClass}' ${r2}`, { layer: e2 });
}
function Je(e2) {
  return e2 && e2 instanceof j$F;
}
const $e = s$t();
function We(e2, r2, t2) {
  const i2 = !!(t2 == null ? void 0 : t2.writeLayerSchema);
  return { enabled: i2, ignoreOrigin: i2 };
}
let Be = class extends M$3(n$F(p$S(u$s(a$V(n$N(c$E(a$I(t$u(p$D(p$U(c$G(v$b(O$6(o$B(i$N(i$28(b$h))))))))))))))))) {
  constructor(...e2) {
    super(...e2), this._handles = new t$1N(), this.charts = null, this.copyright = null, this.displayField = null, this.dynamicDataSource = null, this.fields = null, this.fieldsIndex = null, this.formTemplate = null, this.fullExtent = null, this.geometryType = null, this.hasM = void 0, this.hasZ = void 0, this.infoFor3D = null, this.isTable = false, this.labelsVisible = true, this.labelingInfo = null, this.legendEnabled = true, this.objectIdField = null, this.outFields = null, this.path = null, this.popupEnabled = true, this.popupTemplate = null, this.screenSizePerspectiveEnabled = true, this.spatialReference = k$p.WGS84, this.subtypeCode = null, this.templates = null, this.timeInfo = null, this.title = null, this.sublayerTitleMode = "item-title", this.type = "feature", this.typeIdField = null, this.types = null, this.visible = true;
  }
  destroy() {
    var _a2;
    (_a2 = this.source) == null ? void 0 : _a2.destroy(), this._handles = s$26(this._handles);
  }
  normalizeCtorArgs(e2, r2) {
    return typeof e2 == "string" ? __spreadValues({ url: e2 }, r2) : e2;
  }
  load(e2) {
    var _a2;
    const r2 = r$1t(e2) ? e2.signal : null;
    if (((_a2 = this.portalItem) == null ? void 0 : _a2.loaded) && this.source)
      return this.addResolvingPromise(this.createGraphicsSource(r2).then((e3) => this.initLayerProperties(e3))), Promise.resolve(this);
    const t2 = this.loadFromPortal({ supportedTypes: ["Feature Service", "Feature Collection"] }, e2).catch(w$O).then(async () => {
      if (this.url && this.layerId == null && /FeatureServer|MapServer\/*$/i.test(this.url)) {
        const e3 = await this._fetchFirstLayerId(r2);
        e3 != null && (this.layerId = e3);
      }
      if (!this.url && !this._hasMemorySource())
        throw new s$1Z("feature-layer:missing-url-or-source", "Feature layer must be created with either a url or a source");
      return this.initLayerProperties(await this.createGraphicsSource(r2));
    }).then(() => this.finishLoadEditablePortalLayer(e2));
    return this.addResolvingPromise(t2), Promise.resolve(this);
  }
  readCapabilities(e2, r2) {
    return r2 = r2.layerDefinition || r2, h$k(e2, r2, this.url);
  }
  get createQueryVersion() {
    var _a2;
    return this.commitProperty("definitionExpression"), this.commitProperty("dynamicDataSource"), this.commitProperty("timeExtent"), this.commitProperty("timeOffset"), this.commitProperty("geometryType"), this.commitProperty("gdbVersion"), this.commitProperty("historicMoment"), this.commitProperty("returnZ"), this.commitProperty("capabilities"), this.commitProperty("returnM"), ((_a2 = this._get("createQueryVersion")) != null ? _a2 : 0) + 1;
  }
  get editingEnabled() {
    var _a2;
    return !(this.loaded && !((_a2 = this.capabilities) == null ? void 0 : _a2.operations.supportsEditing)) && (this._isOverridden("editingEnabled") ? this._get("editingEnabled") : this._hasMemorySource() || this.userHasEditingPrivileges);
  }
  set editingEnabled(e2) {
    this._overrideIfSome("editingEnabled", e2);
  }
  readEditingEnabled(e2, r2) {
    return this._readEditingEnabled(r2, false);
  }
  readEditingEnabledFromWebMap(e2, r2, t2) {
    return this._readEditingEnabled(r2, true, t2);
  }
  writeEditingEnabled(e2, r2) {
    this._writeEditingEnabled(e2, r2, false);
  }
  writeEditingEnabledToWebMap(e2, r2, t2, i2) {
    this._writeEditingEnabled(e2, r2, true, i2);
  }
  readIsTable(e2, r2) {
    var _a2;
    return (r2 = (_a2 = r2 == null ? void 0 : r2.layerDefinition) != null ? _a2 : r2).type === "Table" || !r2.geometryType;
  }
  writeIsTable(e2, r2, t2, i2) {
    (i2 == null ? void 0 : i2.writeLayerSchema) && o$1X(t2, e2 ? "Table" : "Feature Layer", r2);
  }
  readGlobalIdField(e2, r2) {
    return z$8(r2.layerDefinition || r2);
  }
  readObjectIdField(e2, r2) {
    return U$5(r2.layerDefinition || r2);
  }
  get parsedUrl() {
    const e2 = j$B(this.url);
    return e2 != null && (this.dynamicDataSource != null ? e2.path = G$c(e2.path, "dynamicLayer") : this.layerId != null && (e2.path = G$c(e2.path, this.layerId.toString()))), e2;
  }
  get defaultPopupTemplate() {
    return this.createPopupTemplate();
  }
  set renderer(e2) {
    F$k(e2, this.fieldsIndex), this._set("renderer", e2);
  }
  readRenderer(e2, r2, s2) {
    var _a2, _b2;
    const a2 = (_a2 = (r2 = r2.layerDefinition || r2).drawingInfo) == null ? void 0 : _a2.renderer;
    if (a2) {
      const e3 = (_b2 = o$F(a2, r2, s2)) != null ? _b2 : void 0;
      return e3 || Ne.error("Failed to create renderer", { rendererDefinition: r2.drawingInfo.renderer, layer: this, context: s2 }), e3;
    }
    if (r2.defaultSymbol)
      return r2.types && r2.types.length ? new C$9({ defaultSymbol: ze(r2.defaultSymbol, r2, s2), field: r2.typeIdField, uniqueValueInfos: r2.types.map((e3) => ({ id: e3.id, symbol: ze(e3.symbol, e3, s2) })) }) : new p$19({ symbol: ze(r2.defaultSymbol, r2, s2) });
  }
  set source(e2) {
    const r2 = this._get("source");
    r2 !== e2 && (Je(r2) && this._resetMemorySource(r2), Je(e2) && this._initMemorySource(e2), this._set("source", e2));
  }
  castSource(e2) {
    return e2 ? Array.isArray(e2) || e2 instanceof j$F ? new G$5({ layer: this, items: e2 }) : e2 : null;
  }
  readSource(e2, r2) {
    var _a2;
    const t2 = x$j.fromJSON(r2.featureSet);
    return new G$5({ layer: this, items: (_a2 = t2 == null ? void 0 : t2.features) != null ? _a2 : [] });
  }
  readTemplates(e2, r2) {
    const t2 = r2.editFieldsInfo, i2 = t2 && t2.creatorField, o2 = t2 && t2.editorField;
    return e2 = e2 && e2.map((e3) => p$A.fromJSON(e3)), this._fixTemplates(e2, i2), this._fixTemplates(e2, o2), e2;
  }
  readTitle(e2, r2) {
    var _a2, _b2;
    const t2 = (_b2 = (_a2 = r2.layerDefinition) == null ? void 0 : _a2.name) != null ? _b2 : r2.name, i2 = r2.title || r2.layerDefinition && r2.layerDefinition.title;
    if (t2) {
      const e3 = this.portalItem && this.portalItem.title;
      if (this.sublayerTitleMode === "item-title")
        return this.url ? y$k(this.url, t2) : t2;
      let r3 = t2;
      if (!r3 && this.url) {
        const e4 = m$v(this.url);
        r$1t(e4) && (r3 = e4.title);
      }
      if (!r3)
        return;
      return this.sublayerTitleMode === "item-title-and-service-name" && e3 && e3 !== r3 && (r3 = e3 + " - " + r3), h$m(r3);
    }
    if (this.sublayerTitleMode === "item-title" && i2)
      return i2;
  }
  readTitleFromWebMap(e2, r2) {
    return r2.title || r2.layerDefinition && r2.layerDefinition.name;
  }
  readTypeIdField(e2, r2) {
    let t2 = (r2 = r2.layerDefinition || r2).typeIdField;
    if (t2 && r2.fields) {
      t2 = t2.toLowerCase();
      const e3 = r2.fields.find((e4) => e4.name.toLowerCase() === t2);
      e3 && (t2 = e3.name);
    }
    return t2;
  }
  readTypes(e2, r2) {
    e2 = (r2 = r2.layerDefinition || r2).types;
    const t2 = r2.editFieldsInfo, i2 = t2 && t2.creatorField, o2 = t2 && t2.editorField;
    return e2 && e2.map((e3) => (e3 = n$A.fromJSON(e3), this._fixTemplates(e3.templates, i2), this._fixTemplates(e3.templates, o2), e3));
  }
  readVisible(e2, r2) {
    return r2.layerDefinition && r2.layerDefinition.defaultVisibility != null ? !!r2.layerDefinition.defaultVisibility : r2.visibility != null ? !!r2.visibility : void 0;
  }
  async addAttachment(e2, r2) {
    return F$4(this, e2, r2, Ve$1);
  }
  async updateAttachment(e2, r2, t2) {
    return x$d(this, e2, r2, t2, Ve$1);
  }
  async applyEdits(e2, r2) {
    return P$8(this, e2, r2);
  }
  on(e2, r2) {
    return super.on(e2, r2);
  }
  createPopupTemplate(e2) {
    return p$z(this, e2);
  }
  async createGraphicsSource(e2) {
    if (this._hasMemorySource() && this.source)
      return this.source.load({ signal: e2 });
    const { default: r2 } = await y$1i(import("./FeatureLayerSource.js"), e2);
    return new r2({ layer: this }).load({ signal: e2 });
  }
  createQuery() {
    const e2 = L$9(this);
    e2.dynamicDataSource = this.dynamicDataSource;
    const r2 = r$1t(this.subtypeCode) ? `${this.subtypeField} = ${this.subtypeCode}` : null, t2 = t$D(this.definitionExpression, r2);
    return e2.where = t2 || "1=1", e2;
  }
  async deleteAttachments(e2, r2) {
    return O$5(this, e2, r2, Ve$1);
  }
  async fetchRecomputedExtents(e2) {
    return v$f(this, e2, Ve$1);
  }
  getFeatureType(e2) {
    const { typeIdField: r2, types: t2 } = this;
    if (!r2 || !e2)
      return null;
    const i2 = e2.attributes ? e2.attributes[r2] : void 0;
    if (i2 == null)
      return null;
    let o2 = null;
    return t2 == null ? void 0 : t2.some((e3) => {
      const { id: r3 } = e3;
      return r3 != null && (r3.toString() === i2.toString() && (o2 = e3), !!o2);
    }), o2;
  }
  getFieldDomain(e2, r2) {
    const t2 = r2 && r2.feature, i2 = this.getFeatureType(t2);
    if (i2) {
      const r3 = i2.domains && i2.domains[e2];
      if (r3 && r3.type !== "inherited")
        return r3;
    }
    return this._getLayerDomain(e2);
  }
  getField(e2) {
    return this.fieldsIndex.get(e2);
  }
  async queryAttachments(e2, r2) {
    return E$9(this, e2, r2, Ve$1);
  }
  async queryFeatures(e2, r2) {
    var _a2;
    const t2 = await this.load(), i2 = await t2.source.queryFeatures((_a2 = x$i.from(e2)) != null ? _a2 : t2.createQuery(), r2);
    if (i2 == null ? void 0 : i2.features)
      for (const o2 of i2.features)
        o2.layer = o2.sourceLayer = t2;
    return i2;
  }
  async queryObjectIds(e2, r2) {
    return I$8(this, e2, r2, Ve$1);
  }
  async queryFeatureCount(e2, r2) {
    return T$3(this, e2, r2, Ve$1);
  }
  async queryExtent(e2, r2) {
    return j$8(this, e2, r2, Ve$1);
  }
  async queryRelatedFeatures(e2, r2) {
    return M$4(this, e2, r2, Ve$1);
  }
  async queryRelatedFeaturesCount(e2, r2) {
    return D$4(this, e2, r2, Ve$1);
  }
  async queryTopFeatures(e2, r2) {
    var _a2;
    const { source: t2, capabilities: i2 } = await this.load();
    if (!t2.queryTopFeatures || !((_a2 = i2 == null ? void 0 : i2.query) == null ? void 0 : _a2.supportsTopFeaturesQuery))
      throw new s$1Z(Ve$1, "Layer source does not support queryTopFeatures capability");
    const o2 = await t2.queryTopFeatures(v$p.from(e2), r2);
    if (o2 == null ? void 0 : o2.features)
      for (const s2 of o2.features)
        s2.layer = s2.sourceLayer = this;
    return o2;
  }
  async queryTopObjectIds(e2, r2) {
    const { source: t2, capabilities: i2 } = await this.load();
    if (!t2.queryTopObjectIds || !(i2 == null ? void 0 : i2.query.supportsTopFeaturesQuery))
      throw new s$1Z(Ve$1, "Layer source does not support queryTopObjectIds capability");
    return t2.queryTopObjectIds(v$p.from(e2), r2);
  }
  async queryTopFeaturesExtent(e2, r2) {
    var _a2;
    const { source: t2, capabilities: i2 } = await this.load();
    if (!t2.queryTopExtents || !((_a2 = i2 == null ? void 0 : i2.query) == null ? void 0 : _a2.supportsTopFeaturesQuery))
      throw new s$1Z(Ve$1, "Layer source does not support queryTopExtents capability");
    return t2.queryTopExtents(v$p.from(e2), r2);
  }
  async queryTopFeatureCount(e2, r2) {
    var _a2;
    const { source: t2, capabilities: i2 } = await this.load();
    if (!t2.queryTopCount || !((_a2 = i2 == null ? void 0 : i2.query) == null ? void 0 : _a2.supportsTopFeaturesQuery))
      throw new s$1Z(Ve$1, "Layer source does not support queryFeatureCount capability");
    return t2.queryTopCount(v$p.from(e2), r2);
  }
  read(e2, r2) {
    const t2 = e2.featureCollection;
    if (t2) {
      const e3 = t2.layers;
      e3 && e3.length === 1 && (super.read(e3[0], r2), t2.showLegend != null && super.read({ showLegend: t2.showLegend }, r2));
    }
    super.read(e2, r2), r2 && r2.origin === "service" && this.revert(["objectIdField", "fields", "timeInfo", "spatialReference"], "service");
  }
  write(e2, r2) {
    var _a2, _b2;
    r2 = __spreadProps(__spreadValues({}, r2), { origin: (_a2 = r2 == null ? void 0 : r2.origin) != null ? _a2 : void 0, writeLayerSchema: (_b2 = r2 == null ? void 0 : r2.writeLayerSchema) != null ? _b2 : this._hasMemorySource() });
    const { origin: t2, layerContainerType: i2, messages: o2 } = r2;
    if (this.dynamicDataSource)
      return o2 == null ? void 0 : o2.push(Ge(this, "using a dynamic data source cannot be written to web scenes, web maps and feature service items")), null;
    if (this.isTable) {
      if (t2 === "web-scene" || t2 === "web-map" && i2 !== "tables")
        return o2 == null ? void 0 : o2.push(Ge(this, "using a table source cannot be written to web scenes and web maps")), null;
      if (this._hasMemorySource())
        return o2 == null ? void 0 : o2.push(Ge(this, "using an in-memory table source cannot be written to web scenes and web maps")), null;
    } else if (this.loaded && t2 === "web-map" && i2 === "tables")
      return o2 == null ? void 0 : o2.push(Ge(this, "using a non-table source cannot be written to tables in web maps")), null;
    return super.write(e2, r2);
  }
  clone() {
    if (this._hasMemorySource())
      throw new s$1Z(Ve$1, `FeatureLayer (title: ${this.title}, id: ${this.id}) created using in-memory source cannot be cloned`);
    return super.clone();
  }
  serviceSupportsSpatialReference(e2) {
    var _a2;
    return !!this.loaded && (((_a2 = this.source) == null ? void 0 : _a2.type) === "memory" || e$p(this, e2));
  }
  async save(e2) {
    return (await import("./featureLayerUtils.js")).save(this, e2);
  }
  async saveAs(e2, r2) {
    return (await import("./featureLayerUtils.js")).saveAs(this, e2, r2);
  }
  _readEditingEnabled(e2, r2, t2) {
    var _a2;
    let i2 = (_a2 = e2.layerDefinition) == null ? void 0 : _a2.capabilities;
    return i2 ? this._hasEditingCapability(i2) : (i2 = e2.capabilities, r2 && (t2 == null ? void 0 : t2.origin) === "web-map" && !this._hasMemorySource() && i2 ? this._hasEditingCapability(i2) : void 0);
  }
  _hasEditingCapability(e2) {
    return e2.toLowerCase().split(",").map((e3) => e3.trim()).includes("editing");
  }
  _writeEditingEnabled(e2, r2, t2, i2) {
    var _a2, _b2;
    if (!e2) {
      const e3 = ((_b2 = (_a2 = this.capabilities) == null ? void 0 : _a2.operations) == null ? void 0 : _b2.supportsSync) ? "Query,Sync" : "Query";
      o$1X("layerDefinition.capabilities", e3, r2), t2 && !(i2 == null ? void 0 : i2.writeLayerSchema) && (r2.capabilities = e3);
    }
  }
  _getLayerDomain(e2) {
    const r2 = this.fieldsIndex.get(e2);
    return r2 ? r2.domain : null;
  }
  _fetchFirstLayerId(e2) {
    return U$k(this.url, { query: __spreadProps(__spreadValues({ f: "json" }, this.customParameters), { token: this.apiKey }), responseType: "json", signal: e2 }).then((e3) => {
      const r2 = e3.data;
      if (r2)
        return Array.isArray(r2.layers) && r2.layers.length > 0 ? r2.layers[0].id : Array.isArray(r2.tables) && r2.tables.length > 0 ? r2.tables[0].id : void 0;
    });
  }
  async initLayerProperties(e2) {
    return this._set("source", e2), e2.sourceJSON && (this.sourceJSON = e2.sourceJSON, this.read(e2.sourceJSON, { origin: "service", url: this.parsedUrl })), this._verifySource(), this._verifyFields(), F$k(this.renderer, this.fieldsIndex), x$B(this.timeInfo, this.fieldsIndex), t$s(this, { origin: "service" });
  }
  async hasDataChanged() {
    return G$4(this);
  }
  async fetchPublishingStatus() {
    const e2 = this.source;
    return (e2 == null ? void 0 : e2.fetchPublishingStatus) ? e2.fetchPublishingStatus() : "unavailable";
  }
  _verifyFields() {
    var _a2, _b2, _c2;
    const e2 = (_b2 = (_a2 = this.parsedUrl) == null ? void 0 : _a2.path) != null ? _b2 : "undefined";
    this.objectIdField || console.log("FeatureLayer: 'objectIdField' property is not defined (url: " + e2 + ")"), this.isTable || this._hasMemorySource() || e2.search(/\/FeatureServer\//i) !== -1 || ((_c2 = this.fields) == null ? void 0 : _c2.some((e3) => e3.type === "geometry")) || console.log("FeatureLayer: unable to find field of type 'geometry' in the layer 'fields' list. If you are using a map service layer, features will not have geometry (url: " + e2 + ")");
  }
  _fixTemplates(e2, r2) {
    e2 && e2.forEach((e3) => {
      const t2 = e3.prototype && e3.prototype.attributes;
      t2 && r2 && delete t2[r2];
    });
  }
  _verifySource() {
    if (this._hasMemorySource()) {
      if (this.url)
        throw new s$1Z("feature-layer:mixed-source-and-url", "FeatureLayer cannot be created with both an in-memory source and a url");
    } else if (!this.url)
      throw new s$1Z("feature-layer:source-or-url-required", "FeatureLayer requires either a url, a valid portal item or a source");
  }
  _initMemorySource(e2) {
    e2.forEach((e3) => {
      e3.layer = this, e3.sourceLayer = this;
    }), this._handles.add([e2.on("after-add", (e3) => {
      e3.item.layer = this, e3.item.sourceLayer = this;
    }), e2.on("after-remove", (e3) => {
      e3.item.layer = null, e3.item.sourceLayer = null;
    })], "fl-source");
  }
  _resetMemorySource(e2) {
    e2.forEach((e3) => {
      e3.layer = null, e3.sourceLayer = null;
    }), this._handles.remove("fl-source");
  }
  _hasMemorySource() {
    return !(this.url || !this.source);
  }
};
e$1W([o$1H("service", "capabilities")], Be.prototype, "readCapabilities", null), e$1W([y$1o({ json: { origins: { "portal-item": { write: true }, "web-map": { write: true } } } })], Be.prototype, "charts", void 0), e$1W([y$1o({ readOnly: true })], Be.prototype, "createQueryVersion", null), e$1W([y$1o({ json: { read: { source: "layerDefinition.copyrightText" } } })], Be.prototype, "copyright", void 0), e$1W([y$1o({ json: { read: { source: "layerDefinition.displayField" } } })], Be.prototype, "displayField", void 0), e$1W([y$1o({ types: j$v, readOnly: true })], Be.prototype, "defaultSymbol", void 0), e$1W([y$1o({ type: K$4 })], Be.prototype, "dynamicDataSource", void 0), e$1W([y$1o({ type: Boolean })], Be.prototype, "editingEnabled", null), e$1W([o$1H(["portal-item", "web-scene"], "editingEnabled", ["layerDefinition.capabilities"])], Be.prototype, "readEditingEnabled", null), e$1W([o$1H("web-map", "editingEnabled", ["capabilities", "layerDefinition.capabilities"])], Be.prototype, "readEditingEnabledFromWebMap", null), e$1W([r$1h(["portal-item", "web-scene"], "editingEnabled", { "layerDefinition.capabilities": { type: String } })], Be.prototype, "writeEditingEnabled", null), e$1W([r$1h("web-map", "editingEnabled", { capabilities: { type: String }, "layerDefinition.capabilities": { type: String } })], Be.prototype, "writeEditingEnabledToWebMap", null), e$1W([y$1o(__spreadProps(__spreadValues({}, $e.fields), { json: { read: { source: "layerDefinition.fields" }, origins: { service: { name: "fields" }, "web-map": { write: { target: "layerDefinition.fields", overridePolicy: We } } } } }))], Be.prototype, "fields", void 0), e$1W([y$1o($e.fieldsIndex)], Be.prototype, "fieldsIndex", void 0), e$1W([y$1o({ type: y$l, json: { name: "formInfo", write: true, origins: { "web-scene": { read: false, write: false } } } })], Be.prototype, "formTemplate", void 0), e$1W([y$1o({ json: { read: { source: "layerDefinition.extent" } } })], Be.prototype, "fullExtent", void 0), e$1W([y$1o({ json: { origins: { "web-map": { write: { target: "layerDefinition.geometryType", overridePolicy: We, writer(e2, r2, t2) {
  const i2 = e2 ? i$J.toJSON(e2) : null;
  i2 && o$1X(t2, i2, r2);
} } } }, read: { source: "layerDefinition.geometryType", reader: i$J.read } } })], Be.prototype, "geometryType", void 0), e$1W([y$1o({ json: { read: { source: "layerDefinition.hasM" } } })], Be.prototype, "hasM", void 0), e$1W([y$1o({ json: { read: { source: "layerDefinition.hasZ" } } })], Be.prototype, "hasZ", void 0), e$1W([y$1o(j$9)], Be.prototype, "id", void 0), e$1W([y$1o({ readOnly: true, json: { origins: { service: { read: true } }, read: false } })], Be.prototype, "infoFor3D", void 0), e$1W([y$1o({ json: { origins: { "web-map": { write: { target: "layerDefinition.type" } } } } })], Be.prototype, "isTable", void 0), e$1W([o$1H("service", "isTable", ["type", "geometryType"]), o$1H("isTable", ["layerDefinition.type", "layerDefinition.geometryType"])], Be.prototype, "readIsTable", null), e$1W([r$1h("web-map", "isTable")], Be.prototype, "writeIsTable", null), e$1W([y$1o(m$q)], Be.prototype, "labelsVisible", void 0), e$1W([y$1o({ type: [j$6], json: { origins: { service: { read: { source: "drawingInfo.labelingInfo", reader: i$A }, write: { target: "drawingInfo.labelingInfo", enabled: false } } }, read: { source: "layerDefinition.drawingInfo.labelingInfo", reader: i$A }, write: { target: "layerDefinition.drawingInfo.labelingInfo" } } })], Be.prototype, "labelingInfo", void 0), e$1W([y$1o((() => {
  const e2 = y$1r(u$w);
  return e2.json.origins["portal-item"] = { write: { target: "layerDefinition.drawingInfo.transparency", writer(e3, r2, t2) {
    o$1X(t2, n$1T(e3), r2);
  } } }, e2;
})())], Be.prototype, "opacity", void 0), e$1W([y$1o(c$O)], Be.prototype, "legendEnabled", void 0), e$1W([y$1o({ type: ["show", "hide"], json: (() => {
  const e2 = y$1r(D$5.json);
  return e2.origins["portal-item"] = { read: false, write: false }, e2;
})() })], Be.prototype, "listMode", void 0), e$1W([o$1H("globalIdField", ["layerDefinition.globalIdField", "layerDefinition.fields"])], Be.prototype, "readGlobalIdField", null), e$1W([y$1o({ json: { origins: { "web-map": { write: { target: "layerDefinition.objectIdField", overridePolicy: We } } } } })], Be.prototype, "objectIdField", void 0), e$1W([o$1H("objectIdField", ["layerDefinition.objectIdField", "layerDefinition.fields"])], Be.prototype, "readObjectIdField", null), e$1W([y$1o({ value: "ArcGISFeatureLayer", type: ["ArcGISFeatureLayer"] })], Be.prototype, "operationalLayerType", void 0), e$1W([y$1o($e.outFields)], Be.prototype, "outFields", void 0), e$1W([y$1o({ readOnly: true })], Be.prototype, "parsedUrl", null), e$1W([y$1o({ type: String, json: { origins: { "web-scene": { read: true, write: true } }, read: false } })], Be.prototype, "path", void 0), e$1W([y$1o(p$P)], Be.prototype, "popupEnabled", void 0), e$1W([y$1o({ type: k$o, json: { name: "popupInfo", write: true } })], Be.prototype, "popupTemplate", void 0), e$1W([y$1o({ readOnly: true })], Be.prototype, "defaultPopupTemplate", null), e$1W([y$1o({ types: p$15, json: { origins: { service: { write: { target: "drawingInfo.renderer", enabled: false } }, "web-scene": { types: n$T, name: "layerDefinition.drawingInfo.renderer", write: { overridePolicy: (e2, r2, t2) => ({ ignoreOrigin: t2 == null ? void 0 : t2.writeLayerSchema }) } } }, write: { target: "layerDefinition.drawingInfo.renderer", overridePolicy: (e2, r2, t2) => ({ ignoreOrigin: t2 == null ? void 0 : t2.writeLayerSchema }) } } })], Be.prototype, "renderer", null), e$1W([o$1H("service", "renderer", ["drawingInfo.renderer", "defaultSymbol"]), o$1H("renderer", ["layerDefinition.drawingInfo.renderer", "layerDefinition.defaultSymbol"])], Be.prototype, "readRenderer", null), e$1W([y$1o((() => {
  const e2 = y$1r(l$J);
  return e2.json.origins["portal-item"] = { read: false, write: false }, e2;
})())], Be.prototype, "screenSizePerspectiveEnabled", void 0), e$1W([y$1o({ clonable: false })], Be.prototype, "source", null), e$1W([s$1N("source")], Be.prototype, "castSource", null), e$1W([o$1H("portal-item", "source", ["featureSet"]), o$1H("web-map", "source", ["featureSet"])], Be.prototype, "readSource", null), e$1W([y$1o({ json: { read: { source: "layerDefinition.extent.spatialReference" } } })], Be.prototype, "spatialReference", void 0), e$1W([y$1o({ type: Number })], Be.prototype, "subtypeCode", void 0), e$1W([y$1o({ type: [p$A] })], Be.prototype, "templates", void 0), e$1W([o$1H("templates", ["editFieldsInfo", "creatorField", "editorField", "templates"])], Be.prototype, "readTemplates", null), e$1W([y$1o({ type: v$a })], Be.prototype, "timeInfo", void 0), e$1W([y$1o()], Be.prototype, "title", void 0), e$1W([o$1H("service", "title", ["name"]), o$1H("portal-item", "title", ["layerDefinition.title", "layerDefinition.name", "title"])], Be.prototype, "readTitle", null), e$1W([o$1H("web-map", "title", ["layerDefinition.name", "title"])], Be.prototype, "readTitleFromWebMap", null), e$1W([y$1o({ type: String })], Be.prototype, "sublayerTitleMode", void 0), e$1W([y$1o({ json: { read: false } })], Be.prototype, "type", void 0), e$1W([y$1o({ type: String })], Be.prototype, "typeIdField", void 0), e$1W([o$1H("service", "typeIdField"), o$1H("typeIdField", ["layerDefinition.typeIdField"])], Be.prototype, "readTypeIdField", null), e$1W([y$1o({ type: [n$A] })], Be.prototype, "types", void 0), e$1W([o$1H("service", "types", ["types"]), o$1H("types", ["layerDefinition.types"])], Be.prototype, "readTypes", null), e$1W([y$1o({ type: Boolean, json: { origins: { "portal-item": { write: { target: "layerDefinition.defaultVisibility" } } } } })], Be.prototype, "visible", void 0), e$1W([o$1H("portal-item", "visible", ["visibility", "layerDefinition.defaultVisibility"])], Be.prototype, "readVisible", null), Be = e$1W([n$2f(Qe)], Be);
const ze = s$1W({ types: M$i }), Ze = Be;
var FeatureLayer = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Ze
});
const s$r = ["$datastore", "$map", "$layer", "$aggregatedfeatures"], n$x = "esri.widgets.Feature.support.arcadeFeatureUtils", o$s = s$22.getLogger(n$x);
function c$x(e2) {
  return typeof e2 == "string" ? te(ee(e2)) : Array.isArray(e2) ? p$y(e2) : (e2 == null ? void 0 : e2.declaredClass) === "esri.arcade.Dictionary" ? l$u(e2) : e2;
}
function p$y(e2) {
  return `<ul class="esri-widget__list">${e2.map((e3) => `<li>${typeof e3 == "string" ? te(ee(e3)) : e3}</li>`).join("")}</ul>`;
}
function l$u(e2) {
  return `<table class="esri-widget__table">${e2.keys().map((r2) => {
    const t2 = e2.field(r2);
    return `<tr><th>${r2}</th><td>${typeof t2 == "string" ? te(ee(t2)) : t2}</td></tr>`;
  }).join("")}</table>`;
}
function u$q({ aggregatedFeatures: e2, arcadeUtils: r2, featureSetVars: a2, context: i2, viewInfo: s2, map: n2, graphic: o2, interceptor: c2 }) {
  a2.forEach((a3) => {
    const p2 = a3.toLowerCase(), l2 = { map: n2, spatialReference: s2.sr, interceptor: c2 };
    if (p2 === "$map" && (i2.vars[p2] = r2.convertMapToFeatureSetCollection(l2)), p2 === "$layer" && (i2.vars[p2] = r2.convertFeatureLayerToFeatureSet({ layer: o2.sourceLayer, spatialReference: s2.sr, interceptor: c2 })), p2 === "$datastore" && (i2.vars[p2] = r2.convertServiceUrlToWorkspace({ url: o2.sourceLayer.url, spatialReference: s2.sr, interceptor: c2 })), p2 === "$aggregatedfeatures") {
      const a4 = o2.layer, { fields: n3, objectIdField: l3, geometryType: u2, spatialReference: f2, displayField: g2 } = a4, y2 = new Ze(__spreadProps(__spreadValues({ fields: n3, objectIdField: l3, geometryType: u2, spatialReference: f2, displayField: g2 }, a4.type === "feature" ? { templates: a4.templates, typeIdField: a4.typeIdField, types: a4.types } : null), { source: e2 }));
      i2.vars[p2] = r2.convertFeatureLayerToFeatureSet({ layer: y2, spatialReference: s2.sr, interceptor: c2 });
    }
  });
}
function f$i() {
  return import("./arcadeUtils.js").then(function(n2) {
    return n2.ay;
  });
}
function g$e(e2) {
  return "createQuery" in e2 && "queryFeatures" in e2;
}
async function y$c({ graphic: e2, view: r2 }) {
  const { isAggregate: t2, layer: a2 } = e2;
  if (!t2 || !a2 || (r2 == null ? void 0 : r2.type) !== "2d")
    return [];
  const i2 = await r2.whenLayerView(a2);
  if (!g$e(i2))
    return [];
  const s2 = i2.createQuery();
  s2.aggregateIds = [e2.getObjectId()];
  const { features: n2 } = await i2.queryFeatures(s2);
  return n2;
}
async function d$h({ expressionInfo: e2, arcadeUtils: r2, interceptor: t2, spatialReference: a2, map: i2, graphic: n2, view: c2 }) {
  if (!e2 || !e2.expression)
    return null;
  const p2 = r2.createSyntaxTree(e2.expression), l2 = s$r.filter((e3) => r2.hasVariable(p2, e3)), [f2] = await Promise.all([y$c({ graphic: n2, view: c2 }), r2.loadScriptDependencies(p2, true, l2)]), g2 = r2.getViewInfo({ spatialReference: a2 }), d2 = r2.createExecContext(n2, g2);
  d2.interceptor = t2, d2.useAsync = true, u$q({ aggregatedFeatures: f2, arcadeUtils: r2, featureSetVars: l2, context: d2, viewInfo: g2, map: i2, graphic: n2, interceptor: t2 });
  const m2 = r2.createFunction(p2, d2);
  return r2.executeAsyncFunction(m2, d2).catch((r3) => o$s.error("arcade-execution-error", { error: r3, graphic: n2, expressionInfo: e2 }));
}
async function m$l({ expressionInfos: e2, spatialReference: t2, graphic: a2, interceptor: i2, map: s2, view: n2 }) {
  if (!e2 || !e2.length)
    return {};
  const o2 = await f$i(), p2 = {};
  for (const r2 of e2)
    p2[`expression/${r2.name}`] = d$h({ expressionInfo: r2, arcadeUtils: o2, interceptor: i2, spatialReference: t2, map: s2, graphic: a2, view: n2 });
  const l2 = await E$v(p2), u2 = {};
  for (const r2 in l2)
    u2[r2] = c$x(l2[r2].value);
  return u2;
}
const w$7 = 1;
let j$4 = class extends a$1s(m$1L) {
  constructor(t2) {
    super(t2), this._abortController = null, this.expressionInfo = null, this.graphic = null, this.contentElement = null, this.contentElementViewModel = null, this.interceptor = null, this.view = null, this._cancelQuery = () => {
      const { _abortController: t3 } = this;
      t3 && t3.abort(), this._abortController = null;
    }, this._createVM = () => {
      var _a2, _b2;
      const t3 = (_a2 = this.contentElement) == null ? void 0 : _a2.type;
      (_b2 = this.contentElementViewModel) == null ? void 0 : _b2.destroy();
      const e2 = t3 === "fields" ? new n$1g() : t3 === "media" ? new v$o() : t3 === "text" ? new l$14() : null;
      this._set("contentElementViewModel", e2);
    }, this._compile = async () => {
      this._cancelQuery();
      const t3 = new AbortController();
      this._abortController = t3, await this._compileExpression(), this._abortController === t3 && (this._abortController = null);
    }, this._compileThrottled = e$11(this._compile, w$7, this), this._compileExpression = async () => {
      const { expressionInfo: t3, graphic: e2, interceptor: o2, spatialReference: r2, map: n2, view: s2, _abortController: i2 } = this;
      if (!(t3 && e2 && r2 && n2))
        return void this._set("contentElement", null);
      const l2 = await f$i();
      if (i2 !== this._abortController)
        return;
      const p2 = await d$h({ arcadeUtils: l2, expressionInfo: t3, graphic: e2, interceptor: o2, map: n2, spatialReference: r2, view: s2 });
      if (!p2 || p2.declaredClass !== "esri.arcade.Dictionary")
        return void this._set("contentElement", null);
      const h2 = await p2.castAsJsonAsync(i2.signal), u2 = h2 == null ? void 0 : h2.type, d2 = u2 === "media" ? I$t.fromJSON(h2) : u2 === "text" ? c$2k.fromJSON(h2) : u2 === "fields" ? c$2p.fromJSON(h2) : null;
      this._set("contentElement", d2);
    }, this.handles.add([l$1f(() => [this.expressionInfo, this.graphic, this.map, this.spatialReference, this.view], () => this._compileThrottled(), h$S), l$1f(() => [this.contentElement], () => this._createVM(), h$S)]);
  }
  destroy() {
    var _a2;
    this._cancelQuery(), (_a2 = this.contentElementViewModel) == null ? void 0 : _a2.destroy(), this._set("contentElementViewModel", null), this._set("contentElement", null);
  }
  get spatialReference() {
    var _a2, _b2;
    return (_b2 = (_a2 = this.view) == null ? void 0 : _a2.spatialReference) != null ? _b2 : null;
  }
  set spatialReference(t2) {
    this._override("spatialReference", t2);
  }
  get state() {
    const { _abortController: t2, contentElement: e2, contentElementViewModel: o2 } = this;
    return t2 ? "loading" : e2 || o2 ? "ready" : "disabled";
  }
  get map() {
    var _a2, _b2;
    return (_b2 = (_a2 = this.view) == null ? void 0 : _a2.map) != null ? _b2 : null;
  }
  set map(t2) {
    this._override("map", t2);
  }
};
e$1W([y$1o()], j$4.prototype, "_abortController", void 0), e$1W([y$1o({ type: i$23 })], j$4.prototype, "expressionInfo", void 0), e$1W([y$1o({ type: g$J })], j$4.prototype, "graphic", void 0), e$1W([y$1o({ readOnly: true })], j$4.prototype, "contentElement", void 0), e$1W([y$1o({ readOnly: true })], j$4.prototype, "contentElementViewModel", void 0), e$1W([y$1o()], j$4.prototype, "interceptor", void 0), e$1W([y$1o()], j$4.prototype, "spatialReference", null), e$1W([y$1o({ readOnly: true })], j$4.prototype, "state", null), e$1W([y$1o()], j$4.prototype, "map", null), e$1W([y$1o()], j$4.prototype, "view", void 0), j$4 = e$1W([n$2f("esri.widgets.Feature.FeatureExpression.FeatureExpressionViewModel")], j$4);
const C$7 = j$4;
const c$w = { iconLoading: "esri-icon-loading-indicator esri-rotating", base: "esri-feature-expression", loadingSpinnerContainer: "esri-feature__loading-container", spinner: "esri-feature__loading-spinner" };
let u$p = class extends M$d {
  constructor(e2, t2) {
    super(e2, t2), this.viewModel = new C$7();
  }
  initialize() {
    this.addHandles(l$1f(() => {
      var _a2;
      return (_a2 = this.viewModel) == null ? void 0 : _a2.contentElementViewModel;
    }, () => this._setupExpressionWidget(), h$S));
  }
  destroy() {
    this._destroyContentWidget();
  }
  renderLoading() {
    return n$1k("div", { key: "loading-container", class: c$w.loadingSpinnerContainer }, n$1k("span", { class: this.classes(c$w.iconLoading, c$w.spinner) }));
  }
  render() {
    var _a2;
    const { state: e2 } = this.viewModel;
    return n$1k("div", { class: c$w.base }, e2 === "loading" ? this.renderLoading() : e2 === "disabled" ? null : (_a2 = this._contentWidget) == null ? void 0 : _a2.render());
  }
  _destroyContentWidget() {
    const { _contentWidget: e2 } = this;
    e2 && (e2.viewModel = null, e2.destroy()), this._contentWidget = null;
  }
  _setupExpressionWidget() {
    const { contentElementViewModel: e2, contentElement: t2 } = this.viewModel, s2 = t2 == null ? void 0 : t2.type;
    this._destroyContentWidget();
    const o2 = e2 ? s2 === "fields" ? new m$X({ viewModel: e2 }) : s2 === "media" ? new x$g({ viewModel: e2 }) : s2 === "text" ? new l$13({ viewModel: e2 }) : null : null;
    this._contentWidget = o2, this.scheduleRender();
  }
};
e$1W([y$1o({ type: C$7 })], u$p.prototype, "viewModel", void 0), u$p = e$1W([n$2f("esri.widgets.Feature.FeatureExpression")], u$p);
const m$k = u$p;
const _$c = 100;
let g$d = class extends i$28(s$1u(a$1s(m$1L))) {
  constructor(e2) {
    super(e2), this._queryAbortController = null, this._queryPageAbortController = null, this._queryFeatureCountAbortController = null, this.featuresPerPage = 10, this.description = null, this.graphic = null, this.layer = null, this.map = null, this.orderByFields = null, this.featureCount = 0, this.relationshipId = null, this.showAllEnabled = false, this.title = null, this._cancelQuery = () => {
      const { _queryAbortController: e3 } = this;
      e3 && e3.abort(), this._queryAbortController = null;
    }, this._cancelQueryFeatureCount = () => {
      const { _queryFeatureCountAbortController: e3 } = this;
      e3 && e3.abort(), this._queryFeatureCountAbortController = null;
    }, this._cancelQueryPage = () => {
      const { _queryPageAbortController: e3 } = this;
      e3 && e3.abort(), this._queryPageAbortController = null;
    }, this._queryController = async () => {
      this._cancelQuery();
      const e3 = new AbortController();
      this._queryAbortController = e3, await g$12(this._query()), this._queryAbortController === e3 && (this._queryAbortController = null);
    }, this._queryFeatureCountController = async () => {
      this._cancelQueryFeatureCount();
      const e3 = new AbortController();
      this._queryFeatureCountAbortController = e3, await g$12(this._queryFeatureCount()), this._queryFeatureCountAbortController === e3 && (this._queryFeatureCountAbortController = null);
    }, this._queryPageController = async () => {
      const e3 = new AbortController();
      this._queryPageAbortController = e3, await g$12(this._queryPage()), this._queryPageAbortController === e3 && (this._queryPageAbortController = null);
    }, this._queryThrottled = e$11(this._queryController, _$c, this), this._queryFeatureCountThrottled = e$11(this._queryFeatureCountController, _$c, this), this._queryPageThrottled = e$11(this._queryPageController, _$c, this), this._query = async () => {
      const { _queryAbortController: e3, relatedFeatures: t2 } = this;
      this._destroyRelatedFeatureViewModels(), this.featurePage = 1, t2.removeAll(), t2.addMany(this._sliceFeatures(await this._queryRelatedFeatures({ signal: e3 == null ? void 0 : e3.signal })));
    }, this.handles.add([l$1f(() => [this.displayCount, this.graphic, this.layer, this.map, this.orderByFieldsFixedCasing, this.relationshipId, this.featuresPerPage, this.showAllEnabled], () => this._queryThrottled(), h$S), l$1f(() => [this.featurePage, this.showAllEnabled], () => this._queryPageThrottled()), l$1f(() => [this.layer, this.relationshipId, this.objectId], () => this._queryFeatureCountThrottled())]);
  }
  destroy() {
    this._destroyRelatedFeatureViewModels(), this.relatedFeatures.removeAll(), this._cancelQuery(), this._cancelQueryFeatureCount(), this._cancelQueryPage();
  }
  set featurePage(e2) {
    const { featuresPerPage: t2, featureCount: r2 } = this, o2 = 1, l2 = Math.ceil(r2 / t2) || 1;
    this._set("featurePage", Math.min(Math.max(e2, o2), l2));
  }
  get featurePage() {
    return this._get("featurePage");
  }
  get orderByFieldsFixedCasing() {
    const { orderByFields: e2, relatedLayer: t2 } = this;
    return e2 && (t2 == null ? void 0 : t2.loaded) ? e2.map((e3) => {
      const r2 = e3.clone(), o2 = D$b(e3.field, t2);
      return r2.field = o2, r2;
    }) : e2;
  }
  get itemDescriptionFieldName() {
    var _a2, _b2;
    return ((_b2 = (_a2 = this.orderByFieldsFixedCasing) == null ? void 0 : _a2[0]) == null ? void 0 : _b2.field) || null;
  }
  set displayCount(e2) {
    const t2 = 0, r2 = 10;
    this._set("displayCount", Math.min(Math.max(e2, t2), r2));
  }
  get displayCount() {
    return this._get("displayCount");
  }
  get objectId() {
    var _a2, _b2, _c2;
    return (_c2 = (_b2 = (_a2 = this.graphic) == null ? void 0 : _a2.attributes) == null ? void 0 : _b2[this.objectIdField]) != null ? _c2 : null;
  }
  get objectIdField() {
    var _a2;
    return ((_a2 = this.layer) == null ? void 0 : _a2.objectIdField) || null;
  }
  get relatedFeatures() {
    return this._get("relatedFeatures") || new j$F();
  }
  get relatedLayer() {
    const { layer: e2, map: t2, relationship: r2 } = this;
    return (e2 == null ? void 0 : e2.loaded) ? ye$1(t2, e2, r2) : null;
  }
  get relationship() {
    var _a2, _b2;
    const { relationshipId: e2, layer: t2 } = this;
    return typeof e2 == "number" ? (_b2 = (_a2 = t2 == null ? void 0 : t2.relationships) == null ? void 0 : _a2.find(({ id: t3 }) => t3 === e2)) != null ? _b2 : null : null;
  }
  get relatedFeatureViewModels() {
    return this._get("relatedFeatureViewModels") || new j$F();
  }
  get state() {
    const { _queryAbortController: e2, _queryFeatureCountAbortController: t2, _queryPageAbortController: r2, graphic: o2, relatedLayer: l2 } = this;
    return t2 ? "loading" : e2 || r2 ? "querying" : o2 && l2 ? "ready" : "disabled";
  }
  _destroyRelatedFeatureViewModels() {
    var _a2;
    (_a2 = this.relatedFeatureViewModels) == null ? void 0 : _a2.forEach((e2) => !e2.destroyed && e2.destroy()), this.relatedFeatureViewModels.removeAll();
  }
  async _queryFeatureCount() {
    var _a2, _b2, _c2, _d2, _e3;
    const { layer: e2, relatedLayer: t2, relationshipId: r2, objectId: o2, _queryFeatureCountAbortController: l2 } = this;
    if (await (e2 == null ? void 0 : e2.load()), !t2 || typeof o2 != "number" || !((_b2 = (_a2 = e2 == null ? void 0 : e2.capabilities) == null ? void 0 : _a2.queryRelated) == null ? void 0 : _b2.supportsCount))
      return void this._set("featureCount", 0);
    await t2.load();
    const a2 = t2.createQuery(), s2 = (_e3 = (_d2 = (_c2 = e2.capabilities) == null ? void 0 : _c2.queryRelated) == null ? void 0 : _d2.supportsCacheHint) != null ? _e3 : false, i2 = new d$B({ cacheHint: s2, relationshipId: r2, returnGeometry: false, objectIds: [o2], where: a2.where }), n2 = await e2.queryRelatedFeaturesCount(i2, { signal: l2 == null ? void 0 : l2.signal });
    this._set("featureCount", n2[o2] || 0);
  }
  _sliceFeatures(e2) {
    const { showAllEnabled: t2, displayCount: r2 } = this;
    return t2 ? e2 : r2 ? e2.slice(0, r2) : [];
  }
  async _queryPage() {
    const { relatedFeatures: e2, featurePage: t2, showAllEnabled: r2, _queryPageAbortController: o2 } = this;
    !r2 || t2 < 2 || e2.addMany(await this._queryRelatedFeatures({ signal: o2 == null ? void 0 : o2.signal }));
  }
  async _queryRelatedFeatures(e2) {
    var _a2, _b2, _c2, _d2, _e3;
    const { orderByFieldsFixedCasing: t2, showAllEnabled: r2, featuresPerPage: o2, displayCount: l2, layer: a2, relationshipId: s2, featurePage: i2, featureCount: n2, relatedLayer: u2 } = this;
    await (a2 == null ? void 0 : a2.load());
    const { relationship: d2, objectId: y2 } = this;
    if (!d2 || typeof y2 != "number" || !((_b2 = (_a2 = a2 == null ? void 0 : a2.capabilities) == null ? void 0 : _a2.queryRelated) == null ? void 0 : _b2.supportsPagination))
      return [];
    const h2 = r2 ? ((i2 - 1) * o2 + n2) % n2 : 0, c2 = r2 ? o2 : l2;
    if (!u2)
      return [];
    await u2.load();
    const C2 = u2.objectIdField, _2 = [...t2 == null ? void 0 : t2.map((e3) => e3.field), C2], g2 = t2 == null ? void 0 : t2.map((e3) => `${e3.field} ${e3.order}`), b2 = ((_d2 = (_c2 = a2.capabilities) == null ? void 0 : _c2.queryRelated) == null ? void 0 : _d2.supportsCacheHint) || false, F2 = u2.createQuery(), m2 = new d$B({ orderByFields: g2, start: h2, num: c2, outFields: _2, cacheHint: b2, relationshipId: s2, returnGeometry: false, objectIds: [y2], where: F2.where }), q2 = ((_e3 = (await a2.queryRelatedFeatures(m2, { signal: e2 == null ? void 0 : e2.signal }))[y2]) == null ? void 0 : _e3.features) || [];
    return q2.forEach((e3) => e3.sourceLayer = u2), q2;
  }
};
e$1W([y$1o()], g$d.prototype, "_queryAbortController", void 0), e$1W([y$1o()], g$d.prototype, "_queryPageAbortController", void 0), e$1W([y$1o()], g$d.prototype, "_queryFeatureCountAbortController", void 0), e$1W([y$1o({ value: 1 })], g$d.prototype, "featurePage", null), e$1W([y$1o()], g$d.prototype, "featuresPerPage", void 0), e$1W([y$1o({ readOnly: true })], g$d.prototype, "orderByFieldsFixedCasing", null), e$1W([y$1o()], g$d.prototype, "description", void 0), e$1W([y$1o({ readOnly: true })], g$d.prototype, "itemDescriptionFieldName", null), e$1W([y$1o({ value: 3 })], g$d.prototype, "displayCount", null), e$1W([y$1o({ type: g$J })], g$d.prototype, "graphic", void 0), e$1W([y$1o()], g$d.prototype, "layer", void 0), e$1W([y$1o()], g$d.prototype, "map", void 0), e$1W([y$1o({ readOnly: true })], g$d.prototype, "objectId", null), e$1W([y$1o({ readOnly: true })], g$d.prototype, "objectIdField", null), e$1W([y$1o()], g$d.prototype, "orderByFields", void 0), e$1W([y$1o({ readOnly: true })], g$d.prototype, "relatedFeatures", null), e$1W([y$1o({ readOnly: true })], g$d.prototype, "relatedLayer", null), e$1W([y$1o({ readOnly: true })], g$d.prototype, "relationship", null), e$1W([y$1o({ readOnly: true })], g$d.prototype, "featureCount", void 0), e$1W([y$1o({ readOnly: true })], g$d.prototype, "relatedFeatureViewModels", null), e$1W([y$1o()], g$d.prototype, "relationshipId", void 0), e$1W([y$1o()], g$d.prototype, "showAllEnabled", void 0), e$1W([y$1o({ readOnly: true })], g$d.prototype, "state", null), e$1W([y$1o()], g$d.prototype, "title", void 0), g$d = e$1W([n$2f("esri.widgets.Feature.FeatureRelationship.FeatureRelationshipViewModel")], g$d);
const b$8 = g$d;
const g$c = { base: "esri-feature-relationship", esriWidget: "esri-widget", listContainer: "esri-feature-relationship__list", listContainerQuerying: "esri-feature-relationship__list--querying", featureObserver: "esri-feature__feature-observer", stickySpinnerContainer: "esri-feature__sticky-loading-container", loadingSpinnerContainer: "esri-feature__loading-container", spinner: "esri-feature__loading-spinner", iconLoading: "esri-icon-loading-indicator esri-rotating" }, f$h = { title: true, description: true };
let w$6 = class extends M$d {
  constructor(e2, t2) {
    super(e2, t2), this._featureElementInfo = null, this._relatedFeatureIntersectionObserver = new IntersectionObserver(([e3]) => {
      (e3 == null ? void 0 : e3.isIntersecting) && this._increaseFeaturePage();
    }, { root: window.document }), this.headingLevel = 2, this.viewModel = new b$8(), this.messages = null, this.messagesCommon = null, this.visibleElements = __spreadValues({}, f$h), this._increaseFeaturePage = () => {
      const { state: e3, showAllEnabled: t3, relatedFeatures: r2, featuresPerPage: s2, featurePage: i2 } = this.viewModel;
      e3 === "ready" && t3 && r2.length >= s2 * i2 && this.viewModel.featurePage++;
    };
  }
  initialize() {
    this._featureElementInfo = new l$15(), this.addHandles([l$1f(() => [this.viewModel.description, this.viewModel.title, this.headingLevel], () => this._setupFeatureElementInfo(), h$S), l$1f(() => [this.viewModel.state, this.viewModel.showAllEnabled, this._relatedFeatureIntersectionObserverNode], () => this._handleRelatedFeatureObserverChange()), a$1I(() => this.viewModel.relatedFeatureViewModels, "change", () => this._setupRelatedFeatureViewModels())]);
  }
  loadDependencies() {
    return Promise.all([import("./calcite-list.js"), import("./calcite-list-item.js"), import("./calcite-icon.js"), import("./calcite-notice.js")]);
  }
  destroy() {
    this._unobserveRelatedFeatureObserver(), this._featureElementInfo = s$26(this._featureElementInfo);
  }
  get displayShowAllButton() {
    const { showAllEnabled: e2, featureCount: t2, displayCount: r2 } = this.viewModel;
    return !e2 && (t2 > r2 || r2 === 0);
  }
  get displayListItems() {
    return this.displayShowAllButton || this.viewModel.relatedFeatureViewModels.length > 0;
  }
  get description() {
    return this.viewModel.description;
  }
  set description(e2) {
    this.viewModel.description = e2;
  }
  get featureCountDescription() {
    const { messages: e2 } = this, { featureCount: t2 } = this.viewModel;
    return s$1f(t2 === 1 ? e2 == null ? void 0 : e2.numberRecord : e2 == null ? void 0 : e2.numberRecords, { number: t2 });
  }
  get title() {
    return this.viewModel.title;
  }
  set title(e2) {
    this.viewModel.title = e2;
  }
  castVisibleElements(e2) {
    return __spreadValues(__spreadValues({}, f$h), e2);
  }
  renderStickyLoading() {
    return this.viewModel.state === "querying" ? n$1k("div", { key: "sticky-loader", class: g$c.stickySpinnerContainer }, this.renderLoadingIcon()) : null;
  }
  renderLoadingIcon() {
    return n$1k("span", { class: this.classes(g$c.iconLoading, g$c.spinner) });
  }
  renderLoading() {
    return n$1k("div", { key: "loading-container", class: g$c.loadingSpinnerContainer }, this.renderLoadingIcon());
  }
  renderShowAllIconNode() {
    return n$1k("calcite-icon", { scale: "s", icon: "list", slot: "content-end" });
  }
  renderChevronIconNode() {
    const e2 = f$U(this.container) ? "chevron-left" : "chevron-right";
    return n$1k("calcite-icon", { scale: "s", icon: e2, slot: "content-end" });
  }
  renderRelatedFeature(e2) {
    var _a2, _b2;
    const { itemDescriptionFieldName: t2 } = this.viewModel, r2 = e2.title;
    e2.description = t2 && ((_a2 = e2.formattedAttributes) == null ? void 0 : _a2.global[t2]);
    const s2 = e2.state === "loading";
    return n$1k("calcite-list-item", { key: e2.uid, label: s2 ? `${(_b2 = this.messagesCommon) == null ? void 0 : _b2.loading}\u2026` : r2, description: s2 ? "\u2026" : e2.description, onclick: () => this.emit("select-record", { featureViewModel: e2 }) }, this.renderChevronIconNode());
  }
  renderShowAllListItem() {
    var _a2;
    return this.displayShowAllButton ? n$1k("calcite-list-item", { key: "show-all-item", label: (_a2 = this.messages) == null ? void 0 : _a2.showAll, description: this.featureCountDescription, onclick: () => this.emit("show-all-records") }, this.renderShowAllIconNode()) : null;
  }
  renderNoRelatedFeaturesMessage() {
    var _a2;
    return n$1k("calcite-notice", { key: "no-related-features-message", icon: "information", open: true, color: "blue", scale: "s", width: "full" }, n$1k("div", { slot: "message" }, (_a2 = this.messages) == null ? void 0 : _a2.noRelatedFeatures));
  }
  renderFeatureObserver() {
    return n$1k("div", { key: "feature-observer", class: g$c.featureObserver, bind: this, afterCreate: this._relatedFeatureIntersectionObserverCreated });
  }
  renderList() {
    const { relatedFeatureViewModels: e2 } = this.viewModel;
    return n$1k("calcite-list", null, e2.toArray().map((e3) => this.renderRelatedFeature(e3)), this.renderShowAllListItem());
  }
  renderRelatedFeatures() {
    const { displayListItems: e2 } = this, { state: t2 } = this.viewModel;
    return n$1k("div", { key: "list-container", class: this.classes(g$c.listContainer, { [g$c.listContainerQuerying]: t2 === "querying" }) }, e2 ? this.renderList() : t2 === "ready" ? this.renderNoRelatedFeaturesMessage() : null, this.renderStickyLoading(), this.renderFeatureObserver());
  }
  renderRelationshipNotFound() {
    var _a2;
    return n$1k("calcite-notice", { key: "relationship-not-found", icon: "exclamation-mark-triangle", open: true, color: "red", scale: "s", width: "full" }, n$1k("div", { slot: "message" }, (_a2 = this.messages) == null ? void 0 : _a2.relationshipNotFound));
  }
  render() {
    var _a2;
    const { state: e2 } = this.viewModel;
    return n$1k("div", { class: this.classes(g$c.base, g$c.esriWidget) }, (_a2 = this._featureElementInfo) == null ? void 0 : _a2.render(), e2 === "loading" ? this.renderLoading() : e2 === "disabled" ? this.renderRelationshipNotFound() : this.renderRelatedFeatures());
  }
  _setupRelatedFeatureViewModels() {
    const { relatedFeatureViewModels: e2 } = this.viewModel, t2 = "related-feature-viewmodels";
    this.removeHandles(t2), e2 == null ? void 0 : e2.forEach((e3) => {
      this.addHandles(l$1f(() => [e3.title, e3.state], () => this.scheduleRender(), h$S), t2);
    }), this.scheduleRender();
  }
  _setupFeatureElementInfo() {
    const { headingLevel: e2, visibleElements: t2 } = this, r2 = t2.description && this.description, s2 = t2.title && this.title;
    this._featureElementInfo.set({ description: r2, title: s2, headingLevel: e2 });
  }
  async _handleRelatedFeatureObserverChange() {
    this._unobserveRelatedFeatureObserver();
    const { state: e2, showAllEnabled: t2 } = this.viewModel;
    await U$q(0), this._relatedFeatureIntersectionObserverNode && e2 === "ready" && t2 && this._relatedFeatureIntersectionObserver.observe(this._relatedFeatureIntersectionObserverNode);
  }
  _relatedFeatureIntersectionObserverCreated(e2) {
    this._relatedFeatureIntersectionObserverNode = e2;
  }
  _unobserveRelatedFeatureObserver() {
    this._relatedFeatureIntersectionObserverNode && this._relatedFeatureIntersectionObserver.unobserve(this._relatedFeatureIntersectionObserverNode);
  }
};
e$1W([y$1o()], w$6.prototype, "_relatedFeatureIntersectionObserverNode", void 0), e$1W([y$1o({ readOnly: true })], w$6.prototype, "displayShowAllButton", null), e$1W([y$1o({ readOnly: true })], w$6.prototype, "displayListItems", null), e$1W([y$1o()], w$6.prototype, "description", null), e$1W([y$1o({ readOnly: true })], w$6.prototype, "featureCountDescription", null), e$1W([y$1o()], w$6.prototype, "headingLevel", void 0), e$1W([y$1o()], w$6.prototype, "title", null), e$1W([y$1o({ type: b$8 })], w$6.prototype, "viewModel", void 0), e$1W([y$1o(), e$W("esri/widgets/Feature/t9n/Feature")], w$6.prototype, "messages", void 0), e$1W([y$1o(), e$W("esri/t9n/common")], w$6.prototype, "messagesCommon", void 0), e$1W([y$1o()], w$6.prototype, "visibleElements", void 0), e$1W([s$1N("visibleElements")], w$6.prototype, "castVisibleElements", null), w$6 = e$1W([n$2f("esri.widgets.Feature.FeatureRelationship")], w$6);
const b$7 = w$6;
class e$o {
  constructor(e2, a2) {
    this.preLayerQueryCallback = e2, this.preRequestCallback = a2, this.preLayerQueryCallback || (this.preLayerQueryCallback = (e3) => {
    }), this.preRequestCallback || (this.preLayerQueryCallback = (e3) => {
    });
  }
}
var Q$1;
const G$3 = 1, H$3 = "content-view-models", z$6 = "relationship-view-models", J$2 = { attachmentsContent: true, chartAnimation: true, customContent: true, expressionContent: true, fieldsContent: true, mediaContent: true, textContent: true, relationshipContent: true };
let K$2 = Q$1 = class extends s$1u(m$1L) {
  constructor(e2) {
    super(e2), this._handles = new t$1N(), this._error = null, this._featureAbortController = null, this._graphicChangedThrottled = e$11(this._graphicChanged, G$3, this), this._expressionAttributes = null, this._graphicExpressionAttributes = null, this.abilities = __spreadValues({}, J$2), this.content = null, this.contentViewModels = [], this.description = null, this.defaultPopupTemplateEnabled = false, this.formattedAttributes = null, this.lastEditInfo = null, this.relatedInfos = new Map(), this.title = "", this.view = null, this._isAllowedContentType = (e3) => {
      const { abilities: t2 } = this;
      return e3.type === "attachments" && t2.attachmentsContent || e3.type === "custom" && t2.customContent || e3.type === "fields" && t2.fieldsContent || e3.type === "media" && t2.mediaContent || e3.type === "text" && t2.textContent || e3.type === "expression" && t2.expressionContent || e3.type === "relationship" && t2.relationshipContent;
    }, this._handles.add(l$1f(() => [this.graphic, this._effectivePopupTemplate, this.abilities], () => this._graphicChangedThrottled(), h$S));
  }
  destroy() {
    this._clear(), this._cancelFeatureQuery(), this._error = null, this._handles.destroy(), this._handles = null, this.graphic = null, this._destroyContentViewModels(), this.relatedInfos.clear();
  }
  get _effectivePopupTemplate() {
    return r$1t(this.graphic) ? this.graphic.getEffectivePopupTemplate(this.defaultPopupTemplateEnabled) : null;
  }
  get _fieldInfoMap() {
    return X$2(Y$2(this._effectivePopupTemplate), this._sourceLayer);
  }
  get _sourceLayer() {
    return T$f(this.graphic);
  }
  castAbilities(e2) {
    return __spreadValues(__spreadValues({}, J$2), e2);
  }
  get state() {
    return this.graphic ? this._error ? "error" : this.waitingForContent ? "loading" : "ready" : "disabled";
  }
  set graphic(e2) {
    this._set("graphic", e2 ? e2.clone() : null);
  }
  get spatialReference() {
    var _a2, _b2;
    return (_b2 = (_a2 = this.view) == null ? void 0 : _a2.spatialReference) != null ? _b2 : null;
  }
  set spatialReference(e2) {
    this._override("spatialReference", e2);
  }
  get map() {
    var _a2;
    return ((_a2 = this.view) == null ? void 0 : _a2.map) || null;
  }
  set map(e2) {
    this._override("map", e2);
  }
  get waitingForContent() {
    return !!this._featureAbortController;
  }
  setActiveMedia(e2, t2) {
    const i2 = this.contentViewModels[e2];
    i2 instanceof v$o && i2.setActiveMedia(t2);
  }
  nextMedia(e2) {
    const t2 = this.contentViewModels[e2];
    t2 instanceof v$o && t2.next();
  }
  previousMedia(e2) {
    const t2 = this.contentViewModels[e2];
    t2 instanceof v$o && t2.previous();
  }
  _clear() {
    this._set("title", ""), this._set("content", null), this._set("formattedAttributes", null);
  }
  async _graphicChanged() {
    this._cancelFeatureQuery(), this._error = null, this._clear();
    const { graphic: e2 } = this;
    if (!e2)
      return;
    const t2 = new AbortController();
    this._featureAbortController = t2;
    try {
      await this._queryFeature({ signal: t2.signal });
    } catch (i2) {
      j$K(i2) || (this._error = i2, s$22.getLogger(this.declaredClass).error("error", "The popupTemplate could not be displayed for this feature.", { error: i2, graphic: e2, popupTemplate: this._effectivePopupTemplate }));
    }
    this._featureAbortController === t2 && (this._featureAbortController = null);
  }
  _cancelFeatureQuery() {
    const { _featureAbortController: e2 } = this;
    e2 && e2.abort(), this._featureAbortController = null;
  }
  _compileContentElement(e2, t2) {
    return e2.type === "attachments" ? this._compileAttachments(e2, t2) : e2.type === "custom" ? this._compileCustom(e2, t2) : e2.type === "fields" ? this._compileFields(e2, t2) : e2.type === "media" ? this._compileMedia(e2, t2) : e2.type === "text" ? this._compileText(e2, t2) : e2.type === "expression" ? this._compileExpression(e2, t2) : e2.type === "relationship" ? this._compileRelationship(e2, t2) : void 0;
  }
  _compileContent(e2) {
    if (this._destroyContentViewModels(), this.graphic)
      return Array.isArray(e2) ? e2.filter(this._isAllowedContentType).map((e3, t2) => this._compileContentElement(e3, t2)) : typeof e2 == "string" ? this._compileText(new c$2k({ text: e2 }), 0).text : e2;
  }
  _destroyContentViewModels() {
    var _a2, _b2;
    (_a2 = this._handles) == null ? void 0 : _a2.remove(z$6), (_b2 = this._handles) == null ? void 0 : _b2.remove(H$3), this.contentViewModels.forEach((e2) => e2 && !e2.destroyed && e2.destroy()), this._set("contentViewModels", []);
  }
  _matchesFeature(e2, t2) {
    var _a2;
    const i2 = (_a2 = e2 == null ? void 0 : e2.graphic) == null ? void 0 : _a2.getObjectId(), r2 = t2 == null ? void 0 : t2.getObjectId();
    return r$1t(i2) && r$1t(r2) && i2 === r2;
  }
  _setRelatedFeaturesViewModels({ relatedFeatureViewModels: e2, relatedFeatures: t2, map: i2 }) {
    t2 == null ? void 0 : t2.filter(Boolean).forEach((t3) => {
      e2.find((e3) => this._matchesFeature(e3, t3)) || e2.add(new Q$1({ abilities: { relationshipContent: false }, map: i2, graphic: t3 }));
    }), e2.forEach((i3) => {
      const r2 = t2 == null ? void 0 : t2.find((e3) => this._matchesFeature(i3, e3));
      r2 || e2.remove(i3);
    });
  }
  _setExpressionContentVM(e2, t2) {
    const { formattedAttributes: i2 } = this, { contentElement: r2, contentElementViewModel: o2 } = e2, s2 = r2 == null ? void 0 : r2.type;
    o2 && s2 && (s2 === "fields" && (this._createFieldsFormattedAttributes({ contentElement: r2, contentElementIndex: t2, formattedAttributes: i2 }), o2.set(this._createFieldsVMParams(r2, t2))), s2 === "media" && (this._createMediaFormattedAttributes({ contentElement: r2, contentElementIndex: t2, formattedAttributes: i2 }), o2.set(this._createMediaVMParams(r2, t2))), s2 === "text" && o2.set(this._createTextVMParams(r2)));
  }
  _compileRelationship(e2, t2) {
    const { displayCount: i2, orderByFields: r2, relationshipId: o2, title: s2, description: n2 } = e2, { _sourceLayer: a2, graphic: l2, map: p2 } = this, c2 = new b$8(__spreadValues({ displayCount: i2, graphic: l2, orderByFields: r2, relationshipId: o2, layer: a2, map: p2 }, this._compileTitleAndDesc({ title: s2, description: n2 })));
    return this.contentViewModels[t2] = c2, this._handles.add(a$1I(() => c2.relatedFeatures, "change", () => this._setRelatedFeaturesViewModels(c2)), z$6), e2;
  }
  _compileExpression(e2, t2) {
    const { expressionInfo: i2 } = e2, { graphic: r2, map: o2, spatialReference: s2, view: n2 } = this, a2 = new C$7({ expressionInfo: i2, graphic: r2, interceptor: Q$1.interceptor, map: o2, spatialReference: s2, view: n2 });
    return this.contentViewModels[t2] = a2, this._handles.add(l$1f(() => a2.contentElementViewModel, () => this._setExpressionContentVM(a2, t2), h$S), H$3), e2;
  }
  _compileAttachments(e2, t2) {
    const { graphic: i2 } = this, { description: r2, title: o2 } = e2;
    return this.contentViewModels[t2] = new c$1x(__spreadValues({ graphic: i2 }, this._compileTitleAndDesc({ title: o2, description: r2 }))), e2;
  }
  _compileCustom(e2, t2) {
    const { graphic: i2 } = this, { creator: r2, destroyer: o2 } = e2;
    return this.contentViewModels[t2] = new l$14({ graphic: i2, creator: r2, destroyer: o2 }), e2;
  }
  _compileTitleAndDesc({ title: e2, description: t2 }) {
    const { _fieldInfoMap: i2, _sourceLayer: r2, graphic: o2, formattedAttributes: s2, _expressionAttributes: n2 } = this, { attributes: a2 } = o2, l2 = s2.global;
    return { title: $$7({ attributes: a2, fieldInfoMap: i2, globalAttributes: l2, expressionAttributes: n2, layer: r2, text: e2 }), description: $$7({ attributes: a2, fieldInfoMap: i2, globalAttributes: l2, expressionAttributes: n2, layer: r2, text: t2 }) };
  }
  _createFieldsVMParams(e2, t2) {
    var _a2;
    const { _effectivePopupTemplate: i2, formattedAttributes: r2 } = this, o2 = __spreadValues(__spreadValues({}, r2.global), r2.content[t2]), s2 = (_a2 = (e2 == null ? void 0 : e2.fieldInfos) || (i2 == null ? void 0 : i2.fieldInfos)) == null ? void 0 : _a2.filter(({ fieldName: e3 }) => C$g(e3) || le(e3) || o2.hasOwnProperty(e3)), n2 = i2 == null ? void 0 : i2.expressionInfos, { description: a2, title: l2 } = e2;
    return __spreadValues({ attributes: o2, expressionInfos: n2, fieldInfos: s2 }, this._compileTitleAndDesc({ title: l2, description: a2 }));
  }
  _compileFields(e2, t2) {
    const i2 = e2.clone(), r2 = new n$1g(this._createFieldsVMParams(e2, t2));
    return this.contentViewModels[t2] = r2, i2.fieldInfos = r2.formattedFieldInfos.slice(0), i2;
  }
  _createMediaVMParams(e2, t2) {
    const { abilities: i2, graphic: r2, _fieldInfoMap: o2, formattedAttributes: s2, _effectivePopupTemplate: n2, relatedInfos: a2, _sourceLayer: l2, _expressionAttributes: p2 } = this, { attributes: c2 } = r2, { description: d2, mediaInfos: h2, title: u2 } = e2;
    return __spreadValues({ abilities: { chartAnimation: i2.chartAnimation }, activeMediaInfoIndex: e2.activeMediaInfoIndex || 0, attributes: c2, layer: l2, fieldInfoMap: o2, formattedAttributes: __spreadValues(__spreadValues({}, s2.global), s2.content[t2]), expressionAttributes: p2, mediaInfos: h2, popupTemplate: n2, relatedInfos: a2 }, this._compileTitleAndDesc({ title: u2, description: d2 }));
  }
  _compileMedia(e2, t2) {
    const i2 = e2.clone(), r2 = new v$o(this._createMediaVMParams(e2, t2));
    return i2.mediaInfos = r2.formattedMediaInfos.slice(0), this.contentViewModels[t2] = r2, i2;
  }
  _createTextVMParams(e2) {
    const { graphic: t2, _fieldInfoMap: i2, _sourceLayer: r2, _expressionAttributes: o2 } = this;
    if (e2 && e2.text) {
      const { attributes: s2 } = t2, n2 = this.formattedAttributes.global;
      e2.text = $$7({ attributes: s2, fieldInfoMap: i2, globalAttributes: n2, expressionAttributes: o2, layer: r2, text: e2.text });
    }
    return { graphic: t2, creator: e2.text };
  }
  _compileText(e2, t2) {
    const i2 = e2.clone();
    return this.contentViewModels[t2] = new l$14(this._createTextVMParams(i2)), i2;
  }
  _compileLastEditInfo() {
    const { _effectivePopupTemplate: e2, _sourceLayer: t2, graphic: i2 } = this;
    if (!e2)
      return;
    const { lastEditInfoEnabled: r2 } = e2, o2 = t2 == null ? void 0 : t2.editFieldsInfo;
    return r2 && o2 ? W$5(o2, i2.attributes) : void 0;
  }
  _compileTitle(e2) {
    const { _fieldInfoMap: t2, _sourceLayer: i2, graphic: r2, _expressionAttributes: o2 } = this, { attributes: s2 } = r2, n2 = this.formattedAttributes.global;
    return $$7({ attributes: s2, fieldInfoMap: t2, globalAttributes: n2, expressionAttributes: o2, layer: i2, text: e2 });
  }
  async _getTitle() {
    const { _effectivePopupTemplate: e2, graphic: t2 } = this, i2 = e2 == null ? void 0 : e2.title;
    return j$p(i2, { graphic: t2 });
  }
  async _getContent() {
    const { _effectivePopupTemplate: e2, graphic: t2 } = this, i2 = e2 == null ? void 0 : e2.content;
    return j$p(i2, { graphic: t2 });
  }
  async _queryFeature(e2) {
    const { _featureAbortController: t2, _sourceLayer: i2, graphic: r2, _effectivePopupTemplate: o2, spatialReference: s2, map: n2, view: a2 } = this;
    if (t2 !== this._featureAbortController || !r2)
      return;
    await ae({ graphic: r2, popupTemplate: o2, layer: i2, spatialReference: s2 }, e2);
    const { content: { value: l2 }, title: { value: c2 } } = await E$v({ content: this._getContent(), title: this._getTitle() }), { expressionAttributes: { value: d2 } } = await E$v({ checkForRelatedFeatures: this._checkForRelatedFeatures(e2), expressionAttributes: m$l({ expressionInfos: o2 == null ? void 0 : o2.expressionInfos, spatialReference: s2, graphic: r2, map: n2, interceptor: Q$1.interceptor, view: a2 }) });
    t2 === this._featureAbortController && r2 && (this._expressionAttributes = d2, this._graphicExpressionAttributes = __spreadValues(__spreadValues({}, r2.attributes), d2), this._set("formattedAttributes", this._createFormattedAttributes(l2)), this._set("title", this._compileTitle(c2)), this._set("lastEditInfo", this._compileLastEditInfo() || null), this._set("content", this._compileContent(l2) || null));
  }
  _createMediaFormattedAttributes({ contentElement: e2, contentElementIndex: t2, formattedAttributes: i2 }) {
    const { _effectivePopupTemplate: r2, graphic: o2, relatedInfos: s2, _sourceLayer: n2, _fieldInfoMap: a2, _graphicExpressionAttributes: l2 } = this;
    i2.content[t2] = ne({ fieldInfos: r2 == null ? void 0 : r2.fieldInfos, graphic: o2, attributes: __spreadValues(__spreadValues({}, l2), e2.attributes), layer: n2, fieldInfoMap: a2, relatedInfos: s2 });
  }
  _createFieldsFormattedAttributes({ contentElement: e2, contentElementIndex: t2, formattedAttributes: i2 }) {
    if (e2.fieldInfos) {
      const { graphic: r2, relatedInfos: o2, _sourceLayer: s2, _fieldInfoMap: n2, _graphicExpressionAttributes: a2 } = this;
      i2.content[t2] = ne({ fieldInfos: e2.fieldInfos, graphic: r2, attributes: __spreadValues(__spreadValues({}, a2), e2.attributes), layer: s2, fieldInfoMap: n2, relatedInfos: o2 });
    }
  }
  _createFormattedAttributes(e2) {
    const { _effectivePopupTemplate: t2, graphic: i2, relatedInfos: r2, _sourceLayer: o2, _fieldInfoMap: s2, _graphicExpressionAttributes: n2 } = this, a2 = t2 == null ? void 0 : t2.fieldInfos, l2 = { global: ne({ fieldInfos: a2, graphic: i2, attributes: n2, layer: o2, fieldInfoMap: s2, relatedInfos: r2 }), content: [] };
    return Array.isArray(e2) && e2.forEach((e3, t3) => {
      e3.type === "fields" && this._createFieldsFormattedAttributes({ contentElement: e3, contentElementIndex: t3, formattedAttributes: l2 }), e3.type === "media" && this._createMediaFormattedAttributes({ contentElement: e3, contentElementIndex: t3, formattedAttributes: l2 });
    }), l2;
  }
  _checkForRelatedFeatures(e2) {
    const { graphic: t2, _effectivePopupTemplate: i2 } = this;
    return this._queryRelatedInfos(t2, Y$2(i2), e2);
  }
  async _queryRelatedInfos(e2, t2, i2) {
    const { relatedInfos: r2, _sourceLayer: o2 } = this;
    r2.clear();
    const s2 = r$1t(o2.associatedLayer) ? await o2.associatedLayer.load(i2) : o2;
    if (!s2)
      return;
    const n2 = t2.filter((e3) => e3 && le(e3.fieldName));
    if (!n2 || !n2.length)
      return;
    t2.forEach((e3) => this._configureRelatedInfo(e3, s2));
    const l2 = await b$p({ relatedInfos: r2, layer: s2 }, i2);
    Object.keys(l2).forEach((e3) => {
      var _a2;
      const t3 = r2.get(e3.toString()), i3 = (_a2 = l2[e3]) == null ? void 0 : _a2.value;
      t3 && i3 && (t3.layerInfo = i3.data);
    });
    const p2 = await R$9({ graphic: e2, relatedInfos: r2, layer: s2 }, i2);
    Object.keys(p2).forEach((e3) => {
      var _a2;
      g$t((_a2 = p2[e3]) == null ? void 0 : _a2.value, r2.get(e3.toString()));
    });
  }
  _configureRelatedInfo(e2, t2) {
    const { relatedInfos: i2 } = this, r2 = d$A(e2.fieldName);
    if (!r2)
      return;
    const { layerId: o2, fieldName: s2 } = r2;
    if (!o2)
      return;
    const n2 = i2.get(o2.toString()) || h$x(o2, t2);
    n2 && ($$3({ relatedInfo: n2, fieldName: s2, fieldInfo: e2 }), this.relatedInfos.set(o2, n2));
  }
};
K$2.interceptor = new e$o(pe$1, me$1), e$1W([y$1o()], K$2.prototype, "_error", void 0), e$1W([y$1o()], K$2.prototype, "_featureAbortController", void 0), e$1W([y$1o({ readOnly: true })], K$2.prototype, "_effectivePopupTemplate", null), e$1W([y$1o({ readOnly: true })], K$2.prototype, "_fieldInfoMap", null), e$1W([y$1o({ readOnly: true })], K$2.prototype, "_sourceLayer", null), e$1W([y$1o()], K$2.prototype, "abilities", void 0), e$1W([s$1N("abilities")], K$2.prototype, "castAbilities", null), e$1W([y$1o({ readOnly: true })], K$2.prototype, "content", void 0), e$1W([y$1o({ readOnly: true })], K$2.prototype, "contentViewModels", void 0), e$1W([y$1o()], K$2.prototype, "description", void 0), e$1W([y$1o({ type: Boolean })], K$2.prototype, "defaultPopupTemplateEnabled", void 0), e$1W([y$1o({ readOnly: true })], K$2.prototype, "state", null), e$1W([y$1o({ readOnly: true })], K$2.prototype, "formattedAttributes", void 0), e$1W([y$1o({ type: g$J, value: null })], K$2.prototype, "graphic", null), e$1W([y$1o({ readOnly: true })], K$2.prototype, "lastEditInfo", void 0), e$1W([y$1o({ readOnly: true })], K$2.prototype, "relatedInfos", void 0), e$1W([y$1o()], K$2.prototype, "spatialReference", null), e$1W([y$1o({ readOnly: true })], K$2.prototype, "title", void 0), e$1W([y$1o()], K$2.prototype, "map", null), e$1W([y$1o({ readOnly: true })], K$2.prototype, "waitingForContent", null), e$1W([y$1o()], K$2.prototype, "view", void 0), K$2 = Q$1 = e$1W([n$2f("esri.widgets.FeatureViewModel")], K$2);
const W$3 = K$2;
const e$n = { iconText: "esri-icon-font-fallback-text", iconLoading: "esri-icon-loading-indicator esri-rotating", esriTable: "esri-widget__table", esriWidget: "esri-widget", base: "esri-feature", container: "esri-feature__size-container", title: "esri-feature__title", main: "esri-feature__main-container", btn: "esri-feature__button", icon: "esri-feature__icon", content: "esri-feature__content", contentNode: "esri-feature__content-node", contentElement: "esri-feature__content-element", text: "esri-feature__text", lastEditedInfo: "esri-feature__last-edited-info", fields: "esri-feature__fields", fieldHeader: "esri-feature__field-header", fieldData: "esri-feature__field-data", fieldDataDate: "esri-feature__field-data--date", loadingSpinnerContainer: "esri-feature__loading-container", spinner: "esri-feature__loading-spinner" };
const i$z = (i2) => {
  let n2 = class extends i2 {
    constructor() {
      super(...arguments), this.renderNodeContent = (e2) => e$R(e2) && !e2.destroyed ? n$1k("div", { class: e$n.contentNode, key: e2 }, e2.render()) : e2 instanceof HTMLElement ? n$1k("div", { class: e$n.contentNode, key: e2, bind: e2, afterCreate: this._attachToNode }) : t$V(e2) ? n$1k("div", { class: e$n.contentNode, key: e2, bind: e2.domNode, afterCreate: this._attachToNode }) : null;
    }
    _attachToNode(e2) {
      const o2 = this;
      e2.appendChild(o2);
    }
  };
  return n2 = e$1W([n$2f("esri.widgets.Feature.ContentMixin")], n2), n2;
};
var E$5;
const _$b = { title: true, content: true, lastEditedInfo: true }, b$6 = "relationship-handles";
let W$2 = E$5 = class extends i$z(M$d) {
  constructor(e2, t2) {
    super(e2, t2), this._contentWidgets = [], this.flowItems = null, this.headingLevel = 2, this.messages = null, this.messagesCommon = null, this.messagesURIUtils = null, this.visibleElements = __spreadValues({}, _$b), this.viewModel = new W$3();
  }
  initialize() {
    this.addHandles(l$1f(() => {
      var _a2;
      return (_a2 = this.viewModel) == null ? void 0 : _a2.contentViewModels;
    }, () => this._setupContentWidgets(), h$S));
  }
  loadDependencies() {
    return import("./calcite-notice.js");
  }
  destroy() {
    this._destroyContentWidgets();
  }
  get graphic() {
    return this.viewModel.graphic;
  }
  set graphic(e2) {
    this.viewModel.graphic = e2;
  }
  get defaultPopupTemplateEnabled() {
    return this.viewModel.defaultPopupTemplateEnabled;
  }
  set defaultPopupTemplateEnabled(e2) {
    this.viewModel.defaultPopupTemplateEnabled = e2;
  }
  get label() {
    var _a2, _b2;
    return (_b2 = (_a2 = this.messages) == null ? void 0 : _a2.widgetLabel) != null ? _b2 : "";
  }
  set label(e2) {
    this._overrideIfSome("label", e2);
  }
  get spatialReference() {
    return this.viewModel.spatialReference;
  }
  set spatialReference(e2) {
    this.viewModel.spatialReference = e2;
  }
  get title() {
    return this.viewModel.title;
  }
  castVisibleElements(e2) {
    return __spreadValues(__spreadValues({}, _$b), e2);
  }
  get map() {
    return this.viewModel.map;
  }
  set map(e2) {
    this.viewModel.map = e2;
  }
  get view() {
    return this.viewModel.view;
  }
  set view(e2) {
    this.viewModel.view = e2;
  }
  render() {
    const { state: e2 } = this.viewModel, t2 = n$1k("div", { class: e$n.container, key: "container" }, this.renderTitle(), e2 === "error" ? this.renderError() : e2 === "loading" ? this.renderLoading() : this.renderContentContainer());
    return n$1k("div", { class: this.classes(e$n.base, e$n.esriWidget) }, t2);
  }
  setActiveMedia(e2, t2) {
    return this.viewModel.setActiveMedia(e2, t2);
  }
  nextMedia(e2) {
    return this.viewModel.nextMedia(e2);
  }
  previousMedia(e2) {
    return this.viewModel.previousMedia(e2);
  }
  renderError() {
    const { messagesCommon: e2, messages: t2, visibleElements: s2 } = this;
    return n$1k("calcite-notice", { active: true, color: "red", icon: "exclamation-mark-circle", scale: "s" }, s2.title ? n$1k("div", { key: "error-title", slot: "title" }, e2.errorMessage) : null, n$1k("div", { key: "error-message", slot: "message" }, t2.loadingError));
  }
  renderLoading() {
    return n$1k("div", { key: "loading-container", class: e$n.loadingSpinnerContainer }, n$1k("span", { class: this.classes(e$n.iconLoading, e$n.spinner) }));
  }
  renderContentContainer() {
    const { visibleElements: e2 } = this;
    return e2.content ? n$1k("div", { class: e$n.main }, [this.renderContent(), this.renderLastEditInfo()]) : null;
  }
  renderTitle() {
    const { visibleElements: e2, title: t2 } = this;
    return e2.title ? n$1k(n$1j, { level: this.headingLevel, class: e$n.title, innerHTML: t2 }) : null;
  }
  renderContent() {
    const e2 = this.viewModel.content, t2 = "content";
    if (!e2)
      return null;
    if (Array.isArray(e2))
      return e2.length ? n$1k("div", { class: e$n.contentNode, key: `${t2}-content-elements` }, e2.map(this.renderContentElement, this)) : null;
    if (typeof e2 == "string") {
      const e3 = this._contentWidgets[0];
      return !e3 || e3.destroyed ? null : n$1k("div", { class: e$n.contentNode, key: `${t2}-content` }, e3.render());
    }
    return this.renderNodeContent(e2);
  }
  renderContentElement(e2, t2) {
    const { visibleElements: s2 } = this;
    if (typeof s2.content != "boolean" && !s2.content[e2.type])
      return null;
    switch (e2.type) {
      case "attachments":
        return this.renderAttachments(t2);
      case "custom":
        return this.renderCustom(e2, t2);
      case "fields":
        return this.renderFields(t2);
      case "media":
        return this.renderMedia(t2);
      case "text":
        return this.renderText(e2, t2);
      case "expression":
        return this.renderExpression(t2);
      case "relationship":
        return this.renderRelationship(t2);
      default:
        return null;
    }
  }
  renderAttachments(e2) {
    const t2 = this._contentWidgets[e2];
    if (!t2 || t2.destroyed)
      return null;
    const { state: s2, attachmentInfos: i2 } = t2.viewModel;
    return s2 === "loading" || i2.length > 0 ? n$1k("div", { key: this._buildKey("attachments-element", e2), class: this.classes(e$n.contentElement) }, t2.render()) : null;
  }
  renderRelationship(e2) {
    const t2 = this._contentWidgets[e2];
    return t2 && !t2.destroyed && this.flowItems ? n$1k("div", { key: this._buildKey("relationship-element", e2), class: e$n.contentElement }, t2.render()) : null;
  }
  renderExpression(e2) {
    const t2 = this._contentWidgets[e2];
    return !t2 || t2.destroyed ? null : n$1k("div", { key: this._buildKey("expression-element", e2), class: e$n.contentElement }, t2.render());
  }
  renderCustom(e2, t2) {
    const { creator: s2 } = e2, i2 = this._contentWidgets[t2];
    return !i2 || i2.destroyed ? null : s2 ? n$1k("div", { key: this._buildKey("custom-element", t2), class: e$n.contentElement }, i2.render()) : null;
  }
  renderFields(e2) {
    const t2 = this._contentWidgets[e2];
    return !t2 || t2.destroyed ? null : n$1k("div", { key: this._buildKey("fields-element", e2), class: e$n.contentElement }, t2.render());
  }
  renderMedia(e2) {
    const t2 = this._contentWidgets[e2];
    return !t2 || t2.destroyed ? null : n$1k("div", { key: this._buildKey("media-element", e2), class: e$n.contentElement }, t2.render());
  }
  renderLastEditInfo() {
    const { visibleElements: e2, messages: t2 } = this, { lastEditInfo: s2 } = this.viewModel;
    if (!s2 || !e2.lastEditedInfo)
      return null;
    const { date: i2, user: n2 } = s2, r2 = s2.type === "edit" ? n2 ? t2.lastEditedByUser : t2.lastEdited : n2 ? t2.lastCreatedByUser : t2.lastCreated, o2 = s$1f(r2, { date: i2, user: n2 });
    return n$1k("div", { key: "edit-info-element", class: this.classes(e$n.lastEditedInfo, e$n.contentElement) }, o2);
  }
  renderText(e2, t2) {
    const s2 = e2.text, i2 = this._contentWidgets[t2];
    return !i2 || i2.destroyed ? null : s2 ? n$1k("div", { key: this._buildKey("text-element", t2), class: this.classes(e$n.contentElement, e$n.text) }, i2.render()) : null;
  }
  _buildKey(e2, ...t2) {
    return `${e2}__${this.get("viewModel.graphic.uid") || "0"}-${t2.join("-")}`;
  }
  _destroyContentWidget(e2) {
    e2 && (e2.viewModel = null, !e2.destroyed && e2.destroy());
  }
  _destroyContentWidgets() {
    this.removeHandles(b$6), this._contentWidgets.forEach((e2) => this._destroyContentWidget(e2)), this._contentWidgets = [];
  }
  _addFeatureRelationshipHandles(e2) {
    const { flowItems: t2, visibleElements: i2 } = this;
    this.addHandles([a$1I(() => e2, "select-record", ({ featureViewModel: e3 }) => {
      t2 && (e3.abilities = { relationshipContent: true }, t2.push(new E$5({ flowItems: t2, viewModel: e3, visibleElements: i2 })));
    }), a$1I(() => e2, "show-all-records", () => {
      if (!t2)
        return;
      const { viewModel: s2 } = e2;
      s2.showAllEnabled = true;
      const i3 = new b$7({ visibleElements: { title: false, description: false }, viewModel: s2 });
      this._addFeatureRelationshipHandles(i3), t2.push(i3);
    })], b$6);
  }
  _setupContentWidgets() {
    this._destroyContentWidgets();
    const { headingLevel: e2, visibleElements: t2 } = this, s2 = this.get("viewModel.content"), { contentViewModels: i2 } = this.viewModel;
    if (Array.isArray(s2))
      s2.forEach((s3, n2) => {
        if (s3.type === "attachments" && (this._contentWidgets[n2] = new h$I({ displayType: s3.displayType, headingLevel: t2.title ? e2 + 1 : e2, viewModel: i2[n2] })), s3.type === "fields" && (this._contentWidgets[n2] = new m$X({ viewModel: i2[n2] })), s3.type === "media" && (this._contentWidgets[n2] = new x$g({ viewModel: i2[n2] })), s3.type === "text" && (this._contentWidgets[n2] = new l$13({ viewModel: i2[n2] })), s3.type === "custom" && (this._contentWidgets[n2] = new l$13({ viewModel: i2[n2] })), s3.type === "expression" && (this._contentWidgets[n2] = new m$k({ viewModel: i2[n2] })), s3.type === "relationship") {
          const e3 = new b$7({ viewModel: i2[n2] });
          this._addFeatureRelationshipHandles(e3), this._contentWidgets[n2] = e3;
        }
      }, this);
    else {
      const e3 = i2[0];
      e3 && !e3.destroyed && (this._contentWidgets[0] = new l$13({ viewModel: e3 }));
    }
    this.scheduleRender();
  }
};
e$1W([y$1o()], W$2.prototype, "graphic", null), e$1W([y$1o()], W$2.prototype, "defaultPopupTemplateEnabled", null), e$1W([y$1o()], W$2.prototype, "flowItems", void 0), e$1W([y$1o()], W$2.prototype, "headingLevel", void 0), e$1W([y$1o()], W$2.prototype, "label", null), e$1W([y$1o(), e$W("esri/widgets/Feature/t9n/Feature")], W$2.prototype, "messages", void 0), e$1W([y$1o(), e$W("esri/t9n/common")], W$2.prototype, "messagesCommon", void 0), e$1W([y$1o(), e$W("esri/widgets/support/t9n/uriUtils")], W$2.prototype, "messagesURIUtils", void 0), e$1W([y$1o()], W$2.prototype, "spatialReference", null), e$1W([y$1o({ readOnly: true })], W$2.prototype, "title", null), e$1W([y$1o()], W$2.prototype, "visibleElements", void 0), e$1W([s$1N("visibleElements")], W$2.prototype, "castVisibleElements", null), e$1W([y$1o()], W$2.prototype, "map", null), e$1W([y$1o()], W$2.prototype, "view", null), e$1W([y$1o({ type: W$3 })], W$2.prototype, "viewModel", void 0), W$2 = E$5 = e$1W([n$2f("esri.widgets.Feature")], W$2);
const C$6 = W$2;
var l$t;
const d$g = Symbol("anchorHandles");
let m$j = class extends n$26.EventedAccessor {
  constructor(e2) {
    super(e2), this[l$t] = new t$1N(), this.location = null, this.screenLocationEnabled = false, this.view = null, this[d$g].add([f$10(() => o$1Z(this.screenLocationEnabled ? this.view : null, (e3) => [e3.size, e3.type === "3d" ? e3.camera : e3.viewpoint]), () => this.notifyChange("screenLocation")), l$1f(() => this.screenLocation, (e3, o2) => {
      r$1t(e3) && r$1t(o2) && this.emit("view-change");
    })]);
  }
  destroy() {
    this.view = null, this[d$g] = s$26(this[d$g]);
  }
  get screenLocation() {
    const { location: e2, view: o2, screenLocationEnabled: t2 } = this;
    return t2 && r$1t(e2) && r$1t(o2) && o2.ready ? o2.toScreen(e2) : null;
  }
};
l$t = d$g, e$1W([y$1o()], m$j.prototype, "location", void 0), e$1W([y$1o()], m$j.prototype, "screenLocation", null), e$1W([y$1o()], m$j.prototype, "screenLocationEnabled", void 0), e$1W([y$1o()], m$j.prototype, "view", void 0), m$j = e$1W([n$2f("esri.widgets.support.AnchorElementViewModel")], m$j);
const h$g = m$j;
const t$r = "esri.widgets.CompassViewModel";
let p$x = class extends h$g {
  constructor(s2) {
    super(s2), this.visible = false;
  }
};
e$1W([y$1o()], p$x.prototype, "visible", void 0), p$x = e$1W([n$2f(t$r)], p$x);
const c$v = p$x;
const p$w = { base: "esri-spinner", spinnerStart: "esri-spinner--start", spinnerFinish: "esri-spinner--finish" };
let c$u = class extends M$d {
  constructor(i2, e2) {
    super(i2, e2), this._animationDelay = 500, this._animationPromise = null, this.viewModel = new c$v();
  }
  initialize() {
    this.addHandles(l$1f(() => this.visible, (i2) => this._visibleChange(i2)));
  }
  destroy() {
    this._animationPromise = null;
  }
  get location() {
    return this.viewModel.location;
  }
  set location(i2) {
    this.viewModel.location = i2;
  }
  get view() {
    return this.viewModel.view;
  }
  set view(i2) {
    this.viewModel.view = i2;
  }
  get visible() {
    return this.viewModel.visible;
  }
  set visible(i2) {
    this.viewModel.visible = i2;
  }
  show(i2) {
    const { location: e2, promise: t2 } = i2;
    e2 && (this.viewModel.location = e2), this.visible = true;
    const s2 = () => this.hide();
    t2 && t2.catch(() => {
    }).then(s2);
  }
  hide() {
    this.visible = false;
  }
  render() {
    const { visible: i2 } = this, { screenLocation: e2 } = this.viewModel, t2 = !!e2, s2 = i2 && t2, o2 = !i2 && t2, r2 = { [p$w.spinnerStart]: s2, [p$w.spinnerFinish]: o2 }, n2 = this._getPositionStyles();
    return n$1k("div", { class: this.classes(p$w.base, r2), styles: n2 });
  }
  _visibleChange(i2) {
    if (i2)
      return void (this.viewModel.screenLocationEnabled = true);
    const e2 = U$q(this._animationDelay);
    this._animationPromise = e2, e2.catch(() => {
    }).then(() => {
      this._animationPromise === e2 && (this.viewModel.screenLocationEnabled = false, this._animationPromise = null);
    });
  }
  _getPositionStyles() {
    const { screenLocation: i2, view: t2 } = this.viewModel;
    if (t$1W(t2) || t$1W(i2))
      return {};
    const { padding: s2 } = t2;
    return { left: i2.x - s2.left + "px", top: i2.y - s2.top + "px" };
  }
};
e$1W([y$1o()], c$u.prototype, "location", null), e$1W([y$1o()], c$u.prototype, "view", null), e$1W([y$1o({ type: c$v })], c$u.prototype, "viewModel", void 0), e$1W([y$1o()], c$u.prototype, "visible", null), c$u = e$1W([n$2f("esri.widgets.Spinner")], c$u);
const h$f = c$u;
const o$r = "OBJECTID";
var t$q;
!function(a2) {
  a2[a2.size = 22] = "size", a2[a2.lineWidth = 50] = "lineWidth", a2[a2.maxSize = 120] = "maxSize", a2[a2.maxOutlineSize = 80] = "maxOutlineSize", a2[a2.tallSymbolWidth = 20] = "tallSymbolWidth";
}(t$q || (t$q = {}));
function n$w() {
  const n2 = new Float32Array(6);
  return n2[0] = 1, n2[3] = 1, n2;
}
function t$p(n2) {
  const t2 = new Float32Array(6);
  return t2[0] = n2[0], t2[1] = n2[1], t2[2] = n2[2], t2[3] = n2[3], t2[4] = n2[4], t2[5] = n2[5], t2;
}
function r$p(n2, t2, r2, e2, o2, a2) {
  const c2 = new Float32Array(6);
  return c2[0] = n2, c2[1] = t2, c2[2] = r2, c2[3] = e2, c2[4] = o2, c2[5] = a2, c2;
}
function e$m(n2, t2) {
  return new Float32Array(n2, t2, 6);
}
function o$q(n2, t2, r2, e2) {
  const o2 = t2[e2], a2 = t2[e2 + 1];
  n2[e2] = r2[0] * o2 + r2[2] * a2 + r2[4], n2[e2 + 1] = r2[1] * o2 + r2[3] * a2 + r2[5];
}
function a$D(n2, t2, r2, e2 = 0, a2 = 0, c2 = 2) {
  const s2 = a2 || t2.length / c2;
  for (let u2 = e2; u2 < s2; u2++) {
    o$q(n2, t2, r2, u2 * c2);
  }
}
Object.freeze(Object.defineProperty({ __proto__: null, create: n$w, clone: t$p, fromValues: r$p, createView: e$m, transform: o$q, transformMany: a$D }, Symbol.toStringTag, { value: "Module" }));
function a$C(t2, a2) {
  return t2[0] = a2[0], t2[1] = a2[1], t2[2] = a2[2], t2[3] = a2[3], t2[4] = a2[4], t2[5] = a2[5], t2;
}
function n$v(t2) {
  return t2[0] = 1, t2[1] = 0, t2[2] = 0, t2[3] = 1, t2[4] = 0, t2[5] = 0, t2;
}
function s$q(t2, a2, n2, s2, r2, u2, o2) {
  return t2[0] = a2, t2[1] = n2, t2[2] = s2, t2[3] = r2, t2[4] = u2, t2[5] = o2, t2;
}
function r$o(t2, a2) {
  const n2 = a2[0], s2 = a2[1], r2 = a2[2], u2 = a2[3], o2 = a2[4], e2 = a2[5];
  let c2 = n2 * u2 - s2 * r2;
  return c2 ? (c2 = 1 / c2, t2[0] = u2 * c2, t2[1] = -s2 * c2, t2[2] = -r2 * c2, t2[3] = n2 * c2, t2[4] = (r2 * e2 - u2 * o2) * c2, t2[5] = (s2 * o2 - n2 * e2) * c2, t2) : null;
}
function u$o(t2) {
  return t2[0] * t2[3] - t2[1] * t2[2];
}
function o$p(t2, a2, n2) {
  const s2 = a2[0], r2 = a2[1], u2 = a2[2], o2 = a2[3], e2 = a2[4], c2 = a2[5], i2 = n2[0], h2 = n2[1], M2 = n2[2], f2 = n2[3], b2 = n2[4], l2 = n2[5];
  return t2[0] = s2 * i2 + u2 * h2, t2[1] = r2 * i2 + o2 * h2, t2[2] = s2 * M2 + u2 * f2, t2[3] = r2 * M2 + o2 * f2, t2[4] = s2 * b2 + u2 * l2 + e2, t2[5] = r2 * b2 + o2 * l2 + c2, t2;
}
function e$l(t2, a2, n2) {
  const s2 = a2[0], r2 = a2[1], u2 = a2[2], o2 = a2[3], e2 = a2[4], c2 = a2[5], i2 = Math.sin(n2), h2 = Math.cos(n2);
  return t2[0] = s2 * h2 + u2 * i2, t2[1] = r2 * h2 + o2 * i2, t2[2] = s2 * -i2 + u2 * h2, t2[3] = r2 * -i2 + o2 * h2, t2[4] = e2, t2[5] = c2, t2;
}
function c$t(t2, a2, n2) {
  const s2 = a2[0], r2 = a2[1], u2 = a2[2], o2 = a2[3], e2 = a2[4], c2 = a2[5], i2 = n2[0], h2 = n2[1];
  return t2[0] = s2 * i2, t2[1] = r2 * i2, t2[2] = u2 * h2, t2[3] = o2 * h2, t2[4] = e2, t2[5] = c2, t2;
}
function i$y(t2, a2, n2) {
  const s2 = a2[0], r2 = a2[1], u2 = a2[2], o2 = a2[3], e2 = a2[4], c2 = a2[5], i2 = n2[0], h2 = n2[1];
  return t2[0] = s2, t2[1] = r2, t2[2] = u2, t2[3] = o2, t2[4] = s2 * i2 + u2 * h2 + e2, t2[5] = r2 * i2 + o2 * h2 + c2, t2;
}
function h$e(t2, a2) {
  const n2 = Math.sin(a2), s2 = Math.cos(a2);
  return t2[0] = s2, t2[1] = n2, t2[2] = -n2, t2[3] = s2, t2[4] = 0, t2[5] = 0, t2;
}
function M$2(t2, a2) {
  return t2[0] = a2[0], t2[1] = 0, t2[2] = 0, t2[3] = a2[1], t2[4] = 0, t2[5] = 0, t2;
}
function f$g(t2, a2) {
  return t2[0] = 1, t2[1] = 0, t2[2] = 0, t2[3] = 1, t2[4] = a2[0], t2[5] = a2[1], t2;
}
function b$5(t2) {
  return "mat2d(" + t2[0] + ", " + t2[1] + ", " + t2[2] + ", " + t2[3] + ", " + t2[4] + ", " + t2[5] + ")";
}
function l$s(t2) {
  return Math.sqrt(t2[0] ** 2 + t2[1] ** 2 + t2[2] ** 2 + t2[3] ** 2 + t2[4] ** 2 + t2[5] ** 2 + 1);
}
function m$i(t2, a2, n2) {
  return t2[0] = a2[0] + n2[0], t2[1] = a2[1] + n2[1], t2[2] = a2[2] + n2[2], t2[3] = a2[3] + n2[3], t2[4] = a2[4] + n2[4], t2[5] = a2[5] + n2[5], t2;
}
function d$f(t2, a2, n2) {
  return t2[0] = a2[0] - n2[0], t2[1] = a2[1] - n2[1], t2[2] = a2[2] - n2[2], t2[3] = a2[3] - n2[3], t2[4] = a2[4] - n2[4], t2[5] = a2[5] - n2[5], t2;
}
function p$v(t2, a2, n2) {
  return t2[0] = a2[0] * n2, t2[1] = a2[1] * n2, t2[2] = a2[2] * n2, t2[3] = a2[3] * n2, t2[4] = a2[4] * n2, t2[5] = a2[5] * n2, t2;
}
function x$6(t2, a2, n2, s2) {
  return t2[0] = a2[0] + n2[0] * s2, t2[1] = a2[1] + n2[1] * s2, t2[2] = a2[2] + n2[2] * s2, t2[3] = a2[3] + n2[3] * s2, t2[4] = a2[4] + n2[4] * s2, t2[5] = a2[5] + n2[5] * s2, t2;
}
function y$b(t2, a2) {
  return t2[0] === a2[0] && t2[1] === a2[1] && t2[2] === a2[2] && t2[3] === a2[3] && t2[4] === a2[4] && t2[5] === a2[5];
}
function g$b(a2, n2) {
  const s2 = a2[0], r2 = a2[1], u2 = a2[2], o2 = a2[3], e2 = a2[4], c2 = a2[5], i2 = n2[0], h2 = n2[1], M2 = n2[2], f2 = n2[3], b2 = n2[4], l2 = n2[5], m2 = a$23();
  return Math.abs(s2 - i2) <= m2 * Math.max(1, Math.abs(s2), Math.abs(i2)) && Math.abs(r2 - h2) <= m2 * Math.max(1, Math.abs(r2), Math.abs(h2)) && Math.abs(u2 - M2) <= m2 * Math.max(1, Math.abs(u2), Math.abs(M2)) && Math.abs(o2 - f2) <= m2 * Math.max(1, Math.abs(o2), Math.abs(f2)) && Math.abs(e2 - b2) <= m2 * Math.max(1, Math.abs(e2), Math.abs(b2)) && Math.abs(c2 - l2) <= m2 * Math.max(1, Math.abs(c2), Math.abs(l2));
}
const S$6 = o$p, j$3 = d$f;
Object.freeze(Object.defineProperty({ __proto__: null, copy: a$C, identity: n$v, set: s$q, invert: r$o, determinant: u$o, multiply: o$p, rotate: e$l, scale: c$t, translate: i$y, fromRotation: h$e, fromScaling: M$2, fromTranslation: f$g, str: b$5, frob: l$s, add: m$i, subtract: d$f, multiplyScalar: p$v, multiplyScalarAndAdd: x$6, exactEquals: y$b, equals: g$b, mul: S$6, sub: j$3 }, Symbol.toStringTag, { value: "Module" }));
const u$n = has("android");
has("chrome") || u$n && u$n >= 4 ? "auto" : "optimizeLegibility";
i$1r();
function v$9(e2) {
  return e2 && "opacity" in e2 ? e2.opacity * v$9(e2.parent) : 1;
}
async function x$5(i2, s2) {
  var _a2, _b2;
  if (!i2)
    return;
  const o2 = i2.sourceLayer, a2 = (_a2 = r$1t(s2) && s2.useSourceLayer ? o2 : i2.layer) != null ? _a2 : o2, f2 = v$9(a2);
  if (r$1t(i2.symbol) && (!r$1t(s2) || s2.ignoreGraphicSymbol !== true)) {
    const t2 = i2.symbol.type === "web-style" ? await i2.symbol.fetchSymbol(__spreadProps(__spreadValues({}, s2), { cache: r$1t(s2) ? s2.webStyleCache : null })) : i2.symbol.clone();
    return x$m(t2, null, f2), t2;
  }
  const h2 = (_b2 = r$1t(s2) ? s2.renderer : null) != null ? _b2 : a2 && "renderer" in a2 ? a2.renderer : null;
  let y2 = h2 && "getSymbolAsync" in h2 ? await h2.getSymbolAsync(i2, s2) : null;
  if (!y2)
    return;
  if (y2 = y2.type === "web-style" ? await y2.fetchSymbol(__spreadProps(__spreadValues({}, s2), { cache: r$1t(s2) ? s2.webStyleCache : null })) : y2.clone(), !(h2 && "visualVariables" in h2 && h2.visualVariables && h2.visualVariables.length))
    return x$m(y2, null, f2), y2;
  if ("arcadeRequiredForVisualVariables" in h2 && h2.arcadeRequiredForVisualVariables && (t$1W(s2) || t$1W(s2.arcade))) {
    const e2 = __spreadValues({}, e$1U(s2));
    e2.arcade = await i$26(), s2 = e2;
  }
  const p2 = await Promise.resolve().then(function() {
    return visualVariableUtils;
  }), d2 = [], m2 = [], b2 = [], g2 = [];
  for (const e2 of h2.visualVariables)
    switch (e2.type) {
      case "color":
        d2.push(e2);
        break;
      case "opacity":
        m2.push(e2);
        break;
      case "rotation":
        g2.push(e2);
        break;
      case "size":
        e2.target || b2.push(e2);
    }
  const w2 = !!d2.length && d2[d2.length - 1], S2 = w2 ? p2.getColor(w2, i2, s2) : null, x2 = !!m2.length && m2[m2.length - 1];
  let V2 = x2 ? p2.getOpacity(x2, i2, s2) : null;
  if (f2 != null && (V2 = V2 != null ? V2 * f2 : f2), x$m(y2, S2, V2), b2.length) {
    const e2 = p2.getAllSizes(b2, i2, s2);
    await M$9(y2, e2);
  }
  for (const e2 of g2)
    N$5(y2, p2.getRotationAngle(e2, i2, s2), e2.axis);
  return y2;
}
class o$o {
  constructor(r2, o2) {
    this._owner = o2, this._properties = {}, this._afterDispatchHandle = null;
    for (const t2 in r2) {
      const o3 = r2[t2], s2 = new t$1I(o3, void 0, void 0, 2, 2);
      this._properties[t2] = { pool: s2, acquired: [] };
    }
    this._afterDispatchHandle = y$1g(() => this._release());
  }
  destroy() {
    this._afterDispatchHandle && (this._afterDispatchHandle.remove(), this._afterDispatchHandle = null);
    for (const e2 in this._properties) {
      const t2 = this._properties[e2];
      for (const e3 of t2.acquired)
        x$J(e3) || t2.pool.release(e3);
      t2.pool.destroy(), t2.pool = null, t2.acquired = null;
    }
    this._properties = null, this._owner = null;
  }
  get(e2) {
    const t2 = this._owner._get(e2), r2 = this._properties[e2];
    let o2 = r2.pool.acquire();
    for (r2.acquired.push(o2); o2 === t2; )
      r2.acquired.push(o2), o2 = r2.pool.acquire();
    return o2;
  }
  _release() {
    for (const e2 in this._properties) {
      const t2 = this._properties[e2];
      let o2 = 0;
      for (const e3 of t2.acquired)
        x$J(e3) ? t2.acquired[o2++] = e3 : t2.pool.release(e3);
      t2.acquired.length = o2;
    }
  }
}
const e$k = has("mac") ? "Meta" : "Ctrl", t$o = { 8: "Backspace", 9: "Tab", 13: "Enter", 27: "Escape", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete" };
for (let n2 = 48; n2 < 58; n2++)
  t$o[n2] = String.fromCharCode(n2);
for (let n2 = 1; n2 < 25; n2++)
  t$o[111 + n2] = `F${n2}`;
for (let n2 = 65; n2 < 91; n2++)
  t$o[n2] = [String.fromCharCode(n2 + 32), String.fromCharCode(n2)];
function o$n(e2) {
  if (e2.key !== void 0)
    return i$2k(e2);
  const o2 = t$o[e2.keyCode];
  return Array.isArray(o2) ? e2.shiftKey ? o2[1] : o2[0] : o2;
}
function a$B(r2) {
  switch (r2) {
    case "Ctrl":
    case "Alt":
    case "Shift":
    case "Meta":
    case "Primary":
      return true;
  }
  return false;
}
class e$j {
  constructor(e2, t2 = []) {
    this.eventType = e2, this.keyModifiers = t2;
  }
  matches(e2) {
    if (e2.type !== this.eventType)
      return false;
    if (this.keyModifiers.length === 0)
      return true;
    const t2 = e2.modifiers;
    for (const i2 of this.keyModifiers)
      if (!t2.has(i2))
        return false;
    return true;
  }
}
const n$u = s$22.getLogger("esri.views.input.InputHandler");
class i$x {
  constructor(e2) {
    this._manager = null, this._incoming = {}, this._outgoing = {}, this._incomingEventMatches = null, this._incomingEventTypes = null, this._outgoingEventTypes = null, this._hasSideEffects = e2;
  }
  get incomingEventMatches() {
    if (!this._incomingEventMatches) {
      this._incomingEventMatches = [];
      for (const e2 in this._incoming) {
        const t2 = this._incoming[e2];
        for (const e3 of t2)
          this._incomingEventMatches.push(e3.match);
      }
    }
    return this._incomingEventMatches;
  }
  get incomingEventTypes() {
    return this._incomingEventTypes || (this._incomingEventTypes = this.incomingEventMatches.map((e2) => e2.eventType)), this._incomingEventTypes;
  }
  get outgoingEventTypes() {
    return this._outgoingEventTypes || (this._outgoingEventTypes = Object.keys(this._outgoing)), this._outgoingEventTypes;
  }
  get hasSideEffects() {
    return this._hasSideEffects;
  }
  get hasPendingInputs() {
    return false;
  }
  onInstall(e2) {
    this._manager ? n$u.error("This InputHandler has already been registered with an InputManager") : (e2.setEventCallback((e3) => this._handleEvent(e3)), e2.setUninstallCallback(() => this._onUninstall()), this._manager = e2);
  }
  onUninstall() {
  }
  registerIncoming(e2, n2, i2) {
    let a2;
    typeof n2 == "function" ? (i2 = n2, a2 = []) : a2 = n2 || [];
    const o2 = typeof e2 == "string" ? new e$j(e2, a2) : e2, h2 = () => {
      this._incomingEventTypes = null, this._incomingEventMatches = null;
    }, r2 = (e3) => {
      const t2 = this._incoming[e3.match.eventType];
      if (t2) {
        const n3 = t2.indexOf(e3);
        t2.splice(n3, 1), h2(), this._manager && this._manager.updateDependencies();
      }
    }, g2 = new s$p(o2, i2, { onPause: r2, onRemove: r2, onResume: (e3) => {
      const t2 = this._incoming[e3.match.eventType];
      t2 && !t2.includes(e3) && (t2.push(e3), h2(), this._manager && this._manager.updateDependencies());
    } });
    let c2 = this._incoming[o2.eventType];
    return c2 || (c2 = [], this._incoming[o2.eventType] = c2), c2.push(g2), h2(), this._manager && this._manager.updateDependencies(), g2;
  }
  registerOutgoing(e2) {
    if (this._outgoing[e2])
      throw new Error("There is already a callback registered for this outgoing InputEvent: " + e2);
    const t2 = new a$A(e2, { onEmit: (e3, t3, n2, i2) => {
      var _a2;
      (_a2 = this._manager) == null ? void 0 : _a2.emit(e3.eventType, t3, n2, i2);
    }, onRemove: (e3) => {
      var _a2;
      delete this._outgoing[e3.eventType], (_a2 = this._manager) == null ? void 0 : _a2.updateDependencies();
    } });
    return this._outgoing[e2] = t2, this._outgoingEventTypes = null, this._manager && this._manager.updateDependencies(), t2;
  }
  startCapturingPointer(e2) {
    var _a2;
    (_a2 = this._manager) == null ? void 0 : _a2.setPointerCapture(e2, true);
  }
  stopCapturingPointer(e2) {
    var _a2;
    (_a2 = this._manager) == null ? void 0 : _a2.setPointerCapture(e2, false);
  }
  refreshHasPendingInputs() {
    var _a2;
    (_a2 = this._manager) == null ? void 0 : _a2.refreshHasPendingInputs();
  }
  _onUninstall() {
    this._manager ? (this.onUninstall(), this._manager = null) : n$u.error("This InputHandler is not registered with an InputManager");
  }
  _handleEvent(e2) {
    var _a2;
    const t2 = this._incoming[e2.type];
    if (t2) {
      for (const n2 of t2)
        if (n2.match.matches(e2) && ((_a2 = n2.callback) == null ? void 0 : _a2.call(n2, e2), e2.shouldStopPropagation()))
          break;
    }
  }
}
class s$p {
  constructor(e2, t2, n2) {
    this.match = e2, this._callback = t2, this._handler = n2;
  }
  pause() {
    this._handler.onPause(this);
  }
  resume() {
    this._handler.onResume(this);
  }
  remove() {
    this._handler.onRemove(this);
  }
  get callback() {
    return this._callback;
  }
}
class a$A {
  constructor(e2, t2) {
    this.eventType = e2, this._removed = false, this._handler = t2;
  }
  emit(e2, t2, n2) {
    this._removed || this._handler.onEmit(this, e2, t2, n2);
  }
  remove() {
    this._removed = true, this._handler.onRemove(this);
  }
}
class s$o extends i$x {
  constructor(t2) {
    super(true), this._onChange = t2, this._value = "mouse", this._x = null, this._y = null, this.registerIncoming("pointer-move", (t3) => {
      this._update(t3.data);
    });
  }
  _update(t2) {
    const s2 = t2.native.pointerType === "touch" ? "touch" : "mouse", { x: e2, y: i2 } = t2;
    s2 === this._value && this._x === e2 && this._y === i2 || (this._value = s2, this._x = e2, this._y = i2, this._onChange(s2, e2, i2));
  }
}
class t$n {
  constructor(e2) {
    this._observable = new e$1u(), this._value = e2;
  }
  get() {
    return s$1X(this._observable), this._value;
  }
  set(e2) {
    e2 !== this._value && (this._value = e2, this._observable.notify());
  }
}
class i$w extends i$x {
  constructor() {
    super(true), this._activeTouchPointerIds = new Set(), this._multiTouchActive = new t$n(false), this._onPointerAdd = ({ data: t2 }) => {
      t2.pointerType === "touch" && (this._activeTouchPointerIds.add(t2.native.pointerId), this._update());
    }, this._onPointerRemove = ({ data: t2 }) => {
      t2.pointerType === "touch" && (this._activeTouchPointerIds.delete(t2.native.pointerId), this._update());
    }, this.registerIncoming("pointer-down", this._onPointerAdd), this.registerIncoming("pointer-up", this._onPointerRemove), this.registerIncoming("pointer-capture-lost", this._onPointerRemove), this.registerIncoming("pointer-cancel", this._onPointerRemove);
  }
  get multiTouchActive() {
    return this._multiTouchActive.get();
  }
  _update() {
    this._multiTouchActive.set(this._activeTouchPointerIds.size > 1);
  }
}
let u$m = class extends m$1L {
  constructor(e2) {
    super(e2), this._pointerCaptures = new Map(), this._nameToGroup = {}, this._handlers = [], this._handlersPriority = [], this._currentPropagation = null, this._updateDependenciesAfterPropagation = false, this._sourceEvents = new Set(), this._keyModifiers = new Set(), this._activeKeyModifiers = new Set(), this._stoppedPropagationEventIds = new Set(), this.primaryKey = e$k, this._latestPointerType = "mouse", this._propertiesPool = new o$o({ latestPointerLocation: v$8 }, this), this.latestPointerLocation = null, this.test = { timestamp: void 0, hasCurrentPropagation: () => !!this._currentPropagation };
  }
  initialize() {
    this.eventSource.onEventReceived = this._onEventReceived.bind(this), this._installRecognizers();
  }
  destroy() {
    const e2 = Object.keys(this._nameToGroup);
    for (const t2 of e2)
      this.uninstallHandlers(t2);
    this.eventSource.destroy(), this._currentPropagation = null, this._propertiesPool.destroy();
  }
  get hasPendingInputs() {
    return this._handlers.some((e2) => e2.handler.hasPendingInputs);
  }
  get latestPointerType() {
    return this._latestPointerType;
  }
  get multiTouchActive() {
    return this._multiTouchHandler.multiTouchActive;
  }
  installHandlers(e2, t2, i2 = P$5.INTERNAL) {
    if (this._nameToGroup[e2])
      return void s$22.getLogger(this.declaredClass).error("There is already an InputHandler group registered under the name `" + e2 + "`");
    if (t2.length === 0)
      return void s$22.getLogger(this.declaredClass).error("Can't register a group of zero handlers");
    const n2 = { name: e2, handlers: t2.map((e3) => ({ handler: e3, active: true, removed: false, priorityIndex: 0, groupPriority: i2, eventCallback: null, uninstallCallback: null })) };
    this._nameToGroup[e2] = n2;
    for (let r2 = n2.handlers.length - 1; r2 >= 0; r2--) {
      const e3 = n2.handlers[r2];
      this._handlers.push(e3), e3.handler.onInstall({ updateDependencies: () => {
        this.updateDependencies();
      }, emit: (t3, r3, i3, n3, s2) => {
        this._emitInputEvent(e3.priorityIndex + 1, t3, r3, i3, s2, n3);
      }, setPointerCapture: (t3, r3) => {
        this._setPointerCapture(n2, e3, t3, r3);
      }, setEventCallback: (t3) => {
        e3.eventCallback = t3;
      }, setUninstallCallback: (t3) => {
        e3.uninstallCallback = t3;
      }, refreshHasPendingInputs: () => {
        this.notifyChange("hasPendingInputs");
      } });
    }
    this.updateDependencies();
  }
  uninstallHandlers(e2) {
    const t2 = this._nameToGroup[e2];
    t2 ? (t2.handlers.forEach((e3) => {
      var _a2;
      e3.removed = true, (_a2 = e3.uninstallCallback) == null ? void 0 : _a2.call(e3);
    }), delete this._nameToGroup[e2], this._currentPropagation ? this._currentPropagation.needsHandlerGarbageCollect = true : this._garbageCollectRemovedHandlers()) : s$22.getLogger(this.declaredClass).error("There is no InputHandler group registered under the name `" + e2 + "`");
  }
  hasHandlers(e2) {
    return this._nameToGroup[e2] !== void 0;
  }
  updateDependencies() {
    if (this._currentPropagation)
      return void (this._updateDependenciesAfterPropagation = true);
    this._updateDependenciesAfterPropagation = false;
    const e2 = new Set(), t2 = new Set();
    this._handlersPriority = [];
    for (let r2 = this._handlers.length - 1; r2 >= 0; r2--) {
      const e3 = this._handlers[r2];
      e3.priorityIndex = r2, this._handlersPriority.push(e3);
    }
    this._handlersPriority = this._sortHandlersPriority(this._handlersPriority);
    for (let r2 = this._handlersPriority.length - 1; r2 >= 0; r2--) {
      const i2 = this._handlersPriority[r2];
      i2.priorityIndex = r2;
      let n2 = i2.handler.hasSideEffects;
      if (!n2) {
        for (const t3 of i2.handler.outgoingEventTypes)
          if (e2.has(t3)) {
            n2 = true;
            break;
          }
      }
      if (n2)
        for (const r3 of i2.handler.incomingEventMatches) {
          e2.add(r3.eventType);
          for (const e3 of r3.keyModifiers)
            a$B(e3) || t2.add(e3);
        }
      i2.active = n2;
    }
    this._sourceEvents = e2, this._keyModifiers = t2, this._pointerCaptures.size > 0 && this._sourceEvents.add("pointer-capture-lost"), this._keyModifiers.size > 0 && (this._sourceEvents.add("key-down"), this._sourceEvents.add("key-up")), this.eventSource && (this.eventSource.activeEvents = this._sourceEvents);
  }
  _setLatestPointer(e2, t2, r2) {
    this._latestPointerType = e2;
    const n2 = this._get("latestPointerLocation");
    if (t$1W(n2) || n2.x !== t2 || n2.y !== r2) {
      const e3 = this._propertiesPool.get("latestPointerLocation");
      e3.x = t2, e3.y = r2, this._set("latestPointerLocation", e3);
    }
  }
  _onEventReceived(e2, t2) {
    if (e2 === "pointer-capture-lost") {
      const e3 = t2;
      this._pointerCaptures.delete(e3.native.pointerId);
    }
    this._updateKeyModifiers(e2, t2);
    const r2 = this.test.timestamp != null ? this.test.timestamp : t2.native ? t2.native.timestamp : void 0, i2 = t2.native ? t2.native.cancelable : void 0;
    this._emitInputEventFromSource(e2, t2, r2, i2);
  }
  _updateKeyModifiers(e2, t2) {
    if (!t2)
      return;
    let r2 = false;
    const i2 = () => {
      if (!r2) {
        const e3 = new Set();
        this._activeKeyModifiers.forEach((t3) => {
          e3.add(t3);
        }), this._activeKeyModifiers = e3, r2 = true;
      }
    }, n2 = (e3, t3) => {
      t3 && !this._activeKeyModifiers.has(e3) ? (i2(), this._activeKeyModifiers.add(e3)) : !t3 && this._activeKeyModifiers.has(e3) && (i2(), this._activeKeyModifiers.delete(e3));
    };
    if (e2 === "key-down" || e2 === "key-up") {
      const r3 = t2.key;
      this._keyModifiers.has(r3) && n2(r3, e2 === "key-down");
    }
    const s2 = t2.native;
    n2("Alt", !(!s2 || !s2.altKey)), n2("Ctrl", !(!s2 || !s2.ctrlKey)), n2("Shift", !(!s2 || !s2.shiftKey)), n2("Meta", !(!s2 || !s2.metaKey)), n2("Primary", this._activeKeyModifiers.has(this.primaryKey));
  }
  _installRecognizers() {
    this._latestPointerHandler = new s$o((e2, t2, r2) => this._setLatestPointer(e2, t2, r2)), this._multiTouchHandler = new i$w(), this.installHandlers("input-manager-logic", [this._latestPointerHandler, this._multiTouchHandler], P$5.ALWAYS), this.recognizers.length > 0 && this.installHandlers("default", this.recognizers, P$5.INTERNAL);
  }
  _setPointerCapture(e2, t2, r2, i2) {
    const n2 = e2.name + "-" + t2.priorityIndex, s2 = this._pointerCaptures.get(r2.pointerId) || new Set();
    this._pointerCaptures.set(r2.pointerId, s2), i2 ? (s2.add(n2), s2.size === 1 && this.eventSource && this.eventSource.setPointerCapture(r2, true)) : s2.has(n2) && (s2.delete(n2), s2.size === 0 && (this._pointerCaptures.delete(r2.pointerId), this.eventSource && this.eventSource.setPointerCapture(r2, false)));
  }
  _garbageCollectRemovedHandlers() {
    this._handlers = this._handlers.filter((e2) => !e2.removed), this.updateDependencies();
  }
  _emitInputEventFromSource(e2, t2, r2, i2) {
    this._emitInputEvent(0, e2, t2, r2, i2);
  }
  _emitInputEvent(e2, t2, r2, i2, n2, s2) {
    const o2 = i2 !== void 0 ? i2 : this._currentPropagation ? this._currentPropagation.timestamp : performance.now(), a2 = n2 !== void 0 && n2, l2 = { event: new _$a(t2, r2, o2, s2 || this._activeKeyModifiers, a2), priorityIndex: e2 };
    this._currentPropagation ? this._currentPropagation.events.push(l2) : this._doNewPropagation(l2);
  }
  _doNewPropagation(e2) {
    this._currentPropagation = { events: new e$17(), currentHandler: null, needsHandlerGarbageCollect: false, timestamp: e2.event.timestamp }, this._currentPropagation.events.push(e2), this._continuePropagation();
  }
  _continuePropagation() {
    var _a2, _b2;
    const e2 = f$1F(this._currentPropagation);
    for (; e2.events.length > 0; ) {
      const { event: t2, priorityIndex: r2 } = e2.events.pop(), i2 = t2.data && t2.data.eventId;
      if (!(i2 != null && this._stoppedPropagationEventIds.has(i2)))
        for (e2.currentHandler = this._handlersPriority[r2]; e2.currentHandler; ) {
          if (e2.currentHandler.removed)
            e2.needsHandlerGarbageCollect = true;
          else {
            if (e2.currentHandler.active && !t2.shouldStopPropagation() && ((_b2 = (_a2 = e2.currentHandler).eventCallback) == null ? void 0 : _b2.call(_a2, t2)), t2.shouldStopPropagation()) {
              i2 != null && this._stoppedPropagationEventIds.add(i2);
              break;
            }
            if (t2.shouldPausePropagation(() => this._continuePropagation()))
              return void this._pausePropagation({ event: t2, priorityIndex: e2.currentHandler.priorityIndex + 1 });
          }
          e2.currentHandler = this._handlersPriority[e2.currentHandler.priorityIndex + 1];
        }
    }
    e2.needsHandlerGarbageCollect && this._garbageCollectRemovedHandlers(), this.hasPendingInputs || this._stoppedPropagationEventIds.clear(), this._currentPropagation = null, this._updateDependenciesAfterPropagation && this.updateDependencies();
  }
  _pausePropagation(e2) {
    const t2 = new e$17();
    t2.push(e2);
    const r2 = this._currentPropagation;
    if (r2) {
      for (; r2.events.length; )
        t2.push(r2.events.pop());
      r2.events = t2, r2.currentHandler = null;
    }
  }
  _compareHandlerPriority(e2, t2) {
    if (e2.handler.hasSideEffects !== t2.handler.hasSideEffects)
      return e2.handler.hasSideEffects ? 1 : -1;
    if (e2.groupPriority !== t2.groupPriority)
      return e2.groupPriority > t2.groupPriority ? -1 : 1;
    for (const r2 of e2.handler.incomingEventMatches)
      for (const e3 of t2.handler.incomingEventMatches) {
        if (r2.eventType !== e3.eventType)
          continue;
        const t3 = r2.keyModifiers.filter((t4) => e3.keyModifiers.includes(t4));
        if (t3.length === r2.keyModifiers.length !== (t3.length === e3.keyModifiers.length))
          return r2.keyModifiers.length > e3.keyModifiers.length ? -1 : 1;
      }
    return e2.priorityIndex > t2.priorityIndex ? -1 : 1;
  }
  _sortHandlersPriority(e2) {
    const t2 = [];
    for (const r2 of e2) {
      let e3 = 0;
      for (; e3 < t2.length && this._compareHandlerPriority(r2, t2[e3]) >= 0; )
        e3++;
      t2.splice(e3, 0, r2);
    }
    return t2;
  }
  get debug() {
    const e2 = (e3) => {
      const t2 = this._setPointerCapture;
      this._setPointerCapture = () => {
      }, e3(), this._setPointerCapture = t2;
    };
    return { injectEvent: (t2, r2) => {
      e2(() => {
        this._onEventReceived(t2, r2);
      });
    }, disablePointerCapture: e2 };
  }
};
e$1W([y$1o({ readOnly: true })], u$m.prototype, "hasPendingInputs", null), e$1W([y$1o({ constructOnly: true })], u$m.prototype, "eventSource", void 0), e$1W([y$1o({ constructOnly: true })], u$m.prototype, "recognizers", void 0), e$1W([y$1o()], u$m.prototype, "_latestPointerType", void 0), e$1W([y$1o()], u$m.prototype, "latestPointerType", null), e$1W([y$1o()], u$m.prototype, "multiTouchActive", null), e$1W([y$1o({ readOnly: true })], u$m.prototype, "latestPointerLocation", void 0), u$m = e$1W([n$2f("esri.views.input.InputManager")], u$m);
class _$a {
  constructor(e2, t2, r2, i2, n2) {
    this.type = e2, this.data = t2, this.timestamp = r2, this.modifiers = i2, this.cancelable = n2, this._propagationState = g$a.NONE, this._resumeCallback = null;
  }
  stopPropagation() {
    this._propagationState |= g$a.STOPPED;
  }
  shouldStopPropagation() {
    return (this._propagationState & g$a.STOPPED) != 0;
  }
  async(e2) {
    this._propagationState |= g$a.PAUSED;
    const t2 = (e3, t3) => {
      this._propagationState &= ~g$a.PAUSED;
      const r2 = this._resumeCallback;
      if (this._resumeCallback = null, r2 && r2(), t3)
        throw e3;
      return e3;
    };
    return (typeof e2 == "function" ? e2() : e2).then((e3) => t2(e3, false), (e3) => t2(e3, true));
  }
  shouldPausePropagation(e2) {
    return !!(this._propagationState & g$a.PAUSED) && (this._resumeCallback = e2, true);
  }
  preventDefault() {
    this.data.native.preventDefault();
  }
}
var g$a;
!function(e2) {
  e2[e2.NONE = 0] = "NONE", e2[e2.STOPPED = 1] = "STOPPED", e2[e2.PAUSED = 2] = "PAUSED";
}(g$a || (g$a = {}));
const P$5 = { ALWAYS: 1, DEFAULT: 0, TOOL: -1, WIDGET: -2, INTERNAL: -3 };
class v$8 {
}
function e$i(n2) {
  return n2 && typeof n2.highlight == "function";
}
const s$n = { iconZoom: "esri-icon-zoom-in-magnifying-glass", iconTrash: "esri-icon-trash", iconBrowseClusteredFeatures: "esri-icon-table" }, o$m = new a$27({ id: "zoom-to-feature", title: "{messages.zoom}", className: s$n.iconZoom }), t$m = new a$27({ id: "remove-selected-feature", title: "{messages.remove}", className: s$n.iconTrash }), r$n = new a$27({ id: "zoom-to-clustered-features", title: "{messages.zoom}", className: s$n.iconZoom }), i$v = new a$27({ id: "browse-clustered-features", title: "{messages.browseClusteredFeatures}", className: s$n.iconBrowseClusteredFeatures });
const s$m = "esri.widgets.Popup.PopupViewModel", c$s = s$22.getLogger(s$m), u$l = (t2) => {
  const { event: s2, view: c2 } = t2, { action: u2 } = s2, d2 = c2 && c2.popup;
  if (!u2)
    return Promise.reject(new s$1Z("trigger-action:missing-arguments", "Event has no action"));
  if (!d2)
    return Promise.reject(new s$1Z("trigger-action:missing-arguments", "view.popup is missing"));
  const { disabled: l2, id: g2 } = u2;
  if (!g2)
    return Promise.reject(new s$1Z("trigger-action:invalid-action", "action.id is missing"));
  if (l2)
    return Promise.reject(new s$1Z("trigger-action:invalid-action", "Action is disabled"));
  if (g2 === o$m.id)
    return w$5(d2.viewModel).catch(b$T);
  if (g2 === r$n.id)
    return p$u(d2.viewModel);
  if (g2 === i$v.id)
    return d2.featureMenuOpen = !d2.featureMenuOpen, d2.viewModel.browseClusterEnabled = !d2.viewModel.browseClusterEnabled, Promise.resolve();
  if (d2.viewModel.browseClusterEnabled = false, g2 === t$m.id) {
    d2.close();
    const { selectedFeature: t3 } = d2;
    if (!t3)
      return Promise.reject(new s$1Z(`trigger-action:${t$m.id}`, "selectedFeature is required", { selectedFeature: t3 }));
    const { sourceLayer: r2 } = t3;
    return r2 ? r2.remove(t3) : c2.graphics.remove(t3), Promise.resolve();
  }
  return Promise.resolve();
};
function d$e(e2) {
  const { selectedFeature: t2, location: r2, view: o2 } = e2;
  if (!o2)
    return null;
  if (o2.type === "3d")
    return t2 || r2;
  return e2.get("selectedFeature.geometry") || r2;
}
function l$r(e2) {
  var _a2, _b2;
  return (e2 == null ? void 0 : e2.isAggregate) && ((_b2 = (_a2 = e2 == null ? void 0 : e2.sourceLayer) == null ? void 0 : _a2.featureReduction) == null ? void 0 : _b2.type) === "cluster";
}
async function g$9(e2, t2) {
  if ((t2 == null ? void 0 : t2.type) !== "3d" || !e2 || e2.declaredClass !== "esri.Graphic")
    return true;
  const r2 = t2.getViewForGraphic(e2);
  if (r2 && "whenGraphicBounds" in r2) {
    let t3;
    try {
      t3 = await r2.whenGraphicBounds(e2, { useViewElevation: true });
    } catch (o2) {
    }
    return !t3 || !t3.boundingBox || t3.boundingBox[0] === t3.boundingBox[3] && t3.boundingBox[1] === t3.boundingBox[4] && t3.boundingBox[2] === t3.boundingBox[5];
  }
  return true;
}
async function w$5(t2) {
  const { location: r2, selectedFeature: i2, view: n2, zoomFactor: a2 } = t2, s2 = d$e(t2);
  if (!s2) {
    const t3 = new s$1Z("zoom-to:invalid-target-or-view", "Cannot zoom to location without a target and view.", { target: s2, view: n2 });
    throw c$s.error(t3), t3;
  }
  const u2 = n2.scale / a2, l2 = t2.get("selectedFeature.geometry") || r2, w2 = l2 && l2.type === "point" && await g$9(i2, n2);
  o$m.active = true, o$m.disabled = true;
  try {
    await t2.zoomTo({ target: { target: s2, scale: w2 ? u2 : void 0 } });
  } catch (p2) {
    const t3 = new s$1Z("zoom-to:invalid-graphic", "Could not zoom to the location of the graphic.", { graphic: i2 });
    c$s.error(t3);
  } finally {
    o$m.active = false, o$m.disabled = false, t2.zoomToLocation = null, w2 && (t2.location = l2);
  }
}
async function p$u(t2) {
  const { selectedFeature: r2, view: o2 } = t2;
  if ((o2 == null ? void 0 : o2.type) !== "2d") {
    const t3 = new s$1Z("zoomToCluster:invalid-view", "View must be 2d MapView.", { view: o2 });
    throw c$s.error(t3), t3;
  }
  if (!l$r(r2)) {
    const t3 = new s$1Z("zoomToCluster:invalid-selectedFeature", "Selected feature must represent an aggregate/cluster graphic.", { selectedFeature: r2 });
    throw c$s.error(t3), t3;
  }
  const n2 = r2.sourceLayer, a2 = await o2.whenLayerView(n2), s2 = a2.createQuery();
  s2.aggregateIds = [r2.getObjectId()], r$n.active = true, r$n.disabled = true;
  const { extent: u2 } = await a2.queryExtent(s2);
  await t2.zoomTo({ target: u2 }), r$n.active = false, r$n.disabled = false;
}
async function f$f(e2) {
  const { selectedFeature: t2, view: r2 } = e2, o2 = t2.sourceLayer, i2 = await r2.whenLayerView(o2), n2 = i2.createQuery();
  n2.aggregateIds = [t2.getObjectId()];
  const { extent: a2 } = await i2.queryExtent(n2);
  e2.selectedClusterBoundaryFeature.geometry = a2, r2.graphics.add(e2.selectedClusterBoundaryFeature);
}
async function m$h(e2) {
  const { selectedFeature: t2, view: r2 } = e2, o2 = t2.sourceLayer, i2 = await r2.whenLayerView(o2), a2 = i2.createQuery();
  a2.aggregateIds = [t2.getObjectId()], i$v.active = true, i$v.disabled = true;
  const { features: s2 } = await i2.queryFeatures(a2);
  i$v.active = false, i$v.disabled = false, r2.popup.open({ features: [t2].concat(s2), featureMenuOpen: true });
}
function v$7(e2) {
  const t2 = e2.features.filter((e3) => l$r(e3));
  t2.length && (e2.features = t2);
}
const e$h = (e2) => {
  let t2 = class extends e2 {
    constructor(...o2) {
      super(...o2), this.goToOverride = null, this.view = null;
    }
    callGoTo(o2) {
      const { view: r2 } = this;
      return this.goToOverride ? this.goToOverride(r2, o2) : r2.goTo(o2.target, o2.options);
    }
  };
  return e$1W([y$1o()], t2.prototype, "goToOverride", void 0), e$1W([y$1o()], t2.prototype, "view", void 0), t2 = e$1W([n$2f("esri.widgets.support.GoTo")], t2), t2;
};
const B$5 = j$F.ofType({ key: "type", defaultKeyValue: "button", base: c$2i, typeMap: { button: a$27, toggle: a$26 } }), G$2 = () => [o$m.clone()], R$2 = () => [r$n.clone(), i$v.clone()];
let z$5 = class extends e$h(h$g) {
  constructor(e2) {
    super(e2), this._handles = new t$1N(), this._pendingPromises = new Set(), this._fetchFeaturesController = null, this._selectedClusterFeature = null, this.featurePage = null, this.actions = new B$5(), this.activeFeature = null, this.defaultPopupTemplateEnabled = false, this.autoCloseEnabled = false, this.autoOpenEnabled = true, this.browseClusterEnabled = false, this.content = null, this.featuresPerPage = 20, this.featureViewModelAbilities = null, this.featureViewModels = [], this.highlightEnabled = true, this.includeDefaultActions = true, this.selectedClusterBoundaryFeature = new g$J({ symbol: new S$t({ outline: { width: 1.5, color: "cyan" }, style: "none" }) }), this.title = null, this.updateLocationEnabled = false, this.view = null, this.visible = false, this.zoomFactor = 4, this.zoomToLocation = null;
  }
  get isLoadingFeature() {
    return this.featureViewModels.some((e2) => e2.waitingForContent);
  }
  initialize() {
    this._handles.add([l$1f(() => [this.autoOpenEnabled, this.view], () => this._autoOpenEnabledChange()), this.on("view-change", () => this._autoClose()), l$1f(() => [this.highlightEnabled, this.selectedFeature, this.visible, this.view], () => this._highlightSelectedFeature()), l$1f(() => [this.highlightEnabled, this.activeFeature, this.visible, this.view], () => this._highlightActiveFeature()), l$1f(() => {
      var _a2, _b2;
      return (_b2 = (_a2 = this.view) == null ? void 0 : _a2.animation) == null ? void 0 : _b2.state;
    }, (e2) => this._animationStateChange(e2)), l$1f(() => this.location, (e2) => this._locationChange(e2)), l$1f(() => this.selectedFeature, (e2) => this._selectedFeatureChange(e2)), l$1f(() => [this.selectedFeatureIndex, this.featureCount, this.featuresPerPage], () => this._selectedFeatureIndexChange()), l$1f(() => [this.featurePage, this.selectedFeatureIndex, this.featureCount, this.featuresPerPage, this.featureViewModels], () => this._setGraphicOnFeatureViewModels()), l$1f(() => this.featureViewModels, () => this._featureViewModelsChange()), this.on("trigger-action", (e2) => u$l({ event: e2, view: this.view })), f$10(() => !this.waitingForResult, () => this._waitingForResultChange(), U$i), l$1f(() => {
      var _a2, _b2;
      return [this.features, (_a2 = this.view) == null ? void 0 : _a2.map, (_b2 = this.view) == null ? void 0 : _b2.spatialReference];
    }, () => this._updateFeatureVMs()), l$1f(() => {
      var _a2;
      return (_a2 = this.view) == null ? void 0 : _a2.scale;
    }, () => this._viewScaleChange()), f$10(() => !this.visible, () => this.browseClusterEnabled = false), l$1f(() => this.browseClusterEnabled, (e2) => e2 ? this.enableClusterBrowsing() : this.disableClusterBrowsing())]);
  }
  destroy() {
    this._cancelFetchingFeatures(), this._handles.destroy(), this._handles = null, this._pendingPromises.clear(), this.browseClusterEnabled = false, this.view = null;
  }
  get active() {
    return !(!this.visible || this.waitingForResult);
  }
  get allActions() {
    const e2 = this._get("allActions") || new B$5();
    e2.removeAll();
    const { actions: t2, defaultActions: i2, defaultPopupTemplateEnabled: s2, includeDefaultActions: r2, selectedFeature: o2 } = this, n2 = r2 ? i2.concat(t2) : t2, a2 = o2 && (typeof o2.getEffectivePopupTemplate == "function" && o2.getEffectivePopupTemplate(s2) || o2.popupTemplate), l2 = a2 && a2.actions, h2 = a2 && a2.overwriteActions ? l2 : l2 ? l2.concat(n2) : n2;
    return h2 && h2.filter(Boolean).forEach((t3) => e2.add(t3)), e2;
  }
  get defaultActions() {
    const e2 = this._get("defaultActions") || new B$5();
    return e2.removeAll(), e2.addMany(l$r(this.selectedFeature) ? R$2() : G$2()), e2;
  }
  get featureCount() {
    return this.features.length;
  }
  get features() {
    return this._get("features") || [];
  }
  set features(e2) {
    const t2 = e2 || [];
    this._set("features", t2);
    const { pendingPromisesCount: i2, promiseCount: s2, selectedFeatureIndex: r2 } = this, o2 = s2 && t2.length;
    o2 && i2 && r2 === -1 ? this.selectedFeatureIndex = 0 : o2 && r2 !== -1 || (this.selectedFeatureIndex = t2.length ? 0 : -1);
  }
  get location() {
    return this._get("location") || null;
  }
  set location(e2) {
    const t2 = this.get("view.spatialReference.isWebMercator");
    e2 && e2.get("spatialReference.isWGS84") && t2 && (e2 = R$m(e2)), this._set("location", e2);
  }
  get pendingPromisesCount() {
    return this._pendingPromises.size;
  }
  get waitingForResult() {
    return !(!(!!this._fetchFeaturesController || this.pendingPromisesCount > 0) || this.featureCount !== 0);
  }
  get promiseCount() {
    return this.promises.length;
  }
  get promises() {
    return this._get("promises") || [];
  }
  set promises(e2) {
    if (this._pendingPromises.clear(), this.features = [], !Array.isArray(e2) || !e2.length)
      return this._set("promises", []), void this.notifyChange("pendingPromisesCount");
    this._set("promises", e2), (e2 = e2.slice(0)).forEach((e3) => {
      this._pendingPromises.add(e3);
      const t2 = (t3) => {
        this._pendingPromises.has(e3) && this._updateFeatures(t3), this._updatePendingPromises(e3);
      }, i2 = () => this._updatePendingPromises(e3);
      e3.then(t2, i2);
    }), this.notifyChange("pendingPromisesCount");
  }
  get selectedFeature() {
    const { features: e2, selectedFeatureIndex: t2 } = this;
    if (t2 === -1)
      return null;
    return e2[t2] || null;
  }
  get selectedFeatureIndex() {
    const e2 = this._get("selectedFeatureIndex");
    return typeof e2 == "number" ? e2 : -1;
  }
  set selectedFeatureIndex(e2) {
    const { featureCount: t2 } = this;
    e2 = isNaN(e2) || e2 < -1 || !t2 ? -1 : (e2 + t2) % t2, this.activeFeature = null, this._set("selectedFeatureIndex", e2);
  }
  get selectedFeatureViewModel() {
    return this.featureViewModels[this.selectedFeatureIndex] || null;
  }
  get state() {
    return this.get("view.ready") ? "ready" : "disabled";
  }
  centerAtLocation() {
    const { view: e2 } = this, t2 = d$e(this);
    return t2 ? this.callGoTo({ target: { target: t2, scale: e2.scale } }) : Promise.reject(new s$1Z("center-at-location:invalid-target-or-view", "Cannot center at a location without a target and view.", { target: t2, view: e2 }));
  }
  zoomTo(e2) {
    return this.callGoTo(e2);
  }
  clear() {
    this.set({ promises: [], features: [], content: null, title: null, location: null, activeFeature: null });
  }
  fetchFeatures(e2, t2) {
    const { view: i2 } = this;
    if (!i2 || !e2)
      throw new s$1Z("fetch-features:invalid-screenpoint-or-view", "Cannot fetch features without a screenPoint and view.", { screenPoint: e2, view: i2 });
    return i2.fetchPopupFeatures(e2, { event: t2 && t2.event, defaultPopupTemplateEnabled: this.defaultPopupTemplateEnabled, signal: t2 && t2.signal });
  }
  open(e2) {
    const t2 = __spreadProps(__spreadValues({ updateLocationEnabled: false, promises: [], fetchFeatures: false }, e2), { visible: true }), { fetchFeatures: i2 } = t2;
    delete t2.fetchFeatures, i2 && this._setFetchFeaturesPromises(t2.location);
    const s2 = ["actionsMenuOpen", "collapsed", "featureMenuOpen"];
    for (const r2 of s2)
      delete t2[r2];
    this.set(t2);
  }
  triggerAction(e2) {
    const t2 = this.allActions.getItemAt(e2);
    t2 && !t2.disabled && this.emit("trigger-action", { action: t2 });
  }
  next() {
    return this.selectedFeatureIndex = this.selectedFeatureIndex + 1, this;
  }
  previous() {
    return this.selectedFeatureIndex = this.selectedFeatureIndex - 1, this;
  }
  disableClusterBrowsing() {
    v$7(this), this._clearBrowsedClusterGraphics();
  }
  async enableClusterBrowsing() {
    const { view: e2, selectedFeature: t2 } = this;
    (e2 == null ? void 0 : e2.type) === "2d" ? l$r(t2) ? (await f$f(this), await m$h(this)) : s$22.getLogger(this.declaredClass).warn("enableClusterBrowsing:invalid-selectedFeature: Selected feature must represent an aggregate/cluster graphic.", t2) : s$22.getLogger(this.declaredClass).warn("enableClusterBrowsing:invalid-view: View must be 2d MapView.", t2);
  }
  _animationStateChange(e2) {
    this.zoomToLocation || (o$m.disabled = e2 === "waiting-for-target");
  }
  _clearBrowsedClusterGraphics() {
    var _a2;
    const e2 = (_a2 = this.view) == null ? void 0 : _a2.graphics;
    e2 && (e2.remove(this.selectedClusterBoundaryFeature), e2.remove(this._selectedClusterFeature)), this._selectedClusterFeature = null, this.selectedClusterBoundaryFeature.geometry = null;
  }
  _viewScaleChange() {
    if (l$r(this.selectedFeature))
      return this.browseClusterEnabled = false, this.visible = false, void this.clear();
    this.browseClusterEnabled && (this.features = [this.selectedFeature]);
  }
  _locationChange(e2) {
    const { selectedFeature: t2, updateLocationEnabled: i2 } = this;
    i2 && e2 && (!t2 || t2.geometry) && this.centerAtLocation();
  }
  _selectedFeatureIndexChange() {
    this.featurePage = this.featureCount > 1 ? Math.floor(this.selectedFeatureIndex / this.featuresPerPage) + 1 : null;
  }
  _featureViewModelsChange() {
    this.featurePage = this.featureCount > 1 ? 1 : null;
  }
  _setGraphicOnFeatureViewModels() {
    const { features: e2, featureCount: t2, featurePage: i2, featuresPerPage: s2, featureViewModels: r2 } = this;
    if (i2 === null)
      return;
    const o2 = ((i2 - 1) * s2 + t2) % t2, n2 = o2 + s2;
    r2.slice(o2, n2).forEach((t3, i3) => {
      t3 && !t3.graphic && (t3.graphic = e2[o2 + i3]);
    });
  }
  async _selectedFeatureChange(e2) {
    if (!e2)
      return;
    const { location: t2, updateLocationEnabled: i2, view: s2 } = this;
    if (this.browseClusterEnabled) {
      if (this._selectedClusterFeature && (s2.graphics.remove(this._selectedClusterFeature), this._selectedClusterFeature = null), l$r(e2))
        return;
      return e2.symbol = await x$5(e2), this._selectedClusterFeature = e2, void s2.graphics.add(this._selectedClusterFeature);
    }
    !i2 && t2 || !e2.geometry ? i2 && !e2.geometry && this.centerAtLocation().then(() => {
      this.location = s2.center.clone();
    }) : this.location = e$1U(this._getPointFromGeometry(e2.geometry));
  }
  _waitingForResultChange() {
    !this.featureCount && this.promises && (this.visible = false);
  }
  _setFetchFeaturesPromises(e2) {
    return this._fetchFeaturesWithController(this._getScreenPoint(e2 || this.location)).then((e3) => {
      const { clientOnlyGraphics: t2, promisesPerLayerView: i2 } = e3, s2 = Promise.resolve(t2), r2 = i2.map((e4) => e4.promise);
      this.promises = [s2, ...r2];
    });
  }
  _destroyFeatureVMs() {
    this.featureViewModels.forEach((e2) => e2 && !e2.destroyed && e2.destroy()), this._set("featureViewModels", []);
  }
  _updateFeatureVMs() {
    const { selectedFeature: e2, features: t2, featureViewModels: i2 } = this;
    if (l$r(e2) || (this.browseClusterEnabled = false), this._destroyFeatureVMs(), !t2 || !t2.length)
      return;
    const s2 = i2.slice(0), r2 = [];
    t2.forEach((t3, i3) => {
      var _a2, _b2;
      if (!t3)
        return;
      let o2 = null;
      if (s2.some((e3, i4) => (e3 && e3.graphic === t3 && (o2 = e3, s2.splice(i4, 1)), !!o2)), o2)
        r2[i3] = o2;
      else {
        const s3 = new W$3({ abilities: this.featureViewModelAbilities, defaultPopupTemplateEnabled: this.defaultPopupTemplateEnabled, spatialReference: (_a2 = this.view) == null ? void 0 : _a2.spatialReference, graphic: t3 === e2 ? t3 : null, map: (_b2 = this.view) == null ? void 0 : _b2.map, view: this.view });
        r2[i3] = s3;
      }
    }), s2.forEach((e3) => e3 && !e3.destroyed && e3.destroy()), this._set("featureViewModels", r2);
  }
  _getScreenPoint(e2) {
    const { view: t2 } = this;
    return t2 && e2 && typeof t2.toScreen == "function" ? t2.toScreen(e2) : null;
  }
  _autoOpenEnabledChange() {
    const e2 = "auto-fetch-features", { _handles: t2, autoOpenEnabled: i2 } = this;
    if (t2.remove(e2), i2 && this.view) {
      const i3 = this.view.on("click", (e3) => {
        e3.pointerType === "mouse" && e3.button !== 0 || this._fetchFeaturesAndOpen(e3);
      }, P$5.WIDGET);
      t2.add(i3, e2);
    }
  }
  _cancelFetchingFeatures() {
    const e2 = this._fetchFeaturesController;
    e2 && e2.abort(), this._fetchFeaturesController = null, this.notifyChange("waitingForResult");
  }
  _fetchFeaturesWithController(e2, t2) {
    this._cancelFetchingFeatures();
    const i2 = new AbortController(), { signal: s2 } = i2;
    this._fetchFeaturesController = i2, this.notifyChange("waitingForResult");
    const r2 = this.fetchFeatures(e2, { signal: s2, event: t2 });
    return r2.catch(() => {
    }).then(() => {
      this._fetchFeaturesController = null, this.notifyChange("waitingForResult");
    }), r2;
  }
  _fetchFeaturesAndOpen(e2) {
    const { screenPoint: t2, mapPoint: i2 } = e2, { view: s2 } = this;
    this._fetchFeaturesWithController(t2, e2).then((e3) => {
      const { clientOnlyGraphics: t3, promisesPerLayerView: r2, location: o2 } = e3, n2 = [Promise.resolve(t3), ...r2.map((e4) => e4.promise)];
      return s2.popup.open({ location: o2 || i2, promises: n2 }), e3;
    });
  }
  _updatePendingPromises(e2) {
    e2 && this._pendingPromises.has(e2) && (this._pendingPromises.delete(e2), this.notifyChange("pendingPromisesCount"));
  }
  _autoClose() {
    this.autoCloseEnabled && (this.visible = false);
  }
  _getPointFromGeometry(e2) {
    var _a2;
    return t$1W(e2) ? null : e2.type === "point" ? e2 : e2.type === "extent" ? e2.center : e2.type === "polygon" ? e2.centroid : e2.type === "multipoint" || e2.type === "polyline" ? (_a2 = e2.extent) == null ? void 0 : _a2.center : null;
  }
  async _getLayerView(e2, t2) {
    return await e2.when(), e2.whenLayerView(t2);
  }
  _getHighlightLayer(e2) {
    const { layer: t2, sourceLayer: i2 } = e2;
    return i2 && "layer" in i2 && i2.layer ? i2.layer : (i2 == null ? void 0 : i2.type) === "map-notes" || (i2 == null ? void 0 : i2.type) === "subtype-group" ? i2 : t2;
  }
  _getHighlightTarget(e2, t2) {
    const i2 = t2.type === "imagery" ? void 0 : "objectIdField" in t2 ? t2.objectIdField || o$r : null, s2 = e2.attributes;
    return s2 && i2 && s2[i2] || e2;
  }
  async _highlightActiveFeature() {
    const e2 = "highlight-active-feature";
    this._handles.remove(e2);
    const { highlightEnabled: t2, view: i2, activeFeature: s2, visible: r2 } = this;
    if (!(s2 && i2 && t2 && r2))
      return;
    const o2 = this._getHighlightLayer(s2);
    if (!(o2 && o2 instanceof b$h))
      return;
    const n2 = this._getLayerView(i2, o2);
    this._highlightActiveFeaturePromise = n2;
    const a2 = await n2;
    if (!(a2 && e$i(a2) && this._highlightActiveFeaturePromise === n2 && this.activeFeature && this.highlightEnabled))
      return;
    const l2 = a2.highlight(this._getHighlightTarget(s2, o2));
    this._handles.add(l2, e2);
  }
  async _highlightSelectedFeature() {
    const e2 = "highlight-selected-feature";
    this._handles.remove(e2);
    const { selectedFeature: t2, highlightEnabled: i2, view: s2, visible: r2 } = this;
    if (!(t2 && s2 && i2 && r2))
      return;
    const o2 = this._getHighlightLayer(t2);
    if (!(o2 && o2 instanceof b$h))
      return;
    const n2 = this._getLayerView(s2, o2);
    this._highlightSelectedFeaturePromise = n2;
    const a2 = await n2;
    if (!(a2 && e$i(a2) && this._highlightSelectedFeaturePromise === n2 && this.selectedFeature && this.highlightEnabled && this.visible))
      return;
    const l2 = a2.highlight(this._getHighlightTarget(t2, o2));
    this._handles.add(l2, e2);
  }
  _updateFeatures(e2) {
    const { features: t2 } = this;
    if (!e2 || !e2.length)
      return;
    if (!t2.length)
      return void (this.features = e2);
    const i2 = e2.filter((e3) => !t2.includes(e3));
    this.features = t2.concat(i2);
  }
};
e$1W([y$1o()], z$5.prototype, "featurePage", void 0), e$1W([y$1o()], z$5.prototype, "isLoadingFeature", null), e$1W([y$1o({ type: B$5 })], z$5.prototype, "actions", void 0), e$1W([y$1o({ readOnly: true })], z$5.prototype, "active", null), e$1W([y$1o()], z$5.prototype, "activeFeature", void 0), e$1W([y$1o({ readOnly: true })], z$5.prototype, "allActions", null), e$1W([y$1o({ type: Boolean })], z$5.prototype, "defaultPopupTemplateEnabled", void 0), e$1W([y$1o()], z$5.prototype, "autoCloseEnabled", void 0), e$1W([y$1o()], z$5.prototype, "autoOpenEnabled", void 0), e$1W([y$1o()], z$5.prototype, "browseClusterEnabled", void 0), e$1W([y$1o()], z$5.prototype, "content", void 0), e$1W([y$1o({ type: B$5, readOnly: true })], z$5.prototype, "defaultActions", null), e$1W([y$1o({ readOnly: true })], z$5.prototype, "featureCount", null), e$1W([y$1o()], z$5.prototype, "features", null), e$1W([y$1o()], z$5.prototype, "featuresPerPage", void 0), e$1W([y$1o()], z$5.prototype, "featureViewModelAbilities", void 0), e$1W([y$1o({ readOnly: true })], z$5.prototype, "featureViewModels", void 0), e$1W([y$1o()], z$5.prototype, "highlightEnabled", void 0), e$1W([y$1o()], z$5.prototype, "includeDefaultActions", void 0), e$1W([y$1o({ type: w$K })], z$5.prototype, "location", null), e$1W([y$1o({ readOnly: true })], z$5.prototype, "pendingPromisesCount", null), e$1W([y$1o({ readOnly: true })], z$5.prototype, "selectedClusterBoundaryFeature", void 0), e$1W([y$1o({ readOnly: true })], z$5.prototype, "waitingForResult", null), e$1W([y$1o({ readOnly: true })], z$5.prototype, "promiseCount", null), e$1W([y$1o()], z$5.prototype, "promises", null), e$1W([y$1o({ value: null, readOnly: true })], z$5.prototype, "selectedFeature", null), e$1W([y$1o({ value: -1 })], z$5.prototype, "selectedFeatureIndex", null), e$1W([y$1o({ readOnly: true })], z$5.prototype, "selectedFeatureViewModel", null), e$1W([y$1o({ readOnly: true })], z$5.prototype, "state", null), e$1W([y$1o()], z$5.prototype, "title", void 0), e$1W([y$1o()], z$5.prototype, "updateLocationEnabled", void 0), e$1W([y$1o()], z$5.prototype, "view", void 0), e$1W([y$1o()], z$5.prototype, "visible", void 0), e$1W([y$1o()], z$5.prototype, "zoomFactor", void 0), e$1W([y$1o()], z$5.prototype, "zoomToLocation", void 0), e$1W([y$1o()], z$5.prototype, "centerAtLocation", null), z$5 = e$1W([n$2f("esri.widgets.Popup.PopupViewModel")], z$5);
const H$2 = z$5;
const E$4 = "selected-index", N$1 = 0, D$3 = "popup-spinner", B$4 = { calciteThemeLight: "calcite-theme-light", calciteThemeDark: "calcite-theme-dark", iconLeftTriangleArrow: "esri-icon-left-triangle-arrow", iconRightTriangleArrow: "esri-icon-right-triangle-arrow", iconDockToTop: "esri-icon-maximize", iconDockToBottom: "esri-icon-dock-bottom", iconDockToLeft: "esri-icon-dock-left", iconDockToRight: "esri-icon-dock-right", iconClose: "esri-icon-close", iconUndock: "esri-icon-minimize", iconCheckMark: "esri-icon-check-mark", iconLoading: "esri-icon-loading-indicator", iconDefaultAction: "esri-icon-default-action", iconActionsMenu: "esri-icon-handle-horizontal", rotating: "esri-rotating", base: "esri-popup", widget: "esri-widget", main: "esri-popup__main-container", loadingContainer: "esri-popup__loading-container", isCollapsible: "esri-popup--is-collapsible", isCollapsed: "esri-popup--is-collapsed", shadow: "esri-popup--shadow", isDocked: "esri-popup--is-docked", isDockedTopLeft: "esri-popup--is-docked-top-left", isDockedTopCenter: "esri-popup--is-docked-top-center", isDockedTopRight: "esri-popup--is-docked-top-right", isDockedBottomLeft: "esri-popup--is-docked-bottom-left", isDockedBottomCenter: "esri-popup--is-docked-bottom-center", isDockedBottomRight: "esri-popup--is-docked-bottom-right", alignTopCenter: "esri-popup--aligned-top-center", alignBottomCenter: "esri-popup--aligned-bottom-center", alignTopLeft: "esri-popup--aligned-top-left", alignBottomLeft: "esri-popup--aligned-bottom-left", alignTopRight: "esri-popup--aligned-top-right", alignBottomRight: "esri-popup--aligned-bottom-right", isFeatureMenuOpen: "esri-popup--feature-menu-open", isActionsMenuOpen: "esri-popup--actions-menu-open", hasFeatureUpdated: "esri-popup--feature-updated", header: "esri-popup__header", headerButtons: "esri-popup__header-buttons", headerContainer: "esri-popup__header-container", headerContainerButton: "esri-popup__header-container--button", headerTitle: "esri-popup__header-title", content: "esri-popup__content", contentHasFlows: "esri-content--has-flows", contentFlowItem: "esri-content__flow-item", footer: "esri-popup__footer", footerHasPagination: "esri-popup__footer--has-pagination", footerHasActions: "esri-popup__footer--has-actions", footerHasActionsMenu: "esri-popup__footer--has-actions-menu", button: "esri-popup__button", buttonDisabled: "esri-popup__button--disabled", buttonDock: "esri-popup__button--dock", icon: "esri-popup__icon", iconDock: "esri-popup__icon--dock-icon", inlineActionsContainer: "esri-popup__inline-actions-container", actionsMenuButton: "esri-popup__actions-menu-button", actions: "esri-popup__actions", action: "esri-popup__action", actionImage: "esri-popup__action-image", actionText: "esri-popup__action-text", actionToggle: "esri-popup__action-toggle", actionToggleOn: "esri-popup__action-toggle--on", actionExit: "esri-popup__action--exit", pointer: "esri-popup__pointer", pointerDirection: "esri-popup__pointer-direction", navigation: "esri-popup__navigation", paginationPrevious: "esri-popup__pagination-previous", paginationNext: "esri-popup__pagination-next", paginationPreviousIconLTR: "esri-popup__pagination-previous-icon", paginationPreviousIconRTL: "esri-popup__pagination-previous-icon--rtl", paginationNextIconLTR: "esri-popup__pagination-next-icon", paginationNextIconRTL: "esri-popup__pagination-next-icon--rtl", featureMenu: "esri-popup__feature-menu", featureMenuList: "esri-popup__feature-menu-list", featureMenuItem: "esri-popup__feature-menu-item", featureMenuViewport: "esri-popup__feature-menu-viewport", featureMenuHeader: "esri-popup__feature-menu-header", featureMenuNote: "esri-popup__feature-menu-note", featureMenuSelected: "esri-popup__feature-menu-item--selected", featureMenuButton: "esri-popup__feature-menu-button", featureMenuTitle: "esri-popup__feature-menu-title", featureMenuObserver: "esri-popup__feature-menu-observer", featureMenuLoader: "esri-popup__feature-menu-loader", collapseButton: "esri-popup__collapse-button", collapseIcon: "esri-popup__collapse-icon" }, P$4 = { buttonEnabled: true, position: "auto", breakpoint: { width: 544 } }, L$6 = "esri-popup";
function R$1(e2, t2) {
  return t2 === void 0 ? `${L$6}__${e2}` : `${L$6}__${e2}-${t2}`;
}
const S$5 = { closeButton: true, featureNavigation: true };
let V$1 = class extends i$z(M$d) {
  constructor(e2, i2) {
    super(e2, i2), this._blurClose = false, this._blurContainer = false, this._containerNode = null, this._mainContainerNode = null, this._featureMenuNode = null, this._actionsMenuNode = null, this._focusClose = false, this._focusContainer = false, this._focusDockButton = false, this._focusFeatureMenuButton = false, this._focusActionsMenuButton = false, this._focusFirstFeature = false, this._focusFirstAction = false, this._handles = new t$1N(), this._pointerOffsetInPx = 16, this._spinner = null, this._feature = null, this._featureMenuIntersectionObserverCallback = ([e3]) => {
      (e3 == null ? void 0 : e3.isIntersecting) && this.viewModel.featurePage++;
    }, this._featureMenuIntersectionObserver = new IntersectionObserver(this._featureMenuIntersectionObserverCallback, { root: window.document }), this._displaySpinnerThrottled = e$11(() => this._displaySpinner(), N$1), this._exitRelatedRecordsActions = new WeakMap(), this._flowItems = new j$F(), this.alignment = "auto", this.collapsed = false, this.collapseEnabled = true, this.dockEnabled = false, this.featureMenuOpen = false, this.headingLevel = 2, this.maxInlineActions = 3, this.messages = null, this.messagesCommon = null, this.spinnerEnabled = true, this.viewModel = new H$2(), this.visibleElements = __spreadValues({}, S$5), this._addSelectedFeatureIndexHandle(), this.addHandles([l$1f(() => {
      var _a2;
      return (_a2 = this.viewModel) == null ? void 0 : _a2.screenLocation;
    }, () => this._positionContainer()), l$1f(() => {
      var _a2;
      return [(_a2 = this.viewModel) == null ? void 0 : _a2.active, this.dockEnabled];
    }, () => this._toggleScreenLocationEnabled()), l$1f(() => {
      var _a2;
      return (_a2 = this.viewModel) == null ? void 0 : _a2.screenLocation;
    }, (e3, t2) => {
      !!e3 != !!t2 && this.reposition();
    }), l$1f(() => {
      var _a2, _b2, _c2, _d2, _e3, _f2;
      return [(_b2 = (_a2 = this.viewModel) == null ? void 0 : _a2.view) == null ? void 0 : _b2.padding, (_d2 = (_c2 = this.viewModel) == null ? void 0 : _c2.view) == null ? void 0 : _d2.size, (_e3 = this.viewModel) == null ? void 0 : _e3.active, (_f2 = this.viewModel) == null ? void 0 : _f2.location, this.alignment];
    }, () => this.reposition()), l$1f(() => this.spinnerEnabled, (e3) => this._spinnerEnabledChange(e3)), l$1f(() => {
      var _a2, _b2;
      return (_b2 = (_a2 = this.viewModel) == null ? void 0 : _a2.view) == null ? void 0 : _b2.size;
    }, (e3, t2) => this._updateDockEnabledForViewSize(e3, t2)), l$1f(() => {
      var _a2;
      return (_a2 = this.viewModel) == null ? void 0 : _a2.view;
    }, (e3, t2) => this._viewChange(e3, t2)), l$1f(() => {
      var _a2, _b2;
      return (_b2 = (_a2 = this.viewModel) == null ? void 0 : _a2.view) == null ? void 0 : _b2.ready;
    }, (e3, t2) => this._viewReadyChange(e3, t2)), l$1f(() => {
      var _a2, _b2;
      return [(_a2 = this.viewModel) == null ? void 0 : _a2.waitingForResult, (_b2 = this.viewModel) == null ? void 0 : _b2.location];
    }, () => {
      this._hideSpinner(), this._displaySpinnerThrottled();
    }), l$1f(() => this.selectedFeatureWidget, () => this._destroyFlowItemWidgets()), l$1f(() => {
      var _a2, _b2, _c2, _d2;
      return [(_b2 = (_a2 = this.selectedFeatureWidget) == null ? void 0 : _a2.viewModel) == null ? void 0 : _b2.title, (_d2 = (_c2 = this.selectedFeatureWidget) == null ? void 0 : _c2.viewModel) == null ? void 0 : _d2.state];
    }, () => this._setTitleFromFeatureWidget()), l$1f(() => {
      var _a2, _b2, _c2, _d2;
      return [(_b2 = (_a2 = this.selectedFeatureWidget) == null ? void 0 : _a2.viewModel) == null ? void 0 : _b2.content, (_d2 = (_c2 = this.selectedFeatureWidget) == null ? void 0 : _c2.viewModel) == null ? void 0 : _d2.state];
    }, () => this._setContentFromFeatureWidget()), f$10(() => !this.collapsed, () => {
      var _a2, _b2;
      ((_b2 = (_a2 = this.viewModel) == null ? void 0 : _a2.view) == null ? void 0 : _b2.widthBreakpoint) === "xsmall" && this.viewModel.active && this.collapseEnabled && this.viewModel.centerAtLocation();
    }), a$1I(() => {
      var _a2;
      return (_a2 = this.viewModel) == null ? void 0 : _a2.allActions;
    }, "change", () => this._watchActions()), l$1f(() => {
      var _a2;
      return (_a2 = this.viewModel) == null ? void 0 : _a2.allActions;
    }, () => this._watchActions(), h$S), l$1f(() => {
      var _a2;
      return (_a2 = this.viewModel) == null ? void 0 : _a2.featureViewModels;
    }, () => this._featureMenuViewportScrollTop()), a$1I(() => this._flowItems, "change", () => {
      this.notifyChange("_activeFlowItemWidget"), this.scheduleRender();
    }), l$1f(() => {
      var _a2, _b2, _c2, _d2;
      return [(_b2 = (_a2 = this._activeFlowItemWidget) == null ? void 0 : _a2.viewModel) == null ? void 0 : _b2.state, (_d2 = (_c2 = this._activeFlowItemWidget) == null ? void 0 : _c2.viewModel) == null ? void 0 : _d2.title];
    }, () => this.scheduleRender())]);
  }
  loadDependencies() {
    return Promise.all([import("./calcite-flow.js"), import("./calcite-flow-item.js"), import("./calcite-action.js"), import("./calcite-tooltip.js"), import("./calcite-icon.js")]);
  }
  destroy() {
    var _a2, _b2;
    this._destroyFlowItemWidgets(), this._destroySelectedFeatureWidget(), this._destroySpinner(), (_a2 = this._handles) == null ? void 0 : _a2.destroy(), this._unobserveFeatureMenuObserver(), (_b2 = this._featureMenuIntersectionObserver) == null ? void 0 : _b2.disconnect(), this._handles = null;
  }
  get actionsMenuId() {
    return `${this.id}-actions-menu`;
  }
  get actionsMenuButtonId() {
    return `${this.id}-actions-menu-button`;
  }
  get featureMenuId() {
    return `${this.id}-feature-menu`;
  }
  get titleId() {
    return `${this.id}-popup-title`;
  }
  get contentId() {
    return `${this.id}-popup-content`;
  }
  get hasContent() {
    const { selectedFeatureWidget: e2, viewModel: t2 } = this;
    if (!e2)
      return !!(t2 == null ? void 0 : t2.content);
    const i2 = e2.viewModel;
    if ((i2 == null ? void 0 : i2.waitingForContent) || (i2 == null ? void 0 : i2.state) === "error")
      return true;
    const o2 = i2 == null ? void 0 : i2.content;
    return Array.isArray(o2) ? !!o2.length : !!o2;
  }
  get featureNavigationVisible() {
    return this.viewModel.active && this.viewModel.featureCount > 1 && this.visibleElements.featureNavigation;
  }
  get collapsible() {
    return !!(this.collapseEnabled && this.viewModel.title && this.hasContent);
  }
  get featureMenuVisible() {
    return this.featureNavigationVisible && this.featureMenuOpen;
  }
  get contentCollapsed() {
    return this.collapsible && !this.featureMenuVisible && this.collapsed;
  }
  get dividedActions() {
    return this._divideActions();
  }
  get _activeFlowItemWidget() {
    const { _flowItems: e2 } = this;
    return e2.getItemAt(e2.length - 1) || null;
  }
  get actions() {
    return this.viewModel.actions;
  }
  set actions(e2) {
    this.viewModel.actions = e2;
  }
  set actionsMenuOpen(e2) {
    this._set("actionsMenuOpen", !!e2);
  }
  get actionsMenuOpen() {
    return !!this.viewModel.active && this._get("actionsMenuOpen");
  }
  get autoCloseEnabled() {
    return this.viewModel.autoCloseEnabled;
  }
  set autoCloseEnabled(e2) {
    this.viewModel.autoCloseEnabled = e2;
  }
  get autoOpenEnabled() {
    return this.viewModel.autoOpenEnabled;
  }
  set autoOpenEnabled(e2) {
    this.viewModel.autoOpenEnabled = e2;
  }
  get defaultPopupTemplateEnabled() {
    return this.viewModel.defaultPopupTemplateEnabled;
  }
  set defaultPopupTemplateEnabled(e2) {
    this.viewModel.defaultPopupTemplateEnabled = e2;
  }
  get content() {
    return this.viewModel.content;
  }
  set content(e2) {
    this.viewModel.content = e2;
  }
  get currentAlignment() {
    return this._getCurrentAlignment();
  }
  get currentDockPosition() {
    return this._getCurrentDockPosition();
  }
  get dockOptions() {
    return this._get("dockOptions") || P$4;
  }
  set dockOptions(e2) {
    const t2 = __spreadValues({}, P$4), i2 = this.get("viewModel.view.breakpoints"), o2 = {};
    i2 && (o2.width = i2.xsmall, o2.height = i2.xsmall);
    const n2 = __spreadValues(__spreadValues({}, t2), e2), s2 = __spreadValues(__spreadValues({}, t2.breakpoint), o2), { breakpoint: r2 } = n2;
    r2 === true ? n2.breakpoint = s2 : typeof r2 == "object" && (n2.breakpoint = __spreadValues(__spreadValues({}, s2), r2)), this._set("dockOptions", n2), this._setCurrentDockPosition(), this.reposition();
  }
  get featureCount() {
    return this.viewModel.featureCount;
  }
  get features() {
    return this.viewModel.features;
  }
  set features(e2) {
    this.viewModel.features = e2;
  }
  get goToOverride() {
    return this.viewModel.goToOverride;
  }
  set goToOverride(e2) {
    this.viewModel.goToOverride = e2;
  }
  get highlightEnabled() {
    return this.viewModel.highlightEnabled;
  }
  set highlightEnabled(e2) {
    this.viewModel.highlightEnabled = e2;
  }
  get location() {
    return this.viewModel.location;
  }
  set location(e2) {
    this.viewModel.location = e2;
  }
  get label() {
    var _a2, _b2;
    return (_b2 = (_a2 = this.messages) == null ? void 0 : _a2.widgetLabel) != null ? _b2 : "";
  }
  set label(e2) {
    this._overrideIfSome("label", e2);
  }
  get promises() {
    return this.viewModel.promises;
  }
  set promises(e2) {
    this.viewModel.promises = e2;
  }
  get selectedFeature() {
    return this.viewModel.selectedFeature;
  }
  get selectedFeatureIndex() {
    return this.viewModel.selectedFeatureIndex;
  }
  set selectedFeatureIndex(e2) {
    this.viewModel.selectedFeatureIndex = e2;
  }
  get selectedFeatureWidget() {
    const { _feature: e2, visibleElements: t2, headingLevel: i2, _flowItems: o2 } = this, { selectedFeatureViewModel: n2 } = this.viewModel, s2 = __spreadProps(__spreadValues({}, t2), { title: false });
    return n2 ? (e2 ? (e2.viewModel = n2, e2.visibleElements = s2) : this._feature = new C$6({ flowItems: o2, headingLevel: i2 + 1, viewModel: n2, visibleElements: s2 }), this._feature) : null;
  }
  get title() {
    return this.viewModel.title;
  }
  set title(e2) {
    this.viewModel.title = e2;
  }
  get updateLocationEnabled() {
    return this.viewModel.updateLocationEnabled;
  }
  set updateLocationEnabled(e2) {
    this.viewModel.updateLocationEnabled = e2;
  }
  get view() {
    return this.viewModel.view;
  }
  set view(e2) {
    this.viewModel.view = e2;
  }
  get visible() {
    return this.viewModel.visible;
  }
  set visible(e2) {
    this.viewModel.visible = e2;
  }
  castVisibleElements(e2) {
    return __spreadValues(__spreadValues({}, S$5), e2);
  }
  blur() {
    const { active: e2 } = this.viewModel;
    e2 || s$22.getLogger(this.declaredClass).warn("Popup can only be blurred when currently active."), this.visibleElements.closeButton ? this._blurClose = true : this._blurContainer = true, this.scheduleRender();
  }
  clear() {
    return this.viewModel.clear();
  }
  close() {
    this.visible = false;
  }
  fetchFeatures(e2, t2) {
    return this.viewModel.fetchFeatures(e2, t2);
  }
  focus() {
    const { active: e2 } = this.viewModel;
    e2 || s$22.getLogger(this.declaredClass).warn("Popup can only be focused when currently active."), this.visibleElements.closeButton ? this._focusClose = true : this._focusContainer = true, this.scheduleRender();
  }
  next() {
    return this.viewModel.next();
  }
  open(e2) {
    var _a2, _b2;
    this._handles.remove(E$4);
    const t2 = !!e2 && !!e2.featureMenuOpen, i2 = !!e2 && !!e2.actionsMenuOpen, o2 = { collapsed: !!e2 && !!e2.collapsed, actionsMenuOpen: i2, featureMenuOpen: t2 };
    ((_b2 = (_a2 = this.viewModel) == null ? void 0 : _a2.view) == null ? void 0 : _b2.widthBreakpoint) === "xsmall" && (o2.collapsed = true), this.set(o2), this.viewModel.open(e2), this._shouldFocus(e2), this._addSelectedFeatureIndexHandle();
  }
  previous() {
    return this.viewModel.previous();
  }
  reposition() {
    this.renderNow(), this._positionContainer(), this._setCurrentAlignment();
  }
  triggerAction(e2) {
    return this.viewModel.triggerAction(e2);
  }
  render() {
    var _a2, _b2, _c2, _d2;
    const { actionsMenuOpen: e2, dockEnabled: t2, featureMenuVisible: i2, dividedActions: o2, currentAlignment: n2, currentDockPosition: s2 } = this, { active: r2 } = this.viewModel, { menuActions: a2 } = o2, l2 = r2 && a2.length > 1 && e2, c2 = r2 && t2, u2 = r2 && !t2, d2 = (_b2 = (_a2 = this.selectedFeature) == null ? void 0 : _a2.layer) == null ? void 0 : _b2.title, p2 = (_d2 = (_c2 = this.selectedFeature) == null ? void 0 : _c2.layer) == null ? void 0 : _d2.id, h2 = { [B$4.alignTopCenter]: n2 === "top-center", [B$4.alignBottomCenter]: n2 === "bottom-center", [B$4.alignTopLeft]: n2 === "top-left", [B$4.alignBottomLeft]: n2 === "bottom-left", [B$4.alignTopRight]: n2 === "top-right", [B$4.alignBottomRight]: n2 === "bottom-right", [B$4.isDocked]: c2, [B$4.shadow]: u2, [B$4.isDockedTopLeft]: s2 === "top-left", [B$4.isDockedTopCenter]: s2 === "top-center", [B$4.isDockedTopRight]: s2 === "top-right", [B$4.isDockedBottomLeft]: s2 === "bottom-left", [B$4.isDockedBottomCenter]: s2 === "bottom-center", [B$4.isDockedBottomRight]: s2 === "bottom-right", [B$4.isFeatureMenuOpen]: i2, [B$4.isActionsMenuOpen]: l2 };
    return n$1k("div", { class: this.classes(B$4.base, h2), role: "presentation", "data-layer-title": d2, "data-layer-id": p2, bind: this, afterCreate: this._positionContainer, afterUpdate: this._positionContainer }, r2 ? [this.renderMainContainer(), this.renderPointer()] : null);
  }
  renderLoadingIcon() {
    return n$1k("span", { "aria-hidden": "true", class: this.classes(B$4.icon, B$4.iconLoading, B$4.rotating) });
  }
  renderNavigationLoading() {
    const { messagesCommon: e2 } = this;
    return this.viewModel.pendingPromisesCount ? n$1k("div", { key: R$1("loading-container"), role: "presentation", class: B$4.loadingContainer, "aria-label": e2.loading, title: e2.loading }, this.renderLoadingIcon()) : null;
  }
  renderPreviousIcon() {
    const e2 = f$U(this.container), t2 = { [B$4.iconRightTriangleArrow]: e2, [B$4.paginationPreviousIconRTL]: e2, [B$4.iconLeftTriangleArrow]: !e2, [B$4.paginationPreviousIconLTR]: !e2 };
    return n$1k("span", { "aria-hidden": "true", class: this.classes(B$4.icon, t2) });
  }
  renderPreviousButton() {
    const { messages: e2 } = this;
    return n$1k("div", { role: "button", tabIndex: 0, bind: this, onclick: this._previous, onkeydown: this._previous, class: this.classes(B$4.button, B$4.paginationPrevious), "aria-label": e2.previous, title: e2.previous }, this.renderPreviousIcon());
  }
  renderNextIcon() {
    const e2 = f$U(this.container), t2 = { [B$4.iconLeftTriangleArrow]: e2, [B$4.paginationNextIconRTL]: e2, [B$4.iconRightTriangleArrow]: !e2, [B$4.paginationNextIconLTR]: !e2 };
    return n$1k("span", { "aria-hidden": "true", class: this.classes(B$4.icon, t2) });
  }
  renderNextButton() {
    const { messages: e2 } = this;
    return n$1k("div", { role: "button", tabIndex: 0, bind: this, onclick: this._next, onkeydown: this._next, class: this.classes(B$4.button, B$4.paginationNext), "aria-label": e2.next, title: e2.next }, this.renderNextIcon());
  }
  renderFeatureMenuButton() {
    const { featureMenuOpen: e2, featureMenuId: t2, messagesCommon: i2 } = this, { featureCount: o2, selectedFeatureIndex: n2 } = this.viewModel;
    return n$1k("div", { role: "button", tabIndex: 0, bind: this, onclick: this._toggleFeatureMenu, onkeydown: this._toggleFeatureMenu, afterCreate: this._focusFeatureMenuButtonNode, afterUpdate: this._focusFeatureMenuButtonNode, class: this.classes(B$4.button, B$4.featureMenuButton), "aria-haspopup": "true", "aria-controls": t2, "aria-expanded": e2.toString(), "aria-label": i2.menu, title: i2.menu }, this._getPageText(o2, n2));
  }
  renderNavigationButtons() {
    return this.featureNavigationVisible ? [this.renderPreviousButton(), this.renderNavigationLoading() || this.renderFeatureMenuButton(), this.renderNextButton()] : null;
  }
  renderDockIcon() {
    const { dockEnabled: e2 } = this, t2 = this._wouldDockTo(), i2 = { [B$4.iconUndock]: e2, [B$4.iconDock]: !e2, [B$4.iconDockToRight]: !e2 && (t2 === "top-right" || t2 === "bottom-right"), [B$4.iconDockToLeft]: !e2 && (t2 === "top-left" || t2 === "bottom-left"), [B$4.iconDockToTop]: !e2 && t2 === "top-center", [B$4.iconDockToBottom]: !e2 && t2 === "bottom-center" };
    return n$1k("span", { "aria-hidden": "true", class: this.classes(i2, B$4.icon) });
  }
  renderDockButton() {
    var _a2, _b2, _c2;
    const { dockEnabled: e2, messages: t2 } = this, i2 = (_b2 = (_a2 = this.viewModel) == null ? void 0 : _a2.view) == null ? void 0 : _b2.widthBreakpoint, o2 = e2 ? t2.undock : t2.dock;
    return i2 !== "xsmall" && ((_c2 = this.dockOptions) == null ? void 0 : _c2.buttonEnabled) ? n$1k("div", { role: "button", "aria-label": o2, title: o2, tabIndex: 0, bind: this, onclick: this._toggleDockEnabled, onkeydown: this._toggleDockEnabled, afterCreate: this._focusDockButtonNode, afterUpdate: this._focusDockButtonNode, class: this.classes(B$4.button, B$4.buttonDock) }, this.renderDockIcon()) : null;
  }
  renderTitle() {
    const { title: e2 } = this.viewModel, { titleId: t2, collapsible: i2, contentCollapsed: o2, messagesCommon: n2 } = this, s2 = { [B$4.headerContainerButton]: i2 }, r2 = n$1k(n$1j, { level: this.headingLevel, class: B$4.headerTitle, innerHTML: e2 }), a2 = i2 ? n$1k("button", { key: `${e2}--collapsible`, id: t2, title: o2 ? n2.expand : n2.collapse, bind: this, enterAnimation: this._createFeatureUpdatedAnimation(), class: this.classes(B$4.headerContainer, s2), "aria-expanded": o2 ? "false" : "true", onclick: this._toggleCollapsed, type: "button" }, r2, n$1k("calcite-icon", { class: B$4.collapseIcon, key: "collapse-icon", icon: o2 ? "chevron-down" : "chevron-up", scale: "m" })) : n$1k("div", { key: e2, id: t2, bind: this, enterAnimation: this._createFeatureUpdatedAnimation(), class: this.classes(B$4.headerContainer, s2) }, r2);
    return e2 ? a2 : null;
  }
  renderCloseIcon() {
    return n$1k("span", { "aria-hidden": "true", class: this.classes(B$4.icon, B$4.iconClose) });
  }
  renderCloseButton() {
    const { visibleElements: e2, messagesCommon: t2 } = this;
    return e2.closeButton ? n$1k("div", { role: "button", tabIndex: 0, bind: this, onclick: this._close, onkeydown: this._close, class: B$4.button, "aria-label": t2.close, title: t2.close, afterCreate: this._closeButtonNodeUpdated, afterUpdate: this._closeButtonNodeUpdated }, this.renderCloseIcon()) : null;
  }
  renderHeader() {
    return n$1k("header", { class: B$4.header }, this.renderTitle(), n$1k("div", { class: B$4.headerButtons }, this.renderDockButton(), this.renderCloseButton()));
  }
  renderContentContainer() {
    const { contentId: e2, hasContent: t2, contentCollapsed: i2, _flowItems: o2, messagesCommon: n2 } = this, { content: s2 } = this.viewModel, r2 = o2.toArray(), a2 = { [B$4.contentHasFlows]: !!r2.length };
    return t2 && !i2 ? n$1k("div", { key: s2, enterAnimation: this._createFeatureUpdatedAnimation(), id: e2, class: this.classes(B$4.content, a2) }, n$1k("calcite-flow", { bind: this, onCalciteFlowItemBack: this._handleBackClick }, n$1k("calcite-flow-item", { bind: this, "data-node-ref": "_rootFlowItemNode", "intl-back": n2.back, afterCreate: v$A, key: "root-flow-item" }, this.renderContent()), r2.map((e3) => this.renderFlowItem(e3))), r2.map((e3) => this.renderFlowItemTooltip(e3))) : null;
  }
  renderFlowItem(e2) {
    const { messages: t2, messagesCommon: i2 } = this, o2 = r$K();
    return n$1k("calcite-flow-item", { class: this.classes({ [B$4.calciteThemeDark]: !o2, [B$4.calciteThemeLight]: o2 }), heading: e2.title, "intl-back": i2.back, description: this._getFlowItemDescription(e2), key: `flow-item-${e2.viewModel.uid}` }, n$1k("calcite-action", { class: B$4.actionExit, icon: "move-up", label: t2 == null ? void 0 : t2.exitRelatedRecords, text: t2 == null ? void 0 : t2.exitRelatedRecords, slot: "header-actions-start", bind: this, afterCreate: (t3) => this._storeExitRelatedRecordsAction(e2, t3), onclick: this._destroyFlowItemWidgets }), n$1k("div", { class: this.classes(B$4.contentFlowItem, { [B$4.calciteThemeDark]: o2, [B$4.calciteThemeLight]: !o2 }) }, e2.render()));
  }
  renderFlowItemTooltip(e2) {
    const { messages: t2, _exitRelatedRecordsActions: i2 } = this, o2 = r$K();
    return n$1k("calcite-tooltip", { class: this.classes({ [B$4.calciteThemeDark]: !o2, [B$4.calciteThemeLight]: o2 }), key: `exit-related-records-tooltip-${e2.viewModel.uid}`, label: t2 == null ? void 0 : t2.exitRelatedRecords, overlayPositioning: "fixed", referenceElement: i2.get(e2), placement: "top" }, t2 == null ? void 0 : t2.exitRelatedRecords);
  }
  renderActionsMenuButton() {
    const { actionsMenuId: e2, actionsMenuButtonId: t2, actionsMenuOpen: i2, dividedActions: o2, messagesCommon: n2 } = this, s2 = i2 ? n2.close : n2.open, { menuActions: r2 } = o2;
    return r2.length ? n$1k("div", { key: R$1("actions-menu-button"), class: this.classes(B$4.button, B$4.actionsMenuButton), role: "button", id: t2, "aria-haspopup": "true", "aria-controls": i2 ? e2 : null, tabIndex: 0, bind: this, onclick: this._toggleActionsMenu, onkeydown: this._toggleActionsMenu, afterCreate: this._focusActionsMenuButtonNode, afterUpdate: this._focusActionsMenuButtonNode, "aria-label": s2, title: s2 }, n$1k("span", { "aria-hidden": "true", class: B$4.iconActionsMenu })) : null;
  }
  renderMenuActions() {
    const { actionsMenuId: e2, actionsMenuButtonId: t2, actionsMenuOpen: i2, dividedActions: o2 } = this, { menuActions: n2 } = o2;
    return n2.length && i2 ? n$1k("ul", { id: e2, role: "menu", "aria-labelledby": t2, key: R$1("actions"), class: B$4.actions, bind: this, onkeyup: this._handleActionMenuKeyup, afterCreate: this._actionsMenuNodeUpdated, afterUpdate: this._actionsMenuNodeUpdated }, n2.toArray().map((e3) => this.renderAction({ action: e3, type: "menu-item" }))) : null;
  }
  renderInlineActions() {
    const { inlineActions: e2 } = this.dividedActions;
    return !!e2.length && e2.toArray().map((e3) => this.renderAction({ action: e3, type: "inline" }));
  }
  renderInlineActionsContainer() {
    const { inlineActions: e2, menuActions: t2 } = this.dividedActions, i2 = !!e2.length, o2 = !!t2.length;
    return i2 || o2 ? n$1k("div", { key: "inline-actions-container", "data-inline-actions": i2.toString(), "data-menu-actions": o2.toString(), class: B$4.inlineActionsContainer }, this.renderInlineActions(), this.renderActionsMenuButton(), this.renderMenuActions()) : null;
  }
  renderNavigation() {
    return this.featureNavigationVisible ? n$1k("section", { key: R$1("navigation"), class: this.classes(B$4.navigation) }, this.renderNavigationButtons()) : null;
  }
  renderFooter() {
    const { featureNavigationVisible: e2, dividedActions: t2 } = this, { inlineActions: i2, menuActions: o2 } = t2, n2 = !!i2.length, s2 = !!o2.length, r2 = { [B$4.footerHasPagination]: e2, [B$4.footerHasActions]: n2, [B$4.footerHasActionsMenu]: s2 };
    return e2 || n2 ? n$1k("div", { key: R$1("feature-buttons"), class: this.classes(B$4.footer, r2) }, this.renderInlineActionsContainer(), this.renderNavigation()) : null;
  }
  renderFeatureMenuContainer() {
    const { messages: e2 } = this, { featureViewModels: t2, isLoadingFeature: i2 } = this.viewModel, o2 = s$1f(e2.selectedFeatures, { total: t2.length });
    return n$1k("section", { key: R$1("menu"), class: B$4.featureMenu }, n$1k("strong", { class: B$4.featureMenuHeader }, o2), n$1k("nav", { bind: this, class: B$4.featureMenuViewport, "data-node-ref": "_featureMenuViewportNode", afterCreate: v$A }, this.renderFeatureMenu(), n$1k("div", { class: B$4.featureMenuObserver, bind: this, afterCreate: this._featureMenuIntersectionObserverCreated }), i2 ? n$1k("div", { class: B$4.featureMenuLoader }, this.renderLoadingIcon()) : null));
  }
  renderPointer() {
    return this.dockEnabled ? null : n$1k("div", { key: R$1("pointer"), class: B$4.pointer, role: "presentation" }, n$1k("div", { class: this.classes(B$4.pointerDirection, B$4.shadow) }));
  }
  renderMainContainer() {
    const { dockEnabled: e2, currentAlignment: t2, currentDockPosition: i2, titleId: o2, contentId: n2, collapsible: s2, hasContent: r2, contentCollapsed: a2, visibleElements: l2 } = this, { title: c2 } = this.viewModel, u2 = t2 === "bottom-left" || t2 === "bottom-center" || t2 === "bottom-right" || i2 === "top-left" || i2 === "top-center" || i2 === "top-right", d2 = t2 === "top-left" || t2 === "top-center" || t2 === "top-right" || i2 === "bottom-left" || i2 === "bottom-center" || i2 === "bottom-right", p2 = { [B$4.shadow]: e2, [B$4.isCollapsible]: s2, [B$4.isCollapsed]: a2 };
    return n$1k("div", { class: this.classes(B$4.main, B$4.widget, p2), tabIndex: l2.closeButton ? null : -1, role: "dialog", "aria-labelledby": c2 ? o2 : "", "aria-describedby": r2 && !a2 ? n2 : "", bind: this, onkeyup: this._handleMainKeyup, afterCreate: this._mainContainerNodeUpdated, afterUpdate: this._mainContainerNodeUpdated }, u2 ? this.renderFooter() : null, u2 ? this.renderFeatureMenuContainer() : null, this.renderHeader(), this.renderContentContainer(), d2 ? this.renderFooter() : null, d2 ? this.renderFeatureMenuContainer() : null);
  }
  renderContent() {
    var _a2;
    const e2 = (_a2 = this.viewModel) == null ? void 0 : _a2.content;
    return e2 ? typeof e2 == "string" ? n$1k("div", { class: e$n.contentNode, key: e2, innerHTML: e2 }) : this.renderNodeContent(e2) : null;
  }
  renderActionText(e2) {
    return n$1k("span", { key: "text", class: B$4.actionText }, e2);
  }
  renderActionIcon(e2) {
    const t2 = this._getActionClass(e2), i2 = this._getActionImage(e2), o2 = { [B$4.iconLoading]: e2.active, [B$4.rotating]: e2.active, [B$4.icon]: !!t2, [B$4.actionImage]: !e2.active && !!i2 };
    return t2 && (o2[t2] = !e2.active), n$1k("span", { key: "icon", "aria-hidden": "true", class: this.classes(B$4.icon, o2), styles: this._getIconStyles(i2) });
  }
  renderAction(e2) {
    const { action: t2, type: i2 } = e2, o2 = this._getActionTitle(t2), n2 = { [B$4.action]: t2.type !== "toggle", [B$4.actionToggle]: t2.type === "toggle", [B$4.actionToggleOn]: t2.type === "toggle" && t2.value, [B$4.buttonDisabled]: t2.disabled }, s2 = [this.renderActionIcon(t2), this.renderActionText(o2)], r2 = i2 === "menu-item" ? n$1k("li", { key: t2.uid, role: "menuitem", tabIndex: 0, title: o2, "aria-label": o2, class: this.classes(B$4.button, n2), onkeyup: this._handleActionMenuItemKeyup, bind: this, "data-action-uid": t2.uid, onclick: this._triggerAction, onkeydown: this._triggerAction }, s2) : n$1k("div", { key: t2.uid, role: "button", tabIndex: 0, title: o2, "aria-label": o2, class: this.classes(B$4.button, n2), onkeyup: this._handleActionMenuItemKeyup, bind: this, "data-action-uid": t2.uid, onclick: this._triggerAction, onkeydown: this._triggerAction }, s2);
    return t2.visible ? r2 : null;
  }
  renderFeatureMenuItem(e2, t2) {
    const { messages: i2, messagesCommon: o2 } = this, { selectedFeatureIndex: n2, selectedFeatureViewModel: s2 } = this.viewModel, r2 = e2 === s2, a2 = { [B$4.featureMenuSelected]: r2 }, l2 = r2 ? n$1k("span", { key: R$1(`feature-menu-selected-feature-${n2}`), title: i2.selectedFeature, "aria-label": i2.selectedFeature, class: B$4.iconCheckMark }) : null, c2 = n$1k("span", { innerHTML: e2.title || o2.untitled });
    return n$1k("li", { role: "menuitem", tabIndex: -1, key: R$1(`feature-menu-feature-${n2}`), class: this.classes(a2, B$4.featureMenuItem), bind: this, "data-feature-index": t2, onblur: this._removeActiveFeature, onfocus: this._setActiveFeature, onkeyup: this._handleFeatureMenuItemKeyup, onclick: this._selectFeature, onkeydown: this._selectFeature, onmouseover: this._setActiveFeature, onmouseleave: this._removeActiveFeature }, n$1k("span", { class: B$4.featureMenuTitle }, c2, l2));
  }
  renderFeatureMenu() {
    const { featureMenuId: e2 } = this, { featureViewModels: t2 } = this.viewModel;
    return t2.length > 1 ? n$1k("ol", { class: B$4.featureMenuList, id: e2, bind: this, afterCreate: this._featureMenuNodeUpdated, afterUpdate: this._featureMenuNodeUpdated, onkeyup: this._handleFeatureMenuKeyup, role: "menu" }, t2.filter((e3) => !!e3.graphic).map((e3, t3) => this.renderFeatureMenuItem(e3, t3))) : null;
  }
  _storeExitRelatedRecordsAction(e2, t2) {
    this._exitRelatedRecordsActions.set(e2, t2), this.scheduleRender();
  }
  _getFlowItemDescription(e2) {
    return "featureCountDescription" in e2 ? e2.featureCountDescription : e2.viewModel.description;
  }
  _destroyFlowItemWidgets() {
    this._flowItems.removeAll().forEach((e2) => {
      "showAllEnabled" in e2.viewModel && (e2.viewModel.showAllEnabled = false), e2.viewModel = null, e2.destroy();
    });
  }
  _handleBackClick() {
    const e2 = this._flowItems.pop();
    this._exitRelatedRecordsActions.delete(e2), "showAllEnabled" in e2.viewModel && (e2.viewModel.showAllEnabled = false), e2 && (e2.viewModel = null, e2.destroy());
  }
  _getActionTitle(e2) {
    const { messages: t2, selectedFeature: i2, messagesCommon: o2 } = this, { id: n2 } = e2, s2 = i2 == null ? void 0 : i2.attributes, r2 = n2 === "zoom-to-feature" ? s$1f(e2.title, { messages: t2 }) : n2 === "remove-selected-feature" ? s$1f(e2.title, { messages: o2 }) : n2 === "zoom-to-clustered-features" || n2 === "browse-clustered-features" ? s$1f(e2.title, { messages: t2 }) : e2.title;
    return r2 && s2 ? s$1f(r2, s2) : r2;
  }
  _getActionClass(e2) {
    const { selectedFeature: t2 } = this, i2 = t2 == null ? void 0 : t2.attributes, { className: o2, image: n2 } = e2, s2 = n2 || o2 ? o2 : B$4.iconDefaultAction;
    return s2 && i2 ? s$1f(s2, i2) : s2;
  }
  _getActionImage(e2) {
    const { selectedFeature: t2 } = this, i2 = t2 == null ? void 0 : t2.attributes, { image: o2 } = e2;
    return o2 && i2 ? s$1f(o2, i2) : o2;
  }
  _createFeatureUpdatedAnimation() {
    return w$v("enter", B$4.hasFeatureUpdated);
  }
  _getInlineActionCount() {
    const { maxInlineActions: e2, featureNavigationVisible: t2 } = this;
    if (typeof e2 != "number")
      return null;
    const i2 = Math.round(e2);
    return Math.max(t2 ? i2 - 1 : i2, 0);
  }
  _watchActions() {
    const { allActions: e2 } = this.viewModel;
    this.notifyChange("dividedActions");
    const t2 = "actions";
    this._handles.remove(t2), e2 && e2.forEach((e3) => {
      this._handles.add(l$1f(() => [e3.uid, e3.active, e3.className, e3.disabled, e3.id, e3.title, e3.image, e3.visible], () => this.scheduleRender()), t2);
    });
  }
  _divideActions() {
    const { allActions: e2 } = this.viewModel, i2 = e2.filter((e3) => e3.visible), o2 = this._getInlineActionCount(), n2 = o2 === null, s2 = o2 === 0;
    return { inlineActions: n2 ? i2.slice(0) : s2 ? new j$F() : i2.slice(0, o2), menuActions: n2 ? new j$F() : s2 ? i2.slice(0) : i2.slice(o2) };
  }
  _featureMenuOpenChanged(e2) {
    e2 ? this._focusFirstFeature = true : this._focusFeatureMenuButton = true;
  }
  _actionsMenuOpenChanged(e2) {
    e2 ? this._focusFirstAction = true : this._focusActionsMenuButton = true;
  }
  _setTitleFromFeatureWidget() {
    var _a2, _b2;
    const { selectedFeatureWidget: e2, messagesCommon: t2 } = this;
    e2 && (this.viewModel.title = ((_a2 = e2.viewModel) == null ? void 0 : _a2.state) === "error" ? t2.errorMessage : ((_b2 = e2.viewModel) == null ? void 0 : _b2.title) || "");
  }
  _setContentFromFeatureWidget() {
    const { selectedFeatureWidget: e2 } = this;
    e2 && (this.viewModel.content = e2);
  }
  _unobserveFeatureMenuObserver() {
    this._featureMenuIntersectionObserverNode && this._featureMenuIntersectionObserver.unobserve(this._featureMenuIntersectionObserverNode);
  }
  _featureMenuIntersectionObserverCreated(e2) {
    this._unobserveFeatureMenuObserver(), this._featureMenuIntersectionObserver.observe(e2), this._featureMenuIntersectionObserverNode = e2;
  }
  _handleFeatureMenuKeyup(e2) {
    i$2k(e2) === "Escape" && (e2.stopPropagation(), this._focusFeatureMenuButton = true, this.featureMenuOpen = false, this.scheduleRender());
  }
  _handleActionMenuKeyup(e2) {
    i$2k(e2) === "Escape" && (e2.stopPropagation(), this._focusActionsMenuButton = true, this.actionsMenuOpen = false, this.scheduleRender());
  }
  _setActiveFeature(e2) {
    const { viewModel: t2 } = this, i2 = e2.currentTarget["data-feature-index"];
    t2.activeFeature = t2.features[i2] || null;
  }
  _removeActiveFeature() {
    this.viewModel.activeFeature = null;
  }
  _handleFeatureMenuItemKeyup(e2) {
    const t2 = i$2k(e2), { _featureMenuNode: o2 } = this, n2 = e2.currentTarget["data-feature-index"];
    if (!o2)
      return;
    const s2 = o2.querySelectorAll("li"), r2 = s2.length;
    if (t2 !== "ArrowUp")
      if (t2 !== "ArrowDown")
        if (t2 !== "Home")
          if (t2 !== "End")
            ;
          else {
            e2.stopPropagation();
            s2[s2.length - 1].focus();
          }
        else {
          e2.stopPropagation();
          s2[0].focus();
        }
      else {
        e2.stopPropagation();
        s2[(n2 + 1 + r2) % r2].focus();
      }
    else {
      e2.stopPropagation();
      s2[(n2 - 1 + r2) % r2].focus();
    }
  }
  _handleActionMenuItemKeyup(e2) {
    const t2 = i$2k(e2), { _actionsMenuNode: o2 } = this, n2 = e2.currentTarget.dataset.actionUid, { menuActions: s2 } = this.dividedActions, r2 = s2.findIndex((e3) => e3.uid === n2);
    if (!o2)
      return;
    const a2 = o2.querySelectorAll("li"), l2 = a2.length;
    if (t2 !== "ArrowUp")
      if (t2 !== "ArrowDown")
        if (t2 !== "Home")
          if (t2 !== "End")
            ;
          else {
            e2.stopPropagation();
            a2[a2.length - 1].focus();
          }
        else {
          e2.stopPropagation();
          a2[0].focus();
        }
      else {
        e2.stopPropagation();
        a2[(r2 + 1 + l2) % l2].focus();
      }
    else {
      e2.stopPropagation();
      a2[(r2 - 1 + l2) % l2].focus();
    }
  }
  _handleMainKeyup(e2) {
    const t2 = i$2k(e2);
    t2 === "ArrowLeft" && (e2.stopPropagation(), this.previous()), t2 === "ArrowRight" && (e2.stopPropagation(), this.next());
  }
  _spinnerEnabledChange(e2) {
    if (this._destroySpinner(), !e2)
      return;
    const t2 = this.get("viewModel.view");
    this._createSpinner(t2);
  }
  _hideSpinner() {
    const { _spinner: e2 } = this;
    e2 && (e2.location = null, e2.hide());
  }
  _displaySpinner() {
    const { _spinner: e2 } = this;
    if (!e2)
      return;
    const { location: t2, waitingForResult: i2 } = this.viewModel;
    i2 ? e2.show({ location: t2 }) : e2.hide();
  }
  _getIconStyles(e2) {
    return { "background-image": e2 ? `url(${e2})` : "" };
  }
  async _shouldFocus(e2) {
    e2.shouldFocus && (await j$u(() => {
      var _a2;
      return ((_a2 = this.viewModel) == null ? void 0 : _a2.active) === true;
    }), this.focus());
  }
  _addSelectedFeatureIndexHandle() {
    const e2 = l$1f(() => {
      var _a2;
      return (_a2 = this.viewModel) == null ? void 0 : _a2.selectedFeatureIndex;
    }, (e3, t2) => this._selectedFeatureIndexUpdated(e3, t2));
    this._handles.add(e2, E$4);
  }
  _selectedFeatureIndexUpdated(e2, t2) {
    const { featureCount: i2 } = this;
    i2 && e2 !== t2 && e2 !== -1 && (this._destroyFlowItemWidgets(), this.actionsMenuOpen = false, this.featureMenuOpen = false, this._mainContainerNode && (this._mainContainerNode.scrollTop = 0), this._rootFlowItemNode && this._rootFlowItemNode.scrollContentTo({ top: 0 }));
  }
  _destroySelectedFeatureWidget() {
    const { _feature: e2 } = this;
    e2 && (e2.viewModel = null, e2 && !e2.destroyed && e2.destroy()), this._feature = null;
  }
  _isScreenLocationWithinView(e2, t2) {
    return e2.x > -1 && e2.y > -1 && e2.x <= t2.width && e2.y <= t2.height;
  }
  _isOutsideView(e2) {
    const { popupHeight: t2, popupWidth: i2, screenLocation: o2, side: n2, view: s2 } = e2;
    if (isNaN(i2) || isNaN(t2) || !s2 || !o2)
      return false;
    const r2 = s2.padding;
    return n2 === "right" && o2.x + i2 / 2 > s2.width - r2.right || (n2 === "left" && o2.x - i2 / 2 < r2.left || (n2 === "top" && o2.y - t2 < r2.top || n2 === "bottom" && o2.y + t2 > s2.height - r2.bottom));
  }
  _calculateAutoAlignment(e2) {
    if (e2 !== "auto")
      return e2;
    const { _pointerOffsetInPx: t2, _containerNode: i2, _mainContainerNode: o2, viewModel: n2 } = this, { screenLocation: r2, view: a2 } = n2;
    if (t$1W(r2) || !a2 || !i2)
      return "top-center";
    if (!this._isScreenLocationWithinView(r2, a2))
      return this._get("currentAlignment") || "top-center";
    function l2(e3) {
      return parseInt(e3.replace(/[^-\d\.]/g, ""), 10);
    }
    const c2 = o2 ? window.getComputedStyle(o2, null) : null, u2 = c2 ? l2(c2.getPropertyValue("max-height")) : 0, d2 = c2 ? l2(c2.getPropertyValue("height")) : 0, { height: p2, width: h2 } = i2.getBoundingClientRect(), g2 = h2 + t2, _2 = Math.max(p2, u2, d2) + t2, m2 = this._isOutsideView({ popupHeight: _2, popupWidth: g2, screenLocation: r2, side: "right", view: a2 }), f2 = this._isOutsideView({ popupHeight: _2, popupWidth: g2, screenLocation: r2, side: "left", view: a2 }), v2 = this._isOutsideView({ popupHeight: _2, popupWidth: g2, screenLocation: r2, side: "top", view: a2 }), b2 = this._isOutsideView({ popupHeight: _2, popupWidth: g2, screenLocation: r2, side: "bottom", view: a2 });
    return f2 ? v2 ? "bottom-right" : "top-right" : m2 ? v2 ? "bottom-left" : "top-left" : v2 ? b2 ? "top-center" : "bottom-center" : "top-center";
  }
  _callCurrentAlignment(e2) {
    return typeof e2 == "function" ? e2.call(this) : e2;
  }
  _getCurrentAlignment() {
    const { alignment: e2, dockEnabled: t2 } = this;
    return t2 || !this.viewModel.active ? null : this._calculatePositionResult(this._calculateAutoAlignment(this._callCurrentAlignment(e2)));
  }
  _setCurrentAlignment() {
    this._set("currentAlignment", this._getCurrentAlignment());
  }
  _setCurrentDockPosition() {
    this._set("currentDockPosition", this._getCurrentDockPosition());
  }
  _calculatePositionResult(e2) {
    const t2 = ["left", "right"];
    return f$U(this.container) && t2.reverse(), e2.replace(/leading/gi, t2[0]).replace(/trailing/gi, t2[1]);
  }
  _callDockPosition(e2) {
    return typeof e2 == "function" ? e2.call(this) : e2;
  }
  _getDockPosition() {
    var _a2;
    return this._calculatePositionResult(this._calculateAutoDockPosition(this._callDockPosition((_a2 = this.dockOptions) == null ? void 0 : _a2.position)));
  }
  _getCurrentDockPosition() {
    return this.dockEnabled && this.viewModel.active ? this._getDockPosition() : null;
  }
  _wouldDockTo() {
    return this.dockEnabled ? null : this._getDockPosition();
  }
  _calculateAutoDockPosition(e2) {
    var _a2;
    if (e2 !== "auto")
      return e2;
    const t2 = (_a2 = this.viewModel) == null ? void 0 : _a2.view, i2 = f$U(this.container) ? "top-left" : "top-right";
    if (!t2)
      return i2;
    const o2 = t2.padding || { left: 0, right: 0, top: 0, bottom: 0 }, n2 = t2.width - o2.left - o2.right, { breakpoints: s2 } = t2;
    return s2 && n2 <= s2.xsmall ? "bottom-center" : i2;
  }
  _positionContainer(e2 = this._containerNode) {
    if (e2 && (this._containerNode = e2), !e2)
      return;
    const { screenLocation: t2 } = this.viewModel, { width: i2 } = e2.getBoundingClientRect(), o2 = this._calculatePositionStyle(t2, i2);
    o2 && (e2.style.top = o2.top, e2.style.left = o2.left, e2.style.bottom = o2.bottom, e2.style.right = o2.right);
  }
  _calculateFullWidth(e2) {
    const { currentAlignment: t2, _pointerOffsetInPx: i2 } = this;
    return t2 === "top-left" || t2 === "bottom-left" || t2 === "top-right" || t2 === "bottom-right" ? e2 + i2 : e2;
  }
  _calculateAlignmentPosition(e2, t2, i2, o2) {
    const { currentAlignment: n2, _pointerOffsetInPx: s2 } = this, r2 = o2 / 2, a2 = i2.height - t2, l2 = i2.width - e2, { padding: c2 } = this.view;
    return n2 === "bottom-center" ? { top: t2 + s2 - c2.top, left: e2 - r2 - c2.left } : n2 === "top-left" ? { bottom: a2 + s2 - c2.bottom, right: l2 + s2 - c2.right } : n2 === "bottom-left" ? { top: t2 + s2 - c2.top, right: l2 + s2 - c2.right } : n2 === "top-right" ? { bottom: a2 + s2 - c2.bottom, left: e2 + s2 - c2.left } : n2 === "bottom-right" ? { top: t2 + s2 - c2.top, left: e2 + s2 - c2.left } : n2 === "top-center" ? { bottom: a2 + s2 - c2.bottom, left: e2 - r2 - c2.left } : void 0;
  }
  _calculatePositionStyle(e2, t2) {
    const { dockEnabled: i2, view: o2 } = this;
    if (!o2)
      return;
    if (i2)
      return { left: "", top: "", right: "", bottom: "" };
    if (t$1W(e2) || !t2)
      return;
    const n2 = this._calculateFullWidth(t2), r2 = this._calculateAlignmentPosition(e2.x, e2.y, o2, n2);
    return r2 ? { top: r2.top !== void 0 ? `${r2.top}px` : "auto", left: r2.left !== void 0 ? `${r2.left}px` : "auto", bottom: r2.bottom !== void 0 ? `${r2.bottom}px` : "auto", right: r2.right !== void 0 ? `${r2.right}px` : "auto" } : void 0;
  }
  _viewChange(e2, t2) {
    e2 && t2 && (this.close(), this.clear());
  }
  _viewReadyChange(e2, t2) {
    if (e2) {
      const e3 = this.get("viewModel.view");
      this._wireUpView(e3);
    } else
      t2 && (this.close(), this.clear());
  }
  _wireUpView(e2) {
    if (this._destroySpinner(), !e2)
      return;
    const { spinnerEnabled: t2 } = this;
    t2 && this._createSpinner(e2), this._setDockEnabledForViewSize(this.dockOptions);
  }
  _dockingThresholdCrossed(e2, t2, i2) {
    const [o2, n2] = e2, [s2, r2] = t2, { width: a2, height: l2 } = i2;
    return o2 <= a2 && s2 > a2 || o2 > a2 && s2 <= a2 || n2 <= l2 && r2 > l2 || n2 > l2 && r2 <= l2;
  }
  _updateDockEnabledForViewSize(e2, t2) {
    if (!e2 || !t2)
      return;
    const i2 = this.get("viewModel.view.padding") || { left: 0, right: 0, top: 0, bottom: 0 }, o2 = i2.left + i2.right, n2 = i2.top + i2.bottom, s2 = [], r2 = [];
    s2[0] = e2[0] - o2, s2[1] = e2[1] - n2, r2[0] = t2[0] - o2, r2[1] = t2[1] - n2;
    const { dockOptions: a2 } = this, l2 = a2.breakpoint;
    this._dockingThresholdCrossed(s2, r2, l2) && this._setDockEnabledForViewSize(a2), this._setCurrentDockPosition();
  }
  _focusDockButtonNode(e2) {
    this._focusDockButton && (this._focusDockButton = false, e2.focus());
  }
  _closeButtonNodeUpdated(e2) {
    return this._focusClose ? (this._focusClose = false, void e2.focus()) : this._blurClose ? (this._blurClose = false, void e2.blur()) : void 0;
  }
  _mainContainerNodeUpdated(e2) {
    return this._mainContainerNode = e2, this._focusContainer ? (this._focusContainer = false, void e2.focus()) : this._blurContainer ? (this._blurContainer = false, void e2.blur()) : void 0;
  }
  _featureMenuNodeUpdated(e2) {
    if (this._featureMenuNode = e2, !e2 || !this._focusFirstFeature)
      return;
    this._focusFirstFeature = false;
    const t2 = e2.querySelectorAll("li");
    if (t2.length) {
      t2[0].focus();
    }
  }
  _actionsMenuNodeUpdated(e2) {
    if (this._actionsMenuNode = e2, !e2 || !this._focusFirstAction)
      return;
    this._focusFirstAction = false;
    const t2 = e2.querySelectorAll("li");
    if (t2.length) {
      t2[0].focus();
    }
  }
  _focusFeatureMenuButtonNode(e2) {
    this._focusFeatureMenuButton && (this._focusFeatureMenuButton = false, e2.focus());
  }
  _focusActionsMenuButtonNode(e2) {
    this._focusActionsMenuButton && (this._focusActionsMenuButton = false, e2.focus());
  }
  _featureMenuViewportScrollTop() {
    this._featureMenuViewportNode && (this._featureMenuViewportNode.scrollTop = 0);
  }
  _toggleScreenLocationEnabled() {
    const { dockEnabled: e2, viewModel: t2 } = this;
    if (!t2)
      return;
    const i2 = t2.active && !e2;
    t2.screenLocationEnabled = i2;
  }
  _shouldDockAtCurrentViewSize(e2) {
    var _a2, _b2;
    const t2 = e2.breakpoint, i2 = (_b2 = (_a2 = this.viewModel) == null ? void 0 : _a2.view) == null ? void 0 : _b2.ui;
    if (!i2)
      return false;
    const { width: o2, height: n2 } = i2;
    if (isNaN(o2) || isNaN(n2))
      return false;
    const s2 = t2.hasOwnProperty("width") && o2 <= t2.width, r2 = t2.hasOwnProperty("height") && n2 <= t2.height;
    return s2 || r2;
  }
  _setDockEnabledForViewSize(e2) {
    e2.breakpoint && (this.dockEnabled = this._shouldDockAtCurrentViewSize(e2));
  }
  _getPageText(e2, t2) {
    return this.featureNavigationVisible ? s$1f(this.messages.pageText, { index: t2 + 1, total: e2 }) : null;
  }
  _destroySpinner() {
    const { _spinner: e2, view: t2 } = this;
    e2 && (t2 && t2.ui && t2.ui.remove(this._spinner, D$3), e2.destroy(), this._spinner = null);
  }
  _createSpinner(e2) {
    e2 && (this._spinner = new h$f({ view: e2 }), e2.ui.add(this._spinner, { key: D$3, position: "manual" }));
  }
  _toggleCollapsed() {
    this.collapsed = !this.collapsed;
  }
  _close() {
    this.close(), this.view && this.view.focus();
  }
  _toggleDockEnabled() {
    this.dockEnabled = !this.dockEnabled, this._focusDockButton = true, this.scheduleRender();
  }
  _toggleFeatureMenu() {
    const e2 = !this.featureMenuOpen;
    this._featureMenuOpenChanged(e2), this.actionsMenuOpen = false, this.featureMenuOpen = e2;
  }
  _toggleActionsMenu() {
    const e2 = !this.actionsMenuOpen;
    this._actionsMenuOpenChanged(e2), this.featureMenuOpen = false, this.actionsMenuOpen = e2;
  }
  _triggerAction(e2) {
    const t2 = e2.currentTarget.dataset.actionUid, { allActions: i2 } = this.viewModel, o2 = i2.findIndex((e3) => e3.uid === t2), n2 = i2.getItemAt(o2);
    n2 && n2.type === "toggle" && (n2.value = !n2.value), this.actionsMenuOpen = false, this.viewModel.triggerAction(o2);
  }
  _selectFeature(e2) {
    const t2 = e2.currentTarget["data-feature-index"];
    isNaN(t2) || (this.viewModel.selectedFeatureIndex = t2), this.featureMenuOpen = false, this._focusFeatureMenuButton = true, this.scheduleRender();
  }
  _next() {
    this.next();
  }
  _previous() {
    this.previous();
  }
};
e$1W([y$1o({ readOnly: true })], V$1.prototype, "actionsMenuId", null), e$1W([y$1o({ readOnly: true })], V$1.prototype, "actionsMenuButtonId", null), e$1W([y$1o({ readOnly: true })], V$1.prototype, "featureMenuId", null), e$1W([y$1o({ readOnly: true })], V$1.prototype, "titleId", null), e$1W([y$1o({ readOnly: true })], V$1.prototype, "contentId", null), e$1W([y$1o({ readOnly: true })], V$1.prototype, "hasContent", null), e$1W([y$1o({ readOnly: true })], V$1.prototype, "featureNavigationVisible", null), e$1W([y$1o({ readOnly: true })], V$1.prototype, "collapsible", null), e$1W([y$1o({ readOnly: true })], V$1.prototype, "featureMenuVisible", null), e$1W([y$1o({ readOnly: true })], V$1.prototype, "contentCollapsed", null), e$1W([y$1o({ readOnly: true })], V$1.prototype, "dividedActions", null), e$1W([y$1o({ readOnly: true, dependsOn: ["_flowItems.length"] })], V$1.prototype, "_activeFlowItemWidget", null), e$1W([y$1o()], V$1.prototype, "actions", null), e$1W([y$1o()], V$1.prototype, "actionsMenuOpen", null), e$1W([y$1o()], V$1.prototype, "alignment", void 0), e$1W([y$1o()], V$1.prototype, "autoCloseEnabled", null), e$1W([y$1o()], V$1.prototype, "autoOpenEnabled", null), e$1W([y$1o()], V$1.prototype, "defaultPopupTemplateEnabled", null), e$1W([y$1o()], V$1.prototype, "content", null), e$1W([y$1o()], V$1.prototype, "collapsed", void 0), e$1W([y$1o()], V$1.prototype, "collapseEnabled", void 0), e$1W([y$1o({ readOnly: true })], V$1.prototype, "currentAlignment", null), e$1W([y$1o({ readOnly: true })], V$1.prototype, "currentDockPosition", null), e$1W([y$1o()], V$1.prototype, "dockOptions", null), e$1W([y$1o()], V$1.prototype, "dockEnabled", void 0), e$1W([y$1o({ readOnly: true })], V$1.prototype, "featureCount", null), e$1W([y$1o()], V$1.prototype, "featureMenuOpen", void 0), e$1W([y$1o()], V$1.prototype, "features", null), e$1W([y$1o()], V$1.prototype, "goToOverride", null), e$1W([y$1o()], V$1.prototype, "headingLevel", void 0), e$1W([y$1o()], V$1.prototype, "highlightEnabled", null), e$1W([y$1o()], V$1.prototype, "location", null), e$1W([y$1o()], V$1.prototype, "label", null), e$1W([y$1o()], V$1.prototype, "maxInlineActions", void 0), e$1W([y$1o(), e$W("esri/widgets/Popup/t9n/Popup")], V$1.prototype, "messages", void 0), e$1W([y$1o(), e$W("esri/t9n/common")], V$1.prototype, "messagesCommon", void 0), e$1W([y$1o()], V$1.prototype, "promises", null), e$1W([y$1o({ readOnly: true })], V$1.prototype, "selectedFeature", null), e$1W([y$1o()], V$1.prototype, "selectedFeatureIndex", null), e$1W([y$1o({ readOnly: true })], V$1.prototype, "selectedFeatureWidget", null), e$1W([y$1o()], V$1.prototype, "spinnerEnabled", void 0), e$1W([y$1o()], V$1.prototype, "title", null), e$1W([y$1o()], V$1.prototype, "updateLocationEnabled", null), e$1W([y$1o()], V$1.prototype, "view", null), e$1W([y$1o({ type: H$2 }), e$T(["triggerAction", "trigger-action"])], V$1.prototype, "viewModel", void 0), e$1W([y$1o()], V$1.prototype, "visible", null), e$1W([y$1o()], V$1.prototype, "visibleElements", void 0), e$1W([s$1N("visibleElements")], V$1.prototype, "castVisibleElements", null), e$1W([t$Y()], V$1.prototype, "_close", null), e$1W([t$Y()], V$1.prototype, "_toggleDockEnabled", null), e$1W([t$Y()], V$1.prototype, "_toggleFeatureMenu", null), e$1W([t$Y()], V$1.prototype, "_toggleActionsMenu", null), e$1W([t$Y()], V$1.prototype, "_triggerAction", null), e$1W([t$Y()], V$1.prototype, "_selectFeature", null), e$1W([t$Y()], V$1.prototype, "_next", null), e$1W([t$Y()], V$1.prototype, "_previous", null), V$1 = e$1W([n$2f("esri.widgets.Popup")], V$1);
const U$4 = V$1;
const m$g = [0, 0];
function f$e(e2) {
  var _a2, _b2;
  const t2 = (e2.ownerDocument || window.document).defaultView, s2 = e2.getBoundingClientRect();
  return m$g[0] = s2.left + ((_a2 = t2 == null ? void 0 : t2.pageXOffset) != null ? _a2 : 0), m$g[1] = s2.top + ((_b2 = t2 == null ? void 0 : t2.pageYOffset) != null ? _b2 : 0), m$g;
}
function y$a(e2) {
  e2 && (t$15(e2), e2.parentNode && e2.parentNode.removeChild(e2));
}
function v$6(e2) {
  const t2 = document.createElement("div");
  return e2.appendChild(t2), t2;
}
const _$9 = 16, g$8 = 750, w$4 = 512, C$5 = 2, z$4 = (i2) => {
  let m2 = class extends i2 {
    constructor(...e2) {
      var _a2;
      super(...e2), this._freqInfo = { freq: _$9, time: g$8 }, this._overlayRenderTaskHandle = null, this.height = 0, this.overlay = null, this.position = null, this.resizing = false, this.root = null, this.surface = null, this.suspended = true, this.ui = null, this.userContent = null, this.width = 0, this.widthBreakpoint = null, e2.length !== 0 && ((_a2 = e2[0]) == null ? void 0 : _a2.popup) !== void 0 || (this.popup = new U$4({ view: this })), this.handles.add([l$1f(() => this.cursor, (e3) => {
        const { surface: t2 } = this;
        t2 && t2.setAttribute("data-cursor", e3);
      }), l$1f(() => this.interacting, (e3) => {
        const { surface: t2 } = this;
        t2 && t2.setAttribute("data-interacting", e3.toString());
      })]);
    }
    initialize() {
      this.handles.add(l$1f(() => this.ui, (e2, t2) => this._handleUIChange(e2, t2))), this._wireUI(this.ui), this.handles.add([this.on("focus", () => this.notifyChange("focused")), this.on("blur", () => this.notifyChange("focused"))]);
    }
    destroy() {
      this.destroyed || (this.ui = s$26(this.ui), this.popup && !this.popup.destroyed && this.popup.destroy(), this.container = null);
    }
    get container() {
      var _a2;
      return (_a2 = this._get("container")) != null ? _a2 : null;
    }
    set container(e2) {
      const i3 = this._get("container"), r2 = e$13(e2), l2 = r2 instanceof HTMLDivElement ? r2 : null;
      if (l2 || typeof e2 != "string" || s$22.getLogger(this.declaredClass).error("#container", `element with id '${e2}' not found`), i3 === l2)
        return;
      const u2 = "dom-size";
      if (this.handles.remove(u2), this._stopMeasuring(), i3 && (i3.classList.remove("esri-view"), this._overlayRenderTaskHandle && (this._overlayRenderTaskHandle.remove(), this._overlayRenderTaskHandle = null), this.overlay && (this.overlay.destroy(), this._set("overlay", null)), this.root && (y$a(this.root), this._set("root", null)), this.userContent && (r$Q(this.userContent, i3), y$a(this.userContent), this._set("userContent", null))), !l2)
        return this._set("width", 0), this._set("height", 0), this._set("position", null), this._set("suspended", true), this._set("surface", null), void this._set("container", null);
      l2.classList.add("esri-view");
      const c2 = document.createElement("div");
      c2.className = "esri-view-user-storage", r$Q(l2, c2), l2.appendChild(c2), this._set("userContent", c2);
      const m3 = document.createElement("div");
      m3.className = "esri-view-root", l2.insertBefore(m3, l2.firstChild), this._set("root", m3);
      const f2 = document.createElement("div");
      f2.className = "esri-view-surface", f2.setAttribute("role", "application"), f2.tabIndex = 0, m3.appendChild(f2), this._set("surface", f2);
      const v2 = new c$1B();
      m3.appendChild(v2.surface), this._set("overlay", v2), l$1f(() => v2.needsRender, (e3) => {
        e3 && !this._overlayRenderTaskHandle ? this._overlayRenderTaskHandle = A$o({ render: () => {
          var _a2;
          return (_a2 = this.overlay) == null ? void 0 : _a2.render();
        } }) : this._overlayRenderTaskHandle = h$1s(this._overlayRenderTaskHandle);
      }), this.forceDOMReadyCycle(), this.handles.add(l$1f(() => this.size, (e3) => {
        const [t2, s2] = e3, i4 = "esri-view-surface--inset-outline";
        t2 >= document.body.clientWidth || s2 >= document.body.clientHeight ? f2.classList.add(i4) : f2.classList.remove(i4);
      }, h$S), u2), this._set("container", l2), this._startMeasuring();
    }
    get focused() {
      const e2 = document.activeElement === this.surface;
      return document.hasFocus() && e2;
    }
    set popup(e2) {
      const t2 = this._get("popup");
      t2 && t2 !== e2 && t2.destroy(), this._set("popup", e2);
    }
    get size() {
      return [this.width, this.height];
    }
    blur() {
      this.surface && this.surface.blur();
    }
    focus() {
      this.surface && this.surface.focus();
    }
    pageToContainer(e2, t2, s2) {
      const i3 = this.position;
      return e2 -= i3 ? i3[0] : 0, t2 -= i3 ? i3[1] : 0, s2 ? (s2[0] = e2, s2[1] = t2) : s2 = [e2, t2], s2;
    }
    containerToPage(e2, t2, s2) {
      const i3 = this.position;
      return e2 += i3 ? i3[0] : 0, t2 += i3 ? i3[1] : 0, s2 ? (s2[0] = e2, s2[1] = t2) : s2 = [e2, t2], s2;
    }
    _handleUIChange(e2, t2) {
      t2 && (this.handles.remove("ui"), t2.destroy()), e2 && this._wireUI(e2), this._set("ui", e2);
    }
    _wireUI(e2) {
      this.handles.remove("ui"), e2 && (e2.view = this, this.handles.add([l$1f(() => this.root, (t2) => {
        e2.container = t2 ? v$6(t2) : null;
      }, h$S), l$1f(() => this.popup, (t2, s2) => {
        const i3 = "popup", o2 = "manual";
        s2 && e2.remove(s2, i3), t2 && (t2.view = e2.view, e2.add(t2, { key: i3, position: o2 }));
      }, h$S)], "ui"));
    }
    _stopMeasuring() {
      this.handles.remove("measuring"), this._get("resizing") && this._set("resizing", false);
    }
    _startMeasuring() {
      const e2 = this._freqInfo;
      e2.freq = _$9, e2.time = g$8, this.handles.add([(() => {
        const t2 = () => {
          e2.freq = _$9, e2.time = g$8;
        };
        return window.addEventListener("resize", t2), { remove() {
          window.removeEventListener("resize", t2);
        } };
      })(), A$o({ prepare: (e3) => {
        const t2 = this._measure(), s2 = this._freqInfo;
        if (s2.time += e3.deltaTime, t2 && (s2.freq = _$9, this._get("resizing") || this._set("resizing", true)), s2.time < s2.freq)
          return;
        s2.time = 0;
        const i3 = this._position();
        s2.freq = i3 || t2 ? _$9 : Math.min(g$8, s2.freq * C$5), !t2 && s2.freq >= w$4 && this._get("resizing") && this._set("resizing", false);
      } })], "measuring"), this._measure(), this._position();
    }
    _measure() {
      const e2 = this.container, t2 = e2 ? e2.clientWidth : 0, s2 = e2 ? e2.clientHeight : 0;
      if (t2 === 0 || s2 === 0)
        return this.suspended || this._set("suspended", true), false;
      const i3 = this.width, o2 = this.height;
      return t2 === i3 && s2 === o2 ? (this.suspended && this._set("suspended", false), false) : (this._set("width", t2), this._set("height", s2), this.suspended && this._set("suspended", false), this.emit("resize", { oldWidth: i3, oldHeight: o2, width: t2, height: s2 }), true);
    }
    _position() {
      const e2 = this.container, t2 = this.position, s2 = e2 && f$e(e2);
      return !!s2 && ((!t2 || s2[0] !== t2[0] || s2[1] !== t2[1]) && (this._set("position", [s2[0], s2[1]]), true));
    }
    forceDOMReadyCycle() {
    }
  };
  return e$1W([y$1o()], m2.prototype, "container", null), e$1W([y$1o({ readOnly: true })], m2.prototype, "focused", null), e$1W([y$1o({ readOnly: true })], m2.prototype, "height", void 0), e$1W([y$1o({ type: U$4 })], m2.prototype, "popup", null), e$1W([y$1o({ type: c$1B })], m2.prototype, "overlay", void 0), e$1W([y$1o({ readOnly: true })], m2.prototype, "position", void 0), e$1W([y$1o({ readOnly: true })], m2.prototype, "resizing", void 0), e$1W([y$1o({ readOnly: true })], m2.prototype, "root", void 0), e$1W([y$1o({ value: null, readOnly: true })], m2.prototype, "size", null), e$1W([y$1o({ readOnly: true })], m2.prototype, "surface", void 0), e$1W([y$1o({ readOnly: true })], m2.prototype, "suspended", void 0), e$1W([y$1o()], m2.prototype, "ui", void 0), e$1W([y$1o({ readOnly: true })], m2.prototype, "userContent", void 0), e$1W([y$1o({ readOnly: true })], m2.prototype, "width", void 0), e$1W([y$1o()], m2.prototype, "widthBreakpoint", void 0), m2 = e$1W([n$2f("esri.views.DOMContainer")], m2), m2;
};
const a$z = (a2) => {
  let p2 = class extends a2 {
    async fetchPopupFeatures(e2, r2) {
      await this.when();
      const { location: i2, queryArea: a3, layerViewsAndGraphics: p3, clientOnlyGraphics: t2 } = await this._prepareFetchPopupFeatures(e2, r2), o2 = Promise.resolve(t2), c2 = this._queryLayerPopupFeatures(a3, p3, r2), n2 = c2.map((e3) => e3.promise);
      return { location: i2, clientOnlyGraphics: t2, allGraphicsPromise: L$r([o2, ...n2]).then((e3) => Array.from(new Set(e3.flat()))), promisesPerLayerView: c2 };
    }
    _queryLayerPopupFeatures(e2, s2, i2) {
      return s2.map(({ layerView: s3, graphics: a3 }) => {
        const p3 = { clientGraphics: a3, event: r$1t(i2) ? i2.event : null, signal: r$1t(i2) ? i2.signal : null, defaultPopupTemplateEnabled: !!r$1t(i2) && !!i2.defaultPopupTemplateEnabled }, t2 = s3.fetchPopupFeatures(e2, p3);
        return { layerView: s3, promise: t2 };
      });
    }
    _isValidPopupGraphic(e2, s2) {
      return e2 && !!e2.getEffectivePopupTemplate(r$1t(s2) && s2.defaultPopupTemplateEnabled);
    }
    async _prepareFetchPopupFeatures(e2, r2) {
      const { clientGraphics: s2, queryArea: i2, location: a3 } = await this._popupHitTestGraphics(e2, r2), p3 = this._getFetchPopupLayerViews(), { layerViewsAndGraphics: t2, clientOnlyGraphics: o2 } = this._graphicsPerFetchPopupLayerView(s2, p3);
      return { clientOnlyGraphics: o2, layerViewsAndGraphics: t2, queryArea: i2, location: a3 };
    }
    async _popupHitTestGraphics(e2, r2) {
      const { results: s2, mapPoint: i2 } = await this.popupHitTest(e2), a3 = s2.filter((e3) => e3.type === "graphic" && this._isValidPopupGraphic(e3.graphic, r2)), p3 = a3.length ? a3[0].mapPoint : null;
      return { clientGraphics: a3.map((e3) => e3.graphic), queryArea: i2, location: i2 || p3 };
    }
    _getFetchPopupLayerViews() {
      const e2 = [];
      return this.allLayerViews.forEach((r2) => {
        this._isValidPopupLayerView(r2) && e2.push(r2);
      }), r$1t(this.graphicsView) && this._isValidPopupLayerView(this.graphicsView) && e2.push(this.graphicsView), e2.reverse();
    }
    _isValidPopupLayerView(e2) {
      return r$1t(e2) && (!("layer" in e2) || !e2.suspended) && "fetchPopupFeatures" in e2;
    }
    _graphicsPerFetchPopupLayerView(e2, r2) {
      const s2 = [], i2 = new Map(), a3 = r2.map((e3) => {
        const r3 = [];
        return "layer" in e3 ? i2.set(e3.layer, r3) : i2.set(e3.graphics, r3), { layerView: e3, graphics: r3 };
      });
      for (const p3 of e2) {
        const e3 = i2.get(p3.layer) || i2.get(p3.sourceLayer) || null;
        e3 ? e3.push(p3) : s2.push(p3);
      }
      return { layerViewsAndGraphics: a3, clientOnlyGraphics: s2 };
    }
  };
  return p2 = e$1W([n$2f("esri.views.PopupView")], p2), p2;
};
async function n$t(o2, r2) {
  return await o2.load(), i$u(o2, r2);
}
async function i$u(n2, i2) {
  const c2 = [], f2 = (...o2) => {
    for (const r2 of o2)
      t$1W(r2) || (Array.isArray(r2) ? f2(...r2) : j$F.isCollection(r2) ? r2.forEach((o3) => f2(o3)) : m$1g.isLoadable(r2) && c2.push(r2));
  };
  i2(f2);
  let e2 = null;
  if (await h$H(c2, async (o2) => {
    (await b$w(s$l(o2) ? o2.loadAll() : o2.load())).ok !== false || e2 || (e2 = o2);
  }), e2)
    throw e2.loadError;
  return n2;
}
function s$l(o2) {
  return "loadAll" in o2 && typeof o2.loadAll == "function";
}
async function a$y(e2) {
  if (!e2)
    return;
  const a2 = e2.includes("-vector") ? e2.slice(0, e2.indexOf("-vector")) : e2, s2 = await u$15("esri/t9n/basemaps");
  return s2[e2] || s2[a2];
}
const s$k = { streets: { id: "streets", classic: true, deprecated: true, get thumbnailUrl() {
  return a$1G("esri/images/basemap/streets.jpg");
}, baseMapLayers: [{ id: "streets-base-layer", url: "//services.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer", layerType: "ArcGISTiledMapServiceLayer", title: "World Street Map", showLegend: false, visibility: true, opacity: 1 }] }, satellite: { id: "satellite", classic: true, get thumbnailUrl() {
  return a$1G("esri/images/basemap/satellite.jpg");
}, baseMapLayers: [{ id: "satellite-base-layer", url: "//services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer", layerType: "ArcGISTiledMapServiceLayer", title: "World Imagery", showLegend: false, visibility: true, opacity: 1 }] }, hybrid: { id: "hybrid", classic: true, get thumbnailUrl() {
  return a$1G("esri/images/basemap/hybrid.jpg");
}, baseMapLayers: [{ id: "hybrid-base-layer", url: "//services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer", layerType: "ArcGISTiledMapServiceLayer", title: "World Imagery", showLegend: false, visibility: true, opacity: 1 }, { id: "hybrid-reference-layer", styleUrl: "https://cdn.arcgis.com/sharing/rest/content/items/30d6b8271e1849cd9c3042060001f425/resources/styles/root.json", layerType: "VectorTileLayer", title: "Hybrid Reference Layer", isReference: true, showLegend: false, visibility: true, opacity: 1 }] }, terrain: { id: "terrain", classic: true, get thumbnailUrl() {
  return a$1G("esri/images/basemap/terrain.jpg");
}, baseMapLayers: [{ id: "terrain-base-layer", url: "//services.arcgisonline.com/ArcGIS/rest/services/World_Terrain_Base/MapServer", layerType: "ArcGISTiledMapServiceLayer", title: "World Terrain Base", showLegend: false, visibility: true, opacity: 1 }, { id: "terrain-reference-layer", url: "//services.arcgisonline.com/ArcGIS/rest/services/Reference/World_Reference_Overlay/MapServer", layerType: "ArcGISTiledMapServiceLayer", title: "World Reference Overlay", isReference: true, showLegend: false, visibility: true, opacity: 1 }] }, topo: { id: "topo", classic: true, deprecated: true, get thumbnailUrl() {
  return a$1G("esri/images/basemap/topo.jpg");
}, baseMapLayers: [{ id: "topo-base-layer", url: "//services.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer", layerType: "ArcGISTiledMapServiceLayer", title: "World Topo Map", showLegend: false, visibility: true, opacity: 1 }] }, gray: { id: "gray", classic: true, deprecated: true, get thumbnailUrl() {
  return a$1G("esri/images/basemap/gray.jpg");
}, baseMapLayers: [{ id: "gray-base-layer", url: "//services.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Light_Gray_Base/MapServer", layerType: "ArcGISTiledMapServiceLayer", title: "World Light Gray Base", showLegend: false, visibility: true, opacity: 1 }, { id: "gray-reference-layer", url: "//services.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Light_Gray_Reference/MapServer", layerType: "ArcGISTiledMapServiceLayer", title: "World Light Gray Reference", isReference: true, showLegend: false, visibility: true, opacity: 1 }] }, "dark-gray": { id: "dark-gray", classic: true, deprecated: true, get thumbnailUrl() {
  return a$1G("esri/images/basemap/dark-gray.jpg");
}, baseMapLayers: [{ id: "dark-gray-base-layer", url: "//services.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Dark_Gray_Base/MapServer", layerType: "ArcGISTiledMapServiceLayer", title: "World Dark Gray Base", showLegend: false, visibility: true, opacity: 1 }, { id: "dark-gray-reference-layer", url: "//services.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Dark_Gray_Reference/MapServer", layerType: "ArcGISTiledMapServiceLayer", title: "World Dark Gray Reference", isReference: true, showLegend: false, visibility: true, opacity: 1 }] }, oceans: { id: "oceans", classic: true, get thumbnailUrl() {
  return a$1G("esri/images/basemap/oceans.jpg");
}, baseMapLayers: [{ id: "oceans-base-layer", url: "//services.arcgisonline.com/arcgis/rest/services/Ocean/World_Ocean_Base/MapServer", layerType: "ArcGISTiledMapServiceLayer", title: "World Ocean Base", showLegend: false, visibility: true, opacity: 1 }, { id: "oceans-reference-layer", url: "//services.arcgisonline.com/arcgis/rest/services/Ocean/World_Ocean_Reference/MapServer", layerType: "ArcGISTiledMapServiceLayer", title: "World Ocean Reference", isReference: true, showLegend: false, visibility: true, opacity: 1 }] }, "national-geographic": { id: "national-geographic", classic: true, deprecated: true, get thumbnailUrl() {
  return a$1G("esri/images/basemap/national-geographic.jpg");
}, baseMapLayers: [{ id: "national-geographic-base-layer", url: "//services.arcgisonline.com/ArcGIS/rest/services/NatGeo_World_Map/MapServer", title: "NatGeo World Map", showLegend: false, layerType: "ArcGISTiledMapServiceLayer", visibility: true, opacity: 1 }] }, osm: { id: "osm", classic: true, get thumbnailUrl() {
  return a$1G("esri/images/basemap/osm.jpg");
}, baseMapLayers: [{ id: "osm-base-layer", layerType: "OpenStreetMap", title: "Open Street Map", showLegend: false, visibility: true, opacity: 1 }] }, "dark-gray-vector": { id: "dark-gray-vector", classic: true, get thumbnailUrl() {
  return a$1G("esri/images/basemap/dark-gray-vector.jpg");
}, baseMapLayers: [{ id: "dark-gray-base-layer", styleUrl: "https://cdn.arcgis.com/sharing/rest/content/items/5e9b3685f4c24d8781073dd928ebda50/resources/styles/root.json", layerType: "VectorTileLayer", title: "Dark Gray Base", visibility: true, opacity: 1 }, { id: "dark-gray-reference-layer", styleUrl: "https://cdn.arcgis.com/sharing/rest/content/items/747cb7a5329c478cbe6981076cc879c5/resources/styles/root.json", layerType: "VectorTileLayer", title: "Dark Gray Reference", isReference: true, visibility: true, opacity: 1 }] }, "gray-vector": { id: "gray-vector", classic: true, get thumbnailUrl() {
  return a$1G("esri/images/basemap/gray-vector.jpg");
}, baseMapLayers: [{ id: "gray-base-layer", styleUrl: "https://cdn.arcgis.com/sharing/rest/content/items/291da5eab3a0412593b66d384379f89f/resources/styles/root.json", layerType: "VectorTileLayer", title: "Light Gray Base", visibility: true, opacity: 1 }, { id: "gray-reference-layer", styleUrl: "https://cdn.arcgis.com/sharing/rest/content/items/1768e8369a214dfab4e2167d5c5f2454/resources/styles/root.json", layerType: "VectorTileLayer", title: "Light Gray Reference", isReference: true, visibility: true, opacity: 1 }] }, "streets-vector": { id: "streets-vector", classic: true, get thumbnailUrl() {
  return a$1G("esri/images/basemap/streets-vector.jpg");
}, baseMapLayers: [{ id: "streets-vector-base-layer", styleUrl: "//cdn.arcgis.com/sharing/rest/content/items/de26a3cf4cc9451298ea173c4b324736/resources/styles/root.json", layerType: "VectorTileLayer", title: "World Streets", visibility: true, opacity: 1 }] }, "topo-vector": { id: "topo-vector", classic: true, get thumbnailUrl() {
  return a$1G("esri/images/basemap/topo-vector.jpg");
}, baseMapLayers: [{ id: "world-hillshade-layer", url: "//services.arcgisonline.com/arcgis/rest/services/Elevation/World_Hillshade/MapServer", layerType: "ArcGISTiledMapServiceLayer", title: "World Hillshade", showLegend: false, visibility: true, opacity: 1 }, { id: "topo-vector-base-layer", styleUrl: "//cdn.arcgis.com/sharing/rest/content/items/7dc6cea0b1764a1f9af2e679f642f0f5/resources/styles/root.json", layerType: "VectorTileLayer", title: "World Topo", visibility: true, opacity: 1 }] }, "streets-night-vector": { id: "streets-night-vector", classic: true, get thumbnailUrl() {
  return a$1G("esri/images/basemap/streets-night.jpg");
}, baseMapLayers: [{ id: "streets-night-vector-base-layer", styleUrl: "//cdn.arcgis.com/sharing/rest/content/items/86f556a2d1fd468181855a35e344567f/resources/styles/root.json", layerType: "VectorTileLayer", title: "World Streets Night", visibility: true, opacity: 1 }] }, "streets-relief-vector": { id: "streets-relief-vector", classic: true, get thumbnailUrl() {
  return a$1G("esri/images/basemap/streets-relief.jpg");
}, baseMapLayers: [{ id: "world-hillshade-layer", url: "//services.arcgisonline.com/arcgis/rest/services/Elevation/World_Hillshade/MapServer", layerType: "ArcGISTiledMapServiceLayer", title: "World Hillshade", showLegend: false, visibility: true, opacity: 1 }, { id: "streets-relief-vector-base-layer", styleUrl: "//www.arcgis.com/sharing/rest/content/items/b266e6d17fc345b498345613930fbd76/resources/styles/root.json", title: "World Streets Relief", layerType: "VectorTileLayer", visibility: true, opacity: 1 }] }, "streets-navigation-vector": { id: "streets-navigation-vector", classic: true, get thumbnailUrl() {
  return a$1G("esri/images/basemap/streets-navigation.jpg");
}, baseMapLayers: [{ id: "streets-navigation-vector-base-layer", styleUrl: "//cdn.arcgis.com/sharing/rest/content/items/63c47b7177f946b49902c24129b87252/resources/styles/root.json", layerType: "VectorTileLayer", title: "World Streets Navigation", visibility: true, opacity: 1 }] }, "arcgis-imagery": { get thumbnailUrl() {
  return a$1G("esri/images/basemap/hybrid.jpg");
}, title: "Imagery Hybrid", baseMapLayers: [{ layerType: "ArcGISTiledMapServiceLayer", showLegend: false, title: "World Imagery", url: "https://ibasemaps-api.arcgis.com/arcgis/rest/services/World_Imagery/MapServer" }, { layerType: "VectorTileLayer", styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/ArcGIS:Imagery:Labels", title: "Hybrid Reference Layer", isReference: true }] }, "arcgis-imagery-standard": { get thumbnailUrl() {
  return a$1G("esri/images/basemap/satellite.jpg");
}, title: "Imagery", baseMapLayers: [{ layerType: "ArcGISTiledMapServiceLayer", showLegend: false, title: "World Imagery", url: "https://ibasemaps-api.arcgis.com/arcgis/rest/services/World_Imagery/MapServer" }] }, "arcgis-imagery-labels": { title: "Hybrid [Reference]", baseMapLayers: [{ layerType: "VectorTileLayer", styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/ArcGIS:Imagery:Labels", title: "Hybrid Reference Layer", isReference: true }] }, "arcgis-light-gray": { get thumbnailUrl() {
  return a$1G("esri/images/basemap/gray-vector.jpg");
}, title: "Light Gray Canvas", baseMapLayers: [{ layerType: "VectorTileLayer", styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/ArcGIS:LightGray:Base", title: "Light Gray Canvas Base" }, { layerType: "VectorTileLayer", styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/ArcGIS:LightGray:Labels", title: "Light Gray Canvas Labels", isReference: true }] }, "arcgis-dark-gray": { get thumbnailUrl() {
  return a$1G("esri/images/basemap/dark-gray.jpg");
}, title: "Dark Gray Canvas", baseMapLayers: [{ layerType: "VectorTileLayer", styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/ArcGIS:DarkGray:Base", title: "Dark Gray Canvas Base" }, { layerType: "VectorTileLayer", styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/ArcGIS:DarkGray:Labels", title: "Dark Gray Canvas Labels", isReference: true }] }, "arcgis-navigation": { get thumbnailUrl() {
  return a$1G("esri/images/basemap/streets-navigation.jpg");
}, title: "Navigation", baseMapLayers: [{ layerType: "VectorTileLayer", styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/ArcGIS:Navigation", title: "World Navigation Map" }] }, "arcgis-navigation-night": { title: "Navigation (Dark Mode)", baseMapLayers: [{ layerType: "VectorTileLayer", styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/ArcGIS:NavigationNight", title: "World Navigation Map (Dark Mode)" }] }, "arcgis-streets": { get thumbnailUrl() {
  return a$1G("esri/images/basemap/streets-vector.jpg");
}, title: "Streets", baseMapLayers: [{ layerType: "VectorTileLayer", styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/ArcGIS:Streets", title: "World Street Map" }] }, "arcgis-streets-night": { get thumbnailUrl() {
  return a$1G("esri/images/basemap/streets-night.jpg");
}, title: "Streets (Night)", baseMapLayers: [{ layerType: "VectorTileLayer", styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/ArcGIS:StreetsNight", title: "World Street Map (Night)" }] }, "arcgis-streets-relief": { get thumbnailUrl() {
  return a$1G("esri/images/basemap/streets-relief.jpg");
}, title: "Streets (with Relief)", baseMapLayers: [{ layerType: "ArcGISTiledMapServiceLayer", showLegend: false, title: "World Hillshade", url: "https://ibasemaps-api.arcgis.com/arcgis/rest/services/Elevation/World_Hillshade/MapServer" }, { layerType: "VectorTileLayer", styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/ArcGIS:StreetsRelief:Base", title: "World Street Map (with Relief)" }] }, "arcgis-topographic": { get thumbnailUrl() {
  return a$1G("esri/images/basemap/topo.jpg");
}, title: "Topographic", baseMapLayers: [{ layerType: "ArcGISTiledMapServiceLayer", showLegend: false, title: "World Hillshade", url: "https://ibasemaps-api.arcgis.com/arcgis/rest/services/Elevation/World_Hillshade/MapServer" }, { layerType: "VectorTileLayer", styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/ArcGIS:Topographic:Base", title: "World Topographic Map" }] }, "arcgis-oceans": { get thumbnailUrl() {
  return a$1G("esri/images/basemap/oceans.jpg");
}, title: "Oceans", baseMapLayers: [{ layerType: "ArcGISTiledMapServiceLayer", showLegend: false, title: "World Ocean Base", url: "https://ibasemaps-api.arcgis.com/arcgis/rest/services/Ocean/World_Ocean_Base/MapServer" }, { layerType: "VectorTileLayer", styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/ArcGIS:Oceans:Labels", title: "World Ocean Reference", isReference: true }] }, "osm-standard": { title: "OpenStreetMap", baseMapLayers: [{ layerType: "VectorTileLayer", styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/OSM:Standard", title: "OpenStreetMap" }] }, "osm-standard-relief": { title: "OpenStreetMap (with relief)", baseMapLayers: [{ layerType: "ArcGISTiledMapServiceLayer", showLegend: false, title: "World Hillshade", url: "https://ibasemaps-api.arcgis.com/arcgis/rest/services/Elevation/World_Hillshade/MapServer" }, { styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/OSM:StandardRelief:Base", layerType: "VectorTileLayer", title: "OpenStreetMap Relief Base" }] }, "osm-streets": { title: "OpenStreetMap (Streets)", baseMapLayers: [{ layerType: "VectorTileLayer", styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/OSM:Streets", title: "OpenStreetMap (Streets)" }] }, "osm-streets-relief": { title: "OpenStreetMap (Streets with relief)", baseMapLayers: [{ layerType: "ArcGISTiledMapServiceLayer", showLegend: false, title: "World Hillshade", url: "https://ibasemaps-api.arcgis.com/arcgis/rest/services/Elevation/World_Hillshade/MapServer" }, { styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/OSM:StreetsRelief:Base", layerType: "VectorTileLayer", title: "OpenStreetMap Relief Base" }] }, "osm-light-gray": { title: "OpenStreetMap (Light Gray Canvas)", baseMapLayers: [{ layerType: "VectorTileLayer", styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/OSM:LightGray:Base", title: "OSM (Light Gray Base)" }, { layerType: "VectorTileLayer", styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/OSM:LightGray:Labels", title: "OSM (Light Gray Reference)", isReference: true }] }, "osm-dark-gray": { title: "OpenStreetMap (Dark Gray Canvas)", baseMapLayers: [{ layerType: "VectorTileLayer", styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/OSM:DarkGray:Base", title: "OSM (Dark Gray Base)" }, { layerType: "VectorTileLayer", styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/OSM:DarkGray:Labels", title: "OSM (Dark Gray Reference)", isReference: true }] }, "arcgis-terrain": { title: "Terrain with Labels", baseMapLayers: [{ layerType: "ArcGISTiledMapServiceLayer", showLegend: false, title: "World Hillshade", url: "https://ibasemaps-api.arcgis.com/arcgis/rest/services/Elevation/World_Hillshade/MapServer" }, { layerType: "VectorTileLayer", styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/ArcGIS:Terrain:Base", title: "World Terrain Base" }, { layerType: "VectorTileLayer", styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/ArcGIS:Terrain:Detail", title: "World Terrain Reference", isReference: true }] }, "arcgis-community": { title: "Community", baseMapLayers: [{ layerType: "VectorTileLayer", styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/ArcGIS:Community", title: "Community" }] }, "arcgis-charted-territory": { title: "Charted Territory", baseMapLayers: [{ layerType: "ArcGISTiledMapServiceLayer", showLegend: false, title: "World Hillshade", url: "https://ibasemaps-api.arcgis.com/arcgis/rest/services/Elevation/World_Hillshade/MapServer" }, { layerType: "VectorTileLayer", styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/ArcGIS:ChartedTerritory:Base", title: "Charted Territory" }] }, "arcgis-colored-pencil": { title: "Colored Pencil", baseMapLayers: [{ layerType: "VectorTileLayer", styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/ArcGIS:ColoredPencil", title: "Colored Pencil" }] }, "arcgis-nova": { title: "Nova", baseMapLayers: [{ layerType: "VectorTileLayer", styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/ArcGIS:Nova", title: "Nova" }] }, "arcgis-modern-antique": { title: "Modern Antique", baseMapLayers: [{ layerType: "ArcGISTiledMapServiceLayer", showLegend: false, title: "World Hillshade", url: "https://ibasemaps-api.arcgis.com/arcgis/rest/services/Elevation/World_Hillshade/MapServer" }, { layerType: "VectorTileLayer", styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/ArcGIS:ModernAntique:Base", title: "Modern Antique" }] }, "arcgis-midcentury": { title: "Mid-Century", baseMapLayers: [{ layerType: "VectorTileLayer", styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/ArcGIS:Midcentury", title: "Mid-Century" }] }, "arcgis-newspaper": { title: "Newspaper", baseMapLayers: [{ layerType: "VectorTileLayer", styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/ArcGIS:Newspaper", title: "Newspaper" }] }, "arcgis-hillshade-light": { title: "Hillshade", baseMapLayers: [{ layerType: "ArcGISTiledMapServiceLayer", showLegend: false, title: "World Hillshade", url: "https://ibasemaps-api.arcgis.com/arcgis/rest/services/Elevation/World_Hillshade/MapServer" }] }, "arcgis-hillshade-dark": { title: "Hillshade (Dark)", baseMapLayers: [{ layerType: "ArcGISTiledMapServiceLayer", showLegend: false, title: "World Hillshade (Dark)", url: "https://ibasemaps-api.arcgis.com/arcgis/rest/services/Elevation/World_Hillshade_Dark/MapServer" }] }, "arcgis-human-geography": { title: "Human Geography", baseMapLayers: [{ layerType: "VectorTileLayer", styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/ArcGIS:HumanGeography:Base", title: "Human Geography Base" }, { layerType: "VectorTileLayer", styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/ArcGIS:HumanGeography:Detail", title: "Human Geography Detail", isReference: true }, { layerType: "VectorTileLayer", styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/ArcGIS:HumanGeography:Label", title: "Human Geography Label", isReference: true }] }, "arcgis-human-geography-dark": { title: "Human Geography (Dark)", baseMapLayers: [{ layerType: "VectorTileLayer", styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/ArcGIS:HumanGeographyDark:Base", title: "Human Geography Dark Base" }, { layerType: "VectorTileLayer", styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/ArcGIS:HumanGeographyDark:Detail", title: "Human Geography Dark Detail", isReference: true }, { layerType: "VectorTileLayer", styleUrl: "https://basemaps-api.arcgis.com/arcgis/rest/services/styles/ArcGIS:HumanGeographyDark:Label", title: "Human Geography Dark Label", isReference: true }] } };
function l$q(e2) {
  var _a2;
  return (e2 == null ? void 0 : e2.type) === "feature" && !e2.url && ((_a2 = e2.source) == null ? void 0 : _a2.type) === "memory";
}
function o$l(e2) {
  var _a2;
  return (e2 == null ? void 0 : e2.type) === "feature" && ((_a2 = e2.source) == null ? void 0 : _a2.type) === "feature-layer";
}
const l$p = new Set(["bing-maps", "imagery", "imagery-tile", "map-image", "open-street-map", "tile", "unknown", "unsupported", "vector-tile", "web-tile", "wms", "wmts"]), a$x = new Set(["csv", "feature", "geo-rss", "geojson", "group", "imagery", "imagery-tile", "kml", "map-image", "map-notes", "ogc-feature", "route", "subtype-group", "tile", "unknown", "unsupported", "vector-tile", "web-tile", "wfs", "wms", "wmts"]);
function m$f(e2) {
  return e2.layerContainerType === "basemap" ? l$p : e2.layerContainerType === "operational-layers" ? a$x : null;
}
function c$r(e2, t2) {
  if (t2.restrictedWebMapWriting) {
    const r2 = m$f(t2);
    return !r$1t(r2) || r2.has(e2.type) && !l$q(e2);
  }
  return true;
}
function u$k(e2, t2) {
  if (l$q(e2)) {
    const n2 = t$1T("featureCollection.layers", t2), i2 = n2 && n2[0] && n2[0].layerDefinition;
    i2 && d$d(e2, i2);
  } else if (e2.type === "stream") {
    d$d(e2, t2.layerDefinition = t2.layerDefinition || {});
  } else
    e2.type !== "group" && d$d(e2, t2);
}
function d$d(e2, t2) {
  "maxScale" in e2 && (t2.maxScale = y$1l(e2.maxScale)), "minScale" in e2 && (t2.minScale = y$1l(e2.minScale));
}
function f$d(e2, t2) {
  if (u$k(e2, t2), "blendMode" in e2 && (t2.blendMode = e2.blendMode, t2.blendMode === "normal" && delete t2.blendMode), t2.opacity = y$1l(e2.opacity), t2.title = e2.title || "Layer", t2.visibility = e2.visible, "legendEnabled" in e2 && e2.type !== "wmts")
    if (l$q(e2)) {
      const n2 = t2.featureCollection;
      n2 && (n2.showLegend = e2.legendEnabled);
    } else
      t2.showLegend = e2.legendEnabled;
}
function y$9(r2, i2, o2) {
  if (!("write" in r2) || !r2.write)
    return o2 && o2.messages && o2.messages.push(new s$1Z("layer:unsupported", `Layers (${r2.title}, ${r2.id}) of type '${r2.declaredClass}' cannot be persisted`, { layer: r2 })), null;
  if (c$r(r2, o2)) {
    const e2 = {};
    return r2.write(e2, o2) ? e2 : null;
  }
  return r$1t(i2) && f$d(r2, i2 = y$1r(i2)), i2;
}
var v$5;
let S$4 = 0;
const _$8 = "esri.Basemap";
let U$3 = v$5 = class extends u$1N(m$1g) {
  constructor(e2) {
    super(e2), this.id = null, this.portalItem = null, this.spatialReference = null, this.thumbnailUrl = null, this.title = "Basemap", this.id = Date.now().toString(16) + "-basemap-" + S$4++, this.baseLayers = new j$F(), this.referenceLayers = new j$F();
    const t2 = (e3) => {
      e3.parent && e3.parent !== this && "remove" in e3.parent && e3.parent.remove(e3), e3.parent = this, e3.type === "elevation" && s$22.getLogger(this.declaredClass).error(`Layer '${e3.title}, id:${e3.id}' of type '${e3.type}' is not supported as a basemap layer and will therefore be ignored.`);
    }, s2 = (e3) => {
      e3.parent = null;
    };
    this.baseLayers.on("after-add", (e3) => t2(e3.item)), this.referenceLayers.on("after-add", (e3) => t2(e3.item)), this.baseLayers.on("after-remove", (e3) => s2(e3.item)), this.referenceLayers.on("after-remove", (e3) => s2(e3.item));
  }
  initialize() {
    this.when().catch((e2) => {
      s$22.getLogger(this.declaredClass).error("#load()", `Failed to load basemap (title: '${this.title}', id: '${this.id}')`, e2);
    }), this.resourceInfo && this.read(this.resourceInfo.data, this.resourceInfo.context);
  }
  destroy() {
    var _a2;
    const e2 = this.baseLayers.removeAll();
    for (const t2 of e2)
      t2.destroy();
    const r2 = this.referenceLayers.removeAll();
    for (const t2 of r2)
      t2.destroy();
    this.baseLayers.destroy(), this.referenceLayers.destroy(), (_a2 = this.portalItem) == null ? void 0 : _a2.destroy(), this.portalItem = null;
  }
  normalizeCtorArgs(e2) {
    return e2 && "resourceInfo" in e2 && (this._set("resourceInfo", e2.resourceInfo), delete (e2 = __spreadValues({}, e2)).resourceInfo), e2;
  }
  set baseLayers(e2) {
    this._set("baseLayers", n$1N(e2, this._get("baseLayers")));
  }
  _writeBaseLayers(e2, r2, t2) {
    const s2 = [];
    e2 ? (t2 = __spreadProps(__spreadValues({}, t2), { layerContainerType: "basemap" }), this.baseLayers.forEach((e3) => {
      const r3 = y$9(e3, t2.webmap ? t2.webmap.getLayerJSONFromResourceInfo(e3) : null, t2);
      r$1t(r3) && s2.push(r3);
    }), this.referenceLayers.forEach((e3) => {
      const r3 = y$9(e3, t2.webmap ? t2.webmap.getLayerJSONFromResourceInfo(e3) : null, t2);
      r$1t(r3) && (r3.isReference = true, s2.push(r3));
    }), r2.baseMapLayers = s2) : r2.baseMapLayers = s2;
  }
  set referenceLayers(e2) {
    this._set("referenceLayers", n$1N(e2, this._get("referenceLayers")));
  }
  writeTitle(e2, r2) {
    r2.title = e2 || "Basemap";
  }
  load(e2) {
    return this.addResolvingPromise(this._loadFromSource(e2)), Promise.resolve(this);
  }
  loadAll() {
    return n$t(this, (e2) => {
      e2(this.baseLayers, this.referenceLayers);
    });
  }
  clone() {
    const e2 = { id: this.id, title: this.title, portalItem: this.portalItem, baseLayers: this.baseLayers.slice(), referenceLayers: this.referenceLayers.slice() };
    return this.loaded && (e2.loadStatus = "loaded"), new v$5({ resourceInfo: this.resourceInfo }).set(e2);
  }
  read(e2, r2) {
    this.resourceInfo || this._set("resourceInfo", { data: e2, context: r2 }), super.read(e2, r2);
  }
  write(e2, r2) {
    return e2 = e2 || {}, r2 && r2.origin || (r2 = __spreadValues({ origin: "web-map" }, r2)), super.write(e2, r2), !this.loaded && this.resourceInfo && this.resourceInfo.data.baseMapLayers && (e2.baseMapLayers = this.resourceInfo.data.baseMapLayers.map((e3) => {
      const r3 = y$1r(e3);
      return r3.url && ft$2(r3.url) && (r3.url = `https:${r3.url}`), r3.templateUrl && ft$2(r3.templateUrl) && (r3.templateUrl = `https:${r3.templateUrl}`), r3;
    })), e2;
  }
  async _loadFromSource(e2) {
    const { resourceInfo: r2, portalItem: t2 } = this;
    f$1x(e2);
    const s2 = [];
    if (r2) {
      const t3 = r2.context ? r2.context.url : null;
      if (s2.push(this._loadLayersFromJSON(r2.data, t3, e2)), r2.data.id && !r2.data.title) {
        const e3 = r2.data.id;
        s2.push(a$y(e3).then((e4) => {
          e4 && this.read({ title: e4 }, r2.context);
        }));
      }
    } else
      t2 && s2.push(this._loadFromItem(t2, e2));
    await Promise.all(s2);
  }
  async _loadLayersFromJSON(e2, r2, t2) {
    const s2 = this.resourceInfo && this.resourceInfo.context, o2 = this.portalItem && this.portalItem.portal || s2 && s2.portal || null, a2 = s2 && s2.origin === "web-scene" ? "web-scene" : "web-map", { populateOperationalLayers: i2 } = await import("./layersCreator.js"), n2 = [];
    if (f$1x(t2), e2.baseMapLayers && Array.isArray(e2.baseMapLayers)) {
      const t3 = { context: { origin: a2, url: r2, portal: o2, layerContainerType: "basemap" }, defaultLayerType: "DefaultTileLayer" }, s3 = i2(this.baseLayers, e2.baseMapLayers.filter((e3) => !e3.isReference), t3);
      n2.push(s3);
      const l2 = i2(this.referenceLayers, e2.baseMapLayers.filter((e3) => e3.isReference), t3);
      n2.push(l2);
    }
    await E$v(n2);
  }
  async _loadFromItem(e2, r2) {
    var _a2, _b2;
    const t2 = await e2.load(r2), s2 = await t2.fetchData("json", r2), o2 = j$B((_a2 = e2.itemUrl) != null ? _a2 : "");
    return this._set("resourceInfo", { data: (_b2 = s2.baseMap) != null ? _b2 : {}, context: { origin: "web-map", portal: e2.portal || j$y.getDefault(), url: o2 } }), this.read(this.resourceInfo.data, this.resourceInfo.context), this.read({ spatialReference: s2.spatialReference }, this.resourceInfo.context), this.read({ title: e2.title, thumbnailUrl: e2.thumbnailUrl }, { origin: "portal-item", portal: e2.portal || j$y.getDefault(), url: o2 }), this._loadLayersFromJSON(this.resourceInfo.data, o2, r2);
  }
  static fromId(e2) {
    const r2 = s$k[e2];
    if (r2) {
      if (r2.deprecated) {
        let r3 = null;
        e2 === "dark-gray" ? r3 = "dark-gray-vector" : e2 === "gray" ? r3 = "gray-vector" : e2 === "streets" ? r3 = "streets-vector" : e2 === "topo" && (r3 = "topo-vector"), r$1k(s$22.getLogger(_$8), `The ${e2} basemap has entered mature support and is no longer being updated.`, { replacement: r3, see: "https://arcg.is/1iq8aD", warnOnce: true });
      }
      return v$5.fromJSON(r2);
    }
    return null;
  }
};
e$1W([y$1o({ json: { write: { ignoreOrigin: true, target: "baseMapLayers", writer(e2, r2, t2, s2) {
  this._writeBaseLayers(e2, r2, s2);
} }, origins: { "web-scene": { write: { ignoreOrigin: true, target: { baseMapLayers: { type: j$F } }, writer(e2, r2, t2, s2) {
  this._writeBaseLayers(e2, r2, s2);
} } } } } })], U$3.prototype, "baseLayers", null), e$1W([y$1o({ type: String, json: { origins: { "web-scene": { write: true } } } })], U$3.prototype, "id", void 0), e$1W([y$1o({ type: x$7 })], U$3.prototype, "portalItem", void 0), e$1W([y$1o()], U$3.prototype, "referenceLayers", null), e$1W([y$1o({ readOnly: true })], U$3.prototype, "resourceInfo", void 0), e$1W([y$1o({ type: k$p })], U$3.prototype, "spatialReference", void 0), e$1W([y$1o()], U$3.prototype, "thumbnailUrl", void 0), e$1W([y$1o({ type: String, json: { origins: { "web-scene": { write: { isRequired: true } } } } })], U$3.prototype, "title", void 0), e$1W([r$1h("title")], U$3.prototype, "writeTitle", null), U$3 = v$5 = e$1W([n$2f(_$8)], U$3);
const x$4 = U$3;
var Basemap = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": x$4
});
var t$l;
let p$t = t$l = class extends l$1_ {
  constructor(r2) {
    super(r2), this.type = "none";
  }
  clone() {
    return new t$l({ type: this.type });
  }
};
e$1W([r$1a({ none: "none", stayAbove: "stay-above" })], p$t.prototype, "type", void 0), p$t = t$l = e$1W([n$2f("esri.ground.NavigationConstraint")], p$t);
let T$2 = class extends m$1L {
  constructor() {
    super(...arguments), this.SCENEVIEW_HITTEST_RETURN_INTERSECTOR = false, this.DECONFLICTOR_SHOW_VISIBLE = false, this.DECONFLICTOR_SHOW_INVISIBLE = false, this.DECONFLICTOR_SHOW_GRID = false, this.LABELS_SHOW_BORDER = false, this.TEXT_SHOW_BASELINE = false, this.TEXT_SHOW_BORDER = false, this.OVERLAY_DRAW_DEBUG_TEXTURE = false, this.OVERLAY_SHOW_CENTER = false, this.SHOW_POI = false, this.TESTS_DISABLE_OPTIMIZATIONS = false, this.TESTS_DISABLE_FAST_UPDATES = false, this.DRAW_MESH_GEOMETRY_NORMALS = false, this.FEATURE_TILE_FETCH_SHOW_TILES = false, this.FEATURE_TILE_TREE_SHOW_TILES = false, this.TERRAIN_TILE_TREE_SHOW_TILES = false, this.I3S_TREE_SHOW_TILES = false, this.I3S_SHOW_MODIFICATIONS = false, this.LOD_INSTANCE_RENDERER_DISABLE_UPDATES = false, this.LOD_INSTANCE_RENDERER_COLORIZE_BY_LEVEL = false, this.EDGES_SHOW_HIDDEN_TRANSPARENT_EDGES = false, this.LINE_WIREFRAMES = false, this.TERRAIN_USE_LEGACY_SHADING = false;
  }
};
e$1W([y$1o()], T$2.prototype, "SCENEVIEW_HITTEST_RETURN_INTERSECTOR", void 0), e$1W([y$1o()], T$2.prototype, "DECONFLICTOR_SHOW_VISIBLE", void 0), e$1W([y$1o()], T$2.prototype, "DECONFLICTOR_SHOW_INVISIBLE", void 0), e$1W([y$1o()], T$2.prototype, "DECONFLICTOR_SHOW_GRID", void 0), e$1W([y$1o()], T$2.prototype, "LABELS_SHOW_BORDER", void 0), e$1W([y$1o()], T$2.prototype, "TEXT_SHOW_BASELINE", void 0), e$1W([y$1o()], T$2.prototype, "TEXT_SHOW_BORDER", void 0), e$1W([y$1o()], T$2.prototype, "OVERLAY_DRAW_DEBUG_TEXTURE", void 0), e$1W([y$1o()], T$2.prototype, "OVERLAY_SHOW_CENTER", void 0), e$1W([y$1o()], T$2.prototype, "SHOW_POI", void 0), e$1W([y$1o()], T$2.prototype, "TESTS_DISABLE_OPTIMIZATIONS", void 0), e$1W([y$1o()], T$2.prototype, "TESTS_DISABLE_FAST_UPDATES", void 0), e$1W([y$1o()], T$2.prototype, "DRAW_MESH_GEOMETRY_NORMALS", void 0), e$1W([y$1o()], T$2.prototype, "FEATURE_TILE_FETCH_SHOW_TILES", void 0), e$1W([y$1o()], T$2.prototype, "FEATURE_TILE_TREE_SHOW_TILES", void 0), e$1W([y$1o()], T$2.prototype, "TERRAIN_TILE_TREE_SHOW_TILES", void 0), e$1W([y$1o()], T$2.prototype, "I3S_TREE_SHOW_TILES", void 0), e$1W([y$1o()], T$2.prototype, "I3S_SHOW_MODIFICATIONS", void 0), e$1W([y$1o()], T$2.prototype, "LOD_INSTANCE_RENDERER_DISABLE_UPDATES", void 0), e$1W([y$1o()], T$2.prototype, "LOD_INSTANCE_RENDERER_COLORIZE_BY_LEVEL", void 0), e$1W([y$1o()], T$2.prototype, "EDGES_SHOW_HIDDEN_TRANSPARENT_EDGES", void 0), e$1W([y$1o()], T$2.prototype, "LINE_WIREFRAMES", void 0), e$1W([y$1o()], T$2.prototype, "TERRAIN_USE_LEGACY_SHADING", void 0), T$2 = e$1W([n$2f("esri.views.3d.support.DebugFlags")], T$2);
const t$k = new T$2();
var C$4;
let S$3 = C$4 = class extends u$1N(m$1g) {
  constructor(r2) {
    super(r2), this.opacity = 1, this.shading = !t$k.TERRAIN_USE_LEGACY_SHADING, this.surfaceColor = null, this.navigationConstraint = null, this.layers = new j$F();
    const e2 = (r3) => {
      r3.parent && r3.parent !== this && "remove" in r3.parent && r3.parent.remove(r3), r3.parent = this, r3.type !== "elevation" && r3.type !== "base-elevation" && s$22.getLogger(this.declaredClass).error(`Layer '${r3.title}, id:${r3.id}' of type '${r3.type}' is not supported as a ground layer and will therefore be ignored. Only layers of type 'elevation' are supported.`);
    }, t2 = (r3) => {
      r3.parent = null;
    };
    this.layers.on("after-add", (r3) => e2(r3.item)), this.layers.on("after-remove", (r3) => t2(r3.item));
  }
  initialize() {
    this.when().catch((r2) => {
      s$22.getLogger(this.declaredClass).error("#load()", "Failed to load ground", r2);
    }), this.resourceInfo && this.read(this.resourceInfo.data, this.resourceInfo.context);
  }
  destroy() {
    const r2 = this.layers.removeAll();
    for (const e2 of r2)
      e2.destroy();
    this.layers.destroy();
  }
  normalizeCtorArgs(r2) {
    return r2 && "resourceInfo" in r2 && (this._set("resourceInfo", r2.resourceInfo), delete (r2 = __spreadValues({}, r2)).resourceInfo), r2;
  }
  set layers(r2) {
    this._set("layers", n$1N(r2, this._get("layers")));
  }
  writeLayers(r2, e2, o2, t2) {
    const i2 = [];
    r2 ? (t2 = __spreadProps(__spreadValues({}, t2), { layerContainerType: "ground" }), r2.forEach((r3) => {
      if ("write" in r3) {
        const e3 = {};
        o$H(r3)().write(e3, t2) && i2.push(e3);
      } else
        t2 && t2.messages && t2.messages.push(new s$1Z("layer:unsupported", `Layers (${r3.title}, ${r3.id}) of type '${r3.declaredClass}' cannot be persisted in the ground`, { layer: r3 }));
    }), e2.layers = i2) : e2.layers = i2;
  }
  load(r2) {
    return this.addResolvingPromise(this._loadFromSource(r2)), Promise.resolve(this);
  }
  loadAll() {
    return n$t(this, (r2) => {
      r2(this.layers);
    });
  }
  async queryElevation(r2, e2) {
    await this.load({ signal: e2 == null ? void 0 : e2.signal });
    const { ElevationQuery: o2 } = await import("./ElevationQuery.js");
    f$1x(e2);
    const t2 = new o2(), s2 = this.layers.filter(A$3).toArray();
    return t2.queryAll(s2, r2, e2);
  }
  async createElevationSampler(r2, e2) {
    await this.load({ signal: e2 == null ? void 0 : e2.signal });
    const { ElevationQuery: o2 } = await import("./ElevationQuery.js");
    f$1x(e2);
    const t2 = new o2(), s2 = this.layers.filter(A$3).toArray();
    return t2.createSamplerAll(s2, r2, e2);
  }
  clone() {
    const r2 = { opacity: this.opacity, surfaceColor: y$1r(this.surfaceColor), navigationConstraint: y$1r(this.navigationConstraint), layers: this.layers.slice() };
    return this.loaded && (r2.loadStatus = "loaded"), new C$4({ resourceInfo: this.resourceInfo }).set(r2);
  }
  read(r2, e2) {
    this.resourceInfo || this._set("resourceInfo", { data: r2, context: e2 }), super.read(r2, e2);
  }
  _loadFromSource(r2) {
    const e2 = this.resourceInfo;
    return e2 ? this._loadLayersFromJSON(e2.data, e2.context, r2) : Promise.resolve();
  }
  _loadLayersFromJSON(r2, e2, o2) {
    const t2 = e2 && e2.origin || "web-scene", s2 = e2 && e2.portal || null, a2 = e2 && e2.url || null;
    return import("./layersCreator.js").then(({ populateOperationalLayers: e3 }) => {
      f$1x(o2);
      const i2 = [];
      if (r2.layers && Array.isArray(r2.layers)) {
        const o3 = { context: { origin: t2, url: a2, portal: s2, layerContainerType: "ground" }, defaultLayerType: "ArcGISTiledElevationServiceLayer" };
        i2.push(e3(this.layers, r2.layers, o3));
      }
      return E$v(i2);
    }).then(() => {
    });
  }
};
function I$4(r2) {
  return r2 && "createElevationSampler" in r2;
}
function A$3(r2) {
  return r2.type === "elevation" || I$4(r2);
}
e$1W([y$1o({ json: { read: false } })], S$3.prototype, "layers", null), e$1W([r$1h("layers")], S$3.prototype, "writeLayers", null), e$1W([y$1o({ readOnly: true })], S$3.prototype, "resourceInfo", void 0), e$1W([y$1o({ type: Number, nonNullable: true, range: { min: 0, max: 1 }, json: { type: T$r, read: { reader: r$$, source: "transparency" }, write: { writer: (r2, e2) => {
  e2.transparency = n$1T(r2);
}, target: "transparency" } } })], S$3.prototype, "opacity", void 0), e$1W([y$1o({ type: Boolean, nonNullable: true, json: { read: false } })], S$3.prototype, "shading", void 0), e$1W([y$1o({ type: l$1D, json: { type: [T$r], write: (r2, e2) => {
  e2.surfaceColor = r2.toJSON().slice(0, 3);
} } })], S$3.prototype, "surfaceColor", void 0), e$1W([y$1o({ type: p$t, json: { write: true } })], S$3.prototype, "navigationConstraint", void 0), S$3 = C$4 = e$1W([n$2f("esri.Ground")], S$3);
const L$5 = S$3;
function i$t(i2) {
  var _a2;
  return !!(i2 && i2.loaded && "capabilities" in i2 && ((_a2 = i2 == null ? void 0 : i2.capabilities) == null ? void 0 : _a2.operations) && "supportsEditing" in i2.capabilities.operations && i2.capabilities.operations.supportsEditing === true) && !("editingEnabled" in i2 && !i2.editingEnabled);
}
const f$c = s$22.getLogger("esri.support.basemapUtils");
function p$s() {
  return {};
}
function y$8(e2) {
  for (const r2 in e2) {
    const a2 = e2[r2];
    (a2 == null ? void 0 : a2.destroyed) === false && a2.destroy(), delete e2[r2];
  }
}
function m$e(a2, t2) {
  let n2;
  if (typeof a2 == "string") {
    if (!(a2 in s$k)) {
      const e2 = Object.entries(s$k).filter(([e3, a3]) => s$23.apiKey && !a3.classic || !s$23.apiKey && a3.classic && !a3.deprecated).map(([e3]) => `"${e3}"`).join(", ");
      return f$c.warn(`Unable to find basemap definition for: ${a2}. Try one of these: ${e2}`), null;
    }
    t2 && (n2 = t2[a2]), n2 || (n2 = x$4.fromId(a2), t2 && (t2[a2] = n2));
  } else
    n2 = b$U(x$4, a2);
  return (n2 == null ? void 0 : n2.destroyed) && (f$c.warn("The provided basemap is already destroyed", { basemap: n2 }), n2 = null), n2;
}
function t$j(t2) {
  return new l$1g({ getCollections: () => [t2.tables, t2.layers], getChildrenFunction: (e2) => {
    const t3 = [];
    return "tables" in e2 && t3.push(e2.tables), "layers" in e2 && t3.push(e2.layers), t3;
  }, itemFilterFunction: (e2) => {
    const t3 = e2.parent;
    return t3 && "tables" in t3 && t3.tables.includes(e2);
  } });
}
const i$s = { "world-elevation": { id: "worldElevation", url: "//elevation3d.arcgis.com/arcgis/rest/services/WorldElevation3D/Terrain3D/ImageServer", layerType: "ArcGISTiledElevationServiceLayer" }, "world-topobathymetry": { id: "worldTopoBathymetry", url: "//elevation3d.arcgis.com/arcgis/rest/services/WorldElevation3D/TopoBathy3D/ImageServer", layerType: "ArcGISTiledElevationServiceLayer" } };
function t$i(t2) {
  let a2 = null;
  if (typeof t2 == "string")
    if (t2 in i$s) {
      const r2 = i$s[t2];
      a2 = new L$5({ resourceInfo: { data: { layers: [r2] } } });
    } else
      s$22.getLogger("esri.support.groundUtils").warn(`Unable to find ground definition for: ${t2}. Try "world-elevation"`);
  else
    a2 = b$U(L$5, t2);
  return a2;
}
function n$s(e2, r2, t2) {
  let s2, o2;
  if (e2)
    for (let a2 = 0, i2 = e2.length; a2 < i2; a2++) {
      if (s2 = e2.getItemAt(a2), s2[r2] === t2)
        return s2;
      if ((s2 == null ? void 0 : s2.type) === "group" && (o2 = n$s(s2.layers, r2, t2), o2))
        return o2;
    }
}
const d$c = (d2) => {
  let y2 = class extends d2 {
    constructor(...e2) {
      super(...e2), this.layers = new j$F();
      const t2 = (e3) => {
        e3.parent && "remove" in e3.parent && e3.parent.remove(e3);
      }, o2 = (e3) => {
        e3.parent = this, this.layerAdded(e3), e3.type !== "elevation" && e3.type !== "base-elevation" || s$22.getLogger(this.declaredClass).error(`Layer 'title:${e3.title}, id:${e3.id}' of type '${e3.type}' is not supported as an operational layer and will therefore be ignored.`);
      }, a2 = (e3) => {
        e3.parent = null, this.layerRemoved(e3);
      };
      this.layers.on("before-add", (e3) => t2(e3.item)), this.layers.on("after-add", (e3) => o2(e3.item)), this.layers.on("after-remove", (e3) => a2(e3.item));
    }
    destroy() {
      const e2 = this.layers.removeAll();
      for (const r2 of e2)
        this.layerRemoved(r2), r2.destroy();
      this.layers.destroy();
    }
    set layers(e2) {
      this._set("layers", n$1N(e2, this._get("layers")));
    }
    add(e2, r2) {
      const t2 = this.layers;
      if (r2 = t2.getNextIndex(r2), e2 instanceof b$h) {
        const s2 = e2;
        s2.parent === this ? this.reorder(s2, r2) : t2.add(s2, r2);
      } else
        C$q(e2) ? e2.then((e3) => {
          this.destroyed || this.add(e3, r2);
        }) : s$22.getLogger(this.declaredClass).error("#add()", "The item being added is not a Layer or a Promise that resolves to a Layer.");
    }
    addMany(e2, r2) {
      const t2 = this.layers;
      r2 = t2.getNextIndex(r2), e2.slice().forEach((e3) => {
        e3.parent !== this ? (t2.add(e3, r2), r2 += 1) : this.reorder(e3, r2);
      });
    }
    findLayerById(e2) {
      return n$s(this.layers, "id", e2);
    }
    findLayerByUid(e2) {
      return n$s(this.layers, "uid", e2);
    }
    remove(e2) {
      return this.layers.remove(e2);
    }
    removeMany(e2) {
      return this.layers.removeMany(e2);
    }
    removeAll() {
      return this.layers.removeAll();
    }
    reorder(e2, r2) {
      return this.layers.reorder(e2, r2);
    }
    layerAdded(e2) {
    }
    layerRemoved(e2) {
    }
  };
  return e$1W([y$1o()], y2.prototype, "layers", null), y2 = e$1W([n$2f("esri.support.LayersMixin")], y2), y2;
};
function a$w(t2, e2, r2) {
  if (t2)
    for (let s2 = 0, o2 = t2.length; s2 < o2; s2++) {
      const o3 = t2.getItemAt(s2);
      if (o3[e2] === r2)
        return o3;
      if ((o3 == null ? void 0 : o3.type) === "group") {
        const t3 = a$w(o3.tables, e2, r2);
        if (t3)
          return t3;
      }
    }
}
const l$o = (l2) => {
  let n2 = class extends l2 {
    constructor(...t2) {
      super(...t2), this.tables = new j$F(), this.tables.on("after-add", (t3) => {
        const e2 = t3.item;
        e2.parent && e2.parent !== this && "tables" in e2.parent && e2.parent.tables.remove(e2), e2.parent = this, e2.type !== "feature" && s$22.getLogger(this.declaredClass).error(`Layer 'title:${e2.title}, id:${e2.id}' of type '${e2.type}' is not supported as a table and will therefore be ignored.`);
      }), this.tables.on("after-remove", (t3) => {
        t3.item.parent = null;
      });
    }
    destroy() {
      const t2 = this.tables.removeAll();
      for (const e2 of t2)
        e2.destroy();
      this.tables.destroy();
    }
    set tables(t2) {
      this._set("tables", n$1N(t2, this._get("tables")));
    }
    findTableById(t2) {
      return a$w(this.tables, "id", t2);
    }
    findTableByUid(t2) {
      return a$w(this.tables, "uid", t2);
    }
  };
  return e$1W([y$1o()], n2.prototype, "tables", null), n2 = e$1W([n$2f("esri.support.TablesMixin")], n2), n2;
};
let j$2 = class extends l$o(d$c(n$26.EventedMixin(m$1L))) {
  constructor(s2) {
    super(s2), this.allLayers = new l$1g({ getCollections: () => {
      var _a2, _b2, _c2;
      return [(_a2 = this.basemap) == null ? void 0 : _a2.baseLayers, (_b2 = this.ground) == null ? void 0 : _b2.layers, this.layers, (_c2 = this.basemap) == null ? void 0 : _c2.referenceLayers];
    }, getChildrenFunction: (s3) => "layers" in s3 ? s3.layers : null }), this.allTables = t$j(this), this.basemap = null, this.editableLayers = new l$1g({ getCollections: () => [this.allLayers], itemFilterFunction: i$t }), this.ground = new L$5(), this._basemapCache = p$s();
  }
  destroy() {
    var _a2, _b2;
    this.allLayers.destroy(), this.allTables.destroy(), this.editableLayers.destroy(), (_a2 = this.ground) == null ? void 0 : _a2.destroy(), (_b2 = this.basemap) == null ? void 0 : _b2.destroy(), y$8(this._basemapCache), this._basemapCache = null;
  }
  castBasemap(s2) {
    return m$e(s2, this._basemapCache);
  }
  castGround(s2) {
    const e2 = t$i(s2);
    return t$1W(e2) ? this._get("ground") : e2;
  }
  findLayerById(s2) {
    return this.allLayers.find((e2) => e2.id === s2);
  }
  findTableById(s2) {
    return this.allTables.find((e2) => e2.id === s2);
  }
};
e$1W([y$1o({ readOnly: true, dependsOn: [] })], j$2.prototype, "allLayers", void 0), e$1W([y$1o({ readOnly: true })], j$2.prototype, "allTables", void 0), e$1W([y$1o({ type: x$4 })], j$2.prototype, "basemap", void 0), e$1W([s$1N("basemap")], j$2.prototype, "castBasemap", null), e$1W([y$1o({ readOnly: true })], j$2.prototype, "editableLayers", void 0), e$1W([y$1o({ type: L$5, nonNullable: true })], j$2.prototype, "ground", void 0), e$1W([s$1N("ground")], j$2.prototype, "castGround", null), j$2 = e$1W([n$2f("esri.Map")], j$2);
const L$4 = j$2;
let l$n = class extends a$1s(j$F) {
  constructor(e2) {
    super(e2), this.handles.add([this.on("before-add", (e3) => {
      t$1W(e3.item) && e3.preventDefault();
    }), this.on("after-add", (e3) => this._own(e3.item)), this.on("after-remove", (e3) => this._release(e3.item))]);
  }
  get owner() {
    return this._get("owner");
  }
  set owner(e2) {
    e2 !== this._get("owner") && (this._releaseAll(), this._set("owner", e2), this._ownAll());
  }
  _ownAll() {
    for (const e2 of this.items)
      this._own(e2);
  }
  _releaseAll() {
    for (const e2 of this.items)
      this._release(e2);
  }
  _createNewInstance(e2) {
    return this.itemType ? new (j$F.ofType(this.itemType.Type))(e2) : new j$F(e2);
  }
};
function a$v(e2, t2) {
  return { type: e2, cast: t$1f, set(s2) {
    const r2 = n$1N(s2, this._get(t2), e2);
    r2.owner = this, this._set(t2, r2);
  } };
}
e$1W([y$1o()], l$n.prototype, "owner", null), l$n = e$1W([n$2f("esri.core.support.OwningCollection")], l$n);
let i$r = class extends l$n {
  constructor(e2) {
    super(e2), this.handles.add(this.on("before-add", (e3) => {
      t$1W(e3.item) || e3.item.parent === this.owner && (s$22.getLogger(this.declaredClass).warn("Analysis inside the collection must be unique. Not adding this element again."), e3.preventDefault());
    }));
  }
  _own(e2) {
    e2.parent = this.owner;
  }
  _release(e2) {
    e2.parent = null;
  }
};
i$r = e$1W([n$2f("esri.support.AnalysesCollection")], i$r);
let i$q = class extends l$n {
  _own(r2) {
    r2.layer && "remove" in r2.layer && r2.layer !== this.owner && r2.layer.remove(r2), r2.layer = this.owner;
  }
  _release(r2) {
    r2.layer === this.owner && (r2.layer = null);
  }
};
e$1W([n$25({ Type: g$J, ensureType: b$U(g$J) })], i$q.prototype, "itemType", void 0), i$q = e$1W([n$2f("esri.support.GraphicsCollection")], i$q);
let p$r = class extends m$1L {
  constructor(e2) {
    super(e2), this.view = null, this.baseLayerViews = new j$F(), this.referenceLayerViews = new j$F(), this._loadingHandle = l$1f(() => {
      var _a2, _b2;
      return (_b2 = (_a2 = this.view) == null ? void 0 : _a2.map) == null ? void 0 : _b2.basemap;
    }, (e3) => {
      e3 && e3.load().catch(() => {
      });
    }, h$S);
  }
  destroy() {
    this._set("view", null), this._loadingHandle && (this._loadingHandle.remove(), this._loadingHandle = null);
  }
  get suspended() {
    return !this.view || this.view.suspended;
  }
  get updating() {
    var _a2, _b2;
    if (this.view && this.view.suspended)
      return false;
    const e2 = (_b2 = (_a2 = this.view) == null ? void 0 : _a2.map) == null ? void 0 : _b2.basemap;
    return !!e2 && (!!e2.loaded && (this.baseLayerViews.some((e3) => e3.updating) || this.referenceLayerViews.some((e3) => e3.updating)));
  }
};
e$1W([y$1o({ constructOnly: true })], p$r.prototype, "view", void 0), e$1W([y$1o({ readOnly: true })], p$r.prototype, "baseLayerViews", void 0), e$1W([y$1o({ readOnly: true })], p$r.prototype, "referenceLayerViews", void 0), e$1W([y$1o({ readOnly: true })], p$r.prototype, "suspended", null), e$1W([y$1o({ type: Boolean, readOnly: true })], p$r.prototype, "updating", null), p$r = e$1W([n$2f("esri.views.BasemapView")], p$r);
class v$4 {
  constructor(e2, r2, i2) {
    this.layer = e2, this.view = r2, this.layerViewImporter = i2, this._controller = new AbortController(), this._deferred = A$p(), this._started = false, this.done = false, v$S(this._controller.signal, () => {
      const r3 = new s$1Z("cancelled:layerview-create", "layerview creation cancelled", { layer: e2 });
      this._deferred.reject(r3);
    });
  }
  get promise() {
    return this._deferred.promise;
  }
  destroy() {
    this._controller.abort();
    const { layerView: e2 } = this;
    if (!e2)
      return;
    const { layer: r2, view: t2 } = this;
    r2.emit("layerview-destroy", { view: t2, layerView: e2 }), t2.emit("layerview-destroy", { layer: r2, layerView: e2 }), this.done = true, this.layer = null, this.layerView = null, this.view = null, this.layerViewImporter = null;
  }
  async start() {
    var _a2, _b2;
    if (this._started)
      return;
    this._started = true;
    const { _controller: { signal: e2 }, layer: r2, view: i2 } = this;
    this._map = i2.map;
    try {
      let s2, o2;
      if (await r2.load({ signal: e2 }), "prefetchResources" in r2 && await r2.prefetchResources({ signal: e2 }), r2.createLayerView)
        s2 = await r2.createLayerView(i2, { signal: e2 });
      else {
        if (!this.layerViewImporter.hasLayerViewModule(r2))
          throw new s$1Z("layer:view-not-supported", "No layerview implementation was found");
        const a2 = await this.layerViewImporter.importLayerView(r2);
        f$1x(e2), s2 = "default" in a2 ? new a2.default({ layer: r2, view: i2 }) : new a2({ layer: r2, view: i2 });
      }
      const n2 = () => {
        o2 = h$1s(o2), s2.destroyed || s2.destroy(), s2.layer = null, s2.parent = null, s2.view = null, this.done = true;
      };
      o2 = v$S(e2, n2), f$1x(e2);
      try {
        await s2.when();
      } catch (a2) {
        throw n2(), a2;
      }
      const y2 = (_b2 = (_a2 = this._map) == null ? void 0 : _a2.allLayers) == null ? void 0 : _b2.includes(r2);
      if (!y2)
        return n2(), void this._deferred.reject(new s$1Z("view:no-layerview-for-layer", "The layer has been removed from the map", { layer: r2 }));
      this.layerView = s2, r2.emit("layerview-create", { view: i2, layerView: s2 }), i2.emit("layerview-create", { layer: r2, layerView: s2 }), this.done = true, this._deferred.resolve(s2);
    } catch (a2) {
      r2.emit("layerview-create-error", { view: i2, error: a2 }), i2.emit("layerview-create-error", { layer: r2, error: a2 }), this.done = true, this._deferred.reject(new s$1Z("layerview:create-error", "layerview creation failed", { layer: r2, error: a2 }));
    }
  }
}
let V = class extends m$1L {
  constructor(e2) {
    super(e2), this._layerLayerViewInfoMap = new Map(), this._watchUpdatingTracking = new c$1F(), this.supportsGround = true, this._preloadLayerViewModules = () => {
      var _a2;
      const e3 = (_a2 = this.view.map) == null ? void 0 : _a2.allLayers;
      if (e3)
        for (const r2 of e3)
          this.layerViewImporter.hasLayerViewModule(r2) && this.layerViewImporter.importLayerView(r2);
    }, this._reschedule = () => (t$1W(this._workPromise) && (this._workPromise = A$p(), this._workPromise.promise.catch(() => {
    })), this.removeHandles("reschedule"), this.addHandles(v$R(this._doWork), "reschedule"), this._workPromise.promise), this._doWork = () => {
      var _a2, _b2, _c2;
      const e3 = this.view.map;
      if (this._map !== e3 && (this.clear(), this._map = e3), t$1W(this._workPromise))
        return void this.notifyChange("updating");
      this.removeHandles("reschedule"), this.removeHandles("collection-change");
      const r2 = [], t2 = (e4) => {
        if (!t$1W(e4))
          for (const i3 of e4)
            i3 && (r2.push(i3), this._createLayerView(i3), "layers" in i3 && i3.layers && t2(i3.layers));
      };
      for (const s2 of this._rootCollectionNames)
        t2(this.get(s2));
      this._refreshCollections();
      for (const [s2, o2] of this._layerLayerViewInfoMap)
        r2.includes(s2) || (this._layerLayerViewInfoMap.delete(o2.layer), o2.destroy());
      const i2 = r2.filter((e4) => e4.type === "group").map((e4) => e4.layers), a2 = [(_a2 = e3 == null ? void 0 : e3.ground) == null ? void 0 : _a2.layers, (_b2 = e3 == null ? void 0 : e3.basemap) == null ? void 0 : _b2.baseLayers, (_c2 = e3 == null ? void 0 : e3.basemap) == null ? void 0 : _c2.referenceLayers, e3 == null ? void 0 : e3.layers, ...i2].filter((e4) => !!e4);
      this.addHandles(a2.map((e4) => this._watchUpdatingTracking.addOnCollectionChange(() => e4, this._reschedule)), "collection-change"), this._workPromise.resolve(), this._workPromise = null;
    };
  }
  initialize() {
    this.own([a$1I(() => {
      var _a2, _b2;
      return (_b2 = (_a2 = this.view) == null ? void 0 : _a2.map) == null ? void 0 : _b2.allLayers;
    }, "change", this._preloadLayerViewModules, { onListenerAdd: this._preloadLayerViewModules }), l$1f(() => {
      const e2 = this.view, r2 = e2 == null ? void 0 : e2.map;
      return [r2 == null ? void 0 : r2.basemap, r2 == null ? void 0 : r2.ground, r2 == null ? void 0 : r2.layers, e2 == null ? void 0 : e2.ready];
    }, () => this._reschedule(), w$A)]), this._preloadLayerViewModules(), this._reschedule();
  }
  destroy() {
    this.clear(), this._watchUpdatingTracking.destroy(), this._map = null, r$1t(this._workPromise) && (this._workPromise.reject(a$2p()), this._workPromise = null);
  }
  get _layersToLayerViews() {
    const e2 = [["view.map.basemap.baseLayers", "view.basemapView.baseLayerViews"], ["view.map.layers", "view.layerViews"], ["view.map.basemap.referenceLayers", "view.basemapView.referenceLayerViews"]];
    return this.supportsGround && e2.push(["view.map.ground.layers", "view.groundView.layerViews"]), new Map(e2);
  }
  get _rootCollectionNames() {
    return Array.from(this._layersToLayerViews.keys());
  }
  get updating() {
    return r$1t(this._workPromise) || this._watchUpdatingTracking.updating || n$2l(this._layerLayerViewInfoMap, (e2) => !e2.done);
  }
  get updatingRemaining() {
    let e2 = 0;
    for (const r2 of this._layerLayerViewInfoMap.values())
      r2.done || ++e2;
    return e2;
  }
  clear() {
    if (!this.destroyed) {
      for (const e2 of this._layerLayerViewInfoMap.values())
        e2.destroy();
      this._layerLayerViewInfoMap.clear(), this._refreshCollections();
    }
  }
  async whenLayerView(e2) {
    if (await this._reschedule(), !this._layerLayerViewInfoMap.has(e2))
      throw new s$1Z("view:no-layerview-for-layer", "No layerview has been found for the layer", { layer: e2 });
    return this._layerLayerViewInfoMap.get(e2).promise;
  }
  _refreshCollections() {
    for (const [e2, r2] of this._layersToLayerViews)
      this._populateLayerViewsOwners(this.get(e2), this.get(r2), this.view);
    this.notifyChange("updating"), this.notifyChange("updatingRemaining");
  }
  _populateLayerViewsOwners(e2, r2, t2) {
    if (!e2 || !r2)
      return void (r2 && r2.removeAll());
    let i2 = 0;
    for (const a2 of e2) {
      const e3 = this._layerLayerViewInfoMap.get(a2);
      if (!e3 || !e3.layerView)
        continue;
      const s2 = e3.layerView;
      s2.layer = a2, s2.parent = t2, r2.getItemAt(i2) !== s2 && r2.splice(i2, 0, s2), a2.layers && this._populateLayerViewsOwners(a2.layers, s2.layerViews, s2), i2 += 1;
    }
    i2 < r2.length && r2.splice(i2, r2.length);
  }
  _createLayerView(e2) {
    if (this._layerLayerViewInfoMap.has(e2))
      return this.view.ready && this._layerLayerViewInfoMap.get(e2).start(), this.notifyChange("updating"), void this.notifyChange("updatingRemaining");
    e2.load().catch(() => {
    }), this.layerViewImporter.hasLayerViewModule(e2) && this.layerViewImporter.importLayerView(e2);
    const r2 = new v$4(e2, this.view, this.layerViewImporter);
    r2.promise.then(() => this._refreshCollections(), (r3) => {
      var _a2, _b2;
      r3 && (j$K(r3) || r3.name === "cancelled:layerview-create") || s$22.getLogger(this.declaredClass).error(`Failed to create layerview for layer title:'${(_a2 = e2.title) != null ? _a2 : "no title"}', id:'${(_b2 = e2.id) != null ? _b2 : "no id"}' of type '${e2.type}'.`, { layer: e2, error: r3 }), this._refreshCollections();
    }), this._layerLayerViewInfoMap.set(e2, r2), this.view.ready && r2.start(), this.notifyChange("updating"), this.notifyChange("updatingRemaining");
  }
};
e$1W([y$1o()], V.prototype, "_workPromise", void 0), e$1W([y$1o({ readOnly: true })], V.prototype, "_watchUpdatingTracking", void 0), e$1W([y$1o({ readOnly: true })], V.prototype, "_layersToLayerViews", null), e$1W([y$1o({ readOnly: true })], V.prototype, "_rootCollectionNames", null), e$1W([y$1o()], V.prototype, "layerViewImporter", void 0), e$1W([y$1o()], V.prototype, "supportsGround", void 0), e$1W([y$1o({ readOnly: true })], V.prototype, "updating", null), e$1W([y$1o({ readOnly: true })], V.prototype, "updatingRemaining", null), e$1W([y$1o({ constructOnly: true })], V.prototype, "view", void 0), V = e$1W([n$2f("esri.views.LayerViewManager")], V);
const L$3 = V;
let i$p = class extends m$1L {
  constructor(o2) {
    super(o2), this.factor = 1.5, this.offset = c$2b(0, 0), this.position = null, this.size = 120, this.maskUrl = null, this.maskEnabled = true, this.overlayUrl = null, this.overlayEnabled = true, this.visible = true;
  }
  get version() {
    return this.commitProperty("factor"), this.commitProperty("offset"), this.commitProperty("position"), this.commitProperty("visible"), this.commitProperty("size"), this.commitProperty("maskUrl"), this.commitProperty("maskEnabled"), this.commitProperty("overlayUrl"), this.commitProperty("overlayEnabled"), (this._get("version") || 0) + 1;
  }
};
e$1W([y$1o({ type: Number })], i$p.prototype, "factor", void 0), e$1W([y$1o({ nonNullable: true })], i$p.prototype, "offset", void 0), e$1W([y$1o()], i$p.prototype, "position", void 0), e$1W([y$1o({ type: Number, range: { min: 0 } })], i$p.prototype, "size", void 0), e$1W([y$1o()], i$p.prototype, "maskUrl", void 0), e$1W([y$1o()], i$p.prototype, "maskEnabled", void 0), e$1W([y$1o()], i$p.prototype, "overlayUrl", void 0), e$1W([y$1o()], i$p.prototype, "overlayEnabled", void 0), e$1W([y$1o({ readOnly: true })], i$p.prototype, "version", null), e$1W([y$1o({ type: Boolean })], i$p.prototype, "visible", void 0), i$p = e$1W([n$2f("esri.views.Magnifier")], i$p);
const p$q = i$p;
class n$r {
  constructor() {
    this._tasks = new Array(), this._running = new t$n(false);
  }
  get length() {
    return this._tasks.length;
  }
  get running() {
    return this._running.get();
  }
  destroy() {
    this.cancelAll();
  }
  runTask(s2) {
    for (; !s2.done && this._process(s2); )
      s2.madeProgress();
  }
  push(s2, t2, e2) {
    return this._running.set(true), new Promise((r2, n2) => this._tasks.push(new i$o(r2, n2, s2, t2, e2)));
  }
  unshift(s2, t2, e2) {
    return this._running.set(true), new Promise((r2, n2) => this._tasks.unshift(new i$o(r2, n2, s2, t2, e2)));
  }
  _process(r2) {
    var _a2;
    if (this._tasks.length === 0)
      return false;
    const n2 = this._tasks.shift();
    try {
      const i2 = p$2W(n2.signal);
      if (i2 && !n2.abortCallback)
        n2.reject(a$2p());
      else {
        const s2 = i2 ? (_a2 = n2.abortCallback) == null ? void 0 : _a2.call(n2, a$2p()) : n2.callback(r2);
        C$q(s2) ? s2.then(n2.resolve, n2.reject) : n2.resolve(s2);
      }
    } catch (i2) {
      n2.reject(i2);
    }
    return this._running.set(this._tasks.length > 0), true;
  }
  cancelAll() {
    const s2 = a$2p();
    for (const t2 of this._tasks)
      if (t2.abortCallback) {
        const e2 = t2.abortCallback(s2);
        t2.resolve(e2);
      } else
        t2.reject(s2);
    this._tasks.length = 0, this._running.set(false);
  }
}
class i$o {
  constructor(s2, t2, e2, r2, n2) {
    this.resolve = s2, this.reject = t2, this.callback = e2, this.signal = r2, this.abortCallback = n2;
  }
}
let t$h = class extends m$1L {
  constructor() {
    super(...arguments), this.SCHEDULER_LOG_SLOW_TASKS = false, this.FEATURE_SERVICE_SNAPPING_SOURCE_TILE_TREE_SHOW_TILES = false;
  }
};
e$1W([y$1o()], t$h.prototype, "SCHEDULER_LOG_SLOW_TASKS", void 0), e$1W([y$1o()], t$h.prototype, "FEATURE_SERVICE_SNAPPING_SOURCE_TILE_TREE_SHOW_TILES", void 0), t$h = e$1W([n$2f("esri.views.support.DebugFlags")], t$h);
const p$p = new t$h();
var I$3;
!function(I2) {
  I2[I2.ANIMATING = 0] = "ANIMATING", I2[I2.INTERACTING = 1] = "INTERACTING", I2[I2.IDLE = 2] = "IDLE";
}(I$3 || (I$3 = {}));
var I$2;
!function(e2) {
  e2.RESOURCE_CONTROLLER = "schedule", e2.SLIDE = "slide", e2.STREAM_DATA_LOADER = "stream loader", e2.ELEVATION_QUERY = "elevation query", e2.TERRAIN_SURFACE = "terrain", e2.SURFACE_GEOMETRY_UPDATES = "surface geometry updates", e2.GRAPHICS_CORE = "Graphics3D", e2.I3S_CONTROLLER = "I3S", e2.POINT_CLOUD_LAYER = "point cloud", e2.FEATURE_TILE_FETCHER = "feature fetcher", e2.OVERLAY = "overlay", e2.STAGE = "stage", e2.GRAPHICS_DECONFLICTOR = "graphics deconflictor", e2.FILTER_VISIBILITY = "Graphics3D filter visibility", e2.SCALE_VISIBILITY = "Graphics3D scale visibility", e2.FRUSTUM_VISIBILITY = "Graphics3D frustum visibility", e2.POINT_OF_INTEREST_FREQUENT = "POI frequent", e2.POINT_OF_INTEREST_INFREQUENT = "POI infrequent", e2.LABELER = "labeler", e2.FEATURE_QUERY_ENGINE = "feature query", e2.FEATURE_TILE_TREE = "feature tile tree", e2.FEATURE_TILE_TREE_ACTIVE = "fast feature tile tree", e2.ELEVATION_ALIGNMENT = "elevation alignment", e2.TEXT_TEXTURE_ATLAS = "text texture atlas", e2.TEXTURE_UNLOAD = "texture unload", e2.LINE_OF_SIGHT_TOOL = "line of sight tool", e2.LINE_OF_SIGHT_TOOL_INTERACTIVE = "interactive line of sight tool", e2.ELEVATION_PROFILE = "elevation profile", e2.SNAPPING = "snapping", e2.SHADOW_ACCUMULATOR = "shadow accumulator", e2.CLOUDS_GENERATOR = "cloud generator", e2[e2.TEST_PRIO = 1] = "TEST_PRIO";
}(I$2 || (I$2 = {}));
const R = 0, p$o = new Map([[I$2.RESOURCE_CONTROLLER, R], [I$2.SLIDE, R], [I$2.STREAM_DATA_LOADER, R], [I$2.ELEVATION_QUERY, R], [I$2.TERRAIN_SURFACE, 1], [I$2.SURFACE_GEOMETRY_UPDATES, 1], [I$2.GRAPHICS_CORE, 2], [I$2.I3S_CONTROLLER, 2], [I$2.POINT_CLOUD_LAYER, 2], [I$2.FEATURE_TILE_FETCHER, 2], [I$2.OVERLAY, 4], [I$2.STAGE, 4], [I$2.GRAPHICS_DECONFLICTOR, 4], [I$2.FILTER_VISIBILITY, 4], [I$2.SCALE_VISIBILITY, 4], [I$2.FRUSTUM_VISIBILITY, 4], [I$2.CLOUDS_GENERATOR, 4], [I$2.POINT_OF_INTEREST_FREQUENT, 6], [I$2.POINT_OF_INTEREST_INFREQUENT, 30], [I$2.LABELER, 8], [I$2.FEATURE_QUERY_ENGINE, 8], [I$2.FEATURE_TILE_TREE, 16], [I$2.FEATURE_TILE_TREE_ACTIVE, R], [I$2.ELEVATION_ALIGNMENT, 12], [I$2.TEXT_TEXTURE_ATLAS, 12], [I$2.TEXTURE_UNLOAD, 12], [I$2.LINE_OF_SIGHT_TOOL, 16], [I$2.LINE_OF_SIGHT_TOOL_INTERACTIVE, R], [I$2.SNAPPING, R], [I$2.SHADOW_ACCUMULATOR, 30]]), f$b = 32;
function A$2(e2) {
  return p$o.has(e2) ? p$o.get(e2) : typeof e2 == "number" ? e2 : 1;
}
const b$4 = n$2a(6.5), L$2 = n$2a(1), S$2 = n$2a(30), k$3 = n$2a(1e3 / 30), O$3 = n$2a(100), U$2 = 0.9;
var N, P$3;
!function(n2) {
  class u2 {
    constructor() {
      this._updating = new t$n(true), this._microTaskQueued = false, this._frameNumber = 0, this.performanceInfo = { total: new e$1J("total"), tasks: new Map() }, this._frameTaskTimes = new Map(), this._budget = new g2(), this._state = I$3.INTERACTING, this._tasks = new l$22(), this._runQueue = new l$22(), this._load = 0, this._idleStateCallbacks = new l$22(), this._idleUpdatesStartFired = false, this._maxReschedule = f$b, this._forceTask = false, this._debug = false, this._debugHandle = l$1f(() => p$p.SCHEDULER_LOG_SLOW_TASKS, (e3) => this._debug = e3, h$S);
      for (const t2 of Object.keys(I$2))
        this.performanceInfo.tasks.set(I$2[t2], new e$1J(I$2[t2]));
      const e2 = this;
      this._test = { FRAME_SAFETY_BUDGET: b$4, INTERACTING_BUDGET: k$3, IDLE_BUDGET: O$3, get availableBudget() {
        return e2._budget.budget;
      }, usedBudget: 0, getBudget: () => e2._budget, setBudget: (t2) => e2._budget = t2, updateTask: (e3) => this._updateTask(e3), getState: (e3) => this._getState(e3), getRuntime: (e3) => this._getRuntime(e3), frameTaskTimes: this._frameTaskTimes, resetRuntimes: () => this._resetRuntimes(), getRunning: () => this._getRunning() };
    }
    get updating() {
      return this._updating.get();
    }
    set updating(e2) {
      this._updating.set(e2);
    }
    destroy() {
      this._tasks.toArray().forEach((e2) => e2.remove()), this._tasks.clear(), h$1s(this._debugHandle), this._microTaskQueued = false, this._updating.set(false);
    }
    activate() {
      this._budget.done || this._microTaskQueued || (this._microTaskQueued = true, queueMicrotask(() => {
        this._microTaskQueued && (this._microTaskQueued = false, this._budget.done || (this._maxReschedule = f$b, this._schedule(), this.frame()));
      }));
    }
    registerTask(e2, t2) {
      const s2 = A$2(e2), i2 = new _2(this, e2, t2, s2);
      return this._tasks.push(i2), this.performanceInfo.tasks.has(e2) || this.performanceInfo.tasks.set(e2, new e$1J(e2)), i2;
    }
    registerIdleStateCallbacks(e2, t2) {
      const s2 = { idleBegin: e2, idleEnd: t2 };
      this._idleStateCallbacks.push(s2), this.state === I$3.IDLE && this._idleUpdatesStartFired && s2.idleBegin();
      const i2 = this;
      return { remove: () => this._removeIdleStateCallbacks(s2), set idleBegin(e3) {
        i2._idleUpdatesStartFired && (s2.idleEnd(), i2._state === I$3.IDLE && e3()), s2.idleBegin = e3;
      }, set idleEnd(e3) {
        s2.idleEnd = e3;
      } };
    }
    get load() {
      return this._load;
    }
    set state(e2) {
      this._state !== e2 && (this._state = e2, this.state !== I$3.IDLE && this._idleUpdatesStartFired && (this._idleUpdatesStartFired = false, this._idleStateCallbacks.forAll((e3) => e3.idleEnd())));
    }
    get state() {
      return this._state;
    }
    updateBudget(e2) {
      this._test.usedBudget = 0, ++this._frameNumber;
      let t2 = b$4, s2 = e2.frameDuration, i2 = L$2;
      switch (this.state) {
        case I$3.IDLE:
          t2 = n$2a(0), s2 = n$2a(Math.max(O$3, e2.frameDuration)), i2 = S$2;
          break;
        case I$3.INTERACTING:
          s2 = n$2a(Math.max(k$3, e2.frameDuration));
        case I$3.ANIMATING:
      }
      return s2 = n$2a(s2 - e2.elapsedFrameTime - t2), this.state !== I$3.IDLE && s2 < L$2 && !this._forceTask ? (this._forceTask = true, false) : (s2 = n$2a(Math.max(s2, i2)), this._budget.reset(s2, this.state), this._maxReschedule = f$b, this._updateLoad(), this._schedule());
    }
    frame() {
      switch (this._forceTask = false, this._microTaskQueued = false, this.state) {
        case I$3.IDLE:
          this._idleUpdatesStartFired || (this._idleUpdatesStartFired = true, this._idleStateCallbacks.forAll((e2) => e2.idleBegin())), this._runIdle();
          break;
        case I$3.INTERACTING:
          this._runInteracting();
          break;
        default:
          this._runAnimating();
      }
      this._test.usedBudget = this._budget.elapsed;
    }
    stopFrame() {
      this._budget.reset(n$2a(0), this._state), this._budget.madeProgress();
    }
    _removeIdleStateCallbacks(e2) {
      this._idleUpdatesStartFired && e2.idleEnd(), this._idleStateCallbacks.removeUnordered(e2);
    }
    removeTask(e2) {
      this._tasks.removeUnordered(e2), this._runQueue.removeUnordered(e2);
    }
    _updateTask(e2) {
      this._tasks.forAll((t2) => {
        t2.name === e2 && t2.setPriority(e2);
      });
    }
    _getState(e2) {
      if (this._runQueue.some((t3) => t3.name === e2))
        return P$3.SCHEDULED;
      let t2 = P$3.IDLE;
      return this._tasks.forAll((s2) => {
        s2.name === e2 && s2.needsUpdate && (s2.schedulePriority <= 1 ? t2 = P$3.READY : t2 !== P$3.READY && (t2 = P$3.WAITING));
      }), t2;
    }
    _getRuntime(e2) {
      let t2 = 0;
      return this._tasks.forAll((s2) => {
        s2.name === e2 && (t2 += s2.runtime);
      }), t2;
    }
    _resetRuntimes() {
      this._tasks.forAll((e2) => e2.runtime = 0);
    }
    _getRunning() {
      const e2 = new Map();
      if (this._tasks.forAll((t3) => {
        t3.needsUpdate && e2.set(t3.name, (e2.get(t3.name) || 0) + 1);
      }), e2.size === 0)
        return null;
      let t2 = "";
      return e2.forEach((e3, s2) => {
        t2 += e3 > 1 ? ` ${e3}x ${s2}` : ` ${s2}`;
      }), t2;
    }
    _runIdle() {
      this._run();
    }
    _runInteracting() {
      this._run();
    }
    _runAnimating() {
      this._run();
    }
    _updateLoad() {
      const e2 = this._tasks.reduce((e3, t2) => t2.needsUpdate ? ++e3 : e3, 0);
      this._load = this._load * U$2 + e2 * (1 - U$2);
    }
    _schedule() {
      if (this._maxReschedule <= 0)
        return false;
      for (this._runQueue.filterInPlace((e2) => !!e2.needsUpdate || (e2.schedulePriority = e2.basePriority, false)), this._tasks.forAll((e2) => {
        e2.basePriority === R && e2.needsUpdate && !this._runQueue.includes(e2) && this._runQueue.unshift(e2);
      }); this._runQueue.length === 0; ) {
        let e2 = false, t2 = 0;
        if (this._tasks.forAll((s2) => {
          if (s2.needsUpdate && s2.schedulePriority !== 0 && s2.basePriority !== R && (!s2.task.runOncePerFrame || s2.lastFrameRun !== this._frameNumber))
            if (e2 = true, t2 = Math.max(t2, s2.basePriority), s2.schedulePriority === 1)
              s2.schedulePriority = 0, this._runQueue.push(s2);
            else
              --s2.schedulePriority;
        }), !e2)
          return this._updating.set(false), false;
        --this._maxReschedule;
      }
      return this._updating.set(true), true;
    }
    _run() {
      const e2 = this._budget.now();
      this._startFrameTaskTimes();
      do {
        for (; this._runQueue.length > 0; ) {
          const i2 = this._budget.now(), r2 = this._runQueue.pop();
          this._budget.resetProgress();
          try {
            r2.task.runTask(this._budget);
          } catch (s2) {
            s$22.getLogger("esri.views.support.Scheduler").error(`Exception in task "${r2.name}"`, s2);
          }
          r2.schedulePriority = r2.basePriority, r2.lastFrameRun = this._frameNumber;
          const a2 = this._budget.now() - i2;
          if (r2.runtime += a2, this._frameTaskTimes.set(r2.priority, this._frameTaskTimes.get(r2.priority) + a2), this._debug && this._budget.elapsed > 2 * this._budget.budget && console.log("Task", r2.name, "used", this._budget.elapsed, "of max", this._budget.budget, "ms"), this._budget.remaining <= 0)
            return this._updating.set(this._tasks.some((e3) => e3.needsUpdate)), void this._recordFrameTaskTimes(this._budget.now() - e2);
        }
      } while (this._schedule());
      this._updating.set(this._tasks.some((e3) => e3.needsUpdate)), this._recordFrameTaskTimes(this._budget.now() - e2);
    }
    _startFrameTaskTimes() {
      for (const e2 of Object.keys(I$2))
        this._frameTaskTimes.set(I$2[e2], 0);
    }
    _recordFrameTaskTimes(e2) {
      this._frameTaskTimes.forEach((e3, t2) => this.performanceInfo.tasks.get(t2).record(e3)), this.performanceInfo.total.record(e2);
    }
    get test() {
      return this._test;
    }
  }
  n2.Scheduler = u2;
  class _2 {
    constructor(t2, s2, r2, a2) {
      this._scheduler = t2, this.name = s2, this._basePriority = a2, this.lastFrameRun = 0, this.runtime = 0, this._queue = new n$r(), this._handles = new t$1N(), this.schedulePriority = this._basePriority, this._task = new t$n(r$1t(r2) ? r2 : this._queue), this._handles.add(f$10(() => this.task.running, () => t2.activate()));
    }
    get task() {
      return this._task.get();
    }
    get updating() {
      return this._queue.running;
    }
    remove() {
      this.processQueue(F$2), this._scheduler.removeTask(this), this.schedule = y$7.schedule, this.reschedule = y$7.reschedule, this._handles.destroy();
    }
    get basePriority() {
      return this._basePriority;
    }
    setPriority(e2) {
      this.name = e2;
      const t2 = A$2(e2);
      this._basePriority !== R && this.schedulePriority === 0 || (this.schedulePriority = t2), this._basePriority = t2;
    }
    get priority() {
      return this.name;
    }
    set priority(e2) {
      this.setPriority(e2);
    }
    get needsUpdate() {
      return this.updating || this.task.running;
    }
    schedule(e2, t2, s2) {
      return this._queue.push(e2, t2, s2);
    }
    reschedule(e2, t2, s2) {
      return this._queue.unshift(e2, t2, s2);
    }
    processQueue(e2) {
      this._queue.runTask(e2);
    }
  }
  class g2 {
    constructor() {
      this._begin = typeof performance != "undefined" ? performance.now() : 0, this._budget = 0, this._state = I$3.IDLE, this._done = false, this._enabled = true;
    }
    run(e2) {
      return !this.done && (e2() === true && this.madeProgress(), true);
    }
    get done() {
      return this._done;
    }
    get budget() {
      return this._budget;
    }
    madeProgress() {
      this._done = this.elapsed >= this._budget && this._enabled;
    }
    get state() {
      return this._state;
    }
    get enabled() {
      return this._enabled;
    }
    set enabled(e2) {
      this._enabled = e2;
    }
    reset(e2, t2) {
      this._begin = this.now(), this._budget = e2, this._state = t2, this._done = false;
    }
    get remaining() {
      return Math.max(this._budget - this.elapsed, 0);
    }
    now() {
      return performance.now();
    }
    get elapsed() {
      return performance.now() - this._begin;
    }
    resetProgress() {
      this._done = false;
    }
    get hasProgressed() {
      return this._done;
    }
  }
  n2.Budget = g2;
}(N || (N = {})), function(e2) {
  e2.SCHEDULED = "s", e2.READY = "r", e2.WAITING = "w", e2.IDLE = "i";
}(P$3 || (P$3 = {}));
const F$2 = (() => {
  const e2 = new N.Budget();
  return e2.enabled = false, e2;
})();
class C$3 {
  remove() {
  }
  processQueue() {
  }
  schedule(e2, t2, s2) {
    try {
      if (p$2W(t2)) {
        const e3 = a$2p();
        return s2 ? Promise.resolve(s2(e3)) : Promise.reject(e3);
      }
      return $$f(e2(F$2));
    } catch (i2) {
      return Promise.reject(i2);
    }
  }
  reschedule(e2, t2, s2) {
    return this.schedule(e2, t2, s2);
  }
}
const y$7 = new C$3();
let n$q = class extends m$1L {
  constructor(e2, t2) {
    var _a2;
    super({}), this._stage = e2, this._textureRequests = new Map(), this._frameTask = (_a2 = t2 == null ? void 0 : t2.registerTask(I$2.TEXTURE_UNLOAD)) != null ? _a2 : y$7;
  }
  normalizeCtorArgs() {
    return {};
  }
  destroy() {
    super.destroy(), this._frameTask.remove(), this._textureRequests.forEach((e2) => this._releaseTextureRequest(e2)), this._textureRequests.clear();
  }
  get updating() {
    return this._frameTask.updating;
  }
  fromData(e2, t2, r2) {
    const s2 = this.makeUid(e2);
    let o2 = this._textureRequests.get(s2);
    return o2 || (o2 = { referenceCount: 0, texture: t2(), textureAsync: null, abortController: null, onRemove: r2 }, this._stage && (this._stage.add(o2.texture), this._stage.loadImmediate(o2.texture)), this._textureRequests.set(s2, o2)), o2.referenceCount++, { uid: s2, texture: o2.texture, release: () => this._release(s2) };
  }
  _release(e2) {
    const t2 = this._textureRequests.get(e2);
    t2 ? (t2.referenceCount < 1 && console.warn("TextureCollection: reference count is < 1 for " + e2), t2.referenceCount--, t2.referenceCount < 1 && this._frameTask.schedule(() => this._releaseNow(e2))) : console.warn(`TextureCollection: texture doesn't exist: '${e2}'`);
  }
  get test() {
    return { textureRequests: this._textureRequests };
  }
  _releaseNow(e2) {
    if (!this._textureRequests)
      return;
    const t2 = this._textureRequests.get(e2);
    !t2 || t2.referenceCount > 0 || (this._releaseTextureRequest(t2), this._textureRequests.delete(e2));
  }
  _releaseTextureRequest(e2) {
    var _a2;
    e2.onRemove && e2.onRemove(), e2.texture ? (_a2 = this._stage) == null ? void 0 : _a2.remove(e2.texture) : e2.abortController && (e2.abortController.abort(), e2.abortController = null);
  }
  makeUid(e2, t2 = null) {
    return r$1t(t2) ? `${e2}.${t2}px` : e2;
  }
};
e$1W([y$1o()], n$q.prototype, "_frameTask", void 0), e$1W([y$1o()], n$q.prototype, "updating", null), n$q = e$1W([n$2f("esri.views.3d.support.TextureCollection")], n$q);
var t$g;
!function(t2) {
  t2[t2.Left = 0] = "Left", t2[t2.Middle = 1] = "Middle", t2[t2.Right = 2] = "Right";
}(t$g || (t$g = {}));
const r$m = ["click", "double-click", "immediate-click", "immediate-double-click", "hold", "drag", "key-down", "key-up", "pointer-down", "pointer-move", "pointer-up", "pointer-drag", "mouse-wheel", "pointer-enter", "pointer-leave", "gamepad", "focus", "blur"], i$n = {};
function o$k(t2) {
  return !!i$n[t2];
}
function s$j(t2) {
  for (const e2 of t2)
    if (!o$k(e2))
      return false;
  return true;
}
r$m.forEach((t2) => {
  i$n[t2] = true;
});
class p$n {
  constructor(t2) {
    this._handlers = new Map(), this._counter = 0, this._handlerCounts = new Map(), this.view = t2, this.inputManager = null;
  }
  connect(t2) {
    t2 && this.disconnect(), this.inputManager = t2, this._handlers.forEach(({ handler: t3, priority: e2 }, a2) => this.inputManager.installHandlers(a2, [t3], e2));
  }
  disconnect() {
    this.inputManager && this._handlers.forEach((t2, e2) => this.inputManager.uninstallHandlers(e2)), this.inputManager = null;
  }
  destroy() {
    this.disconnect(), this._handlers.clear(), this.view = null;
  }
  on(t2, e2, a2, r2) {
    const i2 = Array.isArray(t2) ? t2 : t2.split(",");
    if (!s$j(i2))
      return i2.some(o$k) && console.error("Error: registering input events and other events on the view at the same time is not supported."), null;
    let p2, l2;
    Array.isArray(e2) ? l2 = e2 : (p2 = e2, l2 = []), typeof a2 == "function" ? p2 = a2 : r2 = a2, r2 = r2 != null ? r2 : P$5.DEFAULT;
    const u2 = this._createUniqueGroupName(), m2 = new c$q(this.view, i2, l2, p2);
    this._handlers.set(u2, { handler: m2, priority: r2 });
    for (const n2 of i2) {
      const t3 = this._handlerCounts.get(n2) || 0;
      this._handlerCounts.set(n2, t3 + 1);
    }
    return this.inputManager && this.inputManager.installHandlers(u2, [m2], r2), { remove: () => this._removeHandler(u2, i2) };
  }
  hasHandler(t2) {
    return !!this._handlerCounts.get(t2);
  }
  _removeHandler(t2, e2) {
    if (this._handlers.has(t2)) {
      this._handlers.delete(t2);
      for (const t3 of e2) {
        const e3 = this._handlerCounts.get(t3);
        e3 === void 0 ? console.error("Trying to remove handler for event that has no handlers registered: ", t3) : e3 === 1 ? this._handlerCounts.delete(t3) : this._handlerCounts.set(t3, e3 - 1);
      }
    }
    this.inputManager && this.inputManager.uninstallHandlers(t2);
  }
  _createUniqueGroupName() {
    return this._counter += 1, `viewEvents_${this._counter}`;
  }
}
class c$q extends i$x {
  constructor(t2, e2, a2, n2) {
    super(true), this.view = t2;
    for (const r2 of e2)
      switch (r2) {
        case "click":
          this.registerIncoming("click", a2, (t3) => n2(this._wrapClick(t3)));
          break;
        case "double-click":
          this.registerIncoming("double-click", a2, (t3) => n2(this._wrapDoubleClick(t3)));
          break;
        case "immediate-click":
          this.registerIncoming("immediate-click", a2, (t3) => n2(this._wrapImmediateClick(t3)));
          break;
        case "immediate-double-click":
          this.registerIncoming("immediate-double-click", a2, (t3) => n2(this._wrapImmediateDoubleClick(t3)));
          break;
        case "hold":
          this.registerIncoming("hold", a2, (t3) => n2(this._wrapHold(t3)));
          break;
        case "drag":
          this.registerIncoming("drag", a2, (t3) => {
            const e3 = this._wrapDrag(t3);
            e3 && n2(e3);
          });
          break;
        case "key-down":
          this.registerIncoming("key-down", a2, (t3) => n2(this._wrapKeyDown(t3)));
          break;
        case "key-up":
          this.registerIncoming("key-up", a2, (t3) => n2(this._wrapKeyUp(t3)));
          break;
        case "pointer-down":
          this.registerIncoming("pointer-down", a2, (t3) => n2(this._wrapPointer(t3, "pointer-down")));
          break;
        case "pointer-move":
          this.registerIncoming("pointer-move", a2, (t3) => n2(this._wrapPointer(t3, "pointer-move")));
          break;
        case "pointer-up":
          this.registerIncoming("pointer-up", a2, (t3) => n2(this._wrapPointer(t3, "pointer-up")));
          break;
        case "pointer-drag":
          this.registerIncoming("pointer-drag", a2, (t3) => n2(this._wrapPointerDrag(t3)));
          break;
        case "mouse-wheel":
          this.registerIncoming("mouse-wheel", a2, (t3) => n2(this._wrapMouseWheel(t3)));
          break;
        case "pointer-enter":
          this.registerIncoming("pointer-enter", a2, (t3) => n2(this._wrapPointer(t3, "pointer-enter")));
          break;
        case "pointer-leave":
          this.registerIncoming("pointer-leave", a2, (t3) => n2(this._wrapPointer(t3, "pointer-leave")));
          break;
        case "gamepad":
          this.registerIncoming("gamepad", a2, (t3) => {
            n2(this._wrapGamepad(t3));
          });
          break;
        case "focus":
          this.registerIncoming("focus", a2, (t3) => {
            n2(this._wrapFocus(t3));
          });
          break;
        case "blur":
          this.registerIncoming("blur", a2, (t3) => {
            n2(this._wrapBlur(t3));
          });
      }
  }
  _wrapFocus(t2) {
    return { type: "focus", timestamp: t2.timestamp, native: t2.data.native, cancelable: t2.cancelable, stopPropagation: () => t2.stopPropagation(), async: (e2) => t2.async(e2), preventDefault: () => t2.preventDefault() };
  }
  _wrapBlur(t2) {
    return { type: "blur", timestamp: t2.timestamp, native: t2.data.native, cancelable: t2.cancelable, stopPropagation: () => t2.stopPropagation(), async: (e2) => t2.async(e2), preventDefault: () => t2.preventDefault() };
  }
  _wrapClick(t2) {
    const { pointerType: a2, button: n2, buttons: r2, x: i2, y: o2, native: s2, eventId: p2 } = t2.data, { cancelable: c2, timestamp: l2 } = t2;
    return { type: "click", pointerType: a2, button: n2, buttons: r2, x: i2, y: o2, native: s2, timestamp: l2, screenPoint: c$2b(i2, o2), mapPoint: this._getMapPoint(i2, o2), eventId: p2, cancelable: c2, stopPropagation: () => t2.stopPropagation(), async: (e2) => t2.async(e2), preventDefault: () => t2.preventDefault() };
  }
  _wrapDoubleClick(t2) {
    const { pointerType: e2, button: a2, buttons: n2, x: r2, y: i2, native: o2, eventId: s2 } = t2.data, { cancelable: p2, timestamp: c2 } = t2;
    return { type: "double-click", pointerType: e2, button: a2, buttons: n2, x: r2, y: i2, native: o2, timestamp: c2, mapPoint: this._getMapPoint(r2, i2), eventId: s2, cancelable: p2, stopPropagation: () => t2.stopPropagation(), async: (e3) => t2.async(e3), preventDefault: () => t2.preventDefault() };
  }
  _wrapImmediateClick(t2) {
    const { pointerType: e2, button: a2, buttons: n2, x: r2, y: i2, native: o2, eventId: s2 } = t2.data, p2 = o2.pointerId, { cancelable: c2, timestamp: l2 } = t2;
    return { type: "immediate-click", pointerId: p2, pointerType: e2, button: a2, buttons: n2, x: r2, y: i2, native: o2, timestamp: l2, mapPoint: this._getMapPoint(r2, i2), eventId: s2, cancelable: c2, stopPropagation: () => t2.stopPropagation(), async: (e3) => t2.async(e3), preventDefault: () => t2.preventDefault() };
  }
  _wrapImmediateDoubleClick(t2) {
    const { pointerType: e2, button: a2, buttons: n2, x: r2, y: i2, native: o2, eventId: s2 } = t2.data, p2 = o2.pointerId, { cancelable: c2, timestamp: l2 } = t2;
    return { type: "immediate-double-click", pointerId: p2, pointerType: e2, button: a2, buttons: n2, x: r2, y: i2, native: o2, timestamp: l2, mapPoint: this._getMapPoint(r2, i2), eventId: s2, cancelable: c2, stopPropagation: () => t2.stopPropagation(), async: (e3) => t2.async(e3), preventDefault: () => t2.preventDefault() };
  }
  _wrapHold(t2) {
    const { pointerType: e2, button: a2, buttons: n2, x: r2, y: i2, native: o2 } = t2.data, { cancelable: s2, timestamp: p2 } = t2;
    return { type: "hold", pointerType: e2, button: a2, buttons: n2, x: r2, y: i2, native: o2, timestamp: p2, mapPoint: this._getMapPoint(r2, i2), cancelable: s2, stopPropagation: () => t2.stopPropagation(), async: (e3) => t2.async(e3), preventDefault: () => t2.preventDefault() };
  }
  _getMapPoint(t2, a2) {
    return this.view.toMap(c$2b(t2, a2), { exclude: [] });
  }
  _wrapDrag(e2) {
    const a2 = e2.data, { x: n2, y: r2 } = a2.center, { action: i2, pointerType: o2, button: s2 } = a2;
    if (i2 === "start" && (this._latestDragStart = a2), !this._latestDragStart)
      return;
    const p2 = a2.pointer.native, c2 = a2.buttons, { cancelable: l2, timestamp: u2 } = e2, m2 = { x: this._latestDragStart.center.x, y: this._latestDragStart.center.y };
    return i2 === "end" && (this._latestDragStart = void 0), { type: "drag", action: i2, x: n2, y: r2, origin: m2, pointerType: o2, button: s2, buttons: c2, radius: a2.radius, angle: b$K(a2.angle), native: p2, timestamp: u2, cancelable: l2, stopPropagation: () => e2.stopPropagation(), async: (t2) => e2.async(t2), preventDefault: () => e2.preventDefault() };
  }
  _wrapKeyDown(t2) {
    const { key: e2, repeat: a2, native: n2 } = t2.data, { cancelable: r2, timestamp: i2 } = t2;
    return { type: "key-down", key: e2, repeat: a2, native: n2, timestamp: i2, cancelable: r2, stopPropagation: () => t2.stopPropagation(), async: (e3) => t2.async(e3), preventDefault: () => t2.preventDefault() };
  }
  _wrapKeyUp(t2) {
    const { key: e2, native: a2 } = t2.data, { cancelable: n2, timestamp: r2 } = t2;
    return { type: "key-up", key: e2, native: a2, timestamp: r2, cancelable: n2, stopPropagation: () => t2.stopPropagation(), async: (e3) => t2.async(e3), preventDefault: () => t2.preventDefault() };
  }
  _wrapPointer(t2, e2) {
    const { x: a2, y: n2, button: r2, buttons: i2, native: o2, eventId: s2 } = t2.data, p2 = o2.pointerId, c2 = o2.pointerType, { cancelable: l2, timestamp: u2 } = t2;
    return { type: e2, x: a2, y: n2, pointerId: p2, pointerType: c2, button: r2, buttons: i2, native: o2, timestamp: u2, eventId: s2, cancelable: l2, stopPropagation: () => t2.stopPropagation(), async: (e3) => t2.async(e3), preventDefault: () => t2.preventDefault() };
  }
  _wrapPointerDrag(t2) {
    const { x: e2, y: a2, buttons: n2, native: r2, eventId: i2 } = t2.data.currentEvent, { button: o2 } = t2.data.startEvent, s2 = t2.data.startEvent.native.pointerId, p2 = t2.data.startEvent.native.pointerType, c2 = t2.data.action, l2 = { x: t2.data.startEvent.x, y: t2.data.startEvent.y }, { cancelable: u2, timestamp: m2 } = t2;
    return { type: "pointer-drag", x: e2, y: a2, pointerId: s2, pointerType: p2, button: o2, buttons: n2, action: c2, origin: l2, native: r2, timestamp: m2, eventId: i2, cancelable: u2, stopPropagation: () => t2.stopPropagation(), async: (e3) => t2.async(e3), preventDefault: () => t2.preventDefault() };
  }
  _wrapMouseWheel(t2) {
    const { cancelable: e2, data: a2, timestamp: n2 } = t2, { x: r2, y: i2, deltaY: o2, native: s2 } = a2;
    return { type: "mouse-wheel", x: r2, y: i2, deltaY: o2, native: s2, timestamp: n2, cancelable: e2, stopPropagation: () => t2.stopPropagation(), async: (e3) => t2.async(e3), preventDefault: () => t2.preventDefault() };
  }
  _wrapGamepad(t2) {
    const { action: e2, state: a2, device: n2 } = t2.data, { cancelable: r2, timestamp: i2 } = t2, { buttons: o2, axes: s2 } = a2;
    return { type: "gamepad", device: n2, timestamp: i2, action: e2, buttons: o2, axes: s2, cancelable: r2, stopPropagation: () => t2.stopPropagation(), async: (e3) => t2.async(e3), preventDefault: () => t2.preventDefault() };
  }
}
var o$j, t$f, u$j;
!function(o2) {
  o2[o2.USER = 0] = "USER", o2[o2.MANAGER = 1] = "MANAGER";
}(o$j || (o$j = {})), function(o2) {
  o2[o2.None = 0] = "None", o2[o2.Unfocused = 1] = "Unfocused", o2[o2.Focused = 2] = "Focused", o2[o2.Unselected = 4] = "Unselected", o2[o2.Selected = 8] = "Selected", o2[o2.All = 15] = "All";
}(t$f || (t$f = {})), function(o2) {
  o2[o2.None = 0] = "None", o2[o2.Custom1 = 16] = "Custom1", o2[o2.Custom2 = 32] = "Custom2", o2[o2.Custom3 = 64] = "Custom3", o2[o2.Custom4 = 128] = "Custom4", o2[o2.Custom5 = 256] = "Custom5", o2[o2.Custom6 = 512] = "Custom6", o2[o2.Custom7 = 1024] = "Custom7", o2[o2.Custom8 = 2048] = "Custom8", o2[o2.Custom9 = 4096] = "Custom9", o2[o2.Custom10 = 8192] = "Custom10", o2[o2.Custom11 = 16384] = "Custom11", o2[o2.Custom12 = 32768] = "Custom12", o2[o2.All = 65520] = "All";
}(u$j || (u$j = {}));
function o$i(t2) {
  return [t2.on("before-add", (o2) => {
    const i2 = o2.item;
    if (i2 == null || t2.includes(i2))
      return s$22.getLogger("esri.views.interactive.interactiveToolUtils").warn("Tool is either already in the list of tools or tool is `null`. Not adding tool."), void o2.preventDefault();
    i2.onAdd();
  }), t2.on("after-remove", (e2) => {
    const t3 = e2.item;
    t3.active && (t3.view.activeTool = null), t3.destroy();
  })];
}
function i$m(e2) {
  return e2.visible && e2.getEditableFlag(o$j.USER) && e2.getEditableFlag(o$j.MANAGER);
}
function n$p(t2) {
  return c$2b(t2.x, t2.y);
}
function i$l(t2, n2) {
  const c2 = (t2 instanceof HTMLElement ? t2 : t2.surface).getBoundingClientRect();
  return c$2b(n2.clientX - c2.left, n2.clientY - c2.top);
}
function r$l(e2, t2) {
  return t2 instanceof Event ? i$l(e2, t2) : n$p(t2);
}
function o$h(e2) {
  if (e2 instanceof Event)
    return true;
  if (typeof e2 == "object" && "type" in e2) {
    switch (e2.type) {
      case "click":
      case "double-click":
      case "pointer-down":
      case "pointer-drag":
      case "pointer-enter":
      case "pointer-leave":
      case "pointer-up":
      case "pointer-move":
      case "immediate-click":
      case "immediate-double-click":
      case "hold":
      case "drag":
      case "mouse-wheel":
        return true;
      default:
        return false;
    }
  }
  return false;
}
class c$p {
  constructor() {
    this._pointerLocations = new Map(), this._hoveredManipulators = new Map(), this._grabbedManipulators = new Map(), this._draggedManipulators = new Map(), this._stopDrag = false, this._revertToNullActiveTool = false, this._cursor = null;
  }
  get cursor() {
    return this._cursor;
  }
  handleInputEvent(t2, e2) {
    const s2 = () => t2.stopPropagation();
    switch (t2.type) {
      case "pointer-move":
        u$i(t2.pointerType) && this._pointerLocations.set(t2.pointerId, { x: t2.x, y: t2.y, pointerType: t2.pointerType });
        break;
      case "drag":
        this._grabbedManipulators.size > 0 && (this._stopDrag = true), this._stopDrag && (s2(), t2.action === "end" && (this._stopDrag = false));
        break;
      case "pointer-down": {
        if (!h$d(t2))
          break;
        const o2 = n$p(t2), a2 = this._intersect(o2, t2.pointerType, e2.forEachTool);
        if (t$1W(a2))
          break;
        const n2 = a2.manipulator, p2 = a2.tool;
        !(r$1t(n2) && r$1t(p2) && n2.interactive) || n2.grabbable && n2.grabbableForEvent(t2) || !n2.grabbing || n2.dragging || this._ungrabManipulatorBeforeDragging(n2, t2, e2), r$1t(n2) && r$1t(p2) && n2.interactive && n2.grabbable && n2.grabbableForEvent(t2) && !n2.grabbing && (this._grabbedManipulators.set(t2.pointerId, { manipulator: n2, tool: p2, start: o2, pointerType: t2.pointerType }), this._grabbedManipulators.size === 1 && t$1W(e2.activeTool) && (this._revertToNullActiveTool = true, e2.setActiveTool(a2.tool)), n2.grabbing = true, n2.events.emit("grab-changed", { action: "start", pointerType: t2.pointerType, screenPoint: o2 }), s2());
        break;
      }
      case "pointer-up":
        this._draggedManipulators.has(t2.pointerId) || this._handlePointerEnd(t2, e2);
        break;
      case "pointer-drag": {
        if (!h$d(t2))
          break;
        const r2 = this._grabbedManipulators.get(t2.pointerId), p2 = o$1Z(r2, ({ manipulator: t3 }) => t3), c2 = o$1Z(r2, ({ tool: t3 }) => t3);
        if (t$1W(p2) || t$1W(c2))
          break;
        const u2 = n$p(t2);
        u2.x = a$21(u2.x, 0, e2.view.width), u2.y = a$21(u2.y, 0, e2.view.height);
        const d2 = e$1U(r2).start, g2 = this._draggedManipulators.get(t2.pointerId);
        switch (t2.action) {
          case "start":
          case "update":
            t2.action !== "update" && this._grabbedManipulators.size !== 1 || (p2.dragging = true, g2 ? p2.events.emit("drag", { action: "update", start: d2, screenPoint: u2 }) : p2.events.emit("drag", { action: "start", start: d2, screenPoint: u2, pointerType: t2.pointerType }), this._draggedManipulators.set(t2.pointerId, { tool: c2, manipulator: p2, start: d2 }));
            break;
          case "end":
            p2.dragging = false, g2 && p2.events.emit("drag", { action: "end", start: d2, screenPoint: u2 }), this._draggedManipulators.delete(t2.pointerId), this._handlePointerEnd(t2, e2);
        }
        s2();
        break;
      }
      case "immediate-click": {
        const o2 = n$p(t2), a2 = this._intersect(o2, t2.pointerType, e2.forEachTool);
        if (d$b(t2) || e2.forEachTool((t3) => {
          if ((!r$1t(a2) || a2.tool !== t3 || t3.automaticManipulatorSelection) && t3.manipulators) {
            let e3 = false;
            t3.manipulators.forEach(({ manipulator: t4 }) => {
              t4.selected && (t4.selected = false, e3 = true);
            }), e3 && t3.onManipulatorSelectionChanged && t3.onManipulatorSelectionChanged();
          }
        }), t$1W(a2))
          break;
        const { manipulator: n2, tool: p2 } = a2;
        if (!n2.interactive)
          break;
        n2.selectable && p2.automaticManipulatorSelection && (n2.selected = !n2.selected, p2.onManipulatorSelectionChanged && p2.onManipulatorSelectionChanged());
        const c2 = t2.native.shiftKey;
        n2.events.emit("immediate-click", { screenPoint: o2, button: t2.button, pointerType: t2.pointerType, shiftKey: c2, stopPropagation: s2 });
        break;
      }
      case "click": {
        const o2 = n$p(t2), a2 = this._intersect(o2, t2.pointerType, e2.forEachTool), n2 = r$1t(a2) ? a2.manipulator : null;
        if (t$1W(n2) || !n2.interactive)
          break;
        const p2 = t2.native.shiftKey;
        n2.events.emit(t2.type, { screenPoint: o2, button: t2.button, pointerType: t2.pointerType, shiftKey: p2 }), s2();
        break;
      }
      case "double-click": {
        const o2 = n$p(t2), a2 = this._intersect(o2, t2.pointerType, e2.forEachTool), n2 = r$1t(a2) ? a2.manipulator : null;
        if (t$1W(n2) || !n2.interactive)
          break;
        const p2 = t2.native.shiftKey;
        n2.events.emit("double-click", { screenPoint: o2, button: t2.button, pointerType: t2.pointerType, shiftKey: p2, stopPropagation: s2 });
        break;
      }
      case "immediate-double-click": {
        const o2 = n$p(t2), a2 = this._intersect(o2, t2.pointerType, e2.forEachTool), n2 = r$1t(a2) ? a2.manipulator : null;
        if (t$1W(n2) || !n2.interactive)
          break;
        const p2 = t2.native.shiftKey;
        n2.events.emit("immediate-double-click", { screenPoint: o2, button: t2.button, pointerType: t2.pointerType, shiftKey: p2, stopPropagation: s2 });
        break;
      }
    }
    this._onFocusChange(e2.forEachTool);
  }
  _ungrabManipulatorBeforeDragging(t2, e2, o2) {
    t2.grabbing = false, t2.events.emit("grab-changed", { action: "end", pointerType: e2.pointerType, screenPoint: n$p(e2) }), this._grabbedManipulators.forEach(({ manipulator: e3 }, o3) => {
      e3 === t2 && this._grabbedManipulators.delete(o3);
    }), this._afterManipulatorUngrab(o2.setActiveTool);
  }
  _handlePointerEnd(t2, e2) {
    const o2 = o$1Z(this._grabbedManipulators.get(t2.pointerId), ({ manipulator: t3 }) => t3);
    t$1W(o2) || o2.grabbing && (o2.grabbing = false, o2.events.emit("grab-changed", { action: "end", pointerType: t2.pointerType, screenPoint: n$p(t2) }), this._grabbedManipulators.delete(t2.pointerId), this._afterManipulatorUngrab(e2.setActiveTool));
  }
  _cursorFromMap(t2) {
    let o2 = null;
    return n$2l(t2, ({ manipulator: t3 }) => !(t$1W(t3) || !t3.interactive) && (t3.grabbing && t3.grabCursor ? (o2 = t3.grabCursor, true) : !!t3.cursor && (o2 = t3.cursor, true))), o2;
  }
  _onFocusChange(t2) {
    this._updateCursor(), this._updateFocusedManipulatorTools(t2);
  }
  _updateCursor() {
    this._grabbedManipulators.size > 0 ? this._cursor = this._cursorFromMap(this._grabbedManipulators) || "grabbing" : this._hoveredManipulators.size > 0 ? this._cursor = this._cursorFromMap(this._hoveredManipulators) || "pointer" : this._cursor = null;
  }
  _updateFocusedManipulatorTools(e2) {
    const o2 = new Set(), i2 = new Set();
    this._grabbedManipulators.forEach(({ tool: t2 }) => {
      o2.add(t2);
    }), this._hoveredManipulators.forEach(({ tool: t2 }) => {
      i2.add(t2);
    }), e2((e3) => {
      e3.hasGrabbedManipulators = o2.has(e3), e3.hasHoveredManipulators = i2.has(e3);
      const a2 = this._grabbedManipulators.values(), n2 = o$1N(a2, ({ tool: t2 }) => t2 === e3);
      e3.firstGrabbedManipulator = r$1t(n2) ? n2.manipulator : null;
    });
  }
  clearPointers(t2, { forEachTool: e2, setActiveTool: o2 }, r2 = true, a2) {
    const n2 = (e3, o3) => e3 === t2 && (t$1W(a2) || a2 === o3);
    this._grabbedManipulators.forEach(({ tool: t3, manipulator: e3, pointerType: o3 }, r3) => {
      n2(t3, e3) && (this._grabbedManipulators.delete(r3), e3.grabbing = false, e3.events.emit("grab-changed", { action: "end", screenPoint: null, pointerType: o3 }));
    }), this._draggedManipulators.forEach(({ tool: t3, manipulator: e3 }, o3) => {
      n2(t3, e3) && (this._draggedManipulators.delete(o3), e3.dragging = false, e3.events.emit("drag", { action: "cancel" }));
    }), r2 && this._hoveredManipulators.forEach(({ tool: t3, manipulator: e3 }, o3) => {
      n2(t3, e3) && (this._hoveredManipulators.delete(o3), e3.hovering = false);
    }), this._afterManipulatorUngrab(o2), this._onFocusChange(e2);
  }
  _intersect(t2, e2, o2) {
    let r2 = null;
    return o2((o3) => {
      if (o3.manipulators == null || !i$m(o3))
        return false;
      const a2 = o3.manipulators.intersect(t2, e2);
      return !t$1W(a2) && (r2 = { tool: o3, manipulator: a2 }, true);
    }), r2;
  }
  updateHoveredStateFromKnownPointers(t2) {
    this._pointerLocations.forEach((e2, o2) => {
      this._updateHoveredStateForPointerAtScreenPosition(c$2b(e2.x, e2.y), o2, e2.pointerType, t2);
    });
  }
  handleHoverEvent(t2, e2) {
    t2.type !== "pointer-up" && t2.type !== "immediate-click" && t2.type !== "pointer-move" || !u$i(t2.pointerType) || this._updateHoveredStateForPointerAtScreenPosition(n$p(t2), t2.pointerId, t2.pointerType, e2);
  }
  _updateHoveredStateForPointerAtScreenPosition(t2, e2, o2, i2) {
    let n2 = this._intersect(t2, o2, i2);
    const s2 = o$1Z(this._hoveredManipulators.get(e2), ({ manipulator: t3 }) => t3);
    r$1t(n2) && !n2.manipulator.interactive && (n2 = null), r$1t(n2) && s2 === n2.manipulator || (r$1t(s2) && (s2.hovering = false), r$1t(n2) ? (n2.manipulator.hovering = true, this._hoveredManipulators.set(e2, n2)) : this._hoveredManipulators.delete(e2), this._onFocusChange(i2));
  }
  _afterManipulatorUngrab(t2) {
    this._grabbedManipulators.size === 0 && this._revertToNullActiveTool && (t2(null), this._revertToNullActiveTool = false);
  }
}
function u$i(t2) {
  return t2 === "mouse";
}
function h$d(t2) {
  return t2.pointerType !== "mouse" || t2.button === 0;
}
function d$b(t2) {
  return !!t2.native.shiftKey;
}
const g$7 = "attached", E$3 = "tools";
let w$3 = class extends d$O {
  constructor(t2) {
    super(t2), this._manipulatorState = new c$p(), this.tools = new j$F(), this.cursor = null, this._forEachTool = (t3) => {
      for (const o2 of this.tools.items)
        if (t3(o2))
          return;
    };
  }
  initialize() {
    this.handles.add([this.view.on(r$m, (t2) => {
      this._handleInputEvent(t2);
    }, P$5.TOOL), ...o$i(this.tools), this.tools.on("before-add", ({ item: t2 }) => {
      this._updateToolEditableFlag(t2);
    }), this.tools.on("before-remove", ({ item: t2 }) => {
      this._manipulatorState.clearPointers(t2, this._manipulatorStateEventArgs), this._updateCursor();
    }), this.tools.on("change", () => {
      this._refreshToolWatchers();
    })]);
  }
  destroy() {
    this.detach(), this.handles.removeAll();
  }
  get _manipulatorStateEventArgs() {
    return { forEachTool: this._forEachTool, activeTool: this.activeTool, setActiveTool: (t2) => {
      this.activeTool = t2;
    }, view: this.view };
  }
  set activeTool(t2) {
    if (r$1t(t2) && !this.view.ready)
      return void s$22.getLogger(this.declaredClass).error("Cannot set active tool while view is not ready.");
    if (t2 === this.activeTool)
      return;
    const o2 = this.activeTool;
    this._set("activeTool", t2), r$1t(o2) && o2.deactivate(), r$1t(t2) && t2.activate(), this._removeIncompleteTools(t2);
    for (const e2 of this.tools) {
      this._updateToolEditableFlag(e2);
      const t3 = i$m(e2);
      !t$1W(this.activeTool) && t3 || this._manipulatorState.clearPointers(e2, this._manipulatorStateEventArgs, !t3);
    }
    this._updateCursor();
  }
  get updating() {
    var _a2, _b2;
    return this.updatingHandles.updating || this.tools.some((t2) => t2.updating) || ((_b2 = (_a2 = this.textures) == null ? void 0 : _a2.updating) != null ? _b2 : false);
  }
  attach() {
    this.view.type === "3d" ? (this._set("textures", new n$q(this.view._stage, this.view.resourceController.scheduler)), this.handles.add([l$1f(() => {
      const { state: t2 } = this.view;
      return "camera" in t2 && t2.camera;
    }, () => {
      this._forEachManipulator((t2) => {
        t2.onViewChange != null && t2.onViewChange();
      });
    }), this.view.elevationProvider.on("elevation-change", (t2) => {
      this._forEachManipulator((o2) => {
        o2.onElevationChange != null && o2.onElevationChange(t2);
      });
    }), n$2k(() => this._set("textures", s$26(this.textures)))], g$7)) : this.handles.add(l$1f(() => this.view.extent, () => {
      this._forEachManipulator((t2) => {
        t2.onViewChange != null && t2.onViewChange();
      });
    }));
  }
  detach() {
    r$1t(this.activeTool) && (this.activeTool = null), this.tools.removeAll(), this.handles.remove(g$7);
  }
  _forEachManipulator(t2) {
    this._forEachTool((o2) => {
      o2.manipulators && o2.manipulators.forEach(({ manipulator: e2 }) => t2(e2, o2));
    });
  }
  _handleInputEvent(t2) {
    let o2 = false;
    const e2 = __spreadProps(__spreadValues({}, t2), { stopPropagation: () => {
      o2 = true, t2.stopPropagation();
    } });
    r$1t(this.activeTool) ? this.activeTool.handleInputEvent && this.activeTool.handleInputEvent(e2) : this._forEachTool((t3) => {
      !o2 && t3.visible && t3.handleInputEvent(e2);
    }), !o2 && t2.type === "key-down" && t2.key === "Escape" && this.activeTool && (t2.stopPropagation(), this.activeTool = null), this._manipulatorState.handleInputEvent(e2, this._manipulatorStateEventArgs), !o2 && r$1t(this.activeTool) && this.activeTool.handleInputEventAfter(e2), this._manipulatorState.handleHoverEvent(e2, this._forEachTool), this._updateCursor();
  }
  _refreshToolWatchers() {
    this.handles.remove(E$3), this._forEachTool((t2) => {
      if (t2 instanceof m$1L) {
        const o2 = l$1f(() => [t2.cursor, t2.visible, t2.editable], () => {
          i$m(t2) || this._manipulatorState.clearPointers(t2, this._manipulatorStateEventArgs), this._updateCursor();
        });
        this.handles.add(o2, E$3);
      }
      t2.manipulators && this.handles.add([t2.manipulators.on("after-remove", (o2) => {
        this._manipulatorState.clearPointers(t2, this._manipulatorStateEventArgs, true, o2.item.manipulator);
      }), t2.manipulators.on("change", () => {
        this._manipulatorState.updateHoveredStateFromKnownPointers(this._forEachTool), this._updateCursor();
      })], E$3);
    }), this._manipulatorState.updateHoveredStateFromKnownPointers(this._forEachTool), this._updateCursor();
  }
  _updateToolEditableFlag(t2) {
    t2.setEditableFlag(o$j.MANAGER, t$1W(this.activeTool) || t2 === this.activeTool);
  }
  _updateCursor() {
    let t2 = this._manipulatorState.cursor;
    t$1W(t2) && this._forEachTool((o2) => !(!r$1t(o2.cursor) || !o2.visible) && (t2 = o2.cursor, true)), this._get("cursor") !== t2 && this._set("cursor", t2);
  }
  _removeIncompleteTools(t2) {
    this.tools.filter((o2) => (t$1W(t2) || o2 !== t2) && !o2.created && o2.removeIncompleteOnCancel).forEach((t3) => {
      this.tools.remove(t3);
    });
  }
};
e$1W([y$1o({ constructOnly: true, nonNullable: true })], w$3.prototype, "view", void 0), e$1W([y$1o({ readOnly: true, nonNullable: true })], w$3.prototype, "textures", void 0), e$1W([y$1o({ value: null })], w$3.prototype, "activeTool", null), e$1W([y$1o({ readOnly: true, type: j$F })], w$3.prototype, "tools", void 0), e$1W([y$1o({ readOnly: true })], w$3.prototype, "cursor", void 0), e$1W([y$1o({ readOnly: true })], w$3.prototype, "updating", null), w$3 = e$1W([n$2f("esri.views.ToolViewManager")], w$3);
const y$6 = w$3;
let n$o = class extends m$1L {
  constructor(e2) {
    super(), this.nativeIndex = null, this._detectedDeviceType = "unknown", e2.mapping === "standard" ? this._detectedDeviceType = "standard" : o$g.test(e2.id) ? this._detectedDeviceType = "spacemouse" : this._detectedDeviceType = "unknown", this.nativeIndex = e2.index;
  }
  get native() {
    const e2 = navigator.getGamepads ? navigator.getGamepads() : [];
    return this.nativeIndex != null && this.nativeIndex < e2.length ? e2[this.nativeIndex] : null;
  }
  get deviceType() {
    return this._detectedDeviceType;
  }
  get axisThreshold() {
    return i$k[this.deviceType];
  }
};
e$1W([y$1o({ nonNullable: true, readOnly: true })], n$o.prototype, "nativeIndex", void 0), e$1W([y$1o({ type: String, readOnly: true })], n$o.prototype, "deviceType", null), e$1W([y$1o({ type: Number, readOnly: true })], n$o.prototype, "axisThreshold", null), n$o = e$1W([n$2f("esri.views.input.gamepad.GamepadInputDevice")], n$o);
const o$g = new RegExp("^(3dconnexion|space(mouse|navigator|pilot|explorer))", "i"), i$k = { standard: 0.15, spacemouse: 0.025, unknown: 0 }, a$u = n$o;
let c$o = class extends m$1L {
  constructor(...e2) {
    super(...e2), this.devices = new j$F(), this.enabledFocusMode = "document";
  }
};
e$1W([y$1o({ type: j$F.ofType(a$u), readOnly: true })], c$o.prototype, "devices", void 0), e$1W([y$1o({ type: ["document", "view", "none"] })], c$o.prototype, "enabledFocusMode", void 0), c$o = e$1W([n$2f("esri.views.input.gamepad.GamepadSettings")], c$o);
const i$j = c$o;
let p$m = class extends m$1L {
  constructor() {
    super(...arguments), this.gamepad = new i$j();
  }
};
e$1W([y$1o({ readOnly: true })], p$m.prototype, "gamepad", void 0), p$m = e$1W([n$2f("esri.views.input.Input")], p$m);
const a$t = p$m;
let s$i = class extends m$1L {
  constructor(o2) {
    super(o2), this.enabled = true, this.device = null, this.mode = "pan", this.tiltDirection = "forward-down", this.velocityFactor = 1;
  }
};
e$1W([y$1o({ type: Boolean, nonNullable: true })], s$i.prototype, "enabled", void 0), e$1W([y$1o({ type: a$u })], s$i.prototype, "device", void 0), e$1W([y$1o({ type: ["pan", "zoom"], nonNullable: true })], s$i.prototype, "mode", void 0), e$1W([y$1o({ type: ["forward-down", "forward-up"], nonNullable: true })], s$i.prototype, "tiltDirection", void 0), e$1W([y$1o({ type: Number, nonNullable: true })], s$i.prototype, "velocityFactor", void 0), s$i = e$1W([n$2f("esri.views.navigation.gamepad.GamepadSettings")], s$i);
const a$s = s$i;
let a$r = class extends m$1L {
  constructor(o2) {
    super(o2), this.browserTouchPanEnabled = true, this.gamepad = new a$s(), this.momentumEnabled = true, this.mouseWheelZoomEnabled = true;
  }
};
e$1W([y$1o({ type: Boolean })], a$r.prototype, "browserTouchPanEnabled", void 0), e$1W([y$1o({ type: a$s, nonNullable: true })], a$r.prototype, "gamepad", void 0), e$1W([y$1o({ type: Boolean })], a$r.prototype, "momentumEnabled", void 0), e$1W([y$1o({ type: Boolean })], a$r.prototype, "mouseWheelZoomEnabled", void 0), a$r = e$1W([n$2f("esri.views.navigation.Navigation")], a$r);
const p$l = a$r;
var s$h;
function h$c(e2) {
  var _a2;
  const r2 = e2.url ? m$v(e2.url) : void 0, o2 = (_a2 = e2.spatialReference) == null ? void 0 : _a2.vcsWkid;
  return !(o2 == null && r$1t(r2) && r2.serverType === "ImageServer") && u$h(e2) && e2.heightModelInfo ? e2.heightModelInfo : f$a(e2) ? v$h.deriveUnitFromSR(p$k, e2.spatialReference) : null;
}
function u$h(e2) {
  return "heightModelInfo" in e2;
}
function d$a(e2) {
  if (e2.type === "unknown" || !("capabilities" in e2))
    return false;
  switch (e2.type) {
    case "csv":
    case "feature":
    case "geojson":
    case "subtype-group":
    case "ogc-feature":
    case "oriented-imagery":
    case "wfs":
      return true;
    default:
      return false;
  }
}
function f$a(e2) {
  return d$a(e2) ? !!(e2.capabilities && e2.capabilities.data && e2.capabilities.data.supportsZ) : m$d(e2);
}
function g$6(e2) {
  return e2.layers != null || m$d(e2) || d$a(e2) || u$h(e2);
}
function m$d(e2) {
  switch (e2.type) {
    case "building-scene":
    case "elevation":
    case "integrated-mesh":
    case "point-cloud":
    case "scene":
    case "voxel":
      return true;
    case "base-dynamic":
    case "base-elevation":
    case "base-tile":
    case "bing-maps":
    case "csv":
    case "dimension":
    case "geojson":
    case "feature":
    case "subtype-group":
    case "geo-rss":
    case "graphics":
    case "group":
    case "imagery":
    case "imagery-tile":
    case "kml":
    case "line-of-sight":
    case "map-image":
    case "map-notes":
    case "media":
    case "ogc-feature":
    case "open-street-map":
    case "oriented-imagery":
    case "route":
    case "stream":
    case "tile":
    case "unknown":
    case "unsupported":
    case "vector-tile":
    case "wcs":
    case "web-tile":
    case "wfs":
    case "wms":
    case "wmts":
    case null:
      return false;
  }
  return false;
}
!function(e2) {
  e2[e2.Ok = 0] = "Ok", e2[e2.Units = 1] = "Units", e2[e2.HeightModel = 2] = "HeightModel", e2[e2.CRS = 3] = "CRS", e2[e2.Unsupported = 4] = "Unsupported";
}(s$h || (s$h = {}));
const p$k = new v$h({ heightModel: "gravity-related-height" });
var l$m;
!function(l2) {
  l2[l2.Global = 1] = "Global", l2[l2.Local = 2] = "Local";
}(l$m || (l$m = {}));
let n$n, s$g = null;
async function c$n(r2) {
  s$g || (s$g = import("./geometryServiceUtils.js").then((e2) => n$n = e2)), await s$g, f$1x(r2);
}
async function p$j(e2, s2, a2, m2) {
  if (!e2)
    return null;
  const l2 = e2.spatialReference;
  return en() || An(l2, s2) ? rn(e2, s2) : n$n ? n$n.projectGeometry(e2, s2, a2, m2) : (await Promise.race([c$n(m2), tn(m2)]), p$j(e2, s2, a2, m2));
}
let h$b = class extends m$1L {
  constructor(e2) {
    super(e2), this.required = { tileInfo: false, heightModelInfo: false, extent: false }, this.defaultSpatialReference = null, this.userSpatialReference = null, this.sourcePreloadCount = 10, this.priorityCollection = null, this.requiresExtentInSpatialReference = true, this.suspended = false, this._projectExtentTask = { task: null, input: null, output: null, spatialReference: null };
  }
  destroy() {
    this._projectExtentTask.task && (this._projectExtentTask.task = p$33(this._projectExtentTask.task)), this._set("map", null);
  }
  get ready() {
    return !this._spatialReferenceTask.updating && !this._tileInfoTask.updating && !this._extentTask.updating;
  }
  get heightModelInfoReady() {
    return !this._heightModelInfoTask.updating;
  }
  get spatialReference() {
    return r$1t(this.userSpatialReference) ? this.userSpatialReference : e$1U(this._spatialReferenceTask.spatialReference);
  }
  get extent() {
    return e$1U(this._extentTask.extent);
  }
  get heightModelInfo() {
    return e$1U(this._heightModelInfoTask.heightModelInfo);
  }
  get vcsWkid() {
    return e$1U(this._heightModelInfoTask.vcsWkid);
  }
  get latestVcsWkid() {
    return e$1U(this._heightModelInfoTask.latestVcsWkid);
  }
  get viewingMode() {
    return t$1W(this.userSpatialReference) || this.userSpatialReference.equals(e$1U(this._spatialReferenceTask.spatialReference)) ? e$1U(this._spatialReferenceTask.viewingMode) : null;
  }
  get tileInfo() {
    return e$1U(this._tileInfoTask.tileInfo);
  }
  get mapCollections() {
    var _a2, _b2, _c2, _d2;
    const e2 = (_a2 = this.map) == null ? void 0 : _a2.call(this), t2 = [];
    return r$1t(this.priorityCollection) && t2.push(this.priorityCollection), t2.push({ parent: e2 == null ? void 0 : e2.basemap, layers: (_b2 = e2 == null ? void 0 : e2.basemap) == null ? void 0 : _b2.baseLayers }, { layers: e2 == null ? void 0 : e2.layers }, { parent: e2 == null ? void 0 : e2.ground, layers: (_c2 = e2 == null ? void 0 : e2.ground) == null ? void 0 : _c2.layers }, { parent: e2 == null ? void 0 : e2.basemap, layers: (_d2 = e2 == null ? void 0 : e2.basemap) == null ? void 0 : _d2.referenceLayers }), t2;
  }
  get _allLayers() {
    return this._collectLayers(this.mapCollections);
  }
  get _spatialReferenceTask() {
    var _a2;
    if (this.suspended)
      return (_a2 = this._get("_spatialReferenceTask")) != null ? _a2 : { updating: false };
    const { layers: e2, updating: t2 } = this._allLayers;
    let a2 = null;
    for (const i2 of e2) {
      const e3 = this._getSupportedSpatialReferences(i2);
      if (e3.length > 0) {
        const t3 = this._narrowDownSpatialReferenceCandidates(a2, e3);
        r$1t(t3) && (a2 = t3);
      }
      if (r$1t(a2) && a2.length === 1)
        break;
    }
    if (t2 && (t$1W(a2) || a2.length !== 1))
      return { updating: true };
    const n2 = this._pickSpatialReferenceCandidate(a2);
    return { spatialReference: r$1t(n2) ? n2.spatialReference : null, viewingMode: r$1t(n2) ? n2.viewingMode : null, updating: false };
  }
  get _tileInfoTask() {
    var _a2, _b2, _c2, _d2, _e3, _f2, _g2, _h2;
    if (!this.required.tileInfo)
      return (_a2 = this._get("_tileInfoTask")) != null ? _a2 : { updating: false };
    if (!this.spatialReference)
      return { updating: this._spatialReferenceTask.updating };
    const { layers: e2, updating: t2 } = this._collectLayers([{ parent: (_c2 = (_b2 = this.map) == null ? void 0 : _b2.call(this)) == null ? void 0 : _c2.basemap, layers: (_f2 = (_e3 = (_d2 = this.map) == null ? void 0 : _d2.call(this)) == null ? void 0 : _e3.basemap) == null ? void 0 : _f2.baseLayers }, { layers: (_h2 = (_g2 = this.map) == null ? void 0 : _g2.call(this)) == null ? void 0 : _h2.layers }]);
    if (e2 && e2.length > 0 && "tileInfo" in e2[0]) {
      const t3 = e2[0].tileInfo;
      return { tileInfo: t3 && t3.spatialReference.equals(this.spatialReference) ? t3 : null, updating: false };
    }
    return { updating: t2 };
  }
  get _heightModelInfoTask() {
    var _a2, _b2, _c2, _d2;
    if (!this.required.heightModelInfo || this.suspended && ((_a2 = this._get("_heightModelInfoTask")) == null ? void 0 : _a2.heightModelInfo))
      return (_b2 = this._get("_heightModelInfoTask")) != null ? _b2 : { updating: false };
    const { layers: e2, updating: t2 } = this._allLayers;
    for (const a2 of e2)
      if (g$6(a2)) {
        const e3 = h$c(a2);
        if (e3)
          return { heightModelInfo: e3, vcsWkid: (_c2 = a2.spatialReference) == null ? void 0 : _c2.vcsWkid, latestVcsWkid: (_d2 = a2.spatialReference) == null ? void 0 : _d2.latestVcsWkid, updating: false };
      }
    return { updating: t2 };
  }
  get _extentCandidatesTask() {
    var _a2, _b2;
    if (this.suspended || !this.required.extent)
      return (_a2 = this._get("_extentCandidatesTask")) != null ? _a2 : { updating: false };
    if (!this.spatialReference)
      return { updating: this._spatialReferenceTask.updating };
    const e2 = this._allLayers, t2 = e2.updating, a2 = [];
    for (const n2 of e2.layers) {
      const e3 = "fullExtents" in n2 && n2.fullExtents || (r$1t(n2.fullExtent) ? [n2.fullExtent] : []), t3 = this.requiresExtentInSpatialReference ? null : e3[0], i2 = (_b2 = e3.find((e4) => e4.spatialReference.equals(this.spatialReference))) != null ? _b2 : t3;
      if (i2)
        return { candidates: [{ extent: i2, layer: n2 }], updating: false };
      if (this._getSupportedSpatialReferences(n2).length > 0)
        for (const s2 of e3)
          a2.push({ extent: s2, layer: n2 });
    }
    return { candidates: a2, updating: t2 };
  }
  get _extentTask() {
    const { candidates: e2, updating: t2 } = this._extentCandidatesTask;
    if (t2)
      return { updating: t2 };
    if (t$1W(e2) || e2.length === 0)
      return { updating: false };
    if (!this.spatialReference)
      return { updating: this._spatialReferenceTask.updating };
    const i2 = this._pickExtentCandidate(e2), l2 = this.spatialReference;
    return i2.extent.equals(this._projectExtentTask.input) && l2.equals(this._projectExtentTask.spatialReference) ? { extent: this._projectExtentTask.output, updating: r$1t(this._projectExtentTask.task) && !this._projectExtentTask.task.finished } : (r$1t(this._projectExtentTask.task) && (this._projectExtentTask.task = p$33(this._projectExtentTask.task)), this._projectExtentTask = { input: i2.extent.clone(), output: null, spatialReference: l2.clone(), task: j$o(async (e3) => {
      try {
        const t3 = await p$j(i2.extent, l2, i2.layer.portalItem, e3);
        this._projectExtentTask = __spreadProps(__spreadValues({}, this._projectExtentTask), { task: null, output: t3 });
      } catch (t3) {
        if (p$2W(e3))
          return;
        this._projectExtentTask = __spreadProps(__spreadValues({}, this._projectExtentTask), { task: null });
      }
    }) }, { updating: true });
  }
  _narrowDownSpatialReferenceCandidates(e2, t2) {
    if (t$1W(e2))
      return t2;
    const a2 = [], n2 = (e3, t3) => r$1t(e3) ? r$1t(t3) ? e3 === t3 && e3 : e3 : t3;
    for (const s2 of e2)
      for (const e3 of t2) {
        if (!s2.spatialReference.equals(e3.spatialReference))
          continue;
        const t3 = n2(s2.viewingMode, e3.viewingMode);
        if (t3 !== false) {
          a2.push({ spatialReference: s2.spatialReference, viewingMode: t3 });
          break;
        }
      }
    return a2.length > 0 ? a2 : null;
  }
  _pickSpatialReferenceCandidate(e2) {
    const t2 = this.defaultSpatialReference;
    return t$1W(e2) || e2.length < 1 ? r$1t(t2) ? { spatialReference: t2, viewingMode: null } : null : (r$1t(t2) && e2.length > 1 && e2.some(({ spatialReference: e3 }) => e3.equals(t2)) && (e2 = e2.filter(({ spatialReference: e3 }) => e3.equals(t2))), e2.length > 1 && e2.some(({ viewingMode: e3 }) => e3 !== l$m.Local) && (e2 = e2.filter(({ viewingMode: e3 }) => e3 !== l$m.Local)), e2[0]);
  }
  _getSupportedSpatialReferences(e2) {
    const t2 = "supportedSpatialReferences" in e2 && e2.supportedSpatialReferences || (e2.spatialReference ? [e2.spatialReference] : []);
    if (t2.length === 0)
      return [];
    const a2 = [];
    for (const n2 of t2) {
      const t3 = this.getSpatialReferenceSupport({ spatialReference: n2, layer: e2 });
      if (r$1t(t3)) {
        const e3 = r$1t(t3.constraints) ? t3.constraints : [{ spatialReference: n2, viewingMode: null }];
        for (const { spatialReference: t4, viewingMode: n3 } of e3)
          (!this.requiresExtentInSpatialReference || t$1W(this.userSpatialReference) || t4.equals(this.userSpatialReference)) && a2.push({ spatialReference: t4, viewingMode: n3 });
      }
    }
    return a2;
  }
  _pickExtentCandidate(e2) {
    const t2 = this.spatialReference;
    return e2.find(({ extent: e3 }) => t2.equals(e3.spatialReference)) || e2[0];
  }
  _collectLayers(e2) {
    var _a2;
    if (this._loadMaybe((_a2 = this.map) == null ? void 0 : _a2.call(this)) !== "loaded")
      return { layers: [], updating: true };
    const t2 = { layers: [], preloading: -1, updating: false };
    for (const a2 of e2)
      if (this._collectCollection(a2, t2), t2.preloading === this.sourcePreloadCount)
        break;
    return { layers: t2.layers, updating: t2.updating };
  }
  _collectCollection(e2, t2) {
    if (e2.layers) {
      switch (this._loadMaybe(e2.parent)) {
        case "loading":
          return t2.updating = true, void ++t2.preloading;
        case "failed":
          return;
      }
      for (const a2 of e2.layers) {
        switch (this._loadMaybe(a2)) {
          case "failed":
            continue;
          case "loading":
            t2.updating = true, ++t2.preloading;
            break;
          case "loaded":
            t2.updating || t2.layers.push(a2), "layers" in a2 && this._collectCollection({ layers: a2.layers }, t2);
        }
        if (t2.preloading === this.sourcePreloadCount)
          break;
      }
    }
  }
  _loadMaybe(e2) {
    return e2 && "loadStatus" in e2 ? e2.loadStatus === "not-loaded" ? (e2.load().catch(() => {
    }), "loading") : e2.loadStatus : "loaded";
  }
};
e$1W([y$1o()], h$b.prototype, "required", void 0), e$1W([y$1o({ constructOnly: true })], h$b.prototype, "map", void 0), e$1W([y$1o({ constructOnly: true })], h$b.prototype, "getSpatialReferenceSupport", void 0), e$1W([y$1o()], h$b.prototype, "defaultSpatialReference", void 0), e$1W([y$1o()], h$b.prototype, "userSpatialReference", void 0), e$1W([y$1o()], h$b.prototype, "sourcePreloadCount", void 0), e$1W([y$1o()], h$b.prototype, "priorityCollection", void 0), e$1W([y$1o()], h$b.prototype, "requiresExtentInSpatialReference", void 0), e$1W([y$1o()], h$b.prototype, "suspended", void 0), e$1W([y$1o({ readOnly: true })], h$b.prototype, "ready", null), e$1W([y$1o({ readOnly: true })], h$b.prototype, "heightModelInfoReady", null), e$1W([y$1o({ readOnly: true })], h$b.prototype, "spatialReference", null), e$1W([y$1o({ readOnly: true })], h$b.prototype, "extent", null), e$1W([y$1o({ readOnly: true })], h$b.prototype, "heightModelInfo", null), e$1W([y$1o({ readOnly: true })], h$b.prototype, "vcsWkid", null), e$1W([y$1o({ readOnly: true })], h$b.prototype, "latestVcsWkid", null), e$1W([y$1o({ readOnly: true })], h$b.prototype, "viewingMode", null), e$1W([y$1o({ readOnly: true })], h$b.prototype, "tileInfo", null), e$1W([y$1o({ readOnly: true })], h$b.prototype, "mapCollections", null), e$1W([y$1o({ readOnly: true })], h$b.prototype, "_allLayers", null), e$1W([y$1o({ readOnly: true })], h$b.prototype, "_spatialReferenceTask", null), e$1W([y$1o({ readOnly: true })], h$b.prototype, "_tileInfoTask", null), e$1W([y$1o({ readOnly: true })], h$b.prototype, "_heightModelInfoTask", null), e$1W([y$1o({ readOnly: true })], h$b.prototype, "_extentCandidatesTask", null), e$1W([y$1o()], h$b.prototype, "_extentTask", null), e$1W([y$1o()], h$b.prototype, "_projectExtentTask", void 0), h$b = e$1W([n$2f("esri.views.support.DefaultsFromMap")], h$b);
var P$2;
let W$1 = P$2 = class extends a$1s(n$26.EventedMixin(m$1h(m$1L))) {
  constructor(e2) {
    super(e2), this._userSpatialReference = null, this._cursor = null, this.allLayerViews = new l$1g({ getCollections: () => {
      var _a2, _b2, _c2;
      return [(_a2 = this.basemapView) == null ? void 0 : _a2.baseLayerViews, (_b2 = this.groundView) == null ? void 0 : _b2.layerViews, this.layerViews, (_c2 = this.basemapView) == null ? void 0 : _c2.referenceLayerViews];
    }, getChildrenFunction: (e3) => e3.layerViews }), this.groundView = null, this.basemapView = null, this.fatalError = null, this.graphics = new i$q(), this.analyses = new i$r(), this.typeSpecificPreconditionsReady = true, this.layerViews = new j$F(), this.magnifier = new p$q(), this.padding = { left: 0, top: 0, right: 0, bottom: 0 }, this.ready = false, this.spatialReferenceWarningDelay = 1e3, this.supportsGround = true, this.timeExtent = null, this.type = null, this.scale = null, this.updating = false, this.initialExtentRequired = true, this.input = new a$t(), this.navigation = new p$l(), this.layerViewManager = null, this.analysisViewManager = null, this.isHeightModelInfoRequired = false, this.width = null, this.height = null, this.resizing = false, this.suspended = false, this.viewEvents = new p$n(this), this.persistableViewModels = new j$F(), this._isValid = false, this._readyCycleForced = false, this.handles.add(l$1f(() => this.preconditionsReady, (e3) => {
      var _a2, _b2;
      e3 ? (this._currentSpatialReference = this.spatialReference, P$2.views.add(this)) : (this._currentSpatialReference = null, P$2.views.remove(this)), this.notifyChange("spatialReference"), !e3 && this.ready ? ((_a2 = this.toolViewManager) == null ? void 0 : _a2.detach(), r$1t(this.analysisViewManager) && this.analysisViewManager.detach(), (_b2 = this.layerViewManager) == null ? void 0 : _b2.clear(), this._teardown()) : e3 && !this.ready && (this._startup(), r$1t(this.analysisViewManager) && this.analysisViewManager.attach(), this.toolViewManager.attach());
    }, U$i));
  }
  initialize() {
    this.addResolvingPromise(this.validate().then(() => (this._isValid = true, j$u(() => this.ready)))), this.basemapView = new p$r({ view: this }), this.layerViewManager = new L$3({ view: this, layerViewImporter: { importLayerView: (e2) => this.importLayerView(e2), hasLayerViewModule: (e2) => this.hasLayerViewModule(e2) }, supportsGround: this.supportsGround }), this.toolViewManager = new y$6({ view: this }), this._setupSpatialReferenceLogger(), this.handles.add([l$1f(() => this.initialExtentRequired, (e2) => this.defaultsFromMap.required = __spreadProps(__spreadValues({}, this.defaultsFromMap.required), { extent: e2 }), { sync: true, initial: true }), l$1f(() => this.ready, (e2) => {
      this.defaultsFromMap && (this.defaultsFromMap.suspended = e2, this.defaultsFromMap.userSpatialReference = e2 ? this.spatialReference : this._userSpatialReference);
    }, { sync: true }), l$1f(() => this._userSpatialReference, (e2) => {
      this.defaultsFromMap && (this.defaultsFromMap.userSpatialReference = e2);
    }, { sync: true, initial: true })]);
  }
  _setupSpatialReferenceLogger() {
    let e2 = null;
    this.handles.add([l$1f(() => {
      var _a2;
      return (_a2 = this.defaultsFromMap) == null ? void 0 : _a2.ready;
    }, (t2) => {
      var _a2;
      const i2 = ((_a2 = this.map) == null ? void 0 : _a2.allLayers.length) > 0;
      if (t2 && !this.spatialReference && i2) {
        if (r$1t(e2))
          return;
        const t3 = n$2k(() => e2 = p$33(e2));
        e2 = j$o(async (t4) => {
          try {
            await U$q(this.spatialReferenceWarningDelay, null, t4);
          } catch {
            return;
          } finally {
            e2 = null;
          }
          s$22.getLogger(this.declaredClass).warn("#spatialReference", "no spatial reference could be derived from the currently added map layers");
        }), this.handles.add(t3, "spatial-reference-logger-task");
      } else
        this.handles.remove("spatial-reference-logger-task");
    }, { sync: true })]);
  }
  destroy() {
    if (this.destroyed)
      return;
    this.viewEvents.destroy(), this.allLayerViews.destroy(), this.navigation && (this.navigation.destroy(), this._set("navigation", null)), this.graphics = s$26(this.graphics), this.analyses = s$26(this.analyses), this.handles.remove("defaultsFromMap"), this.defaultsFromMap.destroy(), this._set("defaultsFromMap", null), s$26(this.analysisViewManager), this.toolViewManager = s$26(this.toolViewManager), this.layerViewManager = s$26(this.layerViewManager), this.basemapView = s$26(this.basemapView), this.invalidate(), this._emitter.clear(), this.handles.removeAll();
    const e2 = this.map;
    this.map = null, e2 == null ? void 0 : e2.destroy();
  }
  _startup() {
    this._set("ready", true);
  }
  _teardown() {
    this._set("ready", false);
  }
  whenReady() {
    return Promise.resolve(this);
  }
  toMap() {
    return s$22.getLogger(this.declaredClass).error("#toMap()", "Not implemented on this instance of View"), null;
  }
  get activeTool() {
    var _a2;
    return (_a2 = this.toolViewManager) == null ? void 0 : _a2.activeTool;
  }
  set activeTool(e2) {
    this.toolViewManager && (this.toolViewManager.activeTool = e2);
  }
  get animation() {
    return this._get("animation");
  }
  set animation(e2) {
    this._set("animation", e2);
  }
  get _defaultsFromMapSettings() {
    return {};
  }
  get defaultsFromMap() {
    return new h$b(__spreadValues({ required: { tileInfo: false, heightModelInfo: false, extent: false }, map: () => this.map, getSpatialReferenceSupport: (e2) => this.getSpatialReferenceSupport(e2) }, this._defaultsFromMapSettings));
  }
  get extent() {
    return this._get("extent");
  }
  set extent(e2) {
    this._set("extent", e2);
  }
  get heightModelInfo() {
    return this.getDefaultHeightModelInfo();
  }
  get interacting() {
    return this.navigating;
  }
  get navigating() {
    return false;
  }
  get preconditionsReady() {
    var _a2;
    return !(this.fatalError || !this._isValid || this._readyCycleForced || !this.map || m$1g.isLoadable(this.map) && !this.map.loaded || this.width === 0 || this.height === 0 || !this.spatialReference || !this._validateSpatialReference(this.spatialReference) || !this._currentSpatialReference && !((_a2 = this.defaultsFromMap) == null ? void 0 : _a2.ready) || !this.typeSpecificPreconditionsReady);
  }
  set map(e2) {
    e2 !== this._get("map") && ((e2 == null ? void 0 : e2.destroyed) && (s$22.getLogger(this.declaredClass).warn("#map", "The provided map is already destroyed", { map: e2 }), e2 = null), m$1g.isLoadable(e2) && e2.load().catch(() => {
    }), this.constructed && (this.forceReadyCycle(), this._currentSpatialReference = null), this._set("map", e2));
  }
  get spatialReference() {
    var _a2, _b2;
    let e2 = this._userSpatialReference || this._currentSpatialReference || this.getDefaultSpatialReference() || null;
    return e2 && ((_b2 = (_a2 = this.defaultsFromMap) == null ? void 0 : _a2.required) == null ? void 0 : _b2.heightModelInfo) && (e2 = e2.clone(), e2.vcsWkid = this.defaultsFromMap.vcsWkid, e2.latestVcsWkid = this.defaultsFromMap.latestVcsWkid), e2;
  }
  set spatialReference(e2) {
    const t2 = !E$u(e2, this._get("spatialReference"));
    this._set("_userSpatialReference", e2), t2 && (this._set("spatialReference", e2), this._spatialReferenceChanged(e2));
  }
  _spatialReferenceChanged(e2) {
  }
  get stationary() {
    return !this.animation && !this.navigating && !this.resizing;
  }
  get tools() {
    var _a2;
    return (_a2 = this.toolViewManager) == null ? void 0 : _a2.tools;
  }
  get initialExtent() {
    var _a2;
    return (_a2 = this.defaultsFromMap) == null ? void 0 : _a2.extent;
  }
  get cursor() {
    const e2 = this.toolViewManager ? this.toolViewManager.cursor : null;
    return r$1t(e2) ? e2 : this._cursor || "default";
  }
  set cursor(e2) {
    this._cursor = e2, this.notifyChange("cursor");
  }
  get size() {
    return [this.width, this.height];
  }
  whenLayerView(e2) {
    return this.layerViewManager.whenLayerView(e2);
  }
  getDefaultSpatialReference() {
    var _a2;
    return (_a2 = this.defaultsFromMap) == null ? void 0 : _a2.spatialReference;
  }
  getDefaultHeightModelInfo() {
    var _a2, _b2, _c2;
    return (_c2 = (_b2 = this.map && "heightModelInfo" in this.map ? this.map.heightModelInfo : void 0) != null ? _b2 : (_a2 = this.defaultsFromMap) == null ? void 0 : _a2.heightModelInfo) != null ? _c2 : null;
  }
  importLayerView(e2) {
    throw new s$1Z("importLayerView() not implemented");
  }
  hasLayerViewModule(e2) {
    return false;
  }
  async validate() {
  }
  invalidate() {
    this._isValid = false;
  }
  getSpatialReferenceSupport() {
    return { constraints: null };
  }
  _validateSpatialReference(e2) {
    return r$1t(this.getSpatialReferenceSupport({ spatialReference: e2 }));
  }
  when(e2, t2) {
    return this.isResolved() && !this.ready && s$22.getLogger(this.declaredClass).warn("#when()", "Calling view.when() while the view is no longer ready but was already resolved once will resolve immediately. Use reactiveUtils.whenOnce(() => view.ready).then(...) instead."), super.when(e2, t2);
  }
  forceReadyCycle() {
    this.ready && (f$10(() => this.preconditionsReady === false, () => this._readyCycleForced = false, { once: true }), this._readyCycleForced = true);
  }
  addAndActivateTool(e2) {
    this.toolViewManager.tools.add(e2), this.activeTool = e2;
  }
  tryFatalErrorRecovery() {
    this.fatalError = null;
  }
};
W$1.views = new j$F(), e$1W([y$1o()], W$1.prototype, "_userSpatialReference", void 0), e$1W([y$1o()], W$1.prototype, "activeTool", null), e$1W([y$1o({ readOnly: true })], W$1.prototype, "allLayerViews", void 0), e$1W([y$1o()], W$1.prototype, "groundView", void 0), e$1W([y$1o()], W$1.prototype, "animation", null), e$1W([y$1o()], W$1.prototype, "basemapView", void 0), e$1W([y$1o({ readOnly: true })], W$1.prototype, "_defaultsFromMapSettings", null), e$1W([y$1o()], W$1.prototype, "defaultsFromMap", null), e$1W([y$1o()], W$1.prototype, "fatalError", void 0), e$1W([y$1o({ type: w$J })], W$1.prototype, "extent", null), e$1W([y$1o(a$v(i$q, "graphics"))], W$1.prototype, "graphics", void 0), e$1W([y$1o(a$v(i$r, "analyses"))], W$1.prototype, "analyses", void 0), e$1W([y$1o({ readOnly: true, type: v$h })], W$1.prototype, "heightModelInfo", null), e$1W([y$1o({ readOnly: true })], W$1.prototype, "interacting", null), e$1W([y$1o({ readOnly: true })], W$1.prototype, "navigating", null), e$1W([y$1o({ readOnly: true, dependsOn: ["fatalError", "_isValid", "_readyCycleForced", "map", "map.loaded?", "width", "height", "spatialReference", "_currentSpatialReference", "defaultsFromMap.ready", "typeSpecificPreconditionsReady"] })], W$1.prototype, "preconditionsReady", null), e$1W([y$1o({ readOnly: true })], W$1.prototype, "typeSpecificPreconditionsReady", void 0), e$1W([y$1o({ type: j$F, readOnly: true })], W$1.prototype, "layerViews", void 0), e$1W([y$1o({ type: p$q })], W$1.prototype, "magnifier", void 0), e$1W([y$1o({ value: null, type: L$4 })], W$1.prototype, "map", null), e$1W([y$1o()], W$1.prototype, "padding", void 0), e$1W([y$1o({ readOnly: true })], W$1.prototype, "ready", void 0), e$1W([y$1o({ type: k$p })], W$1.prototype, "spatialReference", null), e$1W([y$1o()], W$1.prototype, "spatialReferenceWarningDelay", void 0), e$1W([y$1o()], W$1.prototype, "stationary", null), e$1W([y$1o({ readOnly: true })], W$1.prototype, "supportsGround", void 0), e$1W([y$1o({ type: T$b })], W$1.prototype, "timeExtent", void 0), e$1W([y$1o()], W$1.prototype, "tools", null), e$1W([y$1o()], W$1.prototype, "toolViewManager", void 0), e$1W([y$1o({ readOnly: true })], W$1.prototype, "type", void 0), e$1W([y$1o({ type: Number })], W$1.prototype, "scale", void 0), e$1W([y$1o({ readOnly: true })], W$1.prototype, "updating", void 0), e$1W([y$1o({ readOnly: true })], W$1.prototype, "initialExtentRequired", void 0), e$1W([y$1o({ readOnly: true })], W$1.prototype, "initialExtent", null), e$1W([y$1o()], W$1.prototype, "cursor", null), e$1W([y$1o({ readOnly: true })], W$1.prototype, "input", void 0), e$1W([y$1o({ type: p$l, nonNullable: true })], W$1.prototype, "navigation", void 0), e$1W([y$1o()], W$1.prototype, "layerViewManager", void 0), e$1W([y$1o()], W$1.prototype, "analysisViewManager", void 0), e$1W([y$1o()], W$1.prototype, "width", void 0), e$1W([y$1o()], W$1.prototype, "height", void 0), e$1W([y$1o({ readOnly: true })], W$1.prototype, "resizing", void 0), e$1W([y$1o({ value: null, readOnly: true })], W$1.prototype, "size", null), e$1W([y$1o({ readOnly: true })], W$1.prototype, "suspended", void 0), e$1W([y$1o({ readOnly: true })], W$1.prototype, "viewEvents", void 0), e$1W([y$1o({ readOnly: true })], W$1.prototype, "persistableViewModels", void 0), e$1W([y$1o()], W$1.prototype, "_isValid", void 0), e$1W([y$1o()], W$1.prototype, "_readyCycleForced", void 0), e$1W([y$1o()], W$1.prototype, "_currentSpatialReference", void 0), W$1 = P$2 = e$1W([n$2f("esri.views.View")], W$1);
const z$3 = W$1;
let n$m = class extends _$t {
  constructor(t2) {
    super(t2), this.state = "running", this.target = null, this._dfd = null;
  }
  initialize() {
    this.addResolvingPromise(new Promise((t2, s2) => this._dfd = { resolve: t2, reject: s2 }));
  }
  get done() {
    return this.state === "finished" || this.state === "stopped";
  }
  stop() {
    var _a2;
    this.state !== "stopped" && this.state !== "finished" && (this._set("state", "stopped"), (_a2 = this._dfd) == null ? void 0 : _a2.reject(new s$1Z("ViewAnimation stopped")));
  }
  finish() {
    var _a2;
    this.state !== "stopped" && this.state !== "finished" && (this._set("state", "finished"), (_a2 = this._dfd) == null ? void 0 : _a2.resolve());
  }
  update(t2, s2) {
    s2 || (s2 = C$q(t2) ? "waiting-for-target" : "running"), this._set("target", t2), this._set("state", s2);
  }
};
e$1W([y$1o({ readOnly: true })], n$m.prototype, "done", null), e$1W([y$1o({ readOnly: true, type: String })], n$m.prototype, "state", void 0), e$1W([y$1o()], n$m.prototype, "target", void 0), n$m = e$1W([n$2f("esri.views.ViewAnimation")], n$m), function(t2) {
  t2.State = { RUNNING: "running", STOPPED: "stopped", FINISHED: "finished", WAITING_FOR_TARGET: "waiting-for-target" };
}(n$m || (n$m = {}));
const p$i = n$m;
function e$g(e2, n2, t2, r2) {
  const u2 = 3 * e2, i2 = 3 * (t2 - e2) - u2, a2 = 1 - u2 - i2, o2 = 3 * n2, s2 = 3 * (r2 - n2) - o2, f2 = 1 - o2 - s2;
  function c2(e3) {
    return ((a2 * e3 + i2) * e3 + u2) * e3;
  }
  function l2(e3) {
    return ((f2 * e3 + s2) * e3 + o2) * e3;
  }
  function b2(e3) {
    return (3 * a2 * e3 + 2 * i2) * e3 + u2;
  }
  function p2(e3, n3) {
    let t3, r3, u3, i3, a3, o3;
    for (u3 = e3, o3 = 0; o3 < 8; o3++) {
      if (i3 = c2(u3) - e3, Math.abs(i3) < n3)
        return u3;
      if (a3 = b2(u3), Math.abs(a3) < 1e-6)
        break;
      u3 -= i3 / a3;
    }
    if (t3 = 0, r3 = 1, u3 = e3, u3 < t3)
      return t3;
    if (u3 > r3)
      return r3;
    for (; t3 < r3; ) {
      if (i3 = c2(u3), Math.abs(i3 - e3) < n3)
        return u3;
      e3 > i3 ? t3 = u3 : r3 = u3, u3 = 0.5 * (r3 - t3) + t3;
    }
    return u3;
  }
  return function(e3, n3 = 1e-6) {
    return l2(p2(e3, n3));
  };
}
const n$l = /^cubic-bezier\((.*)\)/, t$e = {};
function r$k(r2) {
  let u2 = t$e[r2] || null;
  if (!u2) {
    const t2 = n$l.exec(r2);
    if (t2) {
      const n2 = t2[1].split(",").map((e2) => parseFloat(e2.trim()));
      n2.length !== 4 || n2.some((e2) => isNaN(e2)) || (u2 = e$g.apply(e$g, n2));
    }
  }
  return u2;
}
t$e.ease = e$g(0.25, 0.1, 0.25, 1), t$e.linear = e$g(0, 0, 1, 1), t$e.easeIn = t$e["ease-in"] = e$g(0.42, 0, 1, 1), t$e.easeOut = t$e["ease-out"] = e$g(0, 0, 0.58, 1), t$e.easeInOut = t$e["ease-in-out"] = e$g(0.42, 0, 0.58, 1);
function e$f() {
  return [1, 0, 0, 1, 0, 0];
}
function r$j(e2) {
  return [e2[0], e2[1], e2[2], e2[3], e2[4], e2[5]];
}
function t$d(e2, r2, t2, n2, o2, a2) {
  return [e2, r2, t2, n2, o2, a2];
}
function n$k(e2, r2) {
  return new Float64Array(e2, r2, 6);
}
Object.freeze(Object.defineProperty({ __proto__: null, create: e$f, clone: r$j, fromValues: t$d, createView: n$k }, Symbol.toStringTag, { value: "Module" }));
function a$q(t2, n2) {
  return t2[0] = n2[0], t2[1] = n2[1], t2;
}
function r$i(t2, n2, a2) {
  return t2[0] = n2, t2[1] = a2, t2;
}
function s$f(t2, n2, a2) {
  return t2[0] = n2[0] + a2[0], t2[1] = n2[1] + a2[1], t2;
}
function o$f(t2, n2, a2) {
  return t2[0] = n2[0] - a2[0], t2[1] = n2[1] - a2[1], t2;
}
function u$g(t2, n2, a2) {
  return t2[0] = n2[0] * a2[0], t2[1] = n2[1] * a2[1], t2;
}
function e$e(t2, n2, a2) {
  return t2[0] = n2[0] / a2[0], t2[1] = n2[1] / a2[1], t2;
}
function c$m(t2, n2) {
  return t2[0] = Math.ceil(n2[0]), t2[1] = Math.ceil(n2[1]), t2;
}
function i$i(t2, n2) {
  return t2[0] = Math.floor(n2[0]), t2[1] = Math.floor(n2[1]), t2;
}
function f$9(t2, n2, a2) {
  return t2[0] = Math.min(n2[0], a2[0]), t2[1] = Math.min(n2[1], a2[1]), t2;
}
function M$1(t2, n2, a2) {
  return t2[0] = Math.max(n2[0], a2[0]), t2[1] = Math.max(n2[1], a2[1]), t2;
}
function h$a(t2, n2) {
  return t2[0] = Math.round(n2[0]), t2[1] = Math.round(n2[1]), t2;
}
function l$l(t2, n2, a2) {
  return t2[0] = n2[0] * a2, t2[1] = n2[1] * a2, t2;
}
function d$9(t2, n2, a2, r2) {
  return t2[0] = n2[0] + a2[0] * r2, t2[1] = n2[1] + a2[1] * r2, t2;
}
function m$c(t2, n2) {
  const a2 = n2[0] - t2[0], r2 = n2[1] - t2[1];
  return Math.sqrt(a2 * a2 + r2 * r2);
}
function b$3(t2, n2) {
  const a2 = n2[0] - t2[0], r2 = n2[1] - t2[1];
  return a2 * a2 + r2 * r2;
}
function q$2(t2) {
  const n2 = t2[0], a2 = t2[1];
  return Math.sqrt(n2 * n2 + a2 * a2);
}
function p$h(t2) {
  const n2 = t2[0], a2 = t2[1];
  return n2 * n2 + a2 * a2;
}
function g$5(t2, n2) {
  return t2[0] = -n2[0], t2[1] = -n2[1], t2;
}
function x$3(t2, n2) {
  return t2[0] = 1 / n2[0], t2[1] = 1 / n2[1], t2;
}
function v$3(t2, n2) {
  const a2 = n2[0], r2 = n2[1];
  let s2 = a2 * a2 + r2 * r2;
  return s2 > 0 && (s2 = 1 / Math.sqrt(s2), t2[0] = n2[0] * s2, t2[1] = n2[1] * s2), t2;
}
function j$1(t2, n2) {
  return t2[0] * n2[0] + t2[1] * n2[1];
}
function y$5(t2, n2, a2) {
  const r2 = n2[0] * a2[1] - n2[1] * a2[0];
  return t2[0] = t2[1] = 0, t2[2] = r2, t2;
}
function A$1(t2, n2, a2, r2) {
  const s2 = n2[0], o2 = n2[1];
  return t2[0] = s2 + r2 * (a2[0] - s2), t2[1] = o2 + r2 * (a2[1] - o2), t2;
}
function P$1(n2, a2) {
  a2 = a2 || 1;
  const r2 = 2 * n$1W() * Math.PI;
  return n2[0] = Math.cos(r2) * a2, n2[1] = Math.sin(r2) * a2, n2;
}
function _$7(t2, n2, a2) {
  const r2 = n2[0], s2 = n2[1];
  return t2[0] = a2[0] * r2 + a2[2] * s2, t2[1] = a2[1] * r2 + a2[3] * s2, t2;
}
function z$2(t2, n2, a2) {
  const r2 = n2[0], s2 = n2[1];
  return t2[0] = a2[0] * r2 + a2[2] * s2 + a2[4], t2[1] = a2[1] * r2 + a2[3] * s2 + a2[5], t2;
}
function D$2(t2, n2, a2) {
  const r2 = n2[0], s2 = n2[1];
  return t2[0] = a2[0] * r2 + a2[3] * s2 + a2[6], t2[1] = a2[1] * r2 + a2[4] * s2 + a2[7], t2;
}
function I$1(t2, n2, a2) {
  const r2 = n2[0], s2 = n2[1];
  return t2[0] = a2[0] * r2 + a2[4] * s2 + a2[12], t2[1] = a2[1] * r2 + a2[5] * s2 + a2[13], t2;
}
function L$1(t2, n2, a2, r2) {
  const s2 = n2[0] - a2[0], o2 = n2[1] - a2[1], u2 = Math.sin(r2), e2 = Math.cos(r2);
  return t2[0] = s2 * e2 - o2 * u2 + a2[0], t2[1] = s2 * u2 + o2 * e2 + a2[1], t2;
}
function O$2(t2, n2) {
  const a2 = t2[0], r2 = t2[1], s2 = n2[0], o2 = n2[1];
  let u2 = a2 * a2 + r2 * r2;
  u2 > 0 && (u2 = 1 / Math.sqrt(u2));
  let e2 = s2 * s2 + o2 * o2;
  e2 > 0 && (e2 = 1 / Math.sqrt(e2));
  const c2 = (a2 * s2 + r2 * o2) * u2 * e2;
  return c2 > 1 ? 0 : c2 < -1 ? Math.PI : Math.acos(c2);
}
function S$1(t2) {
  return "vec2(" + t2[0] + ", " + t2[1] + ")";
}
function E$2(t2, n2) {
  return t2[0] === n2[0] && t2[1] === n2[1];
}
function k$2(t2, a2) {
  const r2 = t2[0], s2 = t2[1], o2 = a2[0], u2 = a2[1], e2 = a$23();
  return Math.abs(r2 - o2) <= e2 * Math.max(1, Math.abs(r2), Math.abs(o2)) && Math.abs(s2 - u2) <= e2 * Math.max(1, Math.abs(s2), Math.abs(u2));
}
function w$2(t2, n2, a2, r2, s2) {
  let o2 = n2[0] - a2[0], u2 = n2[1] - a2[1];
  const e2 = (r2[0] * o2 + r2[1] * u2) * (s2 - 1);
  return o2 = r2[0] * e2, u2 = r2[1] * e2, t2[0] = n2[0] + o2, t2[1] = n2[1] + u2, t2;
}
const B$3 = q$2, C$2 = o$f, F$1 = u$g, G$1 = e$e, H$1 = m$c, J$1 = b$3, K$1 = p$h;
Object.freeze(Object.defineProperty({ __proto__: null, copy: a$q, set: r$i, add: s$f, subtract: o$f, multiply: u$g, divide: e$e, ceil: c$m, floor: i$i, min: f$9, max: M$1, round: h$a, scale: l$l, scaleAndAdd: d$9, distance: m$c, squaredDistance: b$3, length: q$2, squaredLength: p$h, negate: g$5, inverse: x$3, normalize: v$3, dot: j$1, cross: y$5, lerp: A$1, random: P$1, transformMat2: _$7, transformMat2d: z$2, transformMat3: D$2, transformMat4: I$1, rotate: L$1, angle: O$2, str: S$1, exactEquals: E$2, equals: k$2, projectAndScale: w$2, len: B$3, sub: C$2, mul: F$1, div: G$1, dist: H$1, sqrDist: J$1, sqrLen: K$1 }, Symbol.toStringTag, { value: "Module" }));
function n$j() {
  return [0, 0];
}
function t$c(n2) {
  return [n2[0], n2[1]];
}
function r$h(n2, t2) {
  return [n2, t2];
}
function e$d(t2) {
  const r2 = n$j(), e2 = Math.min(2, t2.length);
  for (let n2 = 0; n2 < e2; ++n2)
    r2[n2] = t2[n2];
  return r2;
}
function o$e(n2, t2) {
  return new Float64Array(n2, t2, 2);
}
function u$f() {
  return n$j();
}
function a$p() {
  return r$h(1, 1);
}
function s$e() {
  return r$h(1, 0);
}
function c$l() {
  return r$h(0, 1);
}
const f$8 = u$f(), i$h = a$p(), l$k = s$e(), _$6 = c$l();
Object.freeze(Object.defineProperty({ __proto__: null, create: n$j, clone: t$c, fromValues: r$h, fromArray: e$d, createView: o$e, zeros: u$f, ones: a$p, unitX: s$e, unitY: c$l, ZEROS: f$8, ONES: i$h, UNIT_X: l$k, UNIT_Y: _$6 }, Symbol.toStringTag, { value: "Module" }));
const Q = 96, U$1 = 39.37, B$2 = 180 / Math.PI;
function D$1(t2) {
  return t2.wkid ? t2 : t2.spatialReference || k$p.WGS84;
}
function T$1(t2, e2) {
  return e2.type ? r$i(t2, e2.x, e2.y) : a$q(t2, e2);
}
function W(t2) {
  return $$a(t2);
}
function H(t2, e2) {
  const n2 = Math.max(1, e2[0]), r2 = Math.max(1, e2[1]);
  return Math.max(t2.width / n2, t2.height / r2) * ct(t2.spatialReference);
}
async function J(t2, a2, i2, c2) {
  let s2, u2;
  if (!t2)
    return null;
  if (Array.isArray(t2) && !t2.length)
    return null;
  if (j$F.isCollection(t2) && (t2 = t2.toArray()), Array.isArray(t2) && t2.length && typeof t2[0] == "object") {
    const e2 = t2.every((t3) => "attributes" in t3), r2 = t2.some((t3) => !t3.geometry);
    let o2 = t2;
    if (e2 && r2 && a2 && a2.allLayerViews) {
      const e3 = new Map();
      for (const n2 of t2) {
        const t3 = n2.layer, r4 = e3.get(t3) || [], o3 = n2.attributes[t3.objectIdField];
        o3 != null && r4.push(o3), e3.set(t3, r4);
      }
      const r3 = [];
      e3.forEach((t3, e4) => {
        const n2 = a2.allLayerViews.find((t4) => t4.layer.id === e4.id);
        if ("queryFeatures" in n2) {
          const o3 = e4.createQuery();
          o3.objectIds = t3, o3.returnGeometry = true, r3.push(n2.queryFeatures(o3));
        }
      });
      const i3 = await Promise.all(r3), c3 = [];
      for (const t3 of i3)
        if (t3 && t3.features && t3.features.length)
          for (const e4 of t3.features)
            r$1t(e4.geometry) && c3.push(e4.geometry);
      o2 = c3;
    }
    for (const t3 of o2)
      c2 = await J(t3, a2, i2, c2);
    return c2;
  }
  if (Array.isArray(t2) && t2.length === 2 && typeof t2[0] == "number" && typeof t2[1] == "number")
    s2 = new w$K(t2);
  else if (t2 instanceof p$2R)
    s2 = t2;
  else if ("geometry" in t2) {
    if (t2.geometry)
      s2 = t2.geometry;
    else if (t2.layer) {
      const e2 = t2.layer, n2 = a2.allLayerViews.find((t3) => t3.layer.id === e2.id);
      if ("queryFeatures" in n2) {
        const o2 = e2.createQuery();
        o2.objectIds = [t2.attributes[e2.objectIdField]], o2.returnGeometry = true;
        const a3 = await n2.queryFeatures(o2);
        s2 = q$i(a3, "features", 0, "geometry");
      }
    }
  }
  if (t$1W(s2))
    return null;
  if (u2 = s2.type === "point" ? new w$J({ xmin: s2.x, ymin: s2.y, xmax: s2.x, ymax: s2.y, spatialReference: s2.spatialReference }) : s2.extent, !u2)
    return null;
  en() || An(u2.spatialReference, i2) || await tn();
  const f2 = rn(u2, i2);
  return f2 ? c2 = c2 ? c2.union(f2) : f2 : null;
}
function K(t2) {
  if (t2 && (!Array.isArray(t2) || typeof t2[0] != "number") && (typeof t2 == "object" || Array.isArray(t2) && typeof t2[0] == "object")) {
    if ("layer" in t2 && t2.layer && t2.layer.minScale && t2.layer.maxScale) {
      const e2 = t2.layer;
      return { min: e2.minScale, max: e2.maxScale };
    }
    if (Array.isArray(t2) && t2.length && t2.every((t3) => "layer" in t3)) {
      let e2 = 0, n2 = 0;
      for (const r2 of t2) {
        const t3 = r2.layer;
        t3 && t3.minScale && t3.maxScale && (e2 = t3.minScale < e2 ? t3.minScale : e2, n2 = t3.maxScale > n2 ? t3.maxScale : n2);
      }
      return e2 && n2 ? { min: e2, max: n2 } : null;
    }
  }
}
function X(t2, e2) {
  return E$u(D$1(t2), e2) ? t2 : rn(t2, e2);
}
async function Y(e2, r2) {
  if (!e2 || !r2)
    return new u$17({ targetGeometry: new w$K(), scale: 0, rotation: 0 });
  let o2 = r2.spatialReference;
  const { constraints: a2, padding: i2, viewpoint: c2, size: s2 } = r2, u2 = [i2 ? s2[0] - i2.left - i2.right : s2[0], i2 ? s2[1] - i2.top - i2.bottom : s2[1]];
  let f2 = null;
  e2 instanceof u$17 ? f2 = e2 : e2.viewpoint ? f2 = e2.viewpoint : e2.target && e2.target.declaredClass === "esri.Viewpoint" && (f2 = e2.target);
  let l2 = null;
  f2 && f2.targetGeometry ? l2 = f2.targetGeometry : e2 instanceof w$J ? l2 = e2 : (e2 || e2 && ("center" in e2 || "extent" in e2 || "target" in e2)) && (l2 = await J(e2.center, r2, o2) || await J(e2.extent, r2, o2) || await J(e2.target, r2, o2) || await J(e2, r2, o2)), !l2 && c2 && c2.targetGeometry ? l2 = c2.targetGeometry : !l2 && r2.extent && (l2 = r2.extent), o2 || (o2 = D$1(r2.spatialReference || r2.extent || l2)), en() || E$u(l2.spatialReference, o2) || An(l2, o2) || await tn();
  const m2 = X(l2.center ? l2.center : l2, o2);
  let y2 = null;
  if (f2 && r$1t(f2.targetGeometry) && f2.targetGeometry.type === "point")
    y2 = f2.scale;
  else if ("scale" in e2 && e2.scale)
    y2 = e2.scale;
  else if ("zoom" in e2 && e2.zoom !== -1 && a2 && a2.effectiveLODs)
    y2 = a2.zoomToScale(e2.zoom);
  else if (Array.isArray(l2) || l2.type === "point" || l2.type === "extent" && l2.width === 0 && l2.height === 0) {
    const t2 = X(r2.extent, o2);
    y2 = r$1t(t2) ? H(t2, u2) : r2.extent ? H(r2.extent, u2) : c2.scale;
  } else
    y2 = H(X(l2.extent, o2), u2);
  const p2 = K(e2);
  p2 && (p2.min && p2.min > y2 ? y2 = p2.min : p2.max && p2.max < y2 && (y2 = p2.max));
  let g2 = 0;
  f2 ? g2 = f2.rotation : e2.hasOwnProperty("rotation") ? g2 = e2.rotation : c2 && (g2 = c2.rotation);
  let x2 = new u$17({ targetGeometry: m2, scale: y2, rotation: g2 });
  return a2 && (x2 = a2.fit(x2), a2.constrainByGeometry(x2), a2.rotationEnabled || (x2.rotation = g2)), x2;
}
function Z(t2, e2) {
  const n2 = t2.targetGeometry, r2 = e2.targetGeometry;
  return n2.x = r2.x, n2.y = r2.y, n2.spatialReference = r2.spatialReference, t2.scale = e2.scale, t2.rotation = e2.rotation, t2;
}
function $(t2, e2, n2) {
  return n2 ? r$i(t2, 0.5 * (e2[0] - n2.right + n2.left), 0.5 * (e2[1] - n2.bottom + n2.top)) : l$l(t2, e2, 0.5);
}
const _$5 = function() {
  const t2 = n$j();
  return function(e2, n2, r2) {
    const o2 = n2.targetGeometry;
    T$1(t2, o2);
    const a2 = 0.5 * ot(n2);
    return e2.xmin = t2[0] - a2 * r2[0], e2.ymin = t2[1] - a2 * r2[1], e2.xmax = t2[0] + a2 * r2[0], e2.ymax = t2[1] + a2 * r2[1], e2.spatialReference = o2.spatialReference, e2;
  };
}();
function tt(t2, e2, n2, r2, o2) {
  return xt(t2, e2, n2.center), t2.scale = H(n2, r2), o2 && o2.constraints && o2.constraints.constrain(t2), t2;
}
function et(t2, e2, n2, r2) {
  return ft(t2, e2, n2, r2), r$o(t2, t2);
}
const nt = function() {
  const t2 = n$j();
  return function(e2, n2, r2) {
    return C$2(e2, st(e2, n2), $(t2, n2, r2));
  };
}(), rt = function() {
  const t2 = e$f(), e2 = n$j();
  return function(n2, r2, o2, a2) {
    const i2 = ot(r2), f2 = it(r2);
    return r$i(e2, i2, i2), M$2(t2, e2), e$l(t2, t2, f2), i$y(t2, t2, nt(e2, o2, a2)), i$y(t2, t2, [0, a2.top - a2.bottom]), r$i(n2, t2[4], t2[5]);
  };
}();
function ot(t2) {
  return t2.scale * at(t2.targetGeometry);
}
function at(t2) {
  return r$1t(t2) && I$v(t2.spatialReference) ? 1 / (W(t2.spatialReference) * U$1 * Q) : 1;
}
function it(t2) {
  return r$13(t2.rotation) || 0;
}
function ct(t2) {
  return I$v(t2) ? W(t2) * U$1 * Q : 1;
}
function st(t2, e2) {
  return l$l(t2, e2, 0.5);
}
const ut = function() {
  const t2 = n$j(), e2 = n$j(), n2 = n$j();
  return function(r2, o2, a2, i2, c2, m2) {
    return g$5(t2, o2), l$l(e2, a2, 0.5 * m2), r$i(n2, 1 / i2 * m2, -1 / i2 * m2), f$g(r2, e2), c2 && e$l(r2, r2, c2), c$t(r2, r2, n2), i$y(r2, r2, t2), r2;
  };
}(), ft = function() {
  const t2 = n$j();
  return function(e2, n2, r2, o2) {
    const a2 = ot(n2), i2 = it(n2);
    return T$1(t2, n2.targetGeometry), ut(e2, t2, r2, a2, i2, o2);
  };
}(), lt = function() {
  const t2 = n$j();
  return function(e2, n2, r2, o2) {
    const a2 = ot(n2);
    return T$1(t2, n2.targetGeometry), ut(e2, t2, r2, a2, 0, o2);
  };
}();
function mt(t2) {
  const e2 = R$n(t2);
  return e2 ? e2.valid[1] - e2.valid[0] : 0;
}
function yt(t2, e2) {
  return Math.round(mt(t2) / e2);
}
const pt = function() {
  const t2 = n$j(), e2 = n$j(), n2 = [0, 0, 0];
  return function(r2, o2, a2) {
    o$f(t2, r2, o2), v$3(t2, t2), o$f(e2, r2, a2), v$3(e2, e2), y$5(n2, t2, e2);
    let i2 = Math.acos(j$1(t2, e2) / (q$2(t2) * q$2(e2))) * B$2;
    return n2[2] < 0 && (i2 = -i2), isNaN(i2) && (i2 = 0), i2;
  };
}(), gt = function() {
  const t2 = n$j();
  return function(e2, n2, r2, o2) {
    const a2 = e2.targetGeometry;
    return Z(e2, n2), rt(t2, n2, r2, o2), a2.x += t2[0], a2.y += t2[1], e2;
  };
}(), xt = function(t2, e2, n2) {
  Z(t2, e2);
  const r2 = t2.targetGeometry;
  return r2.x = n2.x, r2.y = n2.y, r2.spatialReference = n2.spatialReference, t2;
}, ht = function() {
  const t2 = n$j();
  return function(e2, n2, r2, o2, a2) {
    a2 || (a2 = "center"), C$2(t2, r2, o2), l$l(t2, t2, 0.5);
    const i2 = t2[0], c2 = t2[1];
    switch (a2) {
      case "center":
        r$i(t2, 0, 0);
        break;
      case "left":
        r$i(t2, -i2, 0);
        break;
      case "top":
        r$i(t2, 0, c2);
        break;
      case "right":
        r$i(t2, i2, 0);
        break;
      case "bottom":
        r$i(t2, 0, -c2);
        break;
      case "top-left":
        r$i(t2, -i2, c2);
        break;
      case "bottom-left":
        r$i(t2, -i2, -c2);
        break;
      case "top-right":
        r$i(t2, i2, c2);
        break;
      case "bottom-right":
        r$i(t2, i2, -c2);
    }
    return St(e2, n2, t2), e2;
  };
}();
function bt(t2, e2, n2) {
  return Z(t2, e2), t2.rotation += n2, t2;
}
function wt(t2, e2, n2) {
  return Z(t2, e2), t2.rotation = n2, t2;
}
const dt = function() {
  const t2 = n$j();
  return function(e2, n2, r2, o2, a2) {
    return Z(e2, n2), isNaN(r2) || r2 === 0 || (At(t2, o2, n2, a2), e2.scale = n2.scale * r2, kt(t2, t2, e2, a2), St(e2, e2, r$i(t2, t2[0] - o2[0], o2[1] - t2[1]))), e2;
  };
}();
function jt(t2, e2, n2) {
  return Z(t2, e2), t2.scale = n2, t2;
}
const Gt = function() {
  const t2 = n$j();
  return function(e2, n2, r2, o2, a2, i2) {
    return Z(e2, n2), isNaN(r2) || r2 === 0 || (At(t2, a2, n2, i2), e2.scale = n2.scale * r2, e2.rotation += o2, kt(t2, t2, e2, i2), St(e2, e2, r$i(t2, t2[0] - a2[0], a2[1] - t2[1]))), e2;
  };
}(), Rt = function() {
  const t2 = n$j(), e2 = n$j();
  return function(n2, r2, o2, a2, i2, c2, s2) {
    return nt(e2, c2, s2), s$f(t2, i2, e2), a2 ? Gt(n2, r2, o2, a2, t2, c2) : dt(n2, r2, o2, t2, c2);
  };
}(), At = function() {
  const t2 = e$f();
  return function(e2, n2, r2, o2) {
    return z$2(e2, n2, et(t2, r2, o2, 1));
  };
}(), kt = function() {
  const t2 = e$f();
  return function(e2, n2, r2, o2) {
    return z$2(e2, n2, ft(t2, r2, o2, 1));
  };
}(), St = function() {
  const t2 = n$j(), e2 = e$f();
  return function(n2, r2, o2) {
    Z(n2, r2);
    const a2 = ot(r2), i2 = n2.targetGeometry;
    return h$e(e2, it(r2)), c$t(e2, e2, r$h(a2, a2)), z$2(t2, o2, e2), i2.x += t2[0], i2.y += t2[1], n2;
  };
}();
class m$b {
  constructor(t2, i2, s2, e2) {
    const o2 = t2.targetGeometry, n2 = i2.targetGeometry;
    e2 ? typeof e2 == "string" && (e2 = r$k(e2) || t$e.ease) : e2 = t$e.ease, this.easing = e2, this.duration = s2, this.sCenterX = o2.x, this.sCenterY = o2.y, this.sScale = t2.scale, this.sRotation = t2.rotation, this.tCenterX = n2.x, this.tCenterY = n2.y, this.tScale = i2.scale, this.tRotation = i2.rotation, this.dCenterX = this.tCenterX - this.sCenterX, this.dCenterY = this.tCenterY - this.sCenterY, this.dScale = this.tScale - this.sScale, this.dRotation = this.tRotation - this.sRotation, this.dRotation > 180 ? this.dRotation -= 360 : this.dRotation < -180 && (this.dRotation += 360);
  }
  applyRatio(t2, i2) {
    const s2 = this.easing(i2);
    let e2, o2, n2, a2;
    i2 >= 1 ? (e2 = this.tCenterX, o2 = this.tCenterY, n2 = this.tRotation, a2 = this.tScale) : (e2 = this.sCenterX + s2 * this.dCenterX, o2 = this.sCenterY + s2 * this.dCenterY, n2 = this.sRotation + s2 * this.dRotation, a2 = this.sScale + s2 * this.dScale), t2.targetGeometry.x = e2, t2.targetGeometry.y = o2, t2.scale = a2, t2.rotation = n2;
  }
}
let u$e = class extends m$1L {
  constructor(t2) {
    super(t2), this.duration = 200, this.transition = null, this.easing = t$e.ease, this.view = null, this.viewpoint = null, this.viewpoint = new u$17({ targetGeometry: new w$K(), scale: 0, rotation: 0 }), this._updateTask = A$o({ postRender: this._postRender.bind(this) }), this._updateTask.pause();
  }
  destroy() {
    this._updateTask.remove(), this._updateTask = null;
  }
  animate(t2, i2, s2) {
    this.stop();
    const e2 = this.viewpoint;
    Z(e2, i2), this.transition = new m$b(this.viewpoint, t2.target, s2 && s2.duration || this.duration, s2 && s2.easing || this.easing);
    const o2 = () => {
      this.animation === t2 && this._updateTask && (t2.state === "finished" && (this.transition.applyRatio(this.viewpoint, 1), this.view.state && (this.view.state.viewpoint = this.viewpoint.clone())), this.animation = null, this.updateFunction = null);
    };
    return t2.when(o2, o2), this._startTime = performance.now(), this._updateTask.resume(), this.animation = t2, t2;
  }
  animateContinous(t2, i2) {
    this.stop(), this.updateFunction = i2, this.viewpoint = t2;
    const s2 = new p$i({ target: t2.clone() }), e2 = () => {
      this.animation === s2 && this._updateTask && (this.animation = null, this.updateFunction = null);
    };
    return s2.when(e2, e2), this._startTime = performance.now(), this._updateTask.resume(), this.animation = s2, s2;
  }
  stop() {
    this.animation && (this.animation.stop(), this.animation = null, this.updateFunction = null);
  }
  _postRender(t2) {
    const i2 = this.animation;
    if (i2 && i2.state !== p$i.State.STOPPED) {
      if (this.updateFunction)
        this.updateFunction(this.viewpoint, t2.deltaTime);
      else {
        const t3 = (performance.now() - this._startTime) / this.transition.duration, i3 = t3 >= 1;
        this.transition.applyRatio(this.viewpoint, t3), i3 && this.animation.finish();
      }
      this.view.state && (this.view.state.viewpoint = this.viewpoint.clone());
    } else
      this._updateTask.pause();
  }
};
e$1W([y$1o()], u$e.prototype, "animation", void 0), e$1W([y$1o()], u$e.prototype, "duration", void 0), e$1W([y$1o()], u$e.prototype, "transition", void 0), e$1W([y$1o()], u$e.prototype, "easing", void 0), e$1W([y$1o()], u$e.prototype, "view", void 0), e$1W([y$1o()], u$e.prototype, "viewpoint", void 0), u$e = e$1W([n$2f("esri.views.2d.AnimationManager")], u$e);
const d$8 = u$e;
class s$d {
  constructor(t2) {
    this.view = t2, this._frameTaskHandle = null, this._updateRequested = false, this.stationary = true, this.animationInProgress = false, this.prepare = () => {
      this._updateParameters.state = this.view.state, this._updateParameters.stationary = this.view.stationary, this._updateParameters.pixelRatio = window.devicePixelRatio, this._updateParameters.renderingOptions = this.view.renderingOptions;
    }, this.update = () => {
      this._updateRequested = false;
      const { basemapView: t3, graphicsView: a2, labelManager: s2, layerViews: i2, state: { id: r2 } } = this.view;
      t3.baseLayerViews.forEach(this._updateLayerView, this), i2.forEach(this._updateLayerView, this), t3.referenceLayerViews.forEach(this._updateLayerView, this), r$1t(s2) && (s2.lastUpdateId !== r2 && (s2.viewChange(), s2.lastUpdateId = r2), s2.updateRequested && s2.processUpdate(this._updateParameters)), r$1t(a2) && (a2.lastUpdateId !== r2 && (a2.viewChange(), a2.lastUpdateId = r2), a2.updateRequested && a2.processUpdate(this._updateParameters)), this.view.graphicsTileStore.setViewState(this._updateParameters.state), this.animationInProgress || this._updateRequested || this._frameTaskHandle.pause();
    };
  }
  destroy() {
    this.stop();
  }
  start() {
    if (this._frameTaskHandle)
      return;
    const e2 = this.view;
    this.stationary = e2.stationary, this._updateParameters = { state: e2.state, pixelRatio: window.devicePixelRatio, stationary: this.stationary, renderingOptions: e2.renderingOptions }, this._stationaryHandle = l$1f(() => e2.stationary, (e3) => {
      this.stationary = e3, this.requestFrame();
    }), this._frameTaskHandle = A$o(this), this.requestUpdate();
  }
  stop() {
    this._frameTaskHandle && (this._updateRequested = false, this._stationaryHandle.remove(), this._frameTaskHandle.remove(), this._updateParameters = this._stationaryHandle = this._frameTaskHandle = null, this.stationary = true, this.animationInProgress = false);
  }
  requestUpdate() {
    this._updateRequested || (this._updateRequested = true, this.requestFrame());
  }
  requestFrame() {
    this._frameTaskHandle && this._frameTaskHandle.resume();
  }
  _updateLayerView(e2) {
    const t2 = this.view.state, a2 = e2.lastUpdateId;
    a2 != null && (this.stationary || e2.moving) || (e2.moving = true, e2.moveStart()), a2 !== t2.id && e2.viewChange(), this.stationary && e2.moving && (e2.moving = false, e2.moveEnd()), e2.lastUpdateId = t2.id, e2.updateRequested && e2.processUpdate(this._updateParameters), "layerViews" in e2 && e2.layerViews.forEach(this._updateLayerView, this);
  }
}
function s$c() {
  return Promise.all([import("./webglDeps.js"), import("./mapViewDeps.js")]);
}
const a$o = () => s$c().then(() => import("./TileLayerView2D.js")), i$g = () => s$c().then(() => import("./FeatureLayerView2D.js")), o$d = { "base-dynamic": () => s$c().then(() => import("./BaseDynamicLayerView2D.js")), "base-tile": a$o, "bing-maps": a$o, csv: i$g, "geo-rss": () => s$c().then(() => import("./GeoRSSLayerView2D.js")), feature: i$g, geojson: i$g, graphics: () => s$c().then(() => import("./GraphicsLayerView2D.js")), group: () => s$c().then(() => import("./GroupLayerView2D.js")), imagery: () => s$c().then(() => import("./ImageryLayerView2D.js")), "imagery-tile": () => s$c().then(() => import("./ImageryTileLayerView2D.js")), kml: () => s$c().then(() => import("./KMLLayerView2D.js")), "map-image": () => s$c().then(() => import("./MapImageLayerView2D.js")), "map-notes": () => s$c().then(() => import("./MapNotesLayerView2D.js")), media: () => s$c().then(() => import("./MediaLayerView2D.js")), "ogc-feature": () => s$c().then(() => import("./OGCFeatureLayerView2D.js")), "open-street-map": a$o, "oriented-imagery": i$g, route: () => s$c().then(() => import("./RouteLayerView2D.js")), stream: () => s$c().then(() => import("./StreamLayerView2D.js")), "subtype-group": () => s$c().then(() => import("./SubtypeGroupLayerView2D.js")), tile: a$o, "vector-tile": () => s$c().then(() => import("./VectorTileLayerView2D.js")), wcs: () => s$c().then(() => import("./ImageryTileLayerView2D.js")), "web-tile": a$o, wfs: i$g, wms: () => s$c().then(() => import("./WMSLayerView2D.js")), wmts: () => s$c().then(() => import("./WMTSLayerView2D.js")), "line-of-sight": null, "base-elevation": null, "building-scene": null, dimension: null, elevation: null, "integrated-mesh": null, "point-cloud": null, voxel: null, scene: null, unknown: null, unsupported: null };
function l$j(r2) {
  const t2 = r2.declaredClass ? r2.declaredClass.slice(r2.declaredClass.lastIndexOf(".") + 1) : "Unknown", s2 = t2.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
  return new s$1Z(`${s2}:view-not-supported`, `${t2} is not supported in 2D`);
}
const n$i = { hasLayerViewModule: (e2) => r$1t(o$d[e2.type]), importLayerView: (e2) => {
  const r2 = o$d[e2.type];
  if (t$1W(r2))
    throw l$j(e2);
  return r2(e2);
} };
function o$c(o2, m2) {
  const { spatialReference: r2 } = m2, i2 = [m2.x, m2.y];
  let s2 = Number.POSITIVE_INFINITY, x2 = 0, c2 = 0;
  const a2 = [0, 0], f2 = o2.type === "extent" ? [[[o2.xmin, o2.ymin], [o2.xmin, o2.ymax], [o2.xmax, o2.ymax], [o2.xmax, o2.ymin], [o2.xmin, o2.ymin]]] : o2.rings;
  for (const n2 of f2)
    for (let o3 = 0; o3 < n2.length - 1; o3++) {
      i$2d(a2, i2, n2, o3);
      const m3 = m$c(i2, a2);
      m3 < s2 && (s2 = m3, x2 = a2[0], c2 = a2[1]);
    }
  return { coordinate: new w$K({ x: x2, y: c2, spatialReference: r2 }), distance: s2 };
}
var l$i;
let y$4 = l$i = class extends i$1V(m$1L) {
  constructor(e2) {
    super(e2), this.geometry = null, this.spatialReference = null;
  }
  get normalizedGeometry() {
    if (t$1W(this.geometry) || !this.spatialReference)
      return null;
    if (!this.spatialReference.equals(this.geometry.spatialReference))
      try {
        return rn(this.geometry, this.spatialReference);
      } catch (e2) {
        return s$22.getLogger(this.declaredClass).error("#constraints.geometry", "could not project the geometry to the view's spatial reference", { geometry: this.geometry, spatialReference: this.spatialReference, error: e2 }), null;
      }
    return this.geometry;
  }
  constrain(e2, r2) {
    if (t$1W(this.normalizedGeometry))
      return e2;
    const t2 = e2.targetGeometry;
    if (this.normalizedGeometry.type === "extent" ? r$1e(this.normalizedGeometry, t2) : c$2C(this.normalizedGeometry, t2))
      return e2;
    const { coordinate: o2 } = o$c(this.normalizedGeometry, t2);
    return o2 ? (e2.targetGeometry = o2, e2) : e2;
  }
  clone() {
    var _a2, _b2;
    return new l$i({ geometry: (_a2 = this.geometry) == null ? void 0 : _a2.clone(), spatialReference: (_b2 = this.spatialReference) == null ? void 0 : _b2.clone() });
  }
};
e$1W([y$1o({ constructOnly: true })], y$4.prototype, "geometry", void 0), e$1W([y$1o({ readOnly: true })], y$4.prototype, "normalizedGeometry", null), e$1W([y$1o({ constructOnly: true })], y$4.prototype, "spatialReference", void 0), y$4 = l$i = e$1W([n$2f("esri.views.2d.constraints.GeometryConstraint")], y$4);
var a$n;
let n$h = a$n = class extends i$1V(m$1L) {
  constructor() {
    super(...arguments), this.enabled = true, this.rotationEnabled = true;
  }
  constrain(o2, r2) {
    return this.enabled && r2 ? (this.rotationEnabled || (o2.rotation = r2.rotation), o2) : o2;
  }
  clone() {
    return new a$n({ enabled: this.enabled, rotationEnabled: this.rotationEnabled });
  }
};
e$1W([y$1o()], n$h.prototype, "enabled", void 0), e$1W([y$1o()], n$h.prototype, "rotationEnabled", void 0), n$h = a$n = e$1W([n$2f("esri.views.2d.constraints.RotationConstraint")], n$h);
const i$f = n$h;
var a$m;
let c$k = a$m = class extends i$1V(m$1L) {
  constructor(e2) {
    super(e2), this._lodByScale = {}, this._scales = [], this.effectiveLODs = null, this.effectiveMinZoom = -1, this.effectiveMaxZoom = -1, this.effectiveMinScale = 0, this.effectiveMaxScale = 0, this.lods = null, this.minZoom = -1, this.maxZoom = -1, this.minScale = 0, this.maxScale = 0, this.snapToZoom = true;
  }
  initialize() {
    let e2, { lods: t2, minScale: o2, maxScale: s2, minZoom: i2, maxZoom: a2 } = this, c2 = -1, r2 = -1, l2 = false, n2 = false;
    if (o2 !== 0 && s2 !== 0 && o2 < s2 && ([o2, s2] = [s2, o2]), !t2 || !t2.length)
      return this._set("effectiveMinScale", o2), void this._set("effectiveMaxScale", s2);
    t2 = t2.map((e3) => e3.clone()), t2.sort((e3, t3) => t3.scale - e3.scale), t2.forEach((e3, t3) => e3.level = t3);
    for (const f2 of t2)
      !l2 && o2 > 0 && o2 >= f2.scale && (c2 = f2.level, l2 = true), !n2 && s2 > 0 && s2 >= f2.scale && (r2 = e2 ? e2.level : -1, n2 = true), e2 = f2;
    i2 === -1 && (i2 = o2 === 0 ? 0 : c2), a2 === -1 && (a2 = s2 === 0 ? t2.length - 1 : r2), i2 = Math.max(i2, 0), i2 = Math.min(i2, t2.length - 1), a2 = Math.max(a2, 0), a2 = Math.min(a2, t2.length - 1), i2 > a2 && ([i2, a2] = [a2, i2]), o2 = t2[i2].scale, s2 = t2[a2].scale, t2.splice(0, i2), t2.splice(a2 - i2 + 1, t2.length), t2.forEach((e3, t3) => {
      this._lodByScale[e3.scale] = e3, this._scales[t3] = e3.scale;
    }), this._set("effectiveLODs", t2), this._set("effectiveMinZoom", i2), this._set("effectiveMaxZoom", a2), this._set("effectiveMinScale", o2), this._set("effectiveMaxScale", s2);
  }
  constrain(e2, t2) {
    if (t2 && e2.scale === t2.scale)
      return e2;
    const o2 = this.effectiveMinScale, s2 = this.effectiveMaxScale, i2 = e2.targetGeometry, a2 = t2 && t2.targetGeometry, c2 = s2 !== 0 && e2.scale < s2, r2 = o2 !== 0 && e2.scale > o2;
    if (c2 || r2) {
      const c3 = r2 ? o2 : s2;
      if (t2 && a2) {
        const o3 = (c3 - t2.scale) / (e2.scale - t2.scale);
        i2.x = a2.x + (i2.x - a2.x) * o3, i2.y = a2.y + (i2.y - a2.y) * o3;
      }
      e2.scale = c3;
    }
    return this.snapToZoom && this.effectiveLODs && (e2.scale = this._getClosestScale(e2.scale)), e2;
  }
  fit(e2) {
    if (!this.effectiveLODs || !this.snapToZoom)
      return this.constrain(e2, null);
    const t2 = this.scaleToZoom(e2.scale), o2 = Math.abs(t2 - Math.floor(t2));
    return e2.scale = this.zoomToScale(o2 > 0.99 ? Math.round(t2) : Math.floor(t2)), e2;
  }
  zoomToScale(e2) {
    if (!this.effectiveLODs)
      return 0;
    e2 -= this.effectiveMinZoom, e2 = Math.max(0, e2);
    const t2 = this._scales;
    if (e2 <= 0)
      return t2[0];
    if (e2 >= t2.length)
      return t2[t2.length - 1];
    const o2 = Math.round(e2 - 0.5), s2 = Math.round(e2);
    return t2[s2] + (s2 - e2) * (t2[o2] - t2[s2]);
  }
  scaleToZoom(e2) {
    if (!this.effectiveLODs)
      return -1;
    const t2 = this._scales;
    let o2, s2;
    if (e2 >= t2[0])
      return this.effectiveMinZoom;
    if (e2 <= t2[t2.length - 1])
      return this.effectiveMaxZoom;
    for (let i2 = 0; i2 < t2.length - 1; i2++) {
      if (o2 = t2[i2], s2 = t2[i2 + 1], s2 === e2) {
        return i2 + this.effectiveMinZoom + 1;
      }
      if (o2 > e2 && s2 < e2) {
        return i2 + this.effectiveMinZoom + 1 - (e2 - s2) / (o2 - s2);
      }
    }
    return -1;
  }
  snapToClosestScale(e2) {
    if (!this.effectiveLODs)
      return e2;
    const t2 = this.scaleToZoom(e2);
    return this.zoomToScale(Math.round(t2));
  }
  snapToNextScale(e2, t2 = 0.5) {
    if (!this.effectiveLODs)
      return e2 * t2;
    const o2 = Math.round(this.scaleToZoom(e2));
    return this.zoomToScale(o2 + 1);
  }
  snapToPreviousScale(e2, t2 = 2) {
    if (!this.effectiveLODs)
      return e2 * t2;
    const o2 = Math.round(this.scaleToZoom(e2));
    return this.zoomToScale(o2 - 1);
  }
  clone() {
    return new a$m({ lods: this.lods, minZoom: this.minZoom, maxZoom: this.maxZoom, minScale: this.minScale, maxScale: this.maxScale });
  }
  _getClosestScale(e2) {
    return this._lodByScale[e2] || (e2 = this._scales.reduce((t2, o2) => Math.abs(o2 - e2) <= Math.abs(t2 - e2) ? o2 : t2, this._scales[0])), this._lodByScale[e2].scale;
  }
};
e$1W([y$1o({ readOnly: true })], c$k.prototype, "effectiveLODs", void 0), e$1W([y$1o({ readOnly: true })], c$k.prototype, "effectiveMinZoom", void 0), e$1W([y$1o({ readOnly: true })], c$k.prototype, "effectiveMaxZoom", void 0), e$1W([y$1o({ readOnly: true })], c$k.prototype, "effectiveMinScale", void 0), e$1W([y$1o({ readOnly: true })], c$k.prototype, "effectiveMaxScale", void 0), e$1W([y$1o()], c$k.prototype, "lods", void 0), e$1W([y$1o()], c$k.prototype, "minZoom", void 0), e$1W([y$1o()], c$k.prototype, "maxZoom", void 0), e$1W([y$1o()], c$k.prototype, "minScale", void 0), e$1W([y$1o()], c$k.prototype, "maxScale", void 0), e$1W([y$1o()], c$k.prototype, "snapToZoom", void 0), c$k = a$m = e$1W([n$2f("esri.views.2d.constraints.ZoomConstraint")], c$k);
const r$g = c$k;
const p$g = { base: null, key: "type", typeMap: { extent: w$J, polygon: v$O } };
let c$j = class extends m$1L {
  constructor(o2) {
    super(o2), this.lods = null, this.minScale = 0, this.maxScale = 0, this.minZoom = -1, this.maxZoom = -1, this.rotationEnabled = true, this.snapToZoom = true;
  }
  destroy() {
    this.view = null;
  }
  get effectiveLODs() {
    return this._zoom.effectiveLODs;
  }
  get effectiveMinScale() {
    return this._zoom.effectiveMinScale;
  }
  get effectiveMaxScale() {
    return this._zoom.effectiveMaxScale;
  }
  get effectiveMinZoom() {
    return this._zoom.effectiveMinZoom;
  }
  get effectiveMaxZoom() {
    return this._zoom.effectiveMaxZoom;
  }
  set geometry(o2) {
    o2 ? this._set("geometry", o2) : this._set("geometry", null);
  }
  get version() {
    var _a2, _b2, _c2;
    return `${(_a2 = this._zoom) == null ? void 0 : _a2.uid}/${(_b2 = this._rotation) == null ? void 0 : _b2.uid}/${(_c2 = this._geometry) == null ? void 0 : _c2.uid}`;
  }
  get _defaultLODs() {
    var _a2, _b2, _c2;
    const o2 = (_b2 = (_a2 = this.view) == null ? void 0 : _a2.defaultsFromMap) == null ? void 0 : _b2.tileInfo, e2 = (_c2 = this.view) == null ? void 0 : _c2.spatialReference;
    return o2 && e2 && o2.spatialReference.equals(e2) ? o2.lods : null;
  }
  get _geometry() {
    var _a2;
    return new y$4({ geometry: this.geometry, spatialReference: (_a2 = this.view) == null ? void 0 : _a2.spatialReference });
  }
  get _rotation() {
    return new i$f({ rotationEnabled: this.rotationEnabled });
  }
  get _zoom() {
    const o2 = this._get("_zoom"), e2 = this.lods || this._defaultLODs, t2 = this.minZoom, r2 = this.maxZoom, s2 = this.minScale, i2 = this.maxScale, n2 = this.snapToZoom;
    return o2 && o2.lods === e2 && o2.minZoom === t2 && o2.maxZoom === r2 && o2.minScale === s2 && o2.maxScale === i2 && o2.snapToZoom === n2 ? o2 : new r$g({ lods: e2, minZoom: t2, maxZoom: r2, minScale: s2, maxScale: i2, snapToZoom: n2 });
  }
  canZoomInTo(o2) {
    const e2 = this.effectiveMaxScale;
    return e2 === 0 || o2 >= e2;
  }
  canZoomOutTo(o2) {
    const e2 = this.effectiveMinScale;
    return e2 === 0 || o2 <= e2;
  }
  constrain(o2, e2) {
    return this._zoom.constrain(o2, e2), this._rotation.constrain(o2, e2), this._geometry.constrain(o2, e2), o2;
  }
  constrainByGeometry(o2) {
    return this._geometry.constrain(o2);
  }
  fit(o2) {
    return this._zoom.fit(o2);
  }
  zoomToScale(o2) {
    return this._zoom.zoomToScale(o2);
  }
  scaleToZoom(o2) {
    return this._zoom.scaleToZoom(o2);
  }
  snapScale(o2) {
    return this._zoom.snapToClosestScale(o2);
  }
  snapToNextScale(o2) {
    return this._zoom.snapToNextScale(o2);
  }
  snapToPreviousScale(o2) {
    return this._zoom.snapToPreviousScale(o2);
  }
};
e$1W([y$1o({ readOnly: true })], c$j.prototype, "effectiveLODs", null), e$1W([y$1o({ readOnly: true })], c$j.prototype, "effectiveMinScale", null), e$1W([y$1o({ readOnly: true })], c$j.prototype, "effectiveMaxScale", null), e$1W([y$1o({ readOnly: true })], c$j.prototype, "effectiveMinZoom", null), e$1W([y$1o({ readOnly: true })], c$j.prototype, "effectiveMaxZoom", null), e$1W([y$1o({ types: p$g, value: null })], c$j.prototype, "geometry", null), e$1W([y$1o({ type: [p$1R] })], c$j.prototype, "lods", void 0), e$1W([y$1o()], c$j.prototype, "minScale", void 0), e$1W([y$1o()], c$j.prototype, "maxScale", void 0), e$1W([y$1o()], c$j.prototype, "minZoom", void 0), e$1W([y$1o()], c$j.prototype, "maxZoom", void 0), e$1W([y$1o()], c$j.prototype, "rotationEnabled", void 0), e$1W([y$1o()], c$j.prototype, "snapToZoom", void 0), e$1W([y$1o()], c$j.prototype, "view", void 0), e$1W([y$1o({ readOnly: true })], c$j.prototype, "version", null), e$1W([y$1o()], c$j.prototype, "_defaultLODs", null), e$1W([y$1o({ type: y$4 })], c$j.prototype, "_geometry", null), e$1W([y$1o({ type: i$f })], c$j.prototype, "_rotation", null), e$1W([y$1o({ readOnly: true, type: r$g })], c$j.prototype, "_zoom", null), c$j = e$1W([n$2f("esri.views.2d.MapViewConstraints")], c$j);
const u$d = c$j;
function a$l(t2, a2) {
  return t2[0] = a2[0], t2[1] = a2[1], t2[2] = a2[2], t2[3] = a2[4], t2[4] = a2[5], t2[5] = a2[6], t2[6] = a2[8], t2[7] = a2[9], t2[8] = a2[10], t2;
}
function n$g(t2, a2) {
  return t2[0] = a2[0], t2[1] = a2[1], t2[2] = a2[2], t2[3] = a2[3], t2[4] = a2[4], t2[5] = a2[5], t2[6] = a2[6], t2[7] = a2[7], t2[8] = a2[8], t2;
}
function s$b(t2, a2, n2, s2, r2, o2, u2, c2, e2, i2) {
  return t2[0] = a2, t2[1] = n2, t2[2] = s2, t2[3] = r2, t2[4] = o2, t2[5] = u2, t2[6] = c2, t2[7] = e2, t2[8] = i2, t2;
}
function r$f(t2) {
  return t2[0] = 1, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 1, t2[5] = 0, t2[6] = 0, t2[7] = 0, t2[8] = 1, t2;
}
function o$b(t2, a2) {
  if (t2 === a2) {
    const n2 = a2[1], s2 = a2[2], r2 = a2[5];
    t2[1] = a2[3], t2[2] = a2[6], t2[3] = n2, t2[5] = a2[7], t2[6] = s2, t2[7] = r2;
  } else
    t2[0] = a2[0], t2[1] = a2[3], t2[2] = a2[6], t2[3] = a2[1], t2[4] = a2[4], t2[5] = a2[7], t2[6] = a2[2], t2[7] = a2[5], t2[8] = a2[8];
  return t2;
}
function u$c(t2, a2) {
  const n2 = a2[0], s2 = a2[1], r2 = a2[2], o2 = a2[3], u2 = a2[4], c2 = a2[5], e2 = a2[6], i2 = a2[7], M2 = a2[8], h2 = M2 * u2 - c2 * i2, f2 = -M2 * o2 + c2 * e2, b2 = i2 * o2 - u2 * e2;
  let l2 = n2 * h2 + s2 * f2 + r2 * b2;
  return l2 ? (l2 = 1 / l2, t2[0] = h2 * l2, t2[1] = (-M2 * s2 + r2 * i2) * l2, t2[2] = (c2 * s2 - r2 * u2) * l2, t2[3] = f2 * l2, t2[4] = (M2 * n2 - r2 * e2) * l2, t2[5] = (-c2 * n2 + r2 * o2) * l2, t2[6] = b2 * l2, t2[7] = (-i2 * n2 + s2 * e2) * l2, t2[8] = (u2 * n2 - s2 * o2) * l2, t2) : null;
}
function c$i(t2, a2) {
  const n2 = a2[0], s2 = a2[1], r2 = a2[2], o2 = a2[3], u2 = a2[4], c2 = a2[5], e2 = a2[6], i2 = a2[7], M2 = a2[8];
  return t2[0] = u2 * M2 - c2 * i2, t2[1] = r2 * i2 - s2 * M2, t2[2] = s2 * c2 - r2 * u2, t2[3] = c2 * e2 - o2 * M2, t2[4] = n2 * M2 - r2 * e2, t2[5] = r2 * o2 - n2 * c2, t2[6] = o2 * i2 - u2 * e2, t2[7] = s2 * e2 - n2 * i2, t2[8] = n2 * u2 - s2 * o2, t2;
}
function e$c(t2) {
  const a2 = t2[0], n2 = t2[1], s2 = t2[2], r2 = t2[3], o2 = t2[4], u2 = t2[5], c2 = t2[6], e2 = t2[7], i2 = t2[8];
  return a2 * (i2 * o2 - u2 * e2) + n2 * (-i2 * r2 + u2 * c2) + s2 * (e2 * r2 - o2 * c2);
}
function i$e(t2, a2, n2) {
  const s2 = a2[0], r2 = a2[1], o2 = a2[2], u2 = a2[3], c2 = a2[4], e2 = a2[5], i2 = a2[6], M2 = a2[7], h2 = a2[8], f2 = n2[0], b2 = n2[1], l2 = n2[2], m2 = n2[3], d2 = n2[4], x2 = n2[5], p2 = n2[6], y2 = n2[7], g2 = n2[8];
  return t2[0] = f2 * s2 + b2 * u2 + l2 * i2, t2[1] = f2 * r2 + b2 * c2 + l2 * M2, t2[2] = f2 * o2 + b2 * e2 + l2 * h2, t2[3] = m2 * s2 + d2 * u2 + x2 * i2, t2[4] = m2 * r2 + d2 * c2 + x2 * M2, t2[5] = m2 * o2 + d2 * e2 + x2 * h2, t2[6] = p2 * s2 + y2 * u2 + g2 * i2, t2[7] = p2 * r2 + y2 * c2 + g2 * M2, t2[8] = p2 * o2 + y2 * e2 + g2 * h2, t2;
}
function M(t2, a2, n2) {
  const s2 = a2[0], r2 = a2[1], o2 = a2[2], u2 = a2[3], c2 = a2[4], e2 = a2[5], i2 = a2[6], M2 = a2[7], h2 = a2[8], f2 = n2[0], b2 = n2[1];
  return t2[0] = s2, t2[1] = r2, t2[2] = o2, t2[3] = u2, t2[4] = c2, t2[5] = e2, t2[6] = f2 * s2 + b2 * u2 + i2, t2[7] = f2 * r2 + b2 * c2 + M2, t2[8] = f2 * o2 + b2 * e2 + h2, t2;
}
function h$9(t2, a2, n2) {
  const s2 = a2[0], r2 = a2[1], o2 = a2[2], u2 = a2[3], c2 = a2[4], e2 = a2[5], i2 = a2[6], M2 = a2[7], h2 = a2[8], f2 = Math.sin(n2), b2 = Math.cos(n2);
  return t2[0] = b2 * s2 + f2 * u2, t2[1] = b2 * r2 + f2 * c2, t2[2] = b2 * o2 + f2 * e2, t2[3] = b2 * u2 - f2 * s2, t2[4] = b2 * c2 - f2 * r2, t2[5] = b2 * e2 - f2 * o2, t2[6] = i2, t2[7] = M2, t2[8] = h2, t2;
}
function f$7(t2, a2, n2) {
  const s2 = n2[0], r2 = n2[1], o2 = n2[2];
  return t2[0] = s2 * a2[0], t2[1] = s2 * a2[1], t2[2] = s2 * a2[2], t2[3] = r2 * a2[3], t2[4] = r2 * a2[4], t2[5] = r2 * a2[5], t2[6] = o2 * a2[6], t2[7] = o2 * a2[7], t2[8] = o2 * a2[8], t2;
}
function b$2(t2, a2, n2) {
  const s2 = n2[0], r2 = n2[1];
  return t2[0] = s2 * a2[0], t2[1] = s2 * a2[1], t2[2] = s2 * a2[2], t2[3] = r2 * a2[3], t2[4] = r2 * a2[4], t2[5] = r2 * a2[5], t2;
}
function l$h(t2, a2) {
  return t2[0] = 1, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 1, t2[5] = 0, t2[6] = a2[0], t2[7] = a2[1], t2[8] = 1, t2;
}
function m$a(t2, a2) {
  const n2 = Math.sin(a2), s2 = Math.cos(a2);
  return t2[0] = s2, t2[1] = n2, t2[2] = 0, t2[3] = -n2, t2[4] = s2, t2[5] = 0, t2[6] = 0, t2[7] = 0, t2[8] = 1, t2;
}
function d$7(t2, a2) {
  return t2[0] = a2[0], t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = a2[1], t2[5] = 0, t2[6] = 0, t2[7] = 0, t2[8] = 1, t2;
}
function x$2(t2, a2) {
  return t2[0] = a2[0], t2[1] = a2[1], t2[2] = 0, t2[3] = a2[2], t2[4] = a2[3], t2[5] = 0, t2[6] = a2[4], t2[7] = a2[5], t2[8] = 1, t2;
}
function p$f(t2, a2) {
  const n2 = a2[0], s2 = a2[1], r2 = a2[2], o2 = a2[3], u2 = n2 + n2, c2 = s2 + s2, e2 = r2 + r2, i2 = n2 * u2, M2 = s2 * u2, h2 = s2 * c2, f2 = r2 * u2, b2 = r2 * c2, l2 = r2 * e2, m2 = o2 * u2, d2 = o2 * c2, x2 = o2 * e2;
  return t2[0] = 1 - h2 - l2, t2[3] = M2 - x2, t2[6] = f2 + d2, t2[1] = M2 + x2, t2[4] = 1 - i2 - l2, t2[7] = b2 - m2, t2[2] = f2 - d2, t2[5] = b2 + m2, t2[8] = 1 - i2 - h2, t2;
}
function y$3(t2, a2) {
  const n2 = a2[0], s2 = a2[1], r2 = a2[2], o2 = a2[4], u2 = a2[5], c2 = a2[6], e2 = a2[8], i2 = a2[9], M2 = a2[10], h2 = M2 * u2 - c2 * i2, f2 = -M2 * o2 + c2 * e2, b2 = i2 * o2 - u2 * e2, l2 = n2 * h2 + s2 * f2 + r2 * b2;
  if (!l2)
    return null;
  const m2 = 1 / l2;
  return t2[0] = h2 * m2, t2[1] = (-M2 * s2 + r2 * i2) * m2, t2[2] = (c2 * s2 - r2 * u2) * m2, t2[3] = f2 * m2, t2[4] = (M2 * n2 - r2 * e2) * m2, t2[5] = (-c2 * n2 + r2 * o2) * m2, t2[6] = b2 * m2, t2[7] = (-i2 * n2 + s2 * e2) * m2, t2[8] = (u2 * n2 - s2 * o2) * m2, t2;
}
function g$4(t2, a2) {
  const n2 = a2[0], s2 = a2[1], r2 = a2[2], o2 = a2[3], u2 = a2[4], c2 = a2[5], e2 = a2[6], i2 = a2[7], M2 = a2[8], h2 = a2[9], f2 = a2[10], b2 = a2[11], l2 = a2[12], m2 = a2[13], d2 = a2[14], x2 = a2[15], p2 = n2 * c2 - s2 * u2, y2 = n2 * e2 - r2 * u2, g2 = n2 * i2 - o2 * u2, j2 = s2 * e2 - r2 * c2, S2 = s2 * i2 - o2 * c2, q2 = r2 * i2 - o2 * e2, _2 = M2 * m2 - h2 * l2, v2 = M2 * d2 - f2 * l2, A2 = M2 * x2 - b2 * l2, F2 = h2 * d2 - f2 * m2, O2 = h2 * x2 - b2 * m2, z2 = f2 * x2 - b2 * d2;
  let B2 = p2 * z2 - y2 * O2 + g2 * F2 + j2 * A2 - S2 * v2 + q2 * _2;
  return B2 ? (B2 = 1 / B2, t2[0] = (c2 * z2 - e2 * O2 + i2 * F2) * B2, t2[1] = (e2 * A2 - u2 * z2 - i2 * v2) * B2, t2[2] = (u2 * O2 - c2 * A2 + i2 * _2) * B2, t2[3] = (r2 * O2 - s2 * z2 - o2 * F2) * B2, t2[4] = (n2 * z2 - r2 * A2 + o2 * v2) * B2, t2[5] = (s2 * A2 - n2 * O2 - o2 * _2) * B2, t2[6] = (m2 * q2 - d2 * S2 + x2 * j2) * B2, t2[7] = (d2 * g2 - l2 * q2 - x2 * y2) * B2, t2[8] = (l2 * S2 - m2 * g2 + x2 * p2) * B2, t2) : null;
}
function j(t2, a2, n2) {
  return t2[0] = 2 / a2, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = -2 / n2, t2[5] = 0, t2[6] = -1, t2[7] = 1, t2[8] = 1, t2;
}
function S(t2) {
  return "mat3(" + t2[0] + ", " + t2[1] + ", " + t2[2] + ", " + t2[3] + ", " + t2[4] + ", " + t2[5] + ", " + t2[6] + ", " + t2[7] + ", " + t2[8] + ")";
}
function q$1(t2) {
  return Math.sqrt(t2[0] ** 2 + t2[1] ** 2 + t2[2] ** 2 + t2[3] ** 2 + t2[4] ** 2 + t2[5] ** 2 + t2[6] ** 2 + t2[7] ** 2 + t2[8] ** 2);
}
function _$4(t2, a2, n2) {
  return t2[0] = a2[0] + n2[0], t2[1] = a2[1] + n2[1], t2[2] = a2[2] + n2[2], t2[3] = a2[3] + n2[3], t2[4] = a2[4] + n2[4], t2[5] = a2[5] + n2[5], t2[6] = a2[6] + n2[6], t2[7] = a2[7] + n2[7], t2[8] = a2[8] + n2[8], t2;
}
function v$2(t2, a2, n2) {
  return t2[0] = a2[0] - n2[0], t2[1] = a2[1] - n2[1], t2[2] = a2[2] - n2[2], t2[3] = a2[3] - n2[3], t2[4] = a2[4] - n2[4], t2[5] = a2[5] - n2[5], t2[6] = a2[6] - n2[6], t2[7] = a2[7] - n2[7], t2[8] = a2[8] - n2[8], t2;
}
function A(t2, a2, n2) {
  return t2[0] = a2[0] * n2, t2[1] = a2[1] * n2, t2[2] = a2[2] * n2, t2[3] = a2[3] * n2, t2[4] = a2[4] * n2, t2[5] = a2[5] * n2, t2[6] = a2[6] * n2, t2[7] = a2[7] * n2, t2[8] = a2[8] * n2, t2;
}
function F(t2, a2, n2, s2) {
  return t2[0] = a2[0] + n2[0] * s2, t2[1] = a2[1] + n2[1] * s2, t2[2] = a2[2] + n2[2] * s2, t2[3] = a2[3] + n2[3] * s2, t2[4] = a2[4] + n2[4] * s2, t2[5] = a2[5] + n2[5] * s2, t2[6] = a2[6] + n2[6] * s2, t2[7] = a2[7] + n2[7] * s2, t2[8] = a2[8] + n2[8] * s2, t2;
}
function O$1(t2, a2) {
  return t2[0] === a2[0] && t2[1] === a2[1] && t2[2] === a2[2] && t2[3] === a2[3] && t2[4] === a2[4] && t2[5] === a2[5] && t2[6] === a2[6] && t2[7] === a2[7] && t2[8] === a2[8];
}
function z$1(a2, n2) {
  const s2 = a2[0], r2 = a2[1], o2 = a2[2], u2 = a2[3], c2 = a2[4], e2 = a2[5], i2 = a2[6], M2 = a2[7], h2 = a2[8], f2 = n2[0], b2 = n2[1], l2 = n2[2], m2 = n2[3], d2 = n2[4], x2 = n2[5], p2 = n2[6], y2 = n2[7], g2 = n2[8], j2 = a$23();
  return Math.abs(s2 - f2) <= j2 * Math.max(1, Math.abs(s2), Math.abs(f2)) && Math.abs(r2 - b2) <= j2 * Math.max(1, Math.abs(r2), Math.abs(b2)) && Math.abs(o2 - l2) <= j2 * Math.max(1, Math.abs(o2), Math.abs(l2)) && Math.abs(u2 - m2) <= j2 * Math.max(1, Math.abs(u2), Math.abs(m2)) && Math.abs(c2 - d2) <= j2 * Math.max(1, Math.abs(c2), Math.abs(d2)) && Math.abs(e2 - x2) <= j2 * Math.max(1, Math.abs(e2), Math.abs(x2)) && Math.abs(i2 - p2) <= j2 * Math.max(1, Math.abs(i2), Math.abs(p2)) && Math.abs(M2 - y2) <= j2 * Math.max(1, Math.abs(M2), Math.abs(y2)) && Math.abs(h2 - g2) <= j2 * Math.max(1, Math.abs(h2), Math.abs(g2));
}
function B$1(a2) {
  const n2 = a$23(), s2 = a2[0], r2 = a2[1], o2 = a2[2], u2 = a2[3], c2 = a2[4], e2 = a2[5], i2 = a2[6], M2 = a2[7], h2 = a2[8];
  return Math.abs(1 - (s2 * s2 + u2 * u2 + i2 * i2)) <= n2 && Math.abs(1 - (r2 * r2 + c2 * c2 + M2 * M2)) <= n2 && Math.abs(1 - (o2 * o2 + e2 * e2 + h2 * h2)) <= n2;
}
const E$1 = i$e, T = v$2;
Object.freeze(Object.defineProperty({ __proto__: null, fromMat4: a$l, copy: n$g, set: s$b, identity: r$f, transpose: o$b, invert: u$c, adjoint: c$i, determinant: e$c, multiply: i$e, translate: M, rotate: h$9, scale: f$7, scaleByVec2: b$2, fromTranslation: l$h, fromRotation: m$a, fromScaling: d$7, fromMat2d: x$2, fromQuat: p$f, normalFromMat4Legacy: y$3, normalFromMat4: g$4, projection: j, str: S, frob: q$1, add: _$4, subtract: v$2, multiplyScalar: A, multiplyScalarAndAdd: F, exactEquals: O$1, equals: z$1, isOrthoNormal: B$1, mul: E$1, sub: T }, Symbol.toStringTag, { value: "Module" }));
function e$b() {
  const e2 = new Float32Array(9);
  return e2[0] = 1, e2[4] = 1, e2[8] = 1, e2;
}
function r$e(e2) {
  const r2 = new Float32Array(9);
  return r2[0] = e2[0], r2[1] = e2[1], r2[2] = e2[2], r2[3] = e2[3], r2[4] = e2[4], r2[5] = e2[5], r2[6] = e2[6], r2[7] = e2[7], r2[8] = e2[8], r2;
}
function t$b(e2, r2, t2, n2, o2, a2, c2, u2, l2) {
  const s2 = new Float32Array(9);
  return s2[0] = e2, s2[1] = r2, s2[2] = t2, s2[3] = n2, s2[4] = o2, s2[5] = a2, s2[6] = c2, s2[7] = u2, s2[8] = l2, s2;
}
function n$f(e2, r2) {
  return new Float32Array(e2, r2, 9);
}
Object.freeze(Object.defineProperty({ __proto__: null, create: e$b, clone: r$e, fromValues: t$b, createView: n$f }, Symbol.toStringTag, { value: "Module" }));
function n$e() {
  return new Float32Array(2);
}
function r$d(n2) {
  const r2 = new Float32Array(2);
  return r2[0] = n2[0], r2[1] = n2[1], r2;
}
function t$a(n2, r2) {
  const t2 = new Float32Array(2);
  return t2[0] = n2, t2[1] = r2, t2;
}
function e$a(n2, r2) {
  return new Float32Array(n2, r2, 2);
}
function a$k() {
  return n$e();
}
function o$a() {
  return t$a(1, 1);
}
function u$b() {
  return t$a(1, 0);
}
function s$a() {
  return t$a(0, 1);
}
const c$h = a$k(), i$d = o$a(), f$6 = u$b(), l$g = s$a();
Object.freeze(Object.defineProperty({ __proto__: null, create: n$e, clone: r$d, fromValues: t$a, createView: e$a, zeros: a$k, ones: o$a, unitX: u$b, unitY: s$a, ZEROS: c$h, ONES: i$d, UNIT_X: f$6, UNIT_Y: l$g }, Symbol.toStringTag, { value: "Module" }));
function n$d(n2) {
  return n2 instanceof Float32Array && n2.length >= 2;
}
function r$c(n2) {
  return Array.isArray(n2) && n2.length >= 2;
}
function t$9(t2) {
  return n$d(t2) || r$c(t2);
}
var b$1;
const G = [0, 0];
let O = b$1 = class extends l$1_ {
  constructor(t2) {
    super(t2), this._viewpoint2D = { center: n$j(), rotation: 0, scale: 0, spatialReference: null }, this.center = [0, 0], this.extent = new w$J(), this.id = 0, this.inverseTransform = e$f(), this.resolution = 0, this.rotation = 0, this.scale = 0, this.transform = e$f(), this.transformNoRotation = e$f(), this.displayMat3 = e$b(), this.displayViewMat3 = e$b(), this.viewMat3 = e$b(), this.viewMat2d = n$w(), this.worldScreenWidth = 0, this.size = [0, 0];
  }
  set pixelRatio(t2) {
    this._set("pixelRatio", t2), this._update();
  }
  set size(t2) {
    this._set("size", t2), this._update();
  }
  set viewpoint(t2) {
    if (t2) {
      const s2 = this._viewpoint2D, i2 = t2.targetGeometry;
      s2.center[0] = i2.x, s2.center[1] = i2.y, s2.rotation = t2.rotation, s2.scale = t2.scale, s2.spatialReference = i2.spatialReference;
    }
    this._update();
  }
  copy(t2) {
    const s2 = this.size, i2 = this.viewpoint;
    return i2 && s2 ? (this.viewpoint = Z(i2, t2.viewpoint), this._set("size", a$q(s2, t2.size))) : (this.viewpoint = t2.viewpoint.clone(), this._set("size", [t2.size[0], t2.size[1]])), this._set("pixelRatio", t2.pixelRatio), this;
  }
  clone() {
    return new b$1({ size: this.size, viewpoint: this.viewpoint.clone(), pixelRatio: this.pixelRatio });
  }
  toMap(t2, s2, i2) {
    return t$9(s2) ? z$2(t2, s2, this.inverseTransform) : (G[0] = s2, G[1] = i2, z$2(t2, G, this.inverseTransform));
  }
  toScreen(t2, s2, i2) {
    return t$9(s2) ? z$2(t2, s2, this.transform) : (G[0] = s2, G[1] = i2, z$2(t2, G, this.transform));
  }
  toScreenNoRotation(t2, s2, i2) {
    return t$9(s2) ? z$2(t2, s2, this.transformNoRotation) : (G[0] = s2, G[1] = i2, z$2(t2, G, this.transformNoRotation));
  }
  getScreenTransform(t2, s2) {
    const { center: i2 } = this._viewpoint2D, e2 = this._get("pixelRatio") || 1, o2 = this._get("size");
    return ut(t2, i2, o2, s2, 0, e2), t2;
  }
  _update() {
    const { center: t2, spatialReference: i2, scale: e2, rotation: o2 } = this._viewpoint2D, c2 = this._get("pixelRatio") || 1, m2 = this._get("size"), d2 = new u$17({ targetGeometry: new w$K(t2[0], t2[1], i2), scale: e2, rotation: o2 });
    if (this._set("viewpoint", d2), !m2 || !i2 || !e2)
      return;
    this.resolution = ot(d2), this.rotation = o2, this.scale = e2, this.spatialReference = i2, a$q(this.center, t2);
    const y2 = m2[0] !== 0 ? 2 / m2[0] : 0, _2 = m2[1] !== 0 ? -2 / m2[1] : 0;
    s$b(this.displayMat3, y2, 0, 0, 0, _2, 0, -1, 1, 1);
    const x2 = r$f(this.viewMat3), z2 = t$a(m2[0] / 2, m2[1] / 2), g2 = t$a(-m2[0] / 2, -m2[1] / 2), D2 = r$13(o2);
    M(x2, x2, z2), h$9(x2, x2, D2), M(x2, x2, g2), i$e(this.displayViewMat3, this.displayMat3, x2);
    const b2 = f$g(this.viewMat2d, z2);
    return e$l(b2, b2, D2), i$y(b2, b2, g2), _$5(this.extent, d2, m2), ft(this.transform, d2, m2, c2), r$o(this.inverseTransform, this.transform), lt(this.transformNoRotation, d2, m2, c2), this.worldScreenWidth = yt(this.spatialReference, this.resolution), this._set("id", this.id + 1), this;
  }
};
e$1W([y$1o({ readOnly: true })], O.prototype, "id", void 0), e$1W([y$1o({ value: 1, json: { write: true } })], O.prototype, "pixelRatio", null), e$1W([y$1o({ json: { write: true } })], O.prototype, "size", null), e$1W([y$1o()], O.prototype, "spatialReference", void 0), e$1W([y$1o({ type: u$17, json: { write: true } })], O.prototype, "viewpoint", null), O = b$1 = e$1W([n$2f("esri.views.2d.ViewState")], O);
const U = O;
var l$f, m$9;
let w$1 = l$f = class extends m$1L {
  constructor() {
    super(...arguments), this.left = 0, this.top = 0, this.right = 0, this.bottom = 0;
  }
  clone() {
    return new l$f({ left: this.left, top: this.top, right: this.right, bottom: this.bottom });
  }
};
e$1W([y$1o()], w$1.prototype, "left", void 0), e$1W([y$1o()], w$1.prototype, "top", void 0), e$1W([y$1o()], w$1.prototype, "right", void 0), e$1W([y$1o()], w$1.prototype, "bottom", void 0), w$1 = l$f = e$1W([n$2f("esri.views.2d.PaddedViewState.Padding")], w$1);
let u$a = m$9 = class extends U {
  constructor(...t2) {
    super(...t2), this.paddedViewState = new U(), this._updateContent = (() => {
      const t3 = n$j();
      return () => {
        const e2 = this._get("size"), i2 = this._get("padding");
        if (!e2 || !i2)
          return;
        const o2 = this.paddedViewState;
        r$i(t3, i2.left + i2.right, i2.top + i2.bottom), o$f(t3, e2, t3), a$q(o2.size, t3);
        const s2 = o2.viewpoint;
        s2 && (this.viewpoint = s2);
      };
    })(), this.addHandles(l$1f(() => [this.size, this.padding], () => this._updateContent(), U$i)), this.padding = new w$1(), this.size = [0, 0];
  }
  set padding(t2) {
    this._set("padding", t2 || new w$1());
  }
  set viewpoint(t2) {
    if (t2) {
      const e2 = t2.clone();
      this.paddedViewState.viewpoint = t2, gt(e2, t2, this._get("size"), this._get("padding"));
      const i2 = this._viewpoint2D, o2 = e2.targetGeometry;
      i2.center[0] = o2.x, i2.center[1] = o2.y, i2.rotation = e2.rotation, i2.scale = e2.scale, i2.spatialReference = o2.spatialReference, this._update();
    }
  }
  clone() {
    return new m$9({ padding: this.padding.clone(), size: this.size.slice(), viewpoint: this.paddedViewState.viewpoint.clone(), pixelRatio: this.pixelRatio });
  }
};
e$1W([y$1o()], u$a.prototype, "paddedViewState", void 0), e$1W([y$1o({ type: w$1 })], u$a.prototype, "padding", null), e$1W([y$1o()], u$a.prototype, "viewpoint", null), u$a = m$9 = e$1W([n$2f("esri.views.2d.PaddedViewState")], u$a);
const f$5 = u$a;
class u$9 {
  constructor(e2, s2) {
    this.item = e2, this.controller = s2, this.promise = null;
  }
}
class l$e {
  constructor(s2) {
    this._deferreds = new Map(), this._controllers = new Map(), this._processingItems = new Map(), this._isPaused = false, this._schedule = null, this._task = null, this.concurrency = 1, s2.concurrency && (this.concurrency = s2.concurrency), this._queue = new e$17(s2.peeker), this.process = s2.process;
    const t2 = s2.scheduler;
    s2.priority && r$1t(t2) && (this._task = t2.registerTask(s2.priority, this));
  }
  destroy() {
    this.clear(), this._schedule && (this._schedule.remove(), this._schedule = null), this._task && (this._task.remove(), this._task = null);
  }
  get length() {
    return this._processingItems.size + this._queue.length;
  }
  abort(e2) {
    const s2 = this._controllers.get(e2);
    s2 && s2.abort();
  }
  clear() {
    this._queue.clear();
    const e2 = [];
    this._controllers.forEach((s2) => e2.push(s2)), this._controllers.clear(), e2.forEach((e3) => e3.abort()), this._processingItems.clear(), this._cancelNext();
  }
  forEach(e2) {
    this._deferreds.forEach((s2, t2) => e2(t2));
  }
  get(e2) {
    const s2 = this._deferreds.get(e2);
    return s2 ? s2.promise : void 0;
  }
  isOngoing(e2) {
    return this._processingItems.has(e2);
  }
  has(e2) {
    return this._deferreds.has(e2);
  }
  pause() {
    this._isPaused || (this._isPaused = true, this._cancelNext());
  }
  push(s2, h2) {
    const c2 = this.get(s2);
    if (c2)
      return c2;
    const n2 = new AbortController();
    let u2 = null;
    h2 && (u2 = v$S(h2, () => n2.abort()));
    const l2 = () => {
      const e2 = this._processingItems.get(s2);
      e2 && e2.controller.abort(), _2(), a2.reject(a$2p());
    }, _2 = () => {
      p2.remove(), r$1t(u2) && u2.remove(), this._deferreds.delete(s2), this._controllers.delete(s2), this._queue.remove(s2), this._processingItems.delete(s2), this._scheduleNext();
    }, p2 = d$1x(n2.signal, l2), a2 = A$p();
    return this._deferreds.set(s2, a2), this._controllers.set(s2, n2), a2.promise.then(_2, _2), this._queue.push(s2), this._scheduleNext(), a2.promise;
  }
  last() {
    return this._queue.last();
  }
  peek() {
    return this._queue.peek();
  }
  popLast() {
    return this._queue.popLast();
  }
  reset() {
    const e2 = [];
    this._processingItems.forEach((s2) => e2.push(s2)), this._processingItems.clear();
    for (const s2 of e2)
      this._queue.push(s2.item), s2.controller.abort();
    this._scheduleNext();
  }
  resume() {
    this._isPaused && (this._isPaused = false, this._scheduleNext());
  }
  takeAll() {
    const e2 = [];
    for (; this._queue.length; )
      e2.push(this._queue.pop());
    return this.clear(), e2;
  }
  get running() {
    return !this._isPaused && this._queue.length > 0 && this._processingItems.size < this.concurrency;
  }
  runTask(e2) {
    for (; !e2.done && this._queue.length > 0 && this._processingItems.size < this.concurrency; )
      this._process(this._queue.pop()), e2.madeProgress();
  }
  _scheduleNext() {
    this._task || this._isPaused || this._schedule || (this._schedule = v$R(() => {
      this._schedule = null, this._next();
    }));
  }
  _next() {
    for (; this._queue.length > 0 && this._processingItems.size < this.concurrency; )
      this._process(this._queue.pop());
  }
  _cancelNext() {
    this._schedule && (this._schedule.remove(), this._schedule = null);
  }
  _processResult(e2, s2) {
    this._canProcessFulfillment(e2) && (this._scheduleNext(), this._deferreds.get(e2.item).resolve(s2));
  }
  _processError(e2, s2) {
    this._canProcessFulfillment(e2) && (this._scheduleNext(), this._deferreds.get(e2.item).reject(s2));
  }
  _canProcessFulfillment(e2) {
    return !!this._deferreds.get(e2.item) && this._processingItems.get(e2.item) === e2;
  }
  _process(e2) {
    if (t$1W(e2))
      return;
    let t2;
    const r2 = new AbortController(), i2 = new u$9(e2, r2);
    this._processingItems.set(e2, i2);
    try {
      t2 = this.process(e2, r2.signal);
    } catch (o2) {
      this._processError(i2, o2);
    }
    C$q(t2) ? (i2.promise = t2, t2.then((e3) => this._processResult(i2, e3), (e3) => this._processError(i2, e3))) : this._processResult(i2, t2);
  }
  get test() {
    return { update: (e2) => this.runTask(e2) };
  }
}
function u$8(e2, t2) {
  return e2.length = 0, t2.forEach((t3) => e2.push(t3)), e2;
}
const a$j = new Set(), c$g = [], h$8 = new Map(), l$d = [0, 0];
let p$e = class extends m$1L {
  constructor(e2) {
    super(e2), this._keyToItem = new Map(), this.concurrency = 6, this.strategy = "scale-first", this.tileInfoView = null;
  }
  initialize() {
    const { concurrency: e2, process: t2 } = this;
    this._queue = new l$e({ concurrency: e2, process: (e3, s2) => {
      const r2 = this._keyToItem.get(e3);
      return t2(r2, { signal: s2 });
    }, peeker: (e3) => e3.values().next().value });
  }
  destroy() {
    this.clear(), this._queue = s$26(this._queue);
  }
  get length() {
    return this._queue ? this._queue.length : 0;
  }
  get onGoingCount() {
    return this._keyToItem.size;
  }
  get updating() {
    return this.length > 0 || this.onGoingCount > 0;
  }
  abort(e2) {
    const t2 = typeof e2 == "string" ? e2 : e2.id;
    this._queue.abort(t2);
  }
  clear() {
    this._queue.clear(), this._keyToItem.clear(), this.notifyChange("updating");
  }
  has(e2) {
    return typeof e2 == "string" ? this._keyToItem.has(e2) : this._keyToItem.has(e2.id);
  }
  isOngoing(e2) {
    const t2 = typeof e2 == "string" ? e2 : e2.id;
    return this.has(t2) && this._queue.isOngoing(t2);
  }
  pause() {
    this._queue.pause();
  }
  push(e2, t2) {
    const s2 = e2.key.id + "-" + t2;
    if (this.has(s2))
      return this.get(s2);
    const r2 = this._queue.push(s2), o2 = () => {
      this._keyToItem.delete(s2), this.notifyChange("updating");
    };
    return this._keyToItem.set(s2, e2), r2.then(o2, o2), this.notifyChange("updating"), r2;
  }
  reset() {
    this._queue.reset(), this.notifyChange("updating");
  }
  resume() {
    this._queue.resume();
  }
  _peekByScaleFirst(e2) {
    if (!this.state)
      return e2.values().next().value;
    const t2 = this.tileInfoView;
    let s2 = Number.NEGATIVE_INFINITY, r2 = Number.POSITIVE_INFINITY;
    e2.forEach((e3) => {
      const t3 = this._keyToItem.get(e3), o3 = this.tileInfoView.getTileScale(t3.key);
      h$8.has(o3) || (h$8.set(o3, []), s2 = Math.max(o3, s2), r2 = Math.min(o3, r2)), h$8.get(o3).push(t3.key), a$j.add(o3);
    });
    let o2 = this.state.scale;
    h$8.has(o2) || (u$8(c$g, a$j), c$g.sort((e3, t3) => e3 - t3), o2 = c$g.reduce((e3, t3) => Math.abs(t3 - o2) < Math.abs(e3 - o2) ? t3 : e3, c$g[0])), o2 = Math.min(o2, s2), o2 = Math.max(o2, r2);
    const i2 = h$8.get(o2), n2 = t2.getClosestInfoForScale(o2), l2 = n2.getColumnForX(this.state.center[0]), p2 = n2.getRowForY(this.state.center[1]);
    return i2.sort((e3, t3) => {
      const s3 = n2.denormalizeCol(e3.col, e3.world), r3 = n2.denormalizeCol(t3.col, t3.world);
      return Math.sqrt((l2 - s3) * (l2 - s3) + (p2 - e3.row) * (p2 - e3.row)) - Math.sqrt((l2 - r3) * (l2 - r3) + (p2 - t3.row) * (p2 - t3.row));
    }), a$j.clear(), h$8.clear(), i2[0].id;
  }
  _peekByCenterFirst(e2) {
    if (!this.state)
      return e2.values().next().value;
    const t2 = this.tileInfoView, s2 = this.state.center;
    let r2, o2 = Number.POSITIVE_INFINITY;
    return e2.forEach((e3) => {
      const n2 = this._keyToItem.get(e3);
      t2.getTileCoords(l$d, n2.key);
      const u2 = m$c(l$d, s2);
      u2 < o2 && (o2 = u2, r2 = n2.key);
    }), r2.id;
  }
};
e$1W([y$1o({ constructOnly: true })], p$e.prototype, "concurrency", void 0), e$1W([y$1o({ constructOnly: true })], p$e.prototype, "process", void 0), e$1W([y$1o()], p$e.prototype, "state", void 0), e$1W([y$1o({ constructOnly: true })], p$e.prototype, "strategy", void 0), e$1W([y$1o({ constructOnly: true })], p$e.prototype, "tileInfoView", void 0), e$1W([y$1o({ readOnly: true })], p$e.prototype, "updating", null), p$e = e$1W([n$2f("esri.views.2d.tiling.PagedTileQueue")], p$e);
class e$9 {
  constructor(t2, e2, l2, s2) {
    this.set(t2, e2, l2, s2);
  }
  static getId(t2, e2, l2, s2) {
    return typeof t2 == "object" ? `${t2.level}/${t2.row}/${t2.col}/${t2.world}` : `${t2}/${e2}/${l2}/${s2}`;
  }
  get key() {
    return this;
  }
  get id() {
    return this.toString();
  }
  set id(t2) {
    this.set(t2);
  }
  get hash() {
    const t2 = 4095 & this.row, e2 = 4095 & this.col, l2 = 63 & this.level;
    return (3 & this.world) << 30 | e2 << 22 | t2 << 8 | l2;
  }
  acquire(t2, e2, l2, s2) {
    this.set(t2, e2, l2, s2);
  }
  contains(t2) {
    const e2 = t2.level - this.level;
    return e2 >= 0 && this.row === t2.row >> e2 && this.col === t2.col >> e2 && this.world === t2.world;
  }
  equals(t2) {
    return this.level === t2.level && this.row === t2.row && this.col === t2.col && this.world === t2.world;
  }
  clone() {
    return new e$9(this);
  }
  release() {
    this.level = 0, this.row = 0, this.col = 0, this.world = 0;
  }
  set(t2, e2, l2, s2) {
    if (t2 == null)
      this.level = 0, this.row = 0, this.col = 0, this.world = 0;
    else if (typeof t2 == "object")
      this.level = t2.level || 0, this.row = t2.row || 0, this.col = t2.col || 0, this.world = t2.world || 0;
    else if (typeof t2 == "string") {
      const [e3, l3, s3, o2] = t2.split("/");
      this.level = parseFloat(e3), this.row = parseFloat(l3), this.col = parseFloat(s3), this.world = parseFloat(o2);
    } else
      this.level = +t2, this.row = +e2, this.col = +l2, this.world = +s2 || 0;
    return this;
  }
  toString() {
    return `${this.level}/${this.row}/${this.col}/${this.world}`;
  }
  getParentKey() {
    return this.level <= 0 ? null : new e$9(this.level - 1, this.row >> 1, this.col >> 1, this.world);
  }
  getChildKeys() {
    const t2 = this.level + 1, l2 = this.row << 1, s2 = this.col << 1, o2 = this.world;
    return [new e$9(t2, l2, s2, o2), new e$9(t2, l2, s2 + 1, o2), new e$9(t2, l2 + 1, s2, o2), new e$9(t2, l2 + 1, s2 + 1, o2)];
  }
  compareRowMajor(t2) {
    return this.row < t2.row ? -1 : this.row > t2.row ? 1 : this.col < t2.col ? -1 : this.col > t2.col ? 1 : 0;
  }
}
e$9.pool = new e$1K(e$9, null, null, 25, 50);
function i$c(t2, r2) {
  return [t2, r2];
}
function e$8(t2, r2, o2) {
  return t2[0] = r2, t2[1] = o2, t2;
}
function s$9(t2, r2, o2, i2, e2) {
  return t2[0] = r2, t2[1] = o2, t2[2] = i2, t2[3] = e2, t2;
}
const n$c = new e$9("0/0/0/0");
class l$c {
  constructor(t2, r2, o2, i2, e2, s2, n2, l2, h2, a2, u2, m2) {
    this.level = t2, this.resolution = r2, this.scale = o2, this.origin = i2, this.first = e2, this.last = s2, this.size = n2, this.norm = l2, this.worldStart = h2, this.worldEnd = a2, this.worldSize = u2, this.wrap = m2;
  }
  static create(o2, s2, n2 = null) {
    const h2 = R$n(o2.spatialReference), a2 = s2.origin || i$c(o2.origin.x, o2.origin.y), u2 = i$c(o2.size[0] * s2.resolution, o2.size[1] * s2.resolution), m2 = i$c(-1 / 0, -1 / 0), g2 = i$c(1 / 0, 1 / 0), w2 = i$c(1 / 0, 1 / 0);
    r$1t(n2) && (e$8(m2, Math.max(0, Math.floor((n2.xmin - a2[0]) / u2[0])), Math.max(0, Math.floor((a2[1] - n2.ymax) / u2[1]))), e$8(g2, Math.max(0, Math.floor((n2.xmax - a2[0]) / u2[0])), Math.max(0, Math.floor((a2[1] - n2.ymin) / u2[1]))), e$8(w2, g2[0] - m2[0] + 1, g2[1] - m2[1] + 1));
    const { cols: c2, rows: d2 } = s2;
    let f2, F2, z2, p2;
    return !n2 && c2 && d2 && (e$8(m2, c2[0], d2[0]), e$8(g2, c2[1], d2[1]), e$8(w2, c2[1] - c2[0] + 1, d2[1] - d2[0] + 1)), o2.isWrappable ? (f2 = i$c(Math.ceil(Math.round((h2.valid[1] - h2.valid[0]) / s2.resolution) / o2.size[0]), w2[1]), F2 = i$c(Math.floor((h2.origin[0] - a2[0]) / u2[0]), m2[1]), z2 = i$c(f2[0] + F2[0] - 1, g2[1]), p2 = true) : (F2 = m2, z2 = g2, f2 = w2, p2 = false), new l$c(s2.level, s2.resolution, s2.scale, a2, m2, g2, w2, u2, F2, z2, f2, p2);
  }
  normalizeCol(t2) {
    if (!this.wrap)
      return t2;
    const r2 = this.worldSize[0];
    return t2 < 0 ? r2 - 1 - Math.abs((t2 + 1) % r2) : t2 % r2;
  }
  denormalizeCol(t2, r2) {
    return this.wrap ? this.worldSize[0] * r2 + t2 : t2;
  }
  getWorldForColumn(t2) {
    return this.wrap ? Math.floor(t2 / this.worldSize[0]) : 0;
  }
  getFirstColumnForWorld(t2) {
    return t2 * this.worldSize[0] + this.first[0];
  }
  getLastColumnForWorld(t2) {
    return t2 * this.worldSize[0] + this.first[0] + this.size[0] - 1;
  }
  getColumnForX(t2) {
    return (t2 - this.origin[0]) / this.norm[0];
  }
  getXForColumn(t2) {
    return this.origin[0] + t2 * this.norm[0];
  }
  getRowForY(t2) {
    return (this.origin[1] - t2) / this.norm[1];
  }
  getYForRow(t2) {
    return this.origin[1] - t2 * this.norm[1];
  }
  getTileBounds(t2, r2, o2 = false) {
    n$c.set(r2);
    const i2 = o2 ? n$c.col : this.denormalizeCol(n$c.col, n$c.world), e2 = n$c.row;
    return s$9(t2, this.getXForColumn(i2), this.getYForRow(e2 + 1), this.getXForColumn(i2 + 1), this.getYForRow(e2)), t2;
  }
  getTileCoords(t2, r2, o2 = false) {
    n$c.set(r2);
    const i2 = o2 ? n$c.col : this.denormalizeCol(n$c.col, n$c.world);
    return Array.isArray(t2) ? e$8(t2, this.getXForColumn(i2), this.getYForRow(n$c.row)) : (t2.x = this.getXForColumn(i2), t2.y = this.getYForRow(n$c.row)), t2;
  }
}
class l$b {
  constructor() {
    this.spans = [];
  }
  acquire(o2) {
    this.lodInfo = o2;
  }
  release() {
    this.lodInfo = null, this.spans.length = 0;
  }
  forEach(o2, l2) {
    const { spans: s2, lodInfo: t2 } = this, { level: e2 } = t2;
    if (s2.length !== 0)
      for (const { row: r2, colFrom: n2, colTo: c2 } of s2)
        for (let s3 = n2; s3 <= c2; s3++)
          o2.call(l2, e2, r2, t2.normalizeCol(s3), t2.getWorldForColumn(s3));
  }
}
l$b.pool = new e$1K(l$b);
class o$9 {
  constructor(o2, s2, t2) {
    this.row = o2, this.colFrom = s2, this.colTo = t2;
  }
}
const i$b = new e$9("0/0/0/0");
class n$b {
  constructor(e2, t2, o2, l2, s2, i2, n2, r2) {
    this.x = e2, this.ymin = t2, this.ymax = o2, this.invM = l2, this.leftAdjust = s2, this.rightAdjust = i2, this.leftBound = n2, this.rightBound = r2;
  }
  static create(e2, t2) {
    e2[1] > t2[1] && ([e2, t2] = [t2, e2]);
    const [o2, l2] = e2, [s2, i2] = t2, r2 = s2 - o2, a2 = i2 - l2, h2 = a2 !== 0 ? r2 / a2 : 0, c2 = (Math.ceil(l2) - l2) * h2, f2 = (Math.floor(l2) - l2) * h2;
    return new n$b(o2, Math.floor(l2), Math.ceil(i2), h2, r2 < 0 ? c2 : f2, r2 < 0 ? f2 : c2, r2 < 0 ? s2 : o2, r2 < 0 ? o2 : s2);
  }
  incrRow() {
    this.x += this.invM;
  }
  getLeftCol() {
    return Math.max(this.x + this.leftAdjust, this.leftBound);
  }
  getRightCol() {
    return Math.min(this.x + this.rightAdjust, this.rightBound);
  }
}
const r$b = [[0, 0], [0, 0], [0, 0], [0, 0]], a$i = 1e-6;
class h$7 {
  constructor(e2, o2 = null) {
    this.tileInfo = e2, this.fullExtent = o2, this.scales = [], this._infoByScale = {}, this._infoByLevel = {};
    const l2 = e2.lods.slice();
    l2.sort((e3, t2) => t2.scale - e3.scale);
    const s2 = this._lodInfos = l2.map((l3) => l$c.create(e2, l3, o2));
    l2.forEach((e3, t2) => {
      this._infoByLevel[e3.level] = s2[t2], this._infoByScale[e3.scale] = s2[t2], this.scales[t2] = e3.scale;
    }, this), this._wrap = e2.isWrappable;
  }
  get spatialReference() {
    return this.tileInfo.spatialReference;
  }
  getLODInfoAt(e2) {
    return this._infoByLevel[typeof e2 == "number" ? e2 : e2.level];
  }
  getTileBounds(e2, t2, o2 = false) {
    i$b.set(t2);
    const l2 = this._infoByLevel[i$b.level];
    return l2 ? l2.getTileBounds(e2, i$b, o2) : e2;
  }
  getTileCoords(e2, t2, o2 = false) {
    i$b.set(t2);
    const l2 = this._infoByLevel[i$b.level];
    return l2 ? l2.getTileCoords(e2, i$b, o2) : e2;
  }
  getTileCoverage(e2, t2 = 192, l2 = "closest") {
    const i2 = l2 === "closest" ? this.getClosestInfoForScale(e2.scale) : this.getSmallestInfoForScale(e2.scale), a2 = l$b.pool.acquire(i2), h2 = this._wrap;
    let c2, f2, u2, m2 = 1 / 0, g2 = -1 / 0;
    const d2 = a2.spans;
    r$b[0][0] = r$b[0][1] = r$b[1][1] = r$b[3][0] = -t2, r$b[1][0] = r$b[2][0] = e2.size[0] + t2, r$b[2][1] = r$b[3][1] = e2.size[1] + t2;
    for (const o2 of r$b)
      e2.toMap(o2, o2), o2[0] = i2.getColumnForX(o2[0]), o2[1] = i2.getRowForY(o2[1]);
    const y2 = [];
    let v2 = 3;
    for (let o2 = 0; o2 < 4; o2++) {
      if (r$b[o2][1] === r$b[v2][1]) {
        v2 = o2;
        continue;
      }
      const e3 = n$b.create(r$b[o2], r$b[v2]);
      m2 = Math.min(e3.ymin, m2), g2 = Math.max(e3.ymax, g2), y2[e3.ymin] === void 0 && (y2[e3.ymin] = []), y2[e3.ymin].push(e3), v2 = o2;
    }
    if (m2 == null || g2 == null || g2 - m2 > 100)
      return null;
    let _2 = [];
    for (c2 = m2; c2 < g2; ) {
      y2[c2] != null && (_2 = _2.concat(y2[c2])), f2 = 1 / 0, u2 = -1 / 0;
      for (let e3 = _2.length - 1; e3 >= 0; e3--) {
        const t3 = _2[e3];
        f2 = Math.min(f2, t3.getLeftCol()), u2 = Math.max(u2, t3.getRightCol());
      }
      if (f2 = Math.floor(f2), u2 = Math.floor(u2), c2 >= i2.first[1] && c2 <= i2.last[1])
        if (h2)
          if (i2.size[0] < i2.worldSize[0]) {
            const e3 = Math.floor(u2 / i2.worldSize[0]);
            for (let t3 = Math.floor(f2 / i2.worldSize[0]); t3 <= e3; t3++)
              d2.push(new o$9(c2, Math.max(i2.getFirstColumnForWorld(t3), f2), Math.min(i2.getLastColumnForWorld(t3), u2)));
          } else
            d2.push(new o$9(c2, f2, u2));
        else
          f2 > i2.last[0] || u2 < i2.first[0] || (f2 = Math.max(f2, i2.first[0]), u2 = Math.min(u2, i2.last[0]), d2.push(new o$9(c2, f2, u2)));
      c2 += 1;
      for (let e3 = _2.length - 1; e3 >= 0; e3--) {
        const t3 = _2[e3];
        t3.ymax >= c2 ? t3.incrRow() : _2.splice(e3, 1);
      }
    }
    return a2;
  }
  getTileParentId(e2) {
    i$b.set(e2);
    const t2 = this._infoByLevel[i$b.level], o2 = this._lodInfos.indexOf(t2) - 1;
    return o2 < 0 ? null : (this._getTileIdAtLOD(i$b, this._lodInfos[o2], i$b), i$b.id);
  }
  getTileResolution(e2) {
    const t2 = this._infoByLevel[typeof e2 == "object" ? e2.level : e2];
    return t2 ? t2.resolution : -1;
  }
  getTileScale(e2) {
    const t2 = this._infoByLevel[e2.level];
    return t2 ? t2.scale : -1;
  }
  intersects(e2, t2) {
    i$b.set(t2);
    const o2 = this._infoByLevel[i$b.level], l2 = e2.lodInfo;
    if (l2.resolution > o2.resolution) {
      this._getTileIdAtLOD(i$b, l2, i$b);
      const t3 = l2.denormalizeCol(i$b.col, i$b.world);
      for (const o3 of e2.spans)
        if (o3.row === i$b.row && o3.colFrom <= t3 && o3.colTo >= t3)
          return true;
    }
    if (l2.resolution < o2.resolution) {
      const [t3, s3, n2, r2] = e2.spans.reduce((e3, t4) => (e3[0] = Math.min(e3[0], t4.row), e3[1] = Math.max(e3[1], t4.row), e3[2] = Math.min(e3[2], t4.colFrom), e3[3] = Math.max(e3[3], t4.colTo), e3), [1 / 0, -1 / 0, 1 / 0, -1 / 0]), a2 = o2.denormalizeCol(i$b.col, i$b.world), h2 = l2.getColumnForX(o2.getXForColumn(a2)), c2 = l2.getRowForY(o2.getYForRow(i$b.row)), f2 = l2.getColumnForX(o2.getXForColumn(a2 + 1)) - 1, u2 = l2.getRowForY(o2.getYForRow(i$b.row + 1)) - 1;
      return !(h2 > r2 || f2 < n2 || c2 > s3 || u2 < t3);
    }
    const s2 = l2.denormalizeCol(i$b.col, i$b.world);
    return e2.spans.some((e3) => e3.row === i$b.row && e3.colFrom <= s2 && e3.colTo >= s2);
  }
  normalizeBounds(t2, o2, l2) {
    if (t2[0] = o2[0], t2[1] = o2[1], t2[2] = o2[2], t2[3] = o2[3], this._wrap) {
      const o3 = R$n(this.tileInfo.spatialReference), s2 = -l2 * (o3.valid[1] - o3.valid[0]);
      t2[0] += s2, t2[2] += s2;
    }
    return t2;
  }
  getSmallestInfoForScale(e2) {
    const t2 = this.scales;
    if (this._infoByScale[e2])
      return this._infoByScale[e2];
    if (e2 > t2[0])
      return this._infoByScale[t2[0]];
    for (let o2 = 1; o2 < t2.length - 1; o2++)
      if (e2 > t2[o2] + a$i)
        return this._infoByScale[t2[o2 - 1]];
    return this._infoByScale[t2[t2.length - 1]];
  }
  getClosestInfoForScale(e2) {
    const t2 = this.scales;
    return this._infoByScale[e2] || (e2 = t2.reduce((t3, o2) => Math.abs(o2 - e2) < Math.abs(t3 - e2) ? o2 : t3, t2[0])), this._infoByScale[e2];
  }
  scaleToLevel(e2) {
    const t2 = this.scales;
    if (this._infoByScale[e2])
      return this._infoByScale[e2].level;
    for (let o2 = t2.length - 1; o2 >= 0; o2--)
      if (e2 < t2[o2]) {
        if (o2 === t2.length - 1)
          return this._infoByScale[t2[t2.length - 1]].level;
        return this._infoByScale[t2[o2]].level + (t2[o2] - e2) / (t2[o2] - t2[o2 + 1]);
      }
    return this._infoByScale[t2[0]].level;
  }
  scaleToZoom(e2) {
    return this.tileInfo.scaleToZoom(e2);
  }
  _getTileIdAtLOD(e2, t2, o2) {
    const l2 = this._infoByLevel[o2.level];
    return e2.set(o2), t2.resolution < l2.resolution ? null : (t2.resolution === l2.resolution || (e2.level = t2.level, e2.col = Math.floor(o2.col * l2.resolution / t2.resolution + 0.01), e2.row = Math.floor(o2.row * l2.resolution / t2.resolution + 0.01)), e2);
  }
}
function u$7(e2, t2) {
  return e2.length = 0, t2.forEach((t3) => e2.push(t3)), e2;
}
const c$f = new Set(), a$h = [], h$6 = new Map(), l$a = [0, 0];
let p$d = class extends m$1L {
  constructor(e2) {
    super(e2), this._keyToItem = new Map(), this.concurrency = 6, this.strategy = "scale-first", this.tileInfoView = null;
  }
  initialize() {
    const { concurrency: e2, process: t2, strategy: s2 } = this;
    this._queue = new l$e({ concurrency: e2, process: (e3, s3) => {
      const r2 = this._keyToItem.get(e3);
      return t2(r2, { signal: s3 });
    }, peeker: s2 === "scale-first" ? (e3) => this._peekByScaleFirst(e3) : (e3) => this._peekByCenterFirst(e3) });
  }
  destroy() {
    this.clear(), this._queue = s$26(this._queue);
  }
  get length() {
    return this._queue ? this._queue.length : 0;
  }
  get onGoingCount() {
    return this._keyToItem.size;
  }
  get updating() {
    return this.length > 0 || this.onGoingCount > 0;
  }
  abort(e2) {
    const t2 = typeof e2 == "string" ? e2 : e2.id;
    this._queue.abort(t2);
  }
  clear() {
    this._queue.clear(), this._keyToItem.clear(), this.notifyChange("updating");
  }
  has(e2) {
    return typeof e2 == "string" ? this._keyToItem.has(e2) : this._keyToItem.has(e2.id);
  }
  isOngoing(e2) {
    const t2 = typeof e2 == "string" ? e2 : e2.id;
    return this.has(t2) && this._queue.isOngoing(t2);
  }
  pause() {
    this._queue.pause();
  }
  push(e2) {
    const t2 = e2.key.id;
    if (this._queue.has(t2))
      return this._queue.get(t2);
    const s2 = this._queue.push(t2), r2 = () => {
      this._keyToItem.delete(t2), this.notifyChange("updating");
    };
    return this._keyToItem.set(t2, e2), s2.then(r2, r2), this.notifyChange("updating"), s2;
  }
  reset() {
    this._queue.reset();
  }
  resume() {
    this._queue.resume();
  }
  _peekByScaleFirst(e2) {
    if (!this.state)
      return e2.values().next().value;
    const t2 = this.tileInfoView;
    let s2 = Number.NEGATIVE_INFINITY, r2 = Number.POSITIVE_INFINITY;
    e2.forEach((e3) => {
      const t3 = this._keyToItem.get(e3), o3 = this.tileInfoView.getTileScale(t3.key);
      h$6.has(o3) || (h$6.set(o3, []), s2 = Math.max(o3, s2), r2 = Math.min(o3, r2)), h$6.get(o3).push(t3.key), c$f.add(o3);
    });
    let o2 = this.state.scale;
    h$6.has(o2) || (u$7(a$h, c$f), a$h.sort((e3, t3) => e3 - t3), o2 = a$h.reduce((e3, t3) => Math.abs(t3 - o2) < Math.abs(e3 - o2) ? t3 : e3, a$h[0])), o2 = Math.min(o2, s2), o2 = Math.max(o2, r2);
    const i2 = h$6.get(o2), n2 = t2.getClosestInfoForScale(o2), l2 = n2.getColumnForX(this.state.center[0]), p2 = n2.getRowForY(this.state.center[1]);
    return i2.sort((e3, t3) => {
      const s3 = n2.denormalizeCol(e3.col, e3.world), r3 = n2.denormalizeCol(t3.col, t3.world);
      return Math.sqrt((l2 - s3) * (l2 - s3) + (p2 - e3.row) * (p2 - e3.row)) - Math.sqrt((l2 - r3) * (l2 - r3) + (p2 - t3.row) * (p2 - t3.row));
    }), c$f.clear(), h$6.clear(), i2[0].id;
  }
  _peekByCenterFirst(e2) {
    if (!this.state)
      return e2.values().next().value;
    const t2 = this.tileInfoView, s2 = this.state.center;
    let r2, o2 = Number.POSITIVE_INFINITY;
    return e2.forEach((e3) => {
      const n2 = this._keyToItem.get(e3);
      t2.getTileCoords(l$a, n2.key);
      const u2 = m$c(l$a, s2);
      u2 < o2 && (o2 = u2, r2 = n2.key);
    }), r2.id;
  }
};
e$1W([y$1o({ constructOnly: true })], p$d.prototype, "concurrency", void 0), e$1W([y$1o({ constructOnly: true })], p$d.prototype, "process", void 0), e$1W([y$1o()], p$d.prototype, "state", void 0), e$1W([y$1o({ constructOnly: true })], p$d.prototype, "strategy", void 0), e$1W([y$1o({ constructOnly: true })], p$d.prototype, "tileInfoView", void 0), e$1W([y$1o({ readOnly: true })], p$d.prototype, "updating", null), p$d = e$1W([n$2f("esri.views.2d.tiling.TileQueue")], p$d);
const y$2 = p$d;
class t$8 {
  constructor(e2, t2, i2) {
    this.maxSize = e2, this._tileInfoView = t2, this._removedFunc = i2, this._tilePerId = new Map(), this._tileKeysPerLevel = [];
  }
  has(e2) {
    return this._tilePerId.has(e2);
  }
  get(e2) {
    return this._tilePerId.get(e2);
  }
  pop(e2) {
    const t2 = this._tilePerId.get(e2);
    if (!t2)
      return;
    const s2 = t2.key.level, r2 = this._tileKeysPerLevel[s2];
    i$a(this._tilePerId, e2);
    for (let i2 = 0; i2 < r2.length; i2++)
      if (r2[i2].id === e2) {
        r2.splice(i2, 1);
        break;
      }
    return t2.visible = true, t2;
  }
  add(e2) {
    e2.visible = false;
    const t2 = e2.key, i2 = t2.id;
    if (this._tilePerId.has(i2))
      return;
    this._tilePerId.set(i2, e2);
    const s2 = t2.level;
    this._tileKeysPerLevel[s2] || (this._tileKeysPerLevel[s2] = []), this._tileKeysPerLevel[s2].push(t2);
  }
  prune(e2, t2, i2) {
    let s2 = this._tilePerId.size;
    if (s2 <= this.maxSize)
      return;
    let r2 = this._tileKeysPerLevel.length - 1;
    for (; s2 > this.maxSize && r2 >= 0; )
      r2 !== e2 && (s2 = this._pruneAroundCenterTile(s2, t2, i2, r2)), r2--;
    s2 > this.maxSize && (s2 = this._pruneAroundCenterTile(s2, t2, i2, e2));
  }
  _pruneAroundCenterTile(t2, i2, s2, r2) {
    const l2 = this._tileKeysPerLevel[r2];
    if (!l2 || l2.length === 0)
      return t2;
    const { size: n2, origin: h2 } = this._tileInfoView.tileInfo, o2 = s2 * n2[0], _2 = s2 * n2[1], d2 = [0, 0], u2 = [0, 0];
    for (l2.sort((t3, s3) => (d2[0] = h2.x + o2 * (t3.col + 0.5), d2[1] = h2.y - _2 * (t3.row + 0.5), u2[0] = h2.x + o2 * (s3.col + 0.5), u2[1] = h2.y - _2 * (s3.row + 0.5), b$3(d2, i2) - b$3(u2, i2))); l2.length > 0; ) {
      const e2 = l2.pop();
      if (this._removeTile(e2.id), --t2 === this.maxSize)
        break;
    }
    return t2;
  }
  _removeTile(e2) {
    const t2 = this._tilePerId.get(e2);
    this._removedFunc && t2 && this._removedFunc(t2), i$a(this._tilePerId, e2);
  }
}
function i$a(e2, t2) {
  e2.delete(t2);
}
const a$g = new e$9(0, 0, 0, 0), h$5 = new Map(), o$8 = [], c$e = [];
class r$a {
  constructor(e2) {
    this._previousScale = Number.POSITIVE_INFINITY, this.cachePolicy = "keep", this.coveragePolicy = "closest", this.resampling = true, this.tileIndex = new Map(), this.tiles = [], this.buffer = 192, this.acquireTile = e2.acquireTile, this.releaseTile = e2.releaseTile, this.tileInfoView = e2.tileInfoView, this.resampling = e2.resampling == null || !!e2.resampling, e2.cachePolicy && (this.cachePolicy = e2.cachePolicy), e2.coveragePolicy && (this.coveragePolicy = e2.coveragePolicy), e2.buffer != null && (this.buffer = e2.buffer), e2.cacheSize && (this._tileCache = new t$8(e2.cacheSize, this.tileInfoView, (e3) => {
      this.releaseTile(e3);
    }));
  }
  destroy() {
    this.tileIndex.clear();
  }
  update(e2) {
    const { resampling: i2, tileIndex: t2 } = this, l2 = this.tileInfoView.getTileCoverage(e2.state, this.buffer, this.coveragePolicy);
    if (c$e.length = 0, o$8.length = 0, h$5.clear(), !l2)
      return;
    const { minScale: r2, maxScale: n2 } = this.tileInfoView.tileInfo, { spans: f2, lodInfo: d2 } = l2, { level: u2 } = d2, { scale: p2, center: g2, resolution: y2 } = e2.state, I2 = !e2.stationary && p2 > this._previousScale;
    if (this._previousScale = p2, this.tiles.length = 0, !i2 && (p2 > r2 || p2 < n2))
      return this.tiles.length = 0, h$5.clear(), t2.forEach((e3) => {
        this.releaseTile(e3);
      }), t2.clear(), c$e.length = 0, o$8.length = 0, h$5.clear(), l$b.pool.release(l2), true;
    t2.forEach((e3) => e3.visible = true);
    let T2 = 0, _2 = 0;
    if (f2.length > 0)
      for (const { row: s2, colFrom: o2, colTo: c2 } of f2)
        for (let e3 = o2; e3 <= c2; e3++) {
          T2++;
          const i3 = a$g.set(u2, s2, d2.normalizeCol(e3), d2.getWorldForColumn(e3)).id;
          if (t2.has(i3)) {
            const e4 = t2.get(i3);
            e4.isReady ? (h$5.set(i3, e4), _2++) : I2 || this._addParentTile(i3, h$5);
          } else {
            let e4;
            if (this._tileCache && this._tileCache.has(i3)) {
              if (e4 = this._tileCache.pop(i3), this.tileIndex.set(i3, e4), e4.isReady) {
                h$5.set(i3, e4), _2++;
                continue;
              }
            } else
              e4 = this.acquireTile(a$g), this.tileIndex.set(i3, e4);
            I2 || this._addParentTile(i3, h$5);
          }
        }
    const m2 = _2 === T2;
    t2.forEach((e3, i3) => {
      if (a$g.set(i3), h$5.has(i3))
        return;
      const t3 = this.tileInfoView.intersects(l2, a$g), s2 = this.cachePolicy === "purge" ? a$g.level !== u2 : a$g.level > u2;
      !t3 || !I2 && m2 ? !s2 && t3 || o$8.push(i3) : e3.isReady ? s2 && this.cachePolicy === "purge" && this._hasReadyAncestor(a$g, u2) ? o$8.push(i3) : c$e.push(i3) : s2 && o$8.push(i3);
    });
    for (const s2 of c$e) {
      const e3 = t2.get(s2);
      e3 && e3.isReady && h$5.set(s2, e3);
    }
    for (const s2 of o$8) {
      const e3 = t2.get(s2);
      this._tileCache ? this._tileCache.add(e3) : this.releaseTile(e3), t2.delete(s2);
    }
    return h$5.forEach((e3) => this.tiles.push(e3)), t2.forEach((e3) => {
      h$5.has(e3.key.id) || (e3.visible = false);
    }), this._tileCache && this._tileCache.prune(u2, g2, y2), l$b.pool.release(l2), h$5.clear(), m2;
  }
  clear(e2 = true) {
    const { tileIndex: i2 } = this;
    e2 && i2.forEach((e3) => {
      this.releaseTile(e3);
    }), i2.clear();
  }
  updateCacheSize(e2) {
    this._tileCache && (this._tileCache.maxSize = e2);
  }
  _addParentTile(e2, i2) {
    let t2 = e2, s2 = null;
    for (; t2 = this.tileInfoView.getTileParentId(t2), t2; )
      if (this.tileIndex.has(t2)) {
        if (s2 = this.tileIndex.get(t2), s2 && s2.isReady) {
          i2.has(s2.key.id) || i2.set(s2.key.id, s2);
          break;
        }
      } else if (this._tileCache && this._tileCache.has(t2) && (s2 = this._tileCache.pop(t2), this.tileIndex.set(t2, s2), s2 && s2.isReady)) {
        i2.has(s2.key.id) || i2.set(s2.key.id, s2);
        break;
      }
  }
  _hasReadyAncestor(t2, s2) {
    const l2 = u$1p();
    this.tileInfoView.getTileBounds(l2, t2, true);
    for (const a2 of this.tileIndex.values())
      if (a2.isReady && a2.key.level >= s2 && a2.key.level < t2.level) {
        const t3 = u$1p();
        if (this.tileInfoView.getTileBounds(t3, a2.key, true), R$k(t3, l2))
          return true;
      }
    return false;
  }
}
function t$7(t2, r2) {
  switch (r2) {
    case "primary":
      return t2.pointerType === "touch" || t2.button === 0;
    case "secondary":
      return t2.pointerType !== "touch" && t2.button === 2;
    case "tertiary":
      return t2.pointerType !== "touch" && t2.button === 1;
  }
}
class a$f extends i$x {
  constructor(t2, i2) {
    super(true), this._view = t2, this.registerIncoming("double-click", i2, (t3) => this._handleDoubleClick(t3, i2));
  }
  _handleDoubleClick(t2, a2) {
    t$7(t2.data, "primary") && (t2.stopPropagation(), a2 ? this._view.mapViewNavigation.zoomOut([t2.data.x, t2.data.y]) : this._view.mapViewNavigation.zoomIn([t2.data.x, t2.data.y]));
  }
}
class e$7 extends i$x {
  constructor(t2, e2, a2) {
    super(true), this.view = t2, this.pointerType = e2, this.registerIncoming("double-tap-drag", a2, (t3) => this._handleDoubleTapDrag(t3));
  }
  _handleDoubleTapDrag(t2) {
    const { data: e2 } = t2, { pointerType: a2 } = e2;
    if (a2 !== this.pointerType)
      return;
    t2.stopPropagation();
    const { action: s2, delta: i2 } = e2, { view: r2 } = this, { mapViewNavigation: n2 } = r2;
    switch (s2) {
      case "begin": {
        const { scale: t3 } = r2;
        this._startScale = t3, this._currentScale = t3, this._previousDelta = i2, n2.begin();
        break;
      }
      case "update": {
        if (this._previousDelta.y === i2.y)
          return;
        this._previousDelta = i2;
        const t3 = 1.015 ** i2.y, e3 = this._startScale * t3, a3 = e3 / this._currentScale;
        n2.setViewpointImmediate(a3), this._currentScale = e3;
        break;
      }
      case "end": {
        const { constraints: t3 } = r2, { effectiveLODs: e3, snapToZoom: a3 } = t3;
        if (!a3 || !e3)
          return void n2.end();
        const s3 = t3.snapScale(this._currentScale), o2 = (i2.y > 0 ? Math.max(s3, t3.snapToPreviousScale(this._startScale)) : Math.min(s3, t3.snapToNextScale(this._startScale))) / this._currentScale;
        n2.zoom(o2);
        break;
      }
    }
  }
}
class t$6 {
  constructor(t2) {
    this._callbacks = t2, this._currentCount = 0, this._callbacks.condition || (this._callbacks.condition = () => true);
  }
  handle(t2) {
    const s2 = t2.data, i2 = s2.pointers.size;
    switch (s2.action) {
      case "start":
        this._currentCount = i2, this._emitStart(t2);
        break;
      case "added":
        this._emitEnd(this._previousEvent), this._currentCount = i2, this._emitStart(t2);
        break;
      case "update":
        this._emitUpdate(t2);
        break;
      case "removed":
        this._startEvent && this._emitEnd(this._previousEvent), this._currentCount = i2, this._emitStart(t2);
        break;
      case "end":
        this._emitEnd(t2), this._currentCount = 0;
    }
    this._previousEvent = t2;
  }
  _emitStart(t2) {
    var _a2, _b2;
    this._startEvent = t2, ((_b2 = (_a2 = this._callbacks).condition) == null ? void 0 : _b2.call(_a2, this._currentCount, t2)) && this._callbacks.start(this._currentCount, t2, this._startEvent);
  }
  _emitUpdate(t2) {
    var _a2, _b2;
    ((_b2 = (_a2 = this._callbacks).condition) == null ? void 0 : _b2.call(_a2, this._currentCount, t2)) && this._callbacks.update(this._currentCount, t2, this._startEvent);
  }
  _emitEnd(t2) {
    var _a2, _b2;
    ((_b2 = (_a2 = this._callbacks).condition) == null ? void 0 : _b2.call(_a2, this._currentCount, t2)) && this._callbacks.end(this._currentCount, t2, this._startEvent), this._startEvent = null;
  }
}
class n$a extends i$x {
  constructor(t2, i2, a2) {
    super(true), this.view = t2, this.pointerAction = i2, this.registerIncoming("drag", a2, (t3) => this._handleDrag(t3)), this.registerIncoming("pointer-down", () => this.stopMomentumNavigation());
  }
  onInstall(i2) {
    super.onInstall(i2), this._dragEventSeparator = new t$6({ start: (t2, i3) => {
      this.view.mapViewNavigation.pan.begin(this.view, i3.data), i3.stopPropagation();
    }, update: (t2, i3) => {
      this.view.mapViewNavigation.pan.update(this.view, i3.data), i3.stopPropagation();
    }, end: (t2, i3) => {
      this.view.mapViewNavigation.pan.end(this.view, i3.data), i3.stopPropagation();
    }, condition: (t2, i3) => t2 === 1 && t$7(i3.data, this.pointerAction) });
  }
  _handleDrag(t2) {
    const i2 = this.view.mapViewNavigation;
    i2.pinch.zoomMomentum || i2.pinch.rotateMomentum ? this.stopMomentumNavigation() : this._dragEventSeparator.handle(t2);
  }
  stopMomentumNavigation() {
    this.view.mapViewNavigation.pan.stopMomentumNavigation();
  }
}
class o$7 extends i$x {
  constructor(a2, o2, r2) {
    super(true), this._view = a2, this.pointerAction = o2;
    const e2 = this._view.mapViewNavigation;
    this._dragEventSeparator = new t$6({ start: (t2, a3) => {
      e2.rotate.begin(this._view, a3.data), a3.stopPropagation();
    }, update: (t2, a3) => {
      e2.rotate.update(this._view, a3.data), a3.stopPropagation();
    }, end: (t2, a3) => {
      e2.rotate.end(), a3.stopPropagation();
    }, condition: (t2, a3) => t2 === 1 && t$7(a3.data, this.pointerAction) }), this.registerIncoming("drag", r2, (t2) => this._dragEventSeparator.handle(t2));
  }
}
function n$9(t2) {
  let n2 = t2 * t2;
  return t2 < 0 && (n2 *= -1), n2;
}
function a$e(t2) {
  return t2.translation[0] = 0, t2.translation[1] = 0, t2.translation[2] = 0, t2.heading = 0, t2.tilt = 0, t2;
}
function i$9(a2, i2, o2) {
  const s2 = o2, e2 = a2.state, r2 = a2.device, l2 = i2.tiltDirection === "forward-down" ? 1 : -1, c2 = 1;
  return r2.deviceType === "standard" ? (s2.translation[0] = n$9(e2.axes[0]), s2.translation[1] = n$9(e2.axes[1]), s2.translation[2] = n$9(e2.buttons[7]) - n$9(e2.buttons[6]), s2.heading = n$9(e2.axes[2]), s2.tilt = n$9(e2.axes[3])) : r2.deviceType === "spacemouse" && (s2.translation[0] = 1.2 * n$9(e2.axes[0]), s2.translation[1] = 1.2 * n$9(e2.axes[1]), s2.translation[2] = 2 * -n$9(e2.axes[2]), s2.heading = 1.2 * n$9(e2.axes[5]), s2.tilt = 1.2 * n$9(e2.axes[3])), s2.tilt *= l2, g$R(s2.translation, s2.translation, c2), s2;
}
function s$8(t2) {
  return t2.translation[0] === 0 && t2.translation[1] === 0 && t2.translation[2] === 0 && t2.heading === 0 && t2.tilt === 0 && t2.zoom === 0;
}
class d$6 extends i$x {
  constructor(i2) {
    super(true), this._view = i2, this._frameTask = null, this._watchHandles = new t$1N(), this._currentDevice = null, this._transformation = { translation: [0, 0, 0], heading: 0, tilt: 0, zoom: 0 }, this._handle = this.registerIncoming("gamepad", (t2) => this._handleGamePadEvent(t2)), this._handle.pause();
  }
  onInstall(t2) {
    super.onInstall(t2), this._watchHandles.add([l$1f(() => {
      var _a2;
      return (_a2 = this._view.navigation.gamepad) == null ? void 0 : _a2.enabled;
    }, (t3) => {
      t3 ? (this._handle.resume(), this._frameTask || (this._frameTask = A$o({ update: (t4) => this._frameUpdate(t4.deltaTime) }))) : (this._handle.pause(), this._frameTask && (this._frameTask.remove(), this._frameTask = null));
    }, h$S)]);
  }
  onUninstall() {
    this._watchHandles.removeAll(), this._frameTask && (this._frameTask.remove(), this._frameTask = null), super.onUninstall();
  }
  _handleGamePadEvent(t2) {
    const i2 = this._view.navigation.gamepad.device;
    i2 && t2.data.device !== i2 || this._currentDevice && this._currentDevice !== t2.data.device || (t2.data.action === "end" ? (this._currentDevice = null, a$e(this._transformation)) : (this._currentDevice = t2.data.device, i$9(t2.data, this._view.navigation.gamepad, this._transformation)));
  }
  _frameUpdate(t2) {
    const i2 = this._transformation;
    if (s$8(i2))
      return;
    const e2 = this._view.viewpoint.clone(), a2 = this._view.navigation.gamepad.velocityFactor, r2 = _$3 * a2 * t2;
    St(e2, e2, [i2.translation[0] * r2, -i2.translation[1] * r2]);
    const o2 = 1 + i2.translation[2] * c$d * t2, h2 = this._view.constraints.rotationEnabled ? -i2.heading * m$8 * t2 : 0, d2 = this._view.size, v2 = [d2[0] / 2, d2[1]];
    Gt(e2, e2, o2, h2, v2, d2);
    const p2 = this._view.constraints.constrain(e2, this._view.viewpoint);
    this._view.viewpoint = p2;
  }
}
const m$8 = 0.06, _$3 = 0.7, c$d = 6e-4;
class i$8 extends i$x {
  constructor(e2, i2, t2) {
    super(true), this.view = e2, this.keys = i2, this._pressed = false, this._keyMap = { [i2.left]: "left", [i2.right]: "right", [i2.up]: "up", [i2.down]: "down" }, this.registerIncoming("key-down", t2, (e3) => this._handleKeyDown(e3)), this.registerIncoming("key-up", t2, (e3) => this._handleKeyUp(e3)), this.registerIncoming("blur", t2, () => this._handleBlur());
  }
  _handleKeyDown(e2) {
    e2.data.repeat || this._handleKey(e2, true);
  }
  _handleKeyUp(e2) {
    this._handleKey(e2, false);
  }
  _handleBlur() {
    this._pressed && (this._pressed = false, this.view.mapViewNavigation.stop());
  }
  _handleKey(e2, i2) {
    const t2 = this._keyMap[e2.data.key];
    if (this._pressed = t2 != null, this._pressed) {
      if (i2)
        switch (this.view.mapViewNavigation.begin(), t2) {
          case "left":
            this.view.mapViewNavigation.continousPanLeft();
            break;
          case "right":
            this.view.mapViewNavigation.continousPanRight();
            break;
          case "up":
            this.view.mapViewNavigation.continousPanUp();
            break;
          case "down":
            this.view.mapViewNavigation.continousPanDown();
        }
      else
        this._pressed = false, this.view.mapViewNavigation.stop();
      e2.stopPropagation();
    }
  }
}
class i$7 extends i$x {
  constructor(e2, i2, t2) {
    super(true), this.view = e2, this.keys = i2, this._pressed = false, this._keyToDirection = { [i2.clockwiseOption1]: "clockwise", [i2.clockwiseOption2]: "clockwise", [i2.counterClockwiseOption1]: "counterClockwise", [i2.counterClockwiseOption2]: "counterClockwise", [i2.resetOption1]: "reset", [i2.resetOption2]: "reset" }, this.registerIncoming("key-down", t2, (e3) => this._handleKeyDown(e3)), this.registerIncoming("key-up", t2, (e3) => this._handleKeyUp(e3)), this.registerIncoming("blur", t2, () => this._handleBlur());
  }
  _handleKeyDown(e2) {
    e2.data.repeat || this._handleKey(e2, true);
  }
  _handleKeyUp(e2) {
    this._handleKey(e2, false);
  }
  _handleBlur() {
    this._pressed && (this._pressed = false, this.view.mapViewNavigation.stop());
  }
  _handleKey(e2, i2) {
    const t2 = e2.modifiers;
    if (t2.size > 0 && !t2.has("Shift") || !this.view.constraints.rotationEnabled)
      return;
    const s2 = this._keyToDirection[e2.data.key];
    if (this._pressed = s2 != null, this._pressed) {
      if (i2)
        switch (this.view.mapViewNavigation.begin(), s2) {
          case "clockwise":
            this.view.mapViewNavigation.continousRotateClockwise();
            break;
          case "counterClockwise":
            this.view.mapViewNavigation.continousRotateCounterclockwise();
            break;
          case "reset":
            this.view.mapViewNavigation.resetRotation();
        }
      else
        this._pressed = false, this.view.mapViewNavigation.stop();
      e2.stopPropagation();
    }
  }
}
var t$5;
!function(o2) {
  o2[o2.IN = 0] = "IN", o2[o2.OUT = 1] = "OUT";
}(t$5 || (t$5 = {}));
class e$6 extends i$x {
  constructor(o2, e2, i2) {
    super(true), this.view = o2, this.keys = e2, this._keysToZoomAction = {}, this.registerIncoming("key-down", i2, (o3) => this._handleKeyDown(o3)), e2.zoomIn.forEach((o3) => this._keysToZoomAction[o3] = t$5.IN), e2.zoomOut.forEach((o3) => this._keysToZoomAction[o3] = t$5.OUT);
  }
  _handleKeyDown(o2) {
    this._handleKey(o2);
  }
  _handleKey(o2) {
    const e2 = o2.modifiers;
    if (e2.size > 0 && !e2.has("Shift"))
      return;
    const { key: i2 } = o2.data;
    if (!(i2 in this._keysToZoomAction))
      return;
    const n2 = this._keysToZoomAction[i2], { mapViewNavigation: s2 } = this.view;
    let r2 = null;
    switch (n2) {
      case t$5.IN:
        r2 = s2.zoomIn();
        break;
      case t$5.OUT:
        r2 = s2.zoomOut();
        break;
      default:
        return;
    }
    s2.begin(), r2.then(() => s2.end()), o2.stopPropagation();
  }
}
const t$4 = 0.6;
class o$6 extends i$x {
  constructor(e2, t2) {
    super(true), this._view = e2, this._canZoom = true, this.registerIncoming("mouse-wheel", t2, (e3) => this._handleMouseWheel(e3));
  }
  _handleMouseWheel(e2) {
    if (!this._view.navigation.mouseWheelZoomEnabled)
      return;
    if (e2.preventDefault(), e2.stopPropagation(), !this._canZoom)
      return;
    const o2 = this._view.mapViewNavigation, { x: n2, y: i2, deltaY: s2 } = e2.data, a2 = 1 / t$4 ** (1 / 60 * s2), h2 = o2.zoom(a2, [n2, i2]);
    h2 && (this._canZoom = false, h2.catch(() => {
    }).then(() => {
      this._canZoom = true, o2.end();
    }));
  }
}
class a$d extends i$x {
  constructor(i2) {
    super(true), this.view = i2, this.registerIncoming("drag", (t2) => this._handleDrag(t2)), this.registerIncoming("pointer-down", () => this._stopMomentumNavigation());
    const a2 = this.view.mapViewNavigation;
    this._dragEventSeparator = new t$6({ start: (t2, i3) => {
      a2.pinch.begin(this.view, i3.data), i3.stopPropagation();
    }, update: (t2, i3) => {
      a2.pinch.update(this.view, i3.data), i3.stopPropagation();
    }, end: (t2, i3) => {
      a2.pinch.end(this.view), i3.stopPropagation();
    }, condition: (t2) => t2 >= 2 });
  }
  _handleDrag(t2) {
    this._dragEventSeparator.handle(t2);
  }
  _stopMomentumNavigation() {
    this.view.mapViewNavigation.pinch.stopMomentumNavigation();
  }
}
function t$3(t2) {
  const n2 = t2.native;
  return n2 ? { buttons: n2.buttons.map((t3) => t3.pressed ? t3.value ? t3.value : 1 : 0), axes: n2.axes.map((n3) => s$7(n3, t2.axisThreshold)) } : { buttons: [], axes: [] };
}
function n$8(t2, n2) {
  if (t2.axes.length !== n2.axes.length)
    return false;
  if (t2.buttons.length !== n2.buttons.length)
    return false;
  for (let e2 = 0; e2 < t2.axes.length; e2++)
    if (t2.axes[e2] !== n2.axes[e2])
      return false;
  for (let e2 = 0; e2 < t2.buttons.length; e2++)
    if (t2.buttons[e2] !== n2.buttons[e2])
      return false;
  return true;
}
function e$5(t2) {
  for (let n2 = 0; n2 < t2.axes.length; n2++)
    if (t2.axes[n2] !== 0)
      return false;
  for (let n2 = 0; n2 < t2.buttons.length; n2++)
    if (t2.buttons[n2] !== 0)
      return false;
  return true;
}
function s$7(t2, n2) {
  const e2 = Math.abs(t2);
  return e2 < n2 ? 0 : Math.sign(t2) * (e2 - n2) / (1 - n2);
}
class a$c {
  constructor(e2, t2) {
    this._element = e2, this._input = t2, this._hasEventListeners = false, this._onConnectGamepad = (e3) => {
      this._connectGamepad(e3.gamepad);
    }, this._onDisconnectGamepad = (e3) => {
      const t3 = e3.gamepad, i3 = t3.index, n3 = this._inputDevices[i3];
      n3 && (this._emitGamepadEvent(t3, t$3(n3), false), this._inputDevices.splice(i3, 1), this._latestUpdate.splice(i3, 1), this._input.gamepad.devices.remove(n3), this.ensurePollingState());
    }, this._frameTask = null, this._latestUpdate = new Array(), this._inputDevices = new Array(), this._callback = null;
    const i2 = "getGamepads" in window.navigator, n2 = window.isSecureContext;
    this.supported = i2 && n2, this.supported && (this._forEachGamepad((e3) => this._connectGamepad(e3)), window.addEventListener("gamepadconnected", this._onConnectGamepad), window.addEventListener("gamepaddisconnected", this._onDisconnectGamepad), this.ensurePollingState());
  }
  destroy() {
    this.hasEventListeners = false, this.supported && (window.removeEventListener("gamepadconnected", this._onConnectGamepad), window.removeEventListener("gamepaddisconnected", this._onDisconnectGamepad));
  }
  set hasEventListeners(e2) {
    this._hasEventListeners !== e2 && (this._hasEventListeners = e2, this.ensurePollingState());
  }
  get _eventsEnabled() {
    return this.supported && this._inputDevices.length > 0 && this._hasEventListeners;
  }
  set onEvent(e2) {
    this._callback = e2;
  }
  _connectGamepad(e2) {
    const s2 = new a$u(e2);
    s2.deviceType !== "unknown" && (this._inputDevices[e2.index] = s2, this._input.gamepad.devices.add(s2)), this.ensurePollingState();
  }
  ensurePollingState() {
    this._eventsEnabled ? this._startPolling() : this._stopPolling();
  }
  _startPolling() {
    this._frameTask == null && (this._frameTask = A$o({ update: () => this._readGamepadState() }));
  }
  _stopPolling() {
    this._frameTask != null && (this._frameTask.remove(), this._frameTask = null, this._latestUpdate = new Array());
  }
  _readGamepadState() {
    const e2 = document.hasFocus(), t2 = this._element.contains(document.activeElement), a2 = this._input.gamepad.enabledFocusMode === "document" && !e2 || this._input.gamepad.enabledFocusMode === "view" && !t2;
    this._forEachGamepad((e3) => {
      const t3 = this._inputDevices[e3.index];
      if (!t3)
        return;
      const d2 = this._latestUpdate[e3.index], o2 = t$3(t3), r2 = a2 || e$5(o2);
      if (d2) {
        if (d2.timestamp === e3.timestamp)
          return;
        if (!d2.active && r2)
          return;
        if (n$8(d2.state, o2))
          return;
      }
      this._emitGamepadEvent(e3, o2, !r2);
    });
  }
  _forEachGamepad(e2) {
    const t2 = window.navigator.getGamepads();
    for (let s2 = 0; s2 < t2.length; s2++) {
      const i2 = t2[s2];
      this._validate(i2) && e2(i2);
    }
  }
  _emitGamepadEvent(e2, t2, s2) {
    const i2 = this._latestUpdate[e2.index], n2 = i2 && i2.active;
    if (!n2 && !s2)
      return;
    const a2 = !n2 && s2 ? "start" : n2 && s2 ? "update" : "end";
    this._latestUpdate[e2.index] = { timestamp: e2.timestamp, state: t2, active: s2 }, this._callback && this._callback({ device: this._inputDevices[e2.index], state: t2, action: a2 });
  }
  _validate(e2) {
    if (!e2)
      return false;
    if (!e2.connected)
      return false;
    for (let t2 = 0; t2 < e2.axes.length; t2++)
      if (isNaN(e2.axes[t2]))
        return false;
    return true;
  }
}
const o$5 = has("trident"), a$b = has("edge"), s$6 = has("chrome"), r$9 = has("ff"), h$4 = has("safari"), l$9 = { touchNone: "esri-view-surface--touch-none", touchPan: "esri-view-surface--touch-pan" };
class u$6 {
  constructor(e2, t2) {
    this._input = t2, this._active = {}, this._activePointerCaptures = new Set(), this._keyDownState = new Set(), this._eventId = 1, this._browserTouchPanningEnabled = false, this._element = e2, e2.getAttribute("tabindex") || e2.setAttribute("tabindex", "0"), this._eventHandlers = { "key-down": this._handleKey, "key-up": this._handleKey, "pointer-down": this._handlePointer, "pointer-move": this._handlePointerPreventDefault, "pointer-up": this._handlePointerPreventDefault, "pointer-enter": this._handlePointer, "pointer-leave": this._handlePointer, "pointer-cancel": this._handlePointer, "mouse-wheel": this._handleMouseWheel, "pointer-capture-lost": this._handlePointerCaptureLost }, this._updateTouchAction(), this._element.addEventListener("keydown", this._preventAltKeyDefault), this._gamepadSource = new a$c(e2, this._input), this._gamepadSource.onEvent = (e3) => this._callback("gamepad", e3);
  }
  destroy() {
    this._callback = null, this.activeEvents = null, this._activePointerCaptures.forEach((e2) => {
      this._releasePointerCaptureSafe(e2);
    }), this._gamepadSource = s$26(this._gamepadSource), this._activePointerCaptures = null, this._removeTouchAction(), this._element.removeEventListener("keydown", this._preventAltKeyDefault);
  }
  get browserTouchPanningEnabled() {
    return this._browserTouchPanningEnabled;
  }
  set browserTouchPanningEnabled(e2) {
    this._browserTouchPanningEnabled = e2, this._updateTouchAction(), this._updateTouchEventHandling();
  }
  set onEventReceived(e2) {
    this._callback = e2;
  }
  set activeEvents(e2) {
    for (const t2 in this._active)
      if (!e2 || !e2.has(t2)) {
        const e3 = this._active[t2];
        this._element.removeEventListener(c$c[t2], e3), delete this._active[t2];
      }
    e2 && e2.forEach((e3) => {
      if (!this._active[e3] && c$c[e3]) {
        const t2 = (this._eventHandlers[e3] || this._handleDefault).bind(this, e3);
        this._element.addEventListener(c$c[e3], t2), this._active[e3] = t2;
      }
    }), this._gamepadSource.hasEventListeners = e2 && e2.has("gamepad");
  }
  setPointerCapture(e2, t2) {
    t2 ? (this._element.setPointerCapture(e2.pointerId), this._activePointerCaptures.add(e2.pointerId)) : (this._releasePointerCaptureSafe(e2.pointerId), this._activePointerCaptures.delete(e2.pointerId));
  }
  _updateTouchAction() {
    this._element.classList.remove(this._browserTouchPanningEnabled ? l$9.touchNone : l$9.touchPan), this._element.classList.add(this._browserTouchPanningEnabled ? l$9.touchPan : l$9.touchNone);
  }
  _updateTouchEventHandling() {
    this._browserTouchPanningEnabled ? this._element.addEventListener("touchmove", this._preventMultiTouchPanning) : this._element.removeEventListener("touchmove", this._preventMultiTouchPanning);
  }
  _removeTouchAction() {
    this._element.classList.remove(l$9.touchNone), this._element.classList.remove(l$9.touchPan), this._element.removeEventListener("touchmove", this._preventMultiTouchPanning);
  }
  _releasePointerCaptureSafe(e2) {
    try {
      if (this._element.hasPointerCapture && !this._element.hasPointerCapture(e2))
        return;
      this._element.releasePointerCapture(e2);
    } catch (t2) {
    }
  }
  _updateNormalizedPointerLikeEvent(e2, t2) {
    const n2 = i$l(this._element, e2);
    return u$6.test.disableSubpixelCoordinates && (n2.x = Math.round(n2.x), n2.y = Math.round(n2.y)), t2.x = n2.x, t2.y = n2.y, t2;
  }
  _handleKey(e2, n2) {
    const i2 = o$n(n2);
    i2 && e2 === "key-up" && this._keyDownState.delete(i2);
    const o2 = { native: n2, key: i2, repeat: i2 && this._keyDownState.has(i2) };
    i2 && e2 === "key-down" && this._keyDownState.add(o2.key), this._callback(e2, o2);
  }
  _handlePointer(e2, t2) {
    const n2 = this._updateNormalizedPointerLikeEvent(t2, { native: t2, x: 0, y: 0, pointerType: t2.pointerType, button: t2.button, buttons: t2.buttons, eventId: this._eventId++ });
    this._callback(e2, n2);
  }
  _handlePointerPreventDefault(e2, t2) {
    const n2 = this._updateNormalizedPointerLikeEvent(t2, { native: t2, x: 0, y: 0, pointerType: t2.pointerType, button: t2.button, buttons: t2.buttons, eventId: this._eventId++ });
    t2.preventDefault(), this._callback(e2, n2);
  }
  _handleMouseWheel(e2, t2) {
    let n2 = t2.deltaY;
    switch (t2.deltaMode) {
      case 0:
        (o$5 || a$b) && (n2 = n2 / document.documentElement.clientHeight * 600);
        break;
      case 1:
        n2 *= 30;
        break;
      case 2:
        n2 *= 900;
    }
    o$5 || a$b ? n2 *= 0.7 : s$6 || h$4 ? n2 *= 0.6 : r$9 && (n2 *= 1.375);
    const i2 = 100, l2 = Math.abs(n2);
    if (l2 > i2) {
      const e3 = 0.02;
      n2 = n2 / l2 * 200 / (1 + Math.exp(-e3 * (l2 - i2)));
    }
    const u2 = this._updateNormalizedPointerLikeEvent(t2, { native: t2, x: 0, y: 0, deltaY: n2 });
    this._callback(e2, u2);
  }
  _handlePointerCaptureLost(e2, t2) {
    this._activePointerCaptures.delete(t2.pointerId), this._handleDefault(e2, t2);
  }
  _handleDefault(e2, t2) {
    const n2 = { native: t2 };
    t2.preventDefault(), this._callback(e2, n2);
  }
  _preventAltKeyDefault(e2) {
    e2.key === "Alt" && e2.preventDefault();
  }
  _preventMultiTouchPanning(e2) {
    e2.touches.length > 1 && e2.preventDefault();
  }
}
u$6.test = { disableSubpixelCoordinates: false };
const c$c = { "key-down": "keydown", "key-up": "keyup", "pointer-down": "pointerdown", "pointer-up": "pointerup", "pointer-move": "pointermove", "mouse-wheel": "wheel", "pointer-capture-got": "gotpointercapture", "pointer-capture-lost": "lostpointercapture", "context-menu": "contextmenu", "pointer-enter": "pointerenter", "pointer-leave": "pointerleave", "pointer-cancel": "pointercancel", focus: "focus", blur: "blur" };
class e$4 extends i$x {
  constructor() {
    super(true), this.registerIncoming("context-menu", (t2) => {
      t2.data.native.preventDefault();
    });
  }
}
function e$3(t2, e2) {
  return Math.abs(e2.x - t2.x) + Math.abs(e2.y - t2.y);
}
function n$7(t2, e2) {
  const n2 = e2.x - t2.x, r2 = e2.y - t2.y;
  return Math.sqrt(n2 * n2 + r2 * r2);
}
function r$8(e2, n2) {
  if (n2 ? (n2.radius = 0, n2.center.x = 0, n2.center.y = 0) : n2 = { radius: 0, center: c$2b() }, e2.length === 0)
    return n2;
  if (e2.length === 1)
    return n2.center.x = e2[0].x, n2.center.y = e2[0].y, n2;
  if (e2.length === 2) {
    const [t2, r3] = e2, [c3, o3] = [r3.x - t2.x, r3.y - t2.y];
    return n2.radius = Math.sqrt(c3 * c3 + o3 * o3) / 2, n2.center.x = (t2.x + r3.x) / 2, n2.center.y = (t2.y + r3.y) / 2, n2;
  }
  let r2 = 0, c2 = 0;
  for (let t2 = 0; t2 < e2.length; t2++)
    r2 += e2[t2].x, c2 += e2[t2].y;
  r2 /= e2.length, c2 /= e2.length;
  const o2 = e2.map((t2) => t2.x - r2), s2 = e2.map((t2) => t2.y - c2);
  let u2 = 0, i2 = 0, x2 = 0, y2 = 0, a2 = 0, h2 = 0, l2 = 0;
  for (let t2 = 0; t2 < o2.length; t2++) {
    const e3 = o2[t2], n3 = s2[t2], r3 = e3 * e3, c3 = n3 * n3;
    u2 += r3, i2 += c3, x2 += e3 * n3, y2 += r3 * e3, a2 += c3 * n3, h2 += e3 * c3, l2 += n3 * r3;
  }
  const f2 = 0.5 * (y2 + h2), g2 = 0.5 * (a2 + l2), p2 = u2 * i2 - x2 * x2, d2 = (f2 * i2 - g2 * x2) / p2, m2 = (u2 * g2 - x2 * f2) / p2, M2 = c$2b(d2 + r2, m2 + c2);
  return { radius: Math.sqrt(d2 * d2 + m2 * m2 + (u2 + i2) / e2.length), center: M2 };
}
function c$b(t2) {
  const { native: e2 } = t2, { pointerId: n2, button: r2, pointerType: c2 } = e2;
  return c2 === "mouse" ? `${n2}:${r2}` : `${c2}`;
}
const l$8 = { maximumDoubleClickDelay: 250, maximumDoubleClickDistance: 10, maximumDoubleTouchDelay: 350, maximumDoubleTouchDistance: 35 };
class m$7 extends i$x {
  constructor(t2 = l$8.maximumDoubleClickDelay, i2 = l$8.maximumDoubleClickDistance, o2 = l$8.maximumDoubleTouchDelay, n2 = l$8.maximumDoubleTouchDistance, s2 = t$1F) {
    super(false), this._maximumDoubleClickDelay = t2, this._maximumDoubleClickDistance = i2, this._maximumDoubleTouchDelay = o2, this._maximumDoubleTouchDistance = n2, this._clock = s2, this._pointerState = new Map(), this._click = this.registerOutgoing("click"), this._doubleClick = this.registerOutgoing("double-click"), this.registerIncoming("immediate-click", this._handleImmediateClick.bind(this)), this.registerIncoming("pointer-down", this._handlePointerDown.bind(this));
  }
  onUninstall() {
    this._pointerState.forEach((e2) => e2.doubleClickTimer = h$1s(e2.doubleClickTimer));
  }
  get hasPendingInputs() {
    return n$2l(this._pointerState, (e2) => e2.doubleClickTimer != null);
  }
  _clearDoubleClickTimer(e2, t2) {
    const o2 = this._pointerState.get(e2);
    o2 && (o2.doubleClickTimer = h$1s(o2.doubleClickTimer), t2 && this._click.emit(o2.event.data, void 0, o2.event.modifiers), this._pointerState.delete(e2), this.refreshHasPendingInputs());
  }
  _doubleClickTimeoutExceeded(e2) {
    const t2 = this._pointerState.get(e2);
    t2.pointerDownCount === 1 && this._click.emit(t2.event.data, void 0, t2.event.modifiers), t2.doubleClickTimer = null, this._pointerState.delete(e2), this.refreshHasPendingInputs();
  }
  _getPointerId(e2) {
    const { pointerId: t2, pointerType: i2, button: o2 } = e2.native;
    return i2 === "mouse" ? `${t2}:${o2}` : `${i2}`;
  }
  _handleImmediateClick(e2) {
    const t2 = e2.data, { pointerType: i2 } = t2.native, o2 = this._getPointerId(t2);
    if (!this._pointerState.has(o2))
      return void this._startClick(e2);
    const s2 = this._pointerState.get(o2), { data: l2, modifiers: m2 } = s2.event, c2 = i2 === "touch" ? this._maximumDoubleTouchDistance : this._maximumDoubleClickDistance;
    e$3(l2, t2) > c2 ? (this._clearDoubleClickTimer(o2, true), this._startClick(e2)) : (this._clearDoubleClickTimer(o2, false), s2.pointerDownCount === 2 && this._doubleClick.emit(l2, void 0, m2));
  }
  _handlePointerDown(e2) {
    const t2 = c$b(e2.data), i2 = this._pointerState.get(t2);
    i2 && (i2.pointerDownCount += 1);
  }
  _startClick(e2) {
    const { data: t2 } = e2, { native: { pointerType: i2 } } = t2, o2 = c$b(t2), n2 = i2 === "touch" ? this._maximumDoubleTouchDelay : this._maximumDoubleClickDelay, l2 = this._clock.setTimeout(() => this._doubleClickTimeoutExceeded(o2), n2), m2 = 1;
    this._pointerState.set(o2, { event: e2, doubleClickTimer: l2, pointerDownCount: m2 }), this.refreshHasPendingInputs();
  }
}
class p$c extends i$x {
  constructor(e2 = l$8.maximumDoubleClickDelay, a2 = l$8.maximumDoubleClickDistance, r2 = l$8.maximumDoubleTouchDelay, n2 = l$8.maximumDoubleTouchDistance, u2 = t$1F) {
    super(false), this._maximumDoubleClickDelay = e2, this._maximumDoubleClickDistance = a2, this._maximumDoubleTouchDelay = r2, this._maximumDoubleTouchDistance = n2, this._clock = u2, this._doubleTapDragReady = false, this._doubleTapDragActive = false, this._dragStartCenter = c$2b(0, 0), this._pointerState = new Map(), this._doubleTapDrag = this.registerOutgoing("double-tap-drag"), this._dragEventSeparator = new t$6({ start: (t2, e3) => this._dragStart(t2, e3), update: (t2, e3) => this._dragUpdate(e3), end: (t2, e3) => this._dragEnd(e3) }), this.registerIncoming("drag", (t2) => this._dragEventSeparator.handle(t2)), this.registerIncoming("pointer-down", (t2) => this._handlePointerDown(t2)), this.registerIncoming("pointer-up", () => this._handlePointerUp());
  }
  onUninstall() {
    this._pointerState.forEach((t2) => {
      t2.doubleTapTimeout = h$1s(t2.doubleTapTimeout);
    });
  }
  get hasPendingInputs() {
    return n$2l(this._pointerState, (t2) => t2.doubleTapTimeout != null);
  }
  _clearPointerDown(t2) {
    const e2 = this._pointerState.get(t2);
    e2 && (e2.doubleTapTimeout = h$1s(e2.doubleTapTimeout), this._pointerState.delete(t2), this.refreshHasPendingInputs());
  }
  _createDoubleTapDragData(t2, e2, a2) {
    const { button: i2, buttons: o2, pointer: r2, pointers: s2, pointerType: n2, timestamp: u2 } = a2;
    return { action: t2, delta: e2, button: i2, buttons: o2, pointer: r2, pointers: s2, pointerType: n2, timestamp: u2 };
  }
  _dragStart(t2, e2) {
    if (!this._doubleTapDragReady || t2 !== 1)
      return;
    this._doubleTapDragReady = false, this._doubleTapDragActive = true;
    const { data: a2, modifiers: o2 } = e2, { center: r2 } = a2;
    this._dragStartCenter = r2;
    const s2 = this._createDoubleTapDragData("begin", c$2b(0, 0), a2);
    this._doubleTapDrag.emit(s2, void 0, o2), e2.stopPropagation();
  }
  _dragUpdate(t2) {
    if (!this._doubleTapDragActive)
      return;
    const { data: e2, modifiers: a2 } = t2, { center: o2 } = e2, r2 = c$2b(o2.x - this._dragStartCenter.x, o2.y - this._dragStartCenter.y), s2 = this._createDoubleTapDragData("update", r2, e2);
    this._doubleTapDrag.emit(s2, void 0, a2), t2.stopPropagation();
  }
  _dragEnd(t2) {
    if (!this._doubleTapDragActive)
      return;
    const { data: e2, modifiers: a2 } = t2, { center: o2 } = e2, r2 = c$2b(o2.x - this._dragStartCenter.x, o2.y - this._dragStartCenter.y), s2 = this._createDoubleTapDragData("end", r2, e2);
    this._doubleTapDrag.emit(s2, void 0, a2), this._doubleTapDragActive = false, t2.stopPropagation();
  }
  _handlePointerDown(t2) {
    const { data: e2 } = t2, a2 = c$b(e2), i2 = this._pointerState.get(a2), { pointerType: o2 } = e2.native;
    if (i2) {
      const r2 = o2 === "touch" ? this._maximumDoubleTouchDistance : this._maximumDoubleClickDistance;
      this._clearPointerDown(a2), e$3(i2.event.data, e2) > r2 ? this._storePointerDown(t2) : this._doubleTapDragReady = true;
    } else
      this._storePointerDown(t2);
  }
  _handlePointerUp() {
    this._doubleTapDragReady = false;
  }
  _storePointerDown(t2) {
    const { data: e2 } = t2, { pointerType: a2 } = e2.native, i2 = c$b(e2), o2 = a2 === "touch" ? this._maximumDoubleTouchDelay : this._maximumDoubleClickDelay, r2 = this._clock.setTimeout(() => this._clearPointerDown(i2), o2);
    this._pointerState.set(i2, { event: t2, doubleTapTimeout: r2 }), this.refreshHasPendingInputs();
  }
}
class s$5 extends i$x {
  constructor(t2) {
    super(false), this._navigationTouch = t2, this._startStateModifiers = new Set(), this._activePointerMap = new Map(), this._isDragging = false, this._isCurrentDragSuppressed = false, this._drag = this.registerOutgoing("drag"), this.registerIncoming("pointer-drag", this._handlePointerDrag.bind(this)), this.registerIncoming("pointer-up", this._handlePointerUpAndPointerLost.bind(this)), this.registerIncoming("pointer-capture-lost", this._handlePointerUpAndPointerLost.bind(this)), this.registerIncoming("pointer-cancel", this._handlePointerUpAndPointerLost.bind(this));
  }
  _createPayload(t2, e2, i2, n2) {
    return { action: t2, pointerType: this._pointerType, button: this._mouseButton, buttons: e2.buttons, timestamp: n2, pointers: o$4(this._activePointerMap), pointer: e2, angle: i2.angle, radius: i2.radius, center: i2.center };
  }
  _addPointer(t2) {
    const e2 = t2.native.pointerId, i2 = a$a(this._activePointerMap).angle, n2 = { event: t2, initialAngle: 0, lastAngle: 0 };
    this._activePointerMap.set(e2, n2);
    const s2 = h$3(n2, r$7(this._activePointerMap));
    n2.initialAngle = s2, n2.lastAngle = s2, this._updatePointerAngles(i2);
  }
  _updatePointer(t2) {
    if (t2 && t2.x == null && t2.y == null)
      return;
    const e2 = t2.native.pointerId, i2 = this._activePointerMap.get(e2);
    i2 ? i2.event = t2 : this._addPointer(t2);
  }
  _removePointer(t2) {
    const e2 = a$a(this._activePointerMap).angle;
    this._activePointerMap.delete(t2), this._updatePointerAngles(e2);
  }
  _updatePointerAngles(t2) {
    const e2 = a$a(this._activePointerMap);
    this._activePointerMap.forEach((i2) => {
      i2.initialAngle = h$3(i2, e2) - t2, i2.lastAngle = h$3(i2, e2) - t2;
    });
  }
  _emitEvent(t2, e2, i2) {
    const n2 = a$a(this._activePointerMap);
    this._drag.emit(this._createPayload(t2, e2, n2, i2), void 0, this._startStateModifiers);
  }
  _handlePointerUpAndPointerLost(t2) {
    const i2 = t2.data.native.pointerId, n2 = n$2a(t2.timestamp);
    this._activePointerMap.get(i2) && (this._activePointerMap.size === 1 ? (this._updatePointer(t2.data), !this._isCurrentDragSuppressed && this._emitEvent("end", t2.data, n2), this._isDragging = false, this._isCurrentDragSuppressed = false, this._removePointer(i2)) : (this._removePointer(i2), this._emitEvent("removed", t2.data, n$2a(t2.timestamp))));
  }
  _handlePointerDrag(t2) {
    const i2 = t2.data, n2 = i2.currentEvent, s2 = n$2a(t2.timestamp);
    switch (i2.action) {
      case "start":
      case "update":
        this._isDragging ? this._activePointerMap.has(n2.native.pointerId) ? (this._updatePointer(n2), !this._isCurrentDragSuppressed && this._emitEvent("update", n2, s2)) : (this._addPointer(n2), this._emitEvent("added", n2, s2), this._isCurrentDragSuppressed = this._isSuppressed) : (this._updatePointer(n2), this._pointerType = t2.data.startEvent.pointerType, this._mouseButton = t2.data.startEvent.button, this._startStateModifiers = t2.modifiers, this._isDragging = true, this._isCurrentDragSuppressed = this._isSuppressed, !this._isCurrentDragSuppressed && this._emitEvent("start", n2, s2));
    }
  }
  get _isSuppressed() {
    return !!this._navigationTouch && !this._navigationTouch.browserTouchPanEnabled && this._pointerType === "touch" && this._activePointerMap.size === 1;
  }
}
function r$7(e2) {
  const i2 = [];
  return e2.forEach((e3) => {
    i2.push(c$2b(e3.event.x, e3.event.y));
  }), r$8(i2);
}
function a$a(t2) {
  const e2 = r$7(t2);
  let i2 = 0;
  return t2.forEach((t3) => {
    let n2 = h$3(t3, e2), s2 = n2 - t3.lastAngle;
    for (; s2 > Math.PI; )
      s2 -= 2 * Math.PI;
    for (; s2 < -Math.PI; )
      s2 += 2 * Math.PI;
    n2 = t3.lastAngle + s2, t3.lastAngle = n2;
    const r2 = n2 - t3.initialAngle;
    i2 += r2;
  }), i2 /= t2.size || 1, { angle: i2, radius: e2.radius, center: e2.center };
}
function o$4(t2) {
  const e2 = new Map();
  return t2.forEach((t3, i2) => e2.set(i2, t3.event)), e2;
}
function h$3(t2, e2) {
  const i2 = t2.event, n2 = i2.x - e2.center.x, s2 = i2.y - e2.center.y;
  return Math.atan2(s2, n2);
}
var p$b;
!function(t2) {
  t2[t2.Left = 0] = "Left", t2[t2.Middle = 1] = "Middle", t2[t2.Right = 2] = "Right", t2[t2.Back = 3] = "Back", t2[t2.Forward = 4] = "Forward", t2[t2.Undefined = -1] = "Undefined";
}(p$b || (p$b = {}));
class m$6 extends i$x {
  constructor(e2 = l$8.maximumDoubleClickDelay, o2 = l$8.maximumDoubleClickDistance, a2 = l$8.maximumDoubleTouchDelay, m2 = l$8.maximumDoubleTouchDistance, n2 = t$1F) {
    super(false), this._maximumDoubleClickDelay = e2, this._maximumDoubleClickDistance = o2, this._maximumDoubleTouchDelay = a2, this._maximumDoubleTouchDistance = m2, this._clock = n2, this._pointerState = new Map(), this._immediateDoubleClick = this.registerOutgoing("immediate-double-click"), this.registerIncoming("pointer-down", this._handlePointerDown.bind(this)), this.registerIncoming("pointer-up", this._handlePointerUp.bind(this));
  }
  onUninstall() {
    this._pointerState.forEach((t2) => {
      t2.immediateDoubleClick && t2.immediateDoubleClick.timeoutHandle.remove();
    }), super.onUninstall();
  }
  _handlePointerDown(t2) {
    const e2 = t2.data, i2 = c$b(e2);
    if (!this._pointerState.has(i2)) {
      const t3 = { downButton: e2.native.button, immediateDoubleClick: null };
      this._pointerState.set(i2, t3), this.startCapturingPointer(e2.native);
    }
  }
  _handlePointerUp(t2) {
    const e2 = t2.data, i2 = c$b(e2), m2 = this._pointerState.get(i2);
    if (m2 && m2.downButton === e2.native.button) {
      const i3 = m2.immediateDoubleClick;
      if (i3) {
        i3.timeoutHandle.remove();
        const o2 = t2.data.native.pointerType === "touch" ? this._maximumDoubleTouchDistance : this._maximumDoubleClickDistance;
        e$3(i3, t2.data) > o2 ? this._startImmediateDoubleClick(t2, m2) : (this._immediateDoubleClick.emit(t2.data, void 0, i3.modifiers), this._removeState(e2));
      } else
        this._startImmediateDoubleClick(t2, m2);
    }
  }
  _startImmediateDoubleClick(t2, e2) {
    const i2 = t2.data.native.pointerType === "touch" ? this._maximumDoubleTouchDelay : this._maximumDoubleClickDelay;
    e2.immediateDoubleClick = { x: t2.data.x, y: t2.data.y, modifiers: t2.modifiers, timeoutHandle: this._clock.setTimeout(() => this._removeState(t2.data), i2) };
  }
  _removeState(t2) {
    const e2 = c$b(t2);
    this._pointerState.delete(e2), this.stopCapturingPointer(t2.native), this.refreshHasPendingInputs();
  }
}
const o$3 = { maximumClickDelay: 300, movementUntilMouseDrag: 1.5, movementUntilPenDrag: 6, movementUntilTouchDrag: 6, holdDelay: 500 };
class r$6 extends i$x {
  constructor(e2 = o$3.maximumClickDelay, i2 = o$3.movementUntilMouseDrag, n2 = o$3.movementUntilPenDrag, r2 = o$3.movementUntilTouchDrag, s2 = o$3.holdDelay, a2 = t$1F) {
    super(false), this._maximumClickDelay = e2, this._movementUntilMouseDrag = i2, this._movementUntilPenDrag = n2, this._movementUntilTouchDrag = r2, this._holdDelay = s2, this._clock = a2, this._pointerState = new Map(), this._pointerDrag = this.registerOutgoing("pointer-drag"), this._immediateClick = this.registerOutgoing("immediate-click"), this._pointerHold = this.registerOutgoing("hold"), this.registerIncoming("pointer-down", this._handlePointerDown.bind(this)), this.registerIncoming("pointer-up", (t2) => {
      this._handlePointerLoss(t2, "pointer-up");
    }), this.registerIncoming("pointer-capture-lost", (t2) => {
      this._handlePointerLoss(t2, "pointer-capture-lost");
    }), this.registerIncoming("pointer-cancel", (t2) => {
      this._handlePointerLoss(t2, "pointer-cancel");
    }), this._moveHandle = this.registerIncoming("pointer-move", this._handlePointerMove.bind(this)), this._moveHandle.pause();
  }
  onUninstall() {
    this._pointerState.forEach((t2) => {
      t2.holdTimeout = h$1s(t2.holdTimeout);
    }), super.onUninstall();
  }
  _handlePointerDown(t2) {
    const e2 = t2.data, i2 = e2.native.pointerId;
    let n2 = null;
    this._pointerState.size === 0 && (n2 = this._clock.setTimeout(() => {
      const e3 = this._pointerState.get(i2);
      if (e3) {
        if (!e3.isDragging) {
          const i3 = e3.previousEvent;
          this._pointerHold.emit(i3, void 0, t2.modifiers), e3.holdEmitted = true;
        }
        e3.holdTimeout = null;
      }
    }, this._holdDelay));
    const o2 = { startEvent: e2, previousEvent: e2, startTimestamp: t2.timestamp, isDragging: false, downButton: e2.native.button, holdTimeout: n2, modifiers: new Set() };
    this._pointerState.set(i2, o2), this.startCapturingPointer(e2.native), this._moveHandle.resume(), this._pointerState.size > 1 && this._startDragging(t2);
  }
  _createPointerDragData(t2, e2, i2) {
    return { action: t2, startEvent: e2.startEvent, previousEvent: e2.previousEvent, currentEvent: i2 };
  }
  _handlePointerMove(t2) {
    const e2 = t2.data, i2 = e2.native.pointerId, o2 = this._pointerState.get(i2);
    if (o2) {
      if (o2.isDragging)
        this._pointerDrag.emit(this._createPointerDragData("update", o2, e2), void 0, o2.modifiers);
      else {
        n$7(e2, o2.startEvent) > this._getDragThreshold(e2.native.pointerType) && this._startDragging(t2);
      }
      o2.previousEvent = e2;
    }
  }
  _getDragThreshold(t2) {
    switch (t2) {
      case "touch":
        return this._movementUntilTouchDrag;
      case "pen":
        return this._movementUntilPenDrag;
      default:
        return this._movementUntilMouseDrag;
    }
  }
  _startDragging(t2) {
    const e2 = t2.data, i2 = e2.native.pointerId;
    this._pointerState.forEach((n2) => {
      n2.holdTimeout != null && (n2.holdTimeout.remove(), n2.holdTimeout = null), n2.isDragging || (n2.modifiers = t2.modifiers, n2.isDragging = true, i2 === n2.startEvent.native.pointerId ? this._pointerDrag.emit(this._createPointerDragData("start", n2, e2)) : this._pointerDrag.emit(this._createPointerDragData("start", n2, n2.previousEvent), t2.timestamp));
    });
  }
  _handlePointerLoss(t2, e2) {
    const i2 = t2.data, n2 = i2.native.pointerId, o2 = this._pointerState.get(n2);
    if (o2) {
      if (o2.holdTimeout != null && (o2.holdTimeout.remove(), o2.holdTimeout = null), o2.isDragging)
        this._pointerDrag.emit(this._createPointerDragData("end", o2, e2 === "pointer-up" ? i2 : o2.previousEvent), void 0, o2.modifiers);
      else if (e2 === "pointer-up" && o2.downButton === i2.native.button) {
        t2.timestamp - o2.startTimestamp <= this._maximumClickDelay && !o2.holdEmitted && this._immediateClick.emit(i2);
      }
      this._pointerState.delete(n2), this.stopCapturingPointer(i2.native), this._pointerState.size === 0 && this._moveHandle.pause();
    }
  }
}
const z = { counter: "Ctrl", pan: { left: "ArrowLeft", right: "ArrowRight", up: "ArrowUp", down: "ArrowDown" }, zoom: { zoomIn: ["=", "+"], zoomOut: ["-", "_"] }, rotate: { clockwiseOption1: "a", clockwiseOption2: "A", counterClockwiseOption1: "d", counterClockwiseOption2: "D", resetOption1: "n", resetOption2: "N" } };
let k$1 = class extends m$1L {
  constructor() {
    super(...arguments), this._handles = new t$1N();
  }
  initialize() {
    const e2 = () => {
      var _a2;
      return (_a2 = this.view) == null ? void 0 : _a2.ready;
    };
    this._handles.add([f$10(() => !e2(), () => this._disconnect()), f$10(e2, () => this._connect())]);
  }
  destroy() {
    this._handles && (this._handles.removeAll(), this._handles = null), this._disconnect();
  }
  get latestPointerType() {
    var _a2;
    return (_a2 = this._inputManager) == null ? void 0 : _a2.latestPointerType;
  }
  get latestPointerLocation() {
    var _a2;
    return (_a2 = this._inputManager) == null ? void 0 : _a2.latestPointerLocation;
  }
  get multiTouchActive() {
    var _a2, _b2;
    return (_b2 = (_a2 = this._inputManager) == null ? void 0 : _a2.multiTouchActive) != null ? _b2 : false;
  }
  _disconnect() {
    this.view.viewEvents.disconnect(), this._inputManager = s$26(this._inputManager);
  }
  _connect() {
    const e2 = this.view.surface, t2 = new u$6(e2, this.view.input), o2 = [new m$6(), new r$6(), new m$7(), new s$5(this.view.navigation), new p$c()], r2 = new u$m({ eventSource: t2, recognizers: o2 });
    r2.installHandlers("prevent-context-menu", [new e$4()], P$5.INTERNAL), r2.installHandlers("navigation", [new a$d(this.view), new d$6(this.view), new o$6(this.view), new a$f(this.view), new a$f(this.view, [z.counter]), new n$a(this.view, "primary"), new i$8(this.view, z.pan), new e$6(this.view, z.zoom), new i$7(this.view, z.rotate), new o$7(this.view, "secondary"), new e$7(this.view, "touch")], P$5.INTERNAL), this.view.viewEvents.connect(r2), this._source = t2, this._inputManager = r2, l$1f(() => {
      var _a2, _b2;
      return (_b2 = (_a2 = this.view) == null ? void 0 : _a2.navigation) == null ? void 0 : _b2.browserTouchPanEnabled;
    }, (e3) => {
      this._source && (this._source.browserTouchPanningEnabled = !e3);
    }, h$S);
  }
  get test() {
    return { inputManager: this._inputManager };
  }
};
e$1W([y$1o()], k$1.prototype, "view", void 0), e$1W([y$1o()], k$1.prototype, "latestPointerType", null), e$1W([y$1o()], k$1.prototype, "latestPointerLocation", null), e$1W([y$1o()], k$1.prototype, "multiTouchActive", null), k$1 = e$1W([n$2f("esri.views.2d.input.MapViewInputManager")], k$1);
const C$1 = k$1;
var t$2, o$2, r$5, n$6 = { exports: {} };
t$2 = n$6, o$2 = function() {
  function t2(t3, r3, a2, f2, e2) {
    o2(t3, r3, a2 || 0, f2 || t3.length - 1, e2 || n2);
  }
  function o2(t3, n3, a2, f2, e2) {
    for (; f2 > a2; ) {
      if (f2 - a2 > 600) {
        var h2 = f2 - a2 + 1, i2 = n3 - a2 + 1, u2 = Math.log(h2), M2 = 0.5 * Math.exp(2 * u2 / 3), c2 = 0.5 * Math.sqrt(u2 * M2 * (h2 - M2) / h2) * (i2 - h2 / 2 < 0 ? -1 : 1);
        o2(t3, n3, Math.max(a2, Math.floor(n3 - i2 * M2 / h2 + c2)), Math.min(f2, Math.floor(n3 + (h2 - i2) * M2 / h2 + c2)), e2);
      }
      var s2 = t3[n3], x2 = a2, p2 = f2;
      for (r2(t3, a2, n3), e2(t3[f2], s2) > 0 && r2(t3, a2, f2); x2 < p2; ) {
        for (r2(t3, x2, p2), x2++, p2--; e2(t3[x2], s2) < 0; )
          x2++;
        for (; e2(t3[p2], s2) > 0; )
          p2--;
      }
      e2(t3[a2], s2) === 0 ? r2(t3, a2, p2) : r2(t3, ++p2, f2), p2 <= n3 && (a2 = p2 + 1), n3 <= p2 && (f2 = p2 - 1);
    }
  }
  function r2(t3, o3, r3) {
    var n3 = t3[o3];
    t3[o3] = t3[r3], t3[r3] = n3;
  }
  function n2(t3, o3) {
    return t3 < o3 ? -1 : t3 > o3 ? 1 : 0;
  }
  return t2;
}, (r$5 = o$2()) !== void 0 && (t$2.exports = r$5);
const a$9 = n$6.exports;
function i$6(t2, n2) {
  if (!(this instanceof i$6))
    return new i$6(t2, n2);
  this._maxEntries = Math.max(4, t2 || 9), this._minEntries = Math.max(2, Math.ceil(0.4 * this._maxEntries)), n2 && (typeof n2 == "function" ? this.toBBox = n2 : this._initFormat(n2)), this.clear();
}
function n$5(t2, i2, n2) {
  if (!n2)
    return i2.indexOf(t2);
  for (var h2 = 0; h2 < i2.length; h2++)
    if (n2(t2, i2[h2]))
      return h2;
  return -1;
}
function h$2(t2, i2) {
  a$8(t2, 0, t2.children.length, i2, t2);
}
function a$8(t2, i2, n2, h2, a2) {
  a2 || (a2 = x$1(null)), a2.minX = 1 / 0, a2.minY = 1 / 0, a2.maxX = -1 / 0, a2.maxY = -1 / 0;
  for (var e2, o2 = i2; o2 < n2; o2++)
    e2 = t2.children[o2], r$4(a2, t2.leaf ? h2(e2) : e2);
  return a2;
}
function r$4(t2, i2) {
  return t2.minX = Math.min(t2.minX, i2.minX), t2.minY = Math.min(t2.minY, i2.minY), t2.maxX = Math.max(t2.maxX, i2.maxX), t2.maxY = Math.max(t2.maxY, i2.maxY), t2;
}
function e$2(t2, i2) {
  return t2.minX - i2.minX;
}
function o$1(t2, i2) {
  return t2.minY - i2.minY;
}
function s$4(t2) {
  return (t2.maxX - t2.minX) * (t2.maxY - t2.minY);
}
function l$7(t2) {
  return t2.maxX - t2.minX + (t2.maxY - t2.minY);
}
function m$5(t2, i2) {
  return (Math.max(i2.maxX, t2.maxX) - Math.min(i2.minX, t2.minX)) * (Math.max(i2.maxY, t2.maxY) - Math.min(i2.minY, t2.minY));
}
function c$a(t2, i2) {
  var n2 = Math.max(t2.minX, i2.minX), h2 = Math.max(t2.minY, i2.minY), a2 = Math.min(t2.maxX, i2.maxX), r2 = Math.min(t2.maxY, i2.maxY);
  return Math.max(0, a2 - n2) * Math.max(0, r2 - h2);
}
function u$5(t2, i2) {
  return t2.minX <= i2.minX && t2.minY <= i2.minY && i2.maxX <= t2.maxX && i2.maxY <= t2.maxY;
}
function f$4(t2, i2) {
  return i2.minX <= t2.maxX && i2.minY <= t2.maxY && i2.maxX >= t2.minX && i2.maxY >= t2.minY;
}
function x$1(t2) {
  return { children: t2, height: 1, leaf: true, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
}
function d$5(i2, n2, h2, a2, r2) {
  for (var e2, o2 = [n2, h2]; o2.length; )
    (h2 = o2.pop()) - (n2 = o2.pop()) <= a2 || (e2 = n2 + Math.ceil((h2 - n2) / a2 / 2) * a2, a$9(i2, e2, n2, h2, r2), o2.push(n2, e2, e2, h2));
}
i$6.prototype = { all: function() {
  return this._all(this.data, []);
}, search: function(t2) {
  var i2 = this.data, n2 = [], h2 = this.toBBox;
  if (!f$4(t2, i2))
    return n2;
  for (var a2, r2, e2, o2, s2 = []; i2; ) {
    for (a2 = 0, r2 = i2.children.length; a2 < r2; a2++)
      e2 = i2.children[a2], f$4(t2, o2 = i2.leaf ? h2(e2) : e2) && (i2.leaf ? n2.push(e2) : u$5(t2, o2) ? this._all(e2, n2) : s2.push(e2));
    i2 = s2.pop();
  }
  return n2;
}, collides: function(t2) {
  var i2 = this.data, n2 = this.toBBox;
  if (!f$4(t2, i2))
    return false;
  for (var h2, a2, r2, e2, o2 = []; i2; ) {
    for (h2 = 0, a2 = i2.children.length; h2 < a2; h2++)
      if (r2 = i2.children[h2], f$4(t2, e2 = i2.leaf ? n2(r2) : r2)) {
        if (i2.leaf || u$5(t2, e2))
          return true;
        o2.push(r2);
      }
    i2 = o2.pop();
  }
  return false;
}, load: function(t2) {
  if (!t2 || !t2.length)
    return this;
  if (t2.length < this._minEntries) {
    for (var i2 = 0, n2 = t2.length; i2 < n2; i2++)
      this.insert(t2[i2]);
    return this;
  }
  var h2 = this._build(t2.slice(), 0, t2.length - 1, 0);
  if (this.data.children.length)
    if (this.data.height === h2.height)
      this._splitRoot(this.data, h2);
    else {
      if (this.data.height < h2.height) {
        var a2 = this.data;
        this.data = h2, h2 = a2;
      }
      this._insert(h2, this.data.height - h2.height - 1, true);
    }
  else
    this.data = h2;
  return this;
}, insert: function(t2) {
  return t2 && this._insert(t2, this.data.height - 1), this;
}, clear: function() {
  return this.data = x$1([]), this;
}, remove: function(t2, i2) {
  if (!t2)
    return this;
  for (var h2, a2, r2, e2, o2 = this.data, s2 = this.toBBox(t2), l2 = [], m2 = []; o2 || l2.length; ) {
    if (o2 || (o2 = l2.pop(), a2 = l2[l2.length - 1], h2 = m2.pop(), e2 = true), o2.leaf && (r2 = n$5(t2, o2.children, i2)) !== -1)
      return o2.children.splice(r2, 1), l2.push(o2), this._condense(l2), this;
    e2 || o2.leaf || !u$5(o2, s2) ? a2 ? (h2++, o2 = a2.children[h2], e2 = false) : o2 = null : (l2.push(o2), m2.push(h2), h2 = 0, a2 = o2, o2 = o2.children[0]);
  }
  return this;
}, toBBox: function(t2) {
  return t2;
}, compareMinX: e$2, compareMinY: o$1, toJSON: function() {
  return this.data;
}, fromJSON: function(t2) {
  return this.data = t2, this;
}, _all: function(t2, i2) {
  for (var n2 = []; t2; )
    t2.leaf ? i2.push.apply(i2, t2.children) : n2.push.apply(n2, t2.children), t2 = n2.pop();
  return i2;
}, _build: function(t2, i2, n2, a2) {
  var r2, e2 = n2 - i2 + 1, o2 = this._maxEntries;
  if (e2 <= o2)
    return h$2(r2 = x$1(t2.slice(i2, n2 + 1)), this.toBBox), r2;
  a2 || (a2 = Math.ceil(Math.log(e2) / Math.log(o2)), o2 = Math.ceil(e2 / Math.pow(o2, a2 - 1))), (r2 = x$1([])).leaf = false, r2.height = a2;
  var s2, l2, m2, c2, u2 = Math.ceil(e2 / o2), f2 = u2 * Math.ceil(Math.sqrt(o2));
  for (d$5(t2, i2, n2, f2, this.compareMinX), s2 = i2; s2 <= n2; s2 += f2)
    for (d$5(t2, s2, m2 = Math.min(s2 + f2 - 1, n2), u2, this.compareMinY), l2 = s2; l2 <= m2; l2 += u2)
      c2 = Math.min(l2 + u2 - 1, m2), r2.children.push(this._build(t2, l2, c2, a2 - 1));
  return h$2(r2, this.toBBox), r2;
}, _chooseSubtree: function(t2, i2, n2, h2) {
  for (var a2, r2, e2, o2, l2, c2, u2, f2; h2.push(i2), !i2.leaf && h2.length - 1 !== n2; ) {
    for (u2 = f2 = 1 / 0, a2 = 0, r2 = i2.children.length; a2 < r2; a2++)
      l2 = s$4(e2 = i2.children[a2]), (c2 = m$5(t2, e2) - l2) < f2 ? (f2 = c2, u2 = l2 < u2 ? l2 : u2, o2 = e2) : c2 === f2 && l2 < u2 && (u2 = l2, o2 = e2);
    i2 = o2 || i2.children[0];
  }
  return i2;
}, _insert: function(t2, i2, n2) {
  var h2 = this.toBBox, a2 = n2 ? t2 : h2(t2), e2 = [], o2 = this._chooseSubtree(a2, this.data, i2, e2);
  for (o2.children.push(t2), r$4(o2, a2); i2 >= 0 && e2[i2].children.length > this._maxEntries; )
    this._split(e2, i2), i2--;
  this._adjustParentBBoxes(a2, e2, i2);
}, _split: function(t2, i2) {
  var n2 = t2[i2], a2 = n2.children.length, r2 = this._minEntries;
  this._chooseSplitAxis(n2, r2, a2);
  var e2 = this._chooseSplitIndex(n2, r2, a2), o2 = x$1(n2.children.splice(e2, n2.children.length - e2));
  o2.height = n2.height, o2.leaf = n2.leaf, h$2(n2, this.toBBox), h$2(o2, this.toBBox), i2 ? t2[i2 - 1].children.push(o2) : this._splitRoot(n2, o2);
}, _splitRoot: function(t2, i2) {
  this.data = x$1([t2, i2]), this.data.height = t2.height + 1, this.data.leaf = false, h$2(this.data, this.toBBox);
}, _chooseSplitIndex: function(t2, i2, n2) {
  var h2, r2, e2, o2, l2, m2, u2, f2;
  for (m2 = u2 = 1 / 0, h2 = i2; h2 <= n2 - i2; h2++)
    o2 = c$a(r2 = a$8(t2, 0, h2, this.toBBox), e2 = a$8(t2, h2, n2, this.toBBox)), l2 = s$4(r2) + s$4(e2), o2 < m2 ? (m2 = o2, f2 = h2, u2 = l2 < u2 ? l2 : u2) : o2 === m2 && l2 < u2 && (u2 = l2, f2 = h2);
  return f2;
}, _chooseSplitAxis: function(t2, i2, n2) {
  var h2 = t2.leaf ? this.compareMinX : e$2, a2 = t2.leaf ? this.compareMinY : o$1;
  this._allDistMargin(t2, i2, n2, h2) < this._allDistMargin(t2, i2, n2, a2) && t2.children.sort(h2);
}, _allDistMargin: function(t2, i2, n2, h2) {
  t2.children.sort(h2);
  var e2, o2, s2 = this.toBBox, m2 = a$8(t2, 0, i2, s2), c2 = a$8(t2, n2 - i2, n2, s2), u2 = l$7(m2) + l$7(c2);
  for (e2 = i2; e2 < n2 - i2; e2++)
    o2 = t2.children[e2], r$4(m2, t2.leaf ? s2(o2) : o2), u2 += l$7(m2);
  for (e2 = n2 - i2 - 1; e2 >= i2; e2--)
    o2 = t2.children[e2], r$4(c2, t2.leaf ? s2(o2) : o2), u2 += l$7(c2);
  return u2;
}, _adjustParentBBoxes: function(t2, i2, n2) {
  for (var h2 = n2; h2 >= 0; h2--)
    r$4(i2[h2], t2);
}, _condense: function(t2) {
  for (var i2, n2 = t2.length - 1; n2 >= 0; n2--)
    t2[n2].children.length === 0 ? n2 > 0 ? (i2 = t2[n2 - 1].children).splice(i2.indexOf(t2[n2]), 1) : this.clear() : h$2(t2[n2], this.toBBox);
}, _initFormat: function(t2) {
  var i2 = ["return a", " - b", ";"];
  this.compareMinX = new Function("a", "b", i2.join(t2[0])), this.compareMinY = new Function("a", "b", i2.join(t2[1])), this.toBBox = new Function("a", "return {minX: a" + t2[0] + ", minY: a" + t2[1] + ", maxX: a" + t2[2] + ", maxY: a" + t2[3] + "};");
} };
class n$4 {
  constructor(t2, e2) {
    this.key = new e$9(0, 0, 0, 0), this.bounds = u$1p(), this.objectIds = new Set(), this.key.set(e2);
    const s2 = t2.getLODInfoAt(this.key);
    this.tileInfoView = t2, this.tileInfoView.getTileBounds(this.bounds, this.key, true), this.resolution = s2.resolution, this.scale = s2.scale, this.level = s2.level;
  }
  get id() {
    return this.key.id;
  }
  get extent() {
    return w$J.fromBounds(this.bounds, this.tileInfoView.tileInfo.spatialReference);
  }
  get transform() {
    return { originPosition: "upperLeft", scale: [this.resolution, this.resolution], translate: [this.bounds[0], this.bounds[3]] };
  }
  createChildTiles() {
    const e2 = this.key.getChildKeys(), i2 = t$1J.acquire();
    for (let t2 = 0; t2 < e2.length; t2++)
      i2[t2] = new n$4(this.tileInfoView, e2[t2]);
    return i2;
  }
  getQuantizationParameters() {
    return a$1h.fromJSON({ mode: "view", originPosition: "upperLeft", tolerance: this.resolution, extent: { xmin: this.bounds[0], ymin: this.bounds[1], xmax: this.bounds[2], ymax: this.bounds[3], spatialReference: this.tileInfoView.tileInfo.spatialReference } });
  }
}
const h$1 = { added: [], removed: [] }, n$3 = new Set(), r$3 = new e$9(0, 0, 0, 0);
class d$4 extends n$26 {
  constructor(e2) {
    super(), this._tiles = new Map(), this._index = i$6(9, has("esri-csp-restrictions") ? (e3) => ({ minX: e3.bounds[0], minY: e3.bounds[1], maxX: e3.bounds[2], maxY: e3.bounds[3] }) : [".bounds[0]", ".bounds[1]", ".bounds[2]", ".bounds[3]"]), this.tiles = [], this.tileScheme = e2;
  }
  destroy() {
    this.clear();
  }
  clear() {
    this.tiles.length = 0, this._tiles.clear(), this._index.clear();
  }
  has(e2) {
    return this._tiles.has(e2);
  }
  get(e2) {
    return this._tiles.get(e2);
  }
  boundsIntersections(e2) {
    return this._index.search({ minX: e2[0], minY: e2[1], maxX: e2[2], maxY: e2[3] });
  }
  updateTiles(e2) {
    const t2 = { added: [], removed: [] };
    for (const i2 of e2.added)
      if (!this.has(i2)) {
        const e3 = new n$4(this.tileScheme, i2);
        this._tiles.set(i2, e3), this._index.insert(e3), t2.added.push(e3);
      }
    for (const s2 of e2.removed)
      if (this.has(s2)) {
        const e3 = this.get(s2);
        this._tiles.delete(s2), this._index.remove(e3), t2.removed.push(e3);
      }
    this.tiles.length = 0, this._tiles.forEach((e3) => this.tiles.push(e3)), (t2.added.length || t2.removed.length) && this.emit("update", t2);
  }
  setViewState(e2) {
    const t2 = this.tileScheme.getTileCoverage(e2, 0);
    if (!t2)
      return;
    const { spans: o2, lodInfo: d2 } = t2, { level: l2 } = d2;
    if (o2.length > 0)
      for (const { row: i2, colFrom: a2, colTo: m2 } of o2)
        for (let e3 = a2; e3 <= m2; e3++) {
          const t3 = r$3.set(l2, i2, d2.normalizeCol(e3), d2.getWorldForColumn(e3)).id;
          if (n$3.add(t3), !this.has(t3)) {
            const e4 = new n$4(this.tileScheme, t3);
            this._tiles.set(t3, e4), this._index.insert(e4), this.tiles.push(e4), h$1.added.push(e4);
          }
        }
    for (let s2 = this.tiles.length - 1; s2 >= 0; s2--) {
      const e3 = this.tiles[s2];
      n$3.has(e3.id) || (this._tiles.delete(e3.id), this.tiles.splice(s2, 1), this._index.remove(e3), h$1.removed.push(e3));
    }
    (h$1.added.length || h$1.removed.length) && this.emit("update", h$1), l$b.pool.release(t2), n$3.clear(), h$1.added.length = 0, h$1.removed.length = 0;
  }
}
let p$a = 0, i$5 = class extends m$1L {
  constructor() {
    super(...arguments), this.color = new l$1D([0, 255, 255]), this.haloOpacity = 1, this.fillOpacity = 0.25;
  }
  get version() {
    return p$a++;
  }
};
e$1W([y$1o({ readOnly: true })], i$5.prototype, "version", null), e$1W([y$1o({ type: l$1D })], i$5.prototype, "color", void 0), e$1W([y$1o({ type: l$1D })], i$5.prototype, "haloColor", void 0), e$1W([y$1o()], i$5.prototype, "haloOpacity", void 0), e$1W([y$1o()], i$5.prototype, "fillOpacity", void 0), i$5 = e$1W([n$2f("esri.views.2d.support.HighlightOptions")], i$5);
const c$9 = i$5;
const s$3 = (s2) => s2.includes("Brush");
class e$1 {
  constructor() {
    this._names = new Map();
  }
  begin(e2) {
    this._names.has(e2) || (this._names.set(e2, false), s$3(e2) && this.record("Esri.FirstDraw"), performance.mark(`Esri.${e2}.Start`));
  }
  end(s2) {
    this._names.has(s2) && !this._names.get(s2) && (this._names.set(s2, true), performance.mark(`Esri.${s2}.End`));
  }
  record(s2) {
    this._names.has(s2) || (this._names.set(s2, true), performance.mark(`Esri.${s2}`));
  }
}
function t$1(t2, h2, i2, e2, d2, l2, n2, o2) {
  let u2;
  t2.ignorePadding && (e2 = { left: 0, right: 0, top: 0, bottom: 0 }), t2.width != null && t2.height != null ? u2 = [t2.width, t2.height] : t2.width == null && t2.height != null ? u2 = [t2.height, t2.height] : t2.width != null && t2.height == null ? u2 = [t2.width, t2.width] : t2.width == null && t2.height == null && (u2 = null);
  const r2 = i2[0] - (e2.left + e2.right), a2 = i2[1] - (e2.top + e2.bottom);
  let g2, w2, c2 = t2.area || { x: 0, y: 0, width: r2, height: a2 };
  if (u2) {
    const t3 = r2 / a2, h3 = u2[0] / u2[1];
    if (h3 > t3) {
      const t4 = c2.width / h3;
      c2 = { x: c2.x, y: Math.round(c2.y + (c2.height - t4) / 2), width: c2.width, height: Math.round(t4) };
    } else {
      const t4 = c2.height * h3;
      c2 = { x: Math.round(c2.x + (c2.width - t4) / 2), y: c2.y, width: Math.round(t4), height: c2.height };
    }
  } else
    u2 = [c2.width, c2.height];
  u2[0] > c2.width ? (g2 = Math.min(u2[0] / c2.width, h2), w2 = u2[0] / c2.width / g2) : (g2 = 1, w2 = u2[0] / c2.width);
  return { resolutionScale: g2, cropArea: { x: Math.round((c2.x + e2.left) * g2), y: Math.round((c2.y + e2.top) * g2), width: Math.round(c2.width * g2), height: Math.round(c2.height * g2) }, outputScale: w2, format: d2, quality: l2, children: n2, rotation: o2 };
}
function r$2(t2, h2, i2) {
  const { ctx: e2, canvas: o2 } = g$3(t2, i2), n2 = e2.getImageData(0, 0, t2.width, t2.height), a2 = c$8(o2, h2);
  return f$3(o2), { dataUrl: a2, data: n2 };
}
function l$6(t2, h2) {
  const { ctx: i2, canvas: e2 } = g$3(t2, h2), o2 = i2.getImageData(0, 0, t2.width, t2.height);
  return f$3(e2), o2;
}
function g$3(t2, h2) {
  const i2 = d$3();
  h2.premultipliedAlpha && v$1(t2), i2.width = t2.width, i2.height = t2.height;
  const e2 = i2.getContext("2d");
  return e2.putImageData(t2, 0, 0), h2.flipY && q(e2), { ctx: e2, canvas: i2 };
}
function f$3(t2) {
  t2.width = 0, t2.height = 0;
}
function d$3() {
  return t$1W(u$4) && (u$4 = document.createElement("canvas")), u$4;
}
let u$4 = null;
function c$8(t2, h2) {
  const i2 = I[h2.format], e2 = h2.quality / 100;
  return t2.toDataURL(i2, e2);
}
function s$2(h2, i2) {
  const e2 = D(h2), o2 = B[e2];
  return { format: e2, quality: a$21(i2 != null ? i2 : o2, 0, 100) };
}
function w(t2, h2) {
  return h2 / Math.max(t2[0], t2[1]);
}
function m$4(t2, h2, i2, e2 = 0, o2 = 0, n2 = t2.width - e2, a2 = t2.height - o2, r2 = false) {
  const { data: l2 } = t2, { width: g2, height: f2, data: d2 } = h2, u2 = n2 / g2, c2 = a2 / f2, s2 = Math.ceil(u2 / 2), w2 = Math.ceil(c2 / 2), m2 = t2.width;
  for (let M2 = 0; M2 < f2; M2++)
    for (let t3 = 0; t3 < g2; t3++) {
      const h3 = 4 * (t3 + (r2 ? f2 - M2 - 1 : M2) * g2);
      let n3 = 0, a3 = 0, p2 = 0, y2 = 0, x2 = 0, b2 = 0;
      const j2 = (M2 + 0.5) * c2;
      for (let r3 = Math.floor(M2 * c2); r3 < (M2 + 1) * c2; r3++) {
        const h4 = Math.abs(j2 - (r3 + 0.5)) / w2, g3 = (t3 + 0.5) * u2, f3 = h4 * h4;
        for (let d3 = Math.floor(t3 * u2); d3 < (t3 + 1) * u2; d3++) {
          const t4 = Math.abs(g3 - (d3 + 0.5)) / s2, h5 = Math.sqrt(f3 + t4 * t4);
          if (h5 >= 1)
            continue;
          let u3 = 2 * h5 * h5 * h5 - 3 * h5 * h5 + 1;
          const c3 = 4 * (e2 + d3 + (o2 + r3) * m2);
          b2 += u3 * l2[c3 + 3], a3 += u3, !i2 && l2[c3 + 3] < 255 && (u3 = u3 * l2[c3 + 3] / 255), p2 += u3 * l2[c3], y2 += u3 * l2[c3 + 1], x2 += u3 * l2[c3 + 2], n3 += u3;
        }
      }
      d2[h3] = p2 / n3, d2[h3 + 1] = y2 / n3, d2[h3 + 2] = x2 / n3, d2[h3 + 3] = b2 / a3;
    }
  return h2;
}
function D(t2) {
  switch (t2) {
    case "png":
    case "jpg":
    case "jpeg":
      return t2;
    default:
      return k;
  }
}
function q(t2) {
  t2.save(), t2.globalCompositeOperation = "copy", t2.scale(1, -1), t2.translate(0, -t2.canvas.height), t2.drawImage(t2.canvas, 0, 0), t2.restore();
}
function v$1(t2) {
  const h2 = t2.data, i2 = h2.length;
  for (let e2 = 0; e2 < i2; e2 += 4) {
    const t3 = h2[e2 + 3];
    if (t3 !== 255 && t3 > 0) {
      const i3 = 255 / t3;
      h2[e2 + 0] = h2[e2 + 0] * i3, h2[e2 + 1] = h2[e2 + 1] * i3, h2[e2 + 2] = h2[e2 + 2] * i3;
    }
  }
}
const I = { png: "image/png", jpg: "image/jpeg", jpeg: "image/jpeg" }, P = 98, k = "png", B = { png: 100, jpg: P, jpeg: P };
var r$1;
function o(t2, r2, o2 = {}) {
  const l2 = n$2(t2);
  for (; l2.length > 1; ) {
    const t3 = c$7(r2, l2.shift(), o2);
    if (r$1t(t3))
      return t3;
  }
  return i$4(r2, l2.shift(), o2);
}
function n$2(e2) {
  const t2 = has("esri-force-webgl");
  if (t2 === r$1.WEBGL1 || t2 === r$1.WEBGL2)
    return [t2];
  switch (e2) {
    case "2d":
      return has("mac") && has("chrome") ? [r$1.WEBGL1, r$1.WEBGL2] : [r$1.WEBGL2, r$1.WEBGL1];
    case "3d":
      return [r$1.WEBGL2, r$1.WEBGL1];
  }
}
function i$4(e2, r2, o2 = {}) {
  if (!window.WebGLRenderingContext)
    return l$5(e2, a$7), null;
  const n2 = c$7(e2, r2, o2);
  return t$1W(n2) && l$5(e2, s$1), n2;
}
function c$7(e2, t2, o2 = {}) {
  const n2 = t2 === r$1.WEBGL1 ? ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"] : ["webgl2"];
  let i2 = null;
  for (const r2 of n2) {
    try {
      i2 = e2.getContext(r2, o2);
    } catch (c2) {
    }
    if (i2)
      break;
  }
  return i2;
}
function l$5(e2, t2) {
  const r2 = e2.parentNode;
  r2 && (r2.innerHTML = '<table style="background-color: #8CE; width: 100%; height: 100%;"><tr><td align="center"><div style="display: table-cell; vertical-align: middle;"><div style="">' + t2 + "</div></div></td></tr></table>");
}
!function(e2) {
  e2[e2.WEBGL1 = 1] = "WEBGL1", e2[e2.WEBGL2 = 2] = "WEBGL2";
}(r$1 || (r$1 = {}));
const a$7 = 'This page requires a browser that supports WebGL.<br/><a href="http://get.webgl.org">Click here to upgrade your browser.</a>', s$1 = `It doesn't appear your computer can support WebGL.<br/><a href="http://get.webgl.org/troubleshooting/">Click here for more information.</a>`;
let n$1, a$6;
function l$4(t2) {
  const e2 = n$2(t2);
  for (; e2.length > 1; ) {
    const t3 = u$3(e2.shift());
    if (t3.available)
      return t3;
  }
  return u$3(e2.shift());
}
function u$3(t2) {
  switch (t2) {
    case r$1.WEBGL1:
      return i$3();
    case r$1.WEBGL2:
      return f$2();
  }
}
function i$3() {
  return n$1 || (n$1 = d$2()), n$1;
}
function f$2() {
  return a$6 || (a$6 = x()), a$6;
}
class p$9 {
  constructor() {
    this.available = false, this.majorPerformanceCaveat = false, this.maxTextureSize = 0, this.supportsVertexShaderSamplers = false, this.supportsHighPrecisionFragment = false, this.supportsElementIndexUint = false, this.supportsStandardDerivatives = false, this.supportsInstancedArrays = false, this.supportsTextureFloat = false, this.supportsTextureHalfFloat = false, this.supportsColorBufferFloat = false, this.supportsColorBufferFloatBlend = false, this.supportsColorBufferHalfFloat = false;
  }
}
class c$6 extends p$9 {
  constructor() {
    super(...arguments), this.type = r$1.WEBGL1;
  }
}
class E extends p$9 {
  constructor() {
    super(...arguments), this.type = r$1.WEBGL2, this.supportsElementIndexUint = true, this.supportsStandardDerivatives = true, this.supportsInstancedArrays = true, this.supportsTextureFloat = true, this.supportsTextureHalfFloat = true;
  }
}
function _$2(r2, n2) {
  var _a2;
  if (r2 === r$1.WEBGL1 && typeof WebGLRenderingContext == "undefined" || r2 === r$1.WEBGL2 && typeof WebGL2RenderingContext == "undefined")
    return null;
  const a2 = document.createElement("canvas");
  if (!a2)
    return null;
  let l2 = c$7(a2, r2, { failIfMajorPerformanceCaveat: true });
  if (t$1W(l2) && (l2 = c$7(a2, r2), r$1t(l2) && (n2.majorPerformanceCaveat = true)), t$1W(l2))
    return l2;
  if (r2 === r$1.WEBGL1) {
    const t2 = (_a2 = l2.getParameter(l2.VERSION)) == null ? void 0 : _a2.match(/^WebGL\s+([\d.]*)/);
    if (t2) {
      const e2 = parseFloat(t2[1]);
      n2.available = e2 >= 0.94;
    }
  } else
    n2.available = true;
  n2.maxTextureSize = l2.getParameter(l2.MAX_TEXTURE_SIZE), n2.supportsVertexShaderSamplers = l2.getParameter(l2.MAX_VERTEX_TEXTURE_IMAGE_UNITS) > 0;
  const u2 = l2.getShaderPrecisionFormat(l2.FRAGMENT_SHADER, l2.HIGH_FLOAT);
  return u2 && (n2.supportsHighPrecisionFragment = u2.precision > 0), l2;
}
function d$2() {
  const e2 = new c$6(), r2 = _$2(r$1.WEBGL1, e2);
  return t$1W(r2) || (e2.supportsElementIndexUint = r2.getExtension("OES_element_index_uint") !== null, e2.supportsStandardDerivatives = r2.getExtension("OES_standard_derivatives") !== null, e2.supportsInstancedArrays = r2.getExtension("ANGLE_instanced_arrays") !== null, e2.supportsTextureFloat = r2.getExtension("OES_texture_float") !== null, e2.supportsTextureHalfFloat = r2.getExtension("OES_texture_half_float") !== null, e2.supportsColorBufferFloat = r2.getExtension("WEBGL_color_buffer_float") !== null, e2.supportsColorBufferFloatBlend = r2.getExtension("EXT_float_blend") !== null, e2.supportsColorBufferHalfFloat = r2.getExtension("EXT_color_buffer_half_float") !== null), e2;
}
function x() {
  const e2 = new E(), r2 = _$2(r$1.WEBGL2, e2);
  return t$1W(r2) || (e2.supportsColorBufferFloat = r2.getExtension("EXT_color_buffer_float") !== null, e2.supportsColorBufferFloatBlend = r2.getExtension("EXT_float_blend") !== null, e2.supportsColorBufferHalfFloat = e2.supportsColorBufferFloat || r2.getExtension("EXT_color_buffer_half_float") !== null), e2;
}
function i$2(i2) {
  const s2 = l$4(i2);
  if (!s2.available)
    return new s$1Z("webgl:required", "WebGL is required but not supported.");
  if (i2 === "3d" && s2.majorPerformanceCaveat)
    return new s$1Z("webgl:major-performance-caveat-detected", "Your WebGL implementation doesn't seem to support hardware accelerated rendering. Check your browser settings or if your GPU is in a blocklist.");
  if (!s2.supportsHighPrecisionFragment)
    return new s$1Z("webgl:high-precision-fragment-required", "WebGL support for high precision fragment shaders is required but not supported.");
  if (!s2.supportsVertexShaderSamplers)
    return new s$1Z("webgl:vertex-shader-samplers-required", "WebGL support for vertex shader samplers is required but not supported.");
  if (s2.type === r$1.WEBGL1) {
    if (!s2.supportsElementIndexUint)
      return new s$1Z("webgl:element-index-uint-required", "WebGL support for uint vertex indices is required but not supported.");
    if (!s2.supportsStandardDerivatives)
      return new s$1Z("webgl:standard-derivatives-required", "WebGL support for standard derivatives is required but not supported.");
    if (!s2.supportsInstancedArrays)
      return new s$1Z("webgl:instanced-arrays-required", "WebGL support for instanced rendering is required but not supported.");
  }
  return null;
}
function i$1(t2) {
  return t2 && "nodeType" in t2;
}
function d$1(t2) {
  return t2 && typeof t2.render == "function";
}
const c$5 = { component: "esri-component" };
let p$8 = class extends m$1L {
  constructor() {
    super(...arguments), this.widget = null;
  }
  destroy() {
    this.widget && this.widget.destroy(), this.node = null;
  }
  get id() {
    return this.get("widget.id") || this.get("node.id");
  }
  set node(t2) {
    const e2 = this._get("node");
    t2 !== e2 && (t2 && t2.classList.add(c$5.component), e2 && e2.classList.remove(c$5.component), this._set("node", t2));
  }
  castNode(t2) {
    return t2 ? typeof t2 == "string" || i$1(t2) ? (this._set("widget", null), e$13(t2)) : (d$1(t2) && !t2.domNode && (t2.domNode = document.createElement("div")), this._set("widget", t2), t2.domNode) : (this._set("widget", null), null);
  }
};
e$1W([y$1o({ dependsOn: [] })], p$8.prototype, "id", null), e$1W([y$1o()], p$8.prototype, "node", null), e$1W([s$1N("node")], p$8.prototype, "castNode", null), e$1W([y$1o({ readOnly: true })], p$8.prototype, "widget", void 0), p$8 = e$1W([n$2f("esri.views.ui.Component")], p$8);
const l$3 = p$8;
const m$3 = { left: 0, top: 0, bottom: 0, right: 0 }, u$2 = { bottom: 30, top: 15, right: 15, left: 15 }, f$1 = "manual", _$1 = { ui: "esri-ui", corner: "esri-ui-corner", innerContainer: "esri-ui-inner-container", manualContainer: "esri-ui-manual-container", cornerContainer: "esri-ui-corner-container", topLeft: "esri-ui-top-left", topRight: "esri-ui-top-right", bottomLeft: "esri-ui-bottom-left", bottomRight: "esri-ui-bottom-right" };
function g$2(t2) {
  return t2 && !t2._started && typeof t2.postMixInProperties == "function" && typeof t2.buildRendering == "function" && typeof t2.postCreate == "function" && typeof t2.startup == "function";
}
function y$1(t2) {
  const o2 = t2, i2 = typeof o2 == "object" && o2 !== null && Object.getPrototypeOf(o2);
  return (i2 === null || i2 === Object.prototype) && ("component" in o2 || "index" in o2 || "position" in o2) ? t2 : null;
}
function C(t2, { top: o2, bottom: i2, left: e2, right: n2 }) {
  t2.style.top = o2, t2.style.bottom = i2, t2.style.left = e2, t2.style.right = n2;
}
let v = class extends n$26.EventedAccessor {
  constructor(t2) {
    super(t2), this._cornerNameToContainerLookup = {}, this._positionNameToContainerLookup = {}, this._components = new Array(), this._componentToKey = new Map(), this._handles = new t$1N(), this.view = null, this._applyViewPadding = () => {
      const t3 = this.container;
      t3 && C(t3, this._toPxPosition(this._getViewPadding()));
    }, this._applyUIPadding = () => {
      const t3 = this._innerContainer;
      t3 && C(t3, this._toPxPosition(this.padding));
    }, this._initContainers();
  }
  initialize() {
    this._handles.add([l$1f(() => {
      var _a2;
      return [(_a2 = this.view) == null ? void 0 : _a2.padding, this.container];
    }, this._applyViewPadding, h$S), l$1f(() => this.padding, this._applyUIPadding, h$S)]);
  }
  destroy() {
    this.container = null;
    for (const t2 of this._components)
      t2.destroy();
    this._components.length = 0, this._handles.destroy(), this._componentToKey.clear();
  }
  set container(t2) {
    const i2 = this._get("container");
    t2 !== i2 && (t2 && (t2.classList.add(_$1.ui), n$1h(t2), this._attachContainers(t2)), i2 && (i2.classList.remove(_$1.ui), C(i2, { top: "", bottom: "", left: "", right: "" }), t$15(i2)), this._set("container", t2));
  }
  get height() {
    const t2 = this.get("view.height") || 0;
    if (t2 === 0)
      return t2;
    const o2 = this._getViewPadding(), i2 = o2.top + o2.bottom;
    return Math.max(t2 - i2, 0);
  }
  get padding() {
    return this._get("padding");
  }
  set padding(t2) {
    this._overrideIfSome("padding", t2);
  }
  castPadding(t2) {
    return typeof t2 == "number" ? { bottom: t2, top: t2, right: t2, left: t2 } : __spreadValues(__spreadValues({}, u$2), t2);
  }
  get width() {
    const t2 = this.get("view.width") || 0;
    if (t2 === 0)
      return t2;
    const o2 = this._getViewPadding(), i2 = o2.left + o2.right;
    return Math.max(t2 - i2, 0);
  }
  add(t2, o2) {
    let i2, e2;
    if (Array.isArray(t2))
      return void t2.forEach((t3) => this.add(t3, o2));
    const n2 = y$1(t2);
    n2 && ({ index: i2, position: o2, component: t2, key: e2 } = n2), o2 && typeof o2 == "object" && ({ index: i2, key: e2, position: o2 } = o2), !t2 || o2 && !this._isValidPosition(o2) || this._add(t2, o2, i2, e2);
  }
  remove(t2, o2) {
    if (!t2)
      return;
    if (Array.isArray(t2))
      return t2.map((t3) => this.remove(t3, o2));
    const i2 = this._find(t2);
    if (i2) {
      const e2 = this._componentToKey;
      if (e2.has(t2) && e2.get(t2) !== o2)
        return;
      const n2 = this._components.indexOf(i2);
      return i2.node.parentNode && i2.node.parentNode.removeChild(i2.node), this._componentToKey.delete(t2), this._components.splice(n2, 1)[0];
    }
  }
  empty(t2) {
    if (Array.isArray(t2))
      return t2.map((t3) => this.empty(t3)).reduce((t3, o2) => t3.concat(o2));
    if ((t2 = t2 || f$1) === f$1) {
      return Array.prototype.slice.call(this._manualContainer.children).filter((t3) => !t3.classList.contains(_$1.corner)).map((t3) => this.remove(t3));
    }
    return this._isValidPosition(t2) ? Array.prototype.slice.call(this._cornerNameToContainerLookup[t2].children).map(this.remove, this) : null;
  }
  move(t2, o2) {
    if (Array.isArray(t2) && t2.forEach((t3) => this.move(t3, o2)), !t2)
      return;
    let i2;
    const e2 = y$1(t2) || y$1(o2);
    if (e2 && (i2 = e2.index, o2 = e2.position, t2 = e2.component || t2), o2 && !this._isValidPosition(o2))
      return;
    const n2 = this.remove(t2);
    n2 && this.add(n2, { position: o2, index: i2 });
  }
  find(t2) {
    if (!t2)
      return null;
    const o2 = this._findById(t2);
    return o2 && (o2.widget || o2.node);
  }
  getPosition(t2) {
    for (const o2 in this._positionNameToContainerLookup) {
      if (this._positionNameToContainerLookup[o2].contains(t2))
        return o2;
    }
    return null;
  }
  _add(t2, o2, i2, e2) {
    t2 instanceof l$3 || (t2 = new l$3({ node: t2 })), this._place({ component: t2, position: o2, index: i2 }), this._components.push(t2), e2 && this._componentToKey.set(t2, e2);
  }
  _find(t2) {
    return t2 ? t2 instanceof l$3 ? this._findByComponent(t2) : typeof t2 == "string" ? this._findById(t2) : this._findByNode(t2.domNode || t2) : null;
  }
  _getViewPadding() {
    return this.get("view.padding") || m$3;
  }
  _attachContainers(t2) {
    t2.appendChild(this._innerContainer), t2.appendChild(this._manualContainer);
  }
  _initContainers() {
    const t2 = document.createElement("div");
    t2.classList.add(_$1.innerContainer), t2.classList.add(_$1.cornerContainer);
    const o2 = document.createElement("div");
    o2.classList.add(_$1.innerContainer), o2.classList.add(_$1.manualContainer);
    const i2 = document.createElement("div");
    i2.classList.add(_$1.topLeft), i2.classList.add(_$1.corner), t2.appendChild(i2);
    const e2 = document.createElement("div");
    e2.classList.add(_$1.topRight), e2.classList.add(_$1.corner), t2.appendChild(e2);
    const n2 = document.createElement("div");
    n2.classList.add(_$1.bottomLeft), n2.classList.add(_$1.corner), t2.appendChild(n2);
    const r2 = document.createElement("div");
    r2.classList.add(_$1.bottomRight), r2.classList.add(_$1.corner), t2.appendChild(r2), this._innerContainer = t2, this._manualContainer = o2;
    const s2 = f$U();
    this._cornerNameToContainerLookup = { "top-left": i2, "top-right": e2, "bottom-left": n2, "bottom-right": r2, "top-leading": s2 ? e2 : i2, "top-trailing": s2 ? i2 : e2, "bottom-leading": s2 ? r2 : n2, "bottom-trailing": s2 ? n2 : r2 }, this._positionNameToContainerLookup = __spreadValues({ manual: o2 }, this._cornerNameToContainerLookup);
  }
  _isValidPosition(t2) {
    return !!this._positionNameToContainerLookup[t2];
  }
  _place(t2) {
    const o2 = t2.component, e2 = t2.position || f$1, n2 = t2.index, r2 = this._positionNameToContainerLookup[e2], s2 = n2 > -1;
    if (g$2(o2.widget) && o2.widget.startup(), !s2)
      return void r2.appendChild(o2.node);
    const a2 = Array.prototype.slice.call(r2.children);
    if (n2 === 0)
      return void (r2.firstChild ? o$13(o2.node, r2.firstChild) : r2.appendChild(o2.node));
    n2 >= a2.length ? r2.appendChild(o2.node) : o$13(o2.node, a2[n2]);
  }
  _toPxPosition(t2) {
    return { top: this._toPxUnit(t2.top), left: this._toPxUnit(t2.left), right: this._toPxUnit(t2.right), bottom: this._toPxUnit(t2.bottom) };
  }
  _toPxUnit(t2) {
    return t2 === 0 ? "0" : t2 + "px";
  }
  _findByComponent(t2) {
    let o2, i2 = null;
    return this._components.some((e2) => (o2 = e2 === t2, o2 && (i2 = e2), o2)), i2;
  }
  _findById(t2) {
    let o2, i2 = null;
    return this._components.some((e2) => (o2 = e2.id === t2, o2 && (i2 = e2), o2)), i2;
  }
  _findByNode(t2) {
    let o2, i2 = null;
    return this._components.some((e2) => (o2 = e2.node === t2, o2 && (i2 = e2), o2)), i2;
  }
};
e$1W([y$1o()], v.prototype, "container", null), e$1W([y$1o()], v.prototype, "height", null), e$1W([y$1o({ value: u$2 })], v.prototype, "padding", null), e$1W([s$1N("padding")], v.prototype, "castPadding", null), e$1W([y$1o()], v.prototype, "view", void 0), e$1W([y$1o()], v.prototype, "width", null), v = e$1W([n$2f("esri.views.ui.UI")], v);
const L = v;
function p$7(t2, e2) {
  return t2 && "copyright" in t2 && (!e2 || typeof t2.originOf == "function" && t2.originOf("copyright") === "user");
}
function m$2(t2, e2) {
  return t2.length !== e2.length || t2.some((t3, i2) => t3.text !== e2[i2].text);
}
function f(t2, e2, i2) {
  if (!i2 || !e2)
    return;
  t2.find((t3) => t3.layerView === e2 && t3.text === i2) || t2.push({ text: i2, layerView: e2 });
}
function y(t2) {
  return t2.type === "bing-maps";
}
const b = [];
let g$1 = class extends d$O {
  constructor(t2) {
    super(t2), this._clear = () => {
      this._fetchedAttributionData.clear(), this._pendingAttributions.clear(), this.handles.remove("suspension"), this.notifyChange("state");
    }, this._pendingAttributions = new Set(), this._fetchedAttributionData = new Map(), this.items = new j$F(), this.view = null, this._allLayerViewsChange = (t3) => {
      this.handles.remove("suspension");
      const e2 = this.get("view.allLayerViews");
      e2 && this.handles.add(e2.map((t4) => l$1f(() => {
        var _a2;
        return [t4.suspended, (_a2 = t4.layer) == null ? void 0 : _a2.attributionVisible];
      }, () => this._updateAttributionItems())), "suspension"), t3 && t3.removed && t3.removed.forEach((t4) => {
        this._pendingAttributions.delete(t4), this._fetchedAttributionData.delete(t4);
      }), this._updateAttributionItems();
    }, this.handles.add([a$1I(() => {
      var _a2;
      return (_a2 = this.view) == null ? void 0 : _a2.allLayerViews;
    }, "change", (t3) => this._allLayerViewsChange(t3), { onListenerAdd: () => this._allLayerViewsChange(), onListenerRemove: this._clear }), f$10(() => {
      var _a2;
      return ((_a2 = this.view) == null ? void 0 : _a2.stationary) === true;
    }, () => this._updateAttributionItems())]);
  }
  destroy() {
    this.view = null, this._fetchedAttributionData.clear(), this._pendingAttributions.clear(), this.items.removeAll();
  }
  get state() {
    return this.get("view.ready") ? this._pendingAttributions.size > 0 ? "loading" : "ready" : "disabled";
  }
  _updateAttributionItems() {
    const t2 = this.get("view.allLayerViews");
    b.length = 0, t2 ? (t2.forEach((t3) => {
      var _a2;
      if (t3.suspended || !((_a2 = t3.layer) == null ? void 0 : _a2.attributionVisible))
        return;
      const e2 = t3.layer;
      if (p$7(e2, "user"))
        return void f(b, t3, e2.copyright);
      if (e2.hasAttributionData) {
        if (this._fetchedAttributionData.has(t3)) {
          const i3 = this._fetchedAttributionData.get(t3);
          return void (i3 ? f(b, t3, this._getDynamicAttribution(i3, this.view, e2)) : p$7(e2) && f(b, t3, e2.copyright));
        }
        return void this._fetchAttributionData(t3);
      }
      const i2 = e2.get("portalItem.accessInformation");
      f(b, t3, i2 || e2.copyright);
    }), m$2(this.items, b) && (this.items.removeAll(), this.items.addMany(b)), b.length = 0, this.notifyChange("state")) : this._clear();
  }
  async _fetchAttributionData(t2) {
    if (this._pendingAttributions.has(t2))
      return;
    this._pendingAttributions.add(t2);
    const i2 = await b$w(t2.layer.fetchAttributionData());
    if (this._pendingAttributions.has(t2)) {
      const e2 = i2.ok ? this._createContributionIndex(i2.value, y(t2.layer)) : null;
      this._pendingAttributions.delete(t2), this._fetchedAttributionData.set(t2, e2);
    }
    this._updateAttributionItems();
  }
  _createContributionIndex(t2, e2) {
    const i2 = t2.contributors, r2 = {};
    if (!i2)
      return r2;
    for (let s2 = 0; s2 < i2.length; s2++) {
      const t3 = i2[s2], o2 = t3.coverageAreas;
      if (!o2)
        return;
      for (const i3 of o2) {
        const o3 = i3.bbox, n2 = i3.zoomMin - (e2 && i3.zoomMin ? 1 : 0), a2 = i3.zoomMax - (e2 && i3.zoomMax ? 1 : 0), c2 = { xmin: o3[1], ymin: o3[0], xmax: o3[3], ymax: o3[2], spatialReference: k$p.WGS84 }, u2 = { extent: R$m(c2), attribution: t3.attribution || "", score: i3.score != null ? i3.score : 100, id: s2 };
        for (let t4 = n2; t4 <= a2; t4++)
          r2[t4] = r2[t4] || [], r2[t4].push(u2);
      }
    }
    return r2.maxKey = Math.max.apply(null, Object.keys(r2)), r2;
  }
  _getDynamicAttribution(t2, e2, i2) {
    const { extent: r2, scale: s2 } = e2;
    let o2 = i2.tileInfo.scaleToZoom(s2);
    if (o2 = Math.min(t2.maxKey, Math.round(o2)), !r2 || o2 == null || o2 <= -1)
      return "";
    const n2 = t2[o2], a2 = M$s(r2.center.clone().normalize(), e2.spatialReference), c2 = {};
    return n2 ? n2.filter((t3) => {
      const e3 = !c2[t3.id] && a2 && r$1e(t3.extent, a2);
      return e3 && (c2[t3.id] = true), e3;
    }).sort((t3, e3) => e3.score - t3.score || t3.objectId - e3.objectId).map((t3) => t3.attribution).join(", ") : "";
  }
};
e$1W([y$1o({ readOnly: true, type: j$F })], g$1.prototype, "items", void 0), e$1W([y$1o({ readOnly: true })], g$1.prototype, "state", null), e$1W([y$1o()], g$1.prototype, "view", void 0), g$1 = e$1W([n$2f("esri.widgets.Attribution.AttributionViewModel")], g$1);
const _ = g$1;
const l$2 = { base: "esri-attribution esri-widget", poweredBy: "esri-attribution__powered-by", sources: "esri-attribution__sources", open: "esri-attribution--open", sourcesOpen: "esri-attribution__sources--open", link: "esri-attribution__link", widgetIcon: "esri-icon-description", interactive: "esri-interactive" };
let p$6 = class extends M$d {
  constructor(e2, t2) {
    super(e2, t2), this._isOpen = false, this._attributionTextOverflowed = false, this._prevSourceNodeHeight = 0, this._resizeObserver = new ResizeObserver((e3) => e3.forEach(({ target: e4 }) => this._checkSourceTextOverflow(e4))), this.iconClass = l$2.widgetIcon, this.itemDelimiter = " | ", this.messages = null, this.viewModel = new _();
  }
  initialize() {
    this.addHandles(a$1I(() => {
      var _a2;
      return (_a2 = this.viewModel) == null ? void 0 : _a2.items;
    }, "change", () => this.scheduleRender()));
  }
  destroy() {
    var _a2;
    (_a2 = this._resizeObserver) == null ? void 0 : _a2.disconnect();
  }
  get _isInteractive() {
    return this._isOpen || this._attributionTextOverflowed;
  }
  get attributionText() {
    return this.viewModel.items.reduce((e2, t2) => (e2.includes(t2.text) || e2.push(t2.text), e2), []).join(this.itemDelimiter);
  }
  get label() {
    var _a2, _b2;
    return (_b2 = (_a2 = this.messages) == null ? void 0 : _a2.widgetLabel) != null ? _b2 : "";
  }
  set label(e2) {
    this._overrideIfSome("label", e2);
  }
  get view() {
    return this.viewModel.view;
  }
  set view(e2) {
    this.viewModel.view = e2;
  }
  render() {
    const e2 = { [l$2.open]: this._isOpen };
    return n$1k("div", { bind: this, class: this.classes(l$2.base, e2), dir: "ltr", onclick: this._toggleState, onkeydown: this._toggleState }, this.renderSourcesNode(), this.renderPoweredBy());
  }
  renderPoweredBy() {
    return n$1k("div", { class: l$2.poweredBy }, "Powered by", " ", n$1k("a", { class: l$2.link, href: "http://www.esri.com/", target: "_blank", rel: "noreferrer" }, "Esri"));
  }
  renderSourcesNode() {
    const e2 = this._isOpen, t2 = this._isInteractive, i2 = t2 ? "0" : "", { attributionText: r2 } = this, s2 = { [l$2.sourcesOpen]: e2, [l$2.interactive]: t2 };
    return n$1k("div", { afterCreate: this._afterSourcesNodeCreate, bind: this, class: this.classes(l$2.sources, s2), innerHTML: r2, tabindex: i2 });
  }
  _afterSourcesNodeCreate(e2) {
    this._prevSourceNodeHeight = e2.clientWidth, this._resizeObserver.observe(e2);
  }
  _checkSourceTextOverflow(e2) {
    let t2 = false;
    const { clientHeight: i2, clientWidth: r2, scrollWidth: s2 } = e2, o2 = s2 > r2, n2 = this._attributionTextOverflowed !== o2;
    if (this._attributionTextOverflowed = o2, n2 && (t2 = true), this._isOpen) {
      const e3 = i2 < this._prevSourceNodeHeight;
      this._prevSourceNodeHeight = i2, e3 && (this._isOpen = false, t2 = true);
    }
    t2 && this.scheduleRender();
  }
  _toggleState() {
    this._isInteractive && (this._isOpen = !this._isOpen);
  }
};
e$1W([y$1o()], p$6.prototype, "_isOpen", void 0), e$1W([y$1o()], p$6.prototype, "_isInteractive", null), e$1W([y$1o()], p$6.prototype, "_attributionTextOverflowed", void 0), e$1W([y$1o()], p$6.prototype, "_prevSourceNodeHeight", void 0), e$1W([y$1o({ readOnly: true, dependsOn: ["viewModel.items.length", "itemDelimiter"] })], p$6.prototype, "attributionText", null), e$1W([y$1o()], p$6.prototype, "iconClass", void 0), e$1W([y$1o()], p$6.prototype, "itemDelimiter", void 0), e$1W([y$1o()], p$6.prototype, "label", null), e$1W([y$1o(), e$W("esri/widgets/Attribution/t9n/Attribution")], p$6.prototype, "messages", void 0), e$1W([y$1o()], p$6.prototype, "view", null), e$1W([y$1o({ type: _ })], p$6.prototype, "viewModel", void 0), e$1W([t$Y()], p$6.prototype, "_toggleState", null), p$6 = e$1W([n$2f("esri.widgets.Attribution")], p$6);
const a$5 = p$6;
const p$5 = "esri.widgets.CompassViewModel";
let d = class extends e$h(m$1L) {
  constructor(t2) {
    super(t2), this._handles = new t$1N(), this.orientation = { x: 0, y: 0, z: 0 }, this.view = null, this._updateForCamera = this._updateForCamera.bind(this), this._updateForRotation = this._updateForRotation.bind(this), this._updateRotationWatcher = this._updateRotationWatcher.bind(this);
  }
  initialize() {
    this._handles.add(l$1f(() => this.view, this._updateRotationWatcher, h$S));
  }
  destroy() {
    this._handles = h$1s(this._handles), this.view = null;
  }
  get canShowNorth() {
    const t2 = this.get("view.spatialReference");
    return !(!t2 || !t2.isWebMercator && !t2.isGeographic);
  }
  get state() {
    return this.get("view.ready") ? this.canShowNorth ? "compass" : "rotation" : "disabled";
  }
  reset() {
    if (!this.get("view.ready"))
      return;
    const t2 = {};
    this.view.type === "2d" ? t2.rotation = 0 : t2.heading = 0, this.callGoTo({ target: t2 });
  }
  _updateForRotation(t2) {
    t2 != null && (this.orientation = { z: t2 });
  }
  _updateForCamera(t2) {
    if (!t2)
      return;
    const o2 = -t2.heading;
    this.orientation = { x: 0, y: 0, z: o2 };
  }
  _updateRotationWatcher(t2) {
    this._handles.removeAll(), t2 && this._handles.add(t2.type === "2d" ? l$1f(() => t2 == null ? void 0 : t2.rotation, this._updateForRotation, h$S) : l$1f(() => t2 == null ? void 0 : t2.camera, this._updateForCamera, h$S));
  }
};
e$1W([y$1o({ readOnly: true })], d.prototype, "canShowNorth", null), e$1W([y$1o()], d.prototype, "orientation", void 0), e$1W([y$1o({ readOnly: true })], d.prototype, "state", null), e$1W([y$1o()], d.prototype, "view", void 0), d = e$1W([n$2f(p$5)], d);
const c$4 = d;
const l$1 = { base: "esri-compass esri-widget--button esri-widget", text: "esri-icon-font-fallback-text", icon: "esri-compass__icon", rotationIcon: "esri-icon-dial", northIcon: "esri-icon-compass", widgetIcon: "esri-icon-locate-circled", interactive: "esri-interactive", disabled: "esri-disabled" };
let c$3 = class extends M$d {
  constructor(e2, s2) {
    super(e2, s2), this.iconClass = l$1.widgetIcon, this.messages = null, this.viewModel = new c$4();
  }
  get goToOverride() {
    return this.viewModel.goToOverride;
  }
  set goToOverride(e2) {
    this.viewModel.goToOverride = e2;
  }
  get label() {
    var _a2, _b2;
    return (_b2 = (_a2 = this.messages) == null ? void 0 : _a2.widgetLabel) != null ? _b2 : "";
  }
  set label(e2) {
    this._overrideIfSome("label", e2);
  }
  get view() {
    return this.viewModel.view;
  }
  set view(e2) {
    this.viewModel.view = e2;
  }
  reset() {
    return this.viewModel.reset();
  }
  render() {
    const { orientation: e2, state: s2 } = this.viewModel, t2 = s2 === "disabled", o2 = (s2 === "rotation" ? "rotation" : "compass") === "compass", r2 = t2 ? -1 : 0, i2 = { [l$1.disabled]: t2, [l$1.interactive]: !t2 }, a2 = { [l$1.northIcon]: o2, [l$1.rotationIcon]: !o2 }, { messages: c2 } = this;
    return n$1k("div", { bind: this, class: this.classes(l$1.base, i2), onclick: this._reset, onkeydown: this._reset, role: "button", tabIndex: r2, "aria-label": c2.reset, title: c2.reset }, n$1k("span", { "aria-hidden": "true", class: this.classes(l$1.icon, a2), styles: this._toRotationTransform(e2) }), n$1k("span", { class: l$1.text }, c2.reset));
  }
  _reset() {
    this.viewModel.reset();
  }
  _toRotationTransform(e2) {
    return { transform: `rotateZ(${e2.z}deg)` };
  }
};
e$1W([y$1o()], c$3.prototype, "goToOverride", null), e$1W([y$1o()], c$3.prototype, "iconClass", void 0), e$1W([y$1o()], c$3.prototype, "label", null), e$1W([y$1o(), e$W("esri/widgets/Compass/t9n/Compass")], c$3.prototype, "messages", void 0), e$1W([y$1o()], c$3.prototype, "view", null), e$1W([y$1o({ type: c$4 })], c$3.prototype, "viewModel", void 0), e$1W([t$Y()], c$3.prototype, "_reset", null), c$3 = e$1W([n$2f("esri.widgets.Compass")], c$3);
const p$4 = c$3;
let r = class extends m$1L {
  constructor(t2) {
    super(t2), this.navigationMode = "pan", this.view = null;
  }
  initialize() {
    this.own(f$10(() => {
      var _a2;
      return (_a2 = this.view) == null ? void 0 : _a2.inputManager;
    }, () => this._setNavigationMode()));
  }
  destroy() {
    this.view = null;
  }
  get state() {
    return this.get("view.ready") && this.view.type === "3d" ? "ready" : "disabled";
  }
  toggle() {
    this.state !== "disabled" && (this.navigationMode = this.navigationMode !== "pan" ? "pan" : "rotate", this._setNavigationMode());
  }
  _setNavigationMode() {
    this.get("view.inputManager").primaryDragAction = this.navigationMode === "pan" ? "pan" : "rotate";
  }
};
e$1W([y$1o({ readOnly: true })], r.prototype, "state", null), e$1W([y$1o()], r.prototype, "navigationMode", void 0), e$1W([y$1o()], r.prototype, "view", void 0), r = e$1W([n$2f("esri.widgets.NavigationToggleViewModel")], r);
const a$4 = r;
const l = { base: "esri-navigation-toggle esri-widget", button: "esri-navigation-toggle__button esri-widget--button", activeButton: "esri-navigation-toggle__button--active", panButton: "esri-navigation-toggle__button--pan", rotateButton: "esri-navigation-toggle__button--rotate", isLayoutHorizontal: "esri-navigation-toggle--horizontal", rotationIcon: "esri-icon-rotate", panIcon: "esri-icon-pan", widgetIcon: "esri-icon-pan2", disabled: "esri-disabled" };
let g = class extends M$d {
  constructor(t2, o2) {
    super(t2, o2), this.iconClass = l.widgetIcon, this.messages = null, this.viewModel = new a$4();
  }
  get label() {
    var _a2, _b2;
    return (_b2 = (_a2 = this.messages) == null ? void 0 : _a2.widgetLabel) != null ? _b2 : "";
  }
  set label(t2) {
    this._overrideIfSome("label", t2);
  }
  set layout(t2) {
    t2 !== "horizontal" && (t2 = "vertical"), this._set("layout", t2);
  }
  get view() {
    return this.viewModel.view;
  }
  set view(t2) {
    this.viewModel.view = t2;
  }
  toggle() {
    return this.viewModel.toggle();
  }
  render() {
    const t2 = this.get("viewModel.state") === "disabled", o2 = this.get("viewModel.navigationMode") === "pan", e2 = { [l.disabled]: t2, [l.isLayoutHorizontal]: this.layout === "horizontal" }, s2 = { [l.activeButton]: o2 }, i2 = { [l.activeButton]: !o2 }, a2 = t2 ? -1 : 0, r2 = this.messages.toggle;
    return n$1k("div", { bind: this, class: this.classes(l.base, e2), onclick: this._toggle, onkeydown: this._toggle, tabIndex: a2, "aria-label": r2, title: r2 }, n$1k("div", { class: this.classes(l.button, l.panButton, s2) }, n$1k("span", { class: l.panIcon })), n$1k("div", { class: this.classes(l.button, l.rotateButton, i2) }, n$1k("span", { class: l.rotationIcon })));
  }
  _toggle() {
    this.toggle();
  }
};
e$1W([y$1o()], g.prototype, "iconClass", void 0), e$1W([y$1o()], g.prototype, "label", null), e$1W([y$1o({ value: "vertical" })], g.prototype, "layout", null), e$1W([y$1o(), e$W("esri/widgets/NavigationToggle/t9n/NavigationToggle")], g.prototype, "messages", void 0), e$1W([y$1o()], g.prototype, "view", null), e$1W([y$1o({ type: a$4 })], g.prototype, "viewModel", void 0), e$1W([t$Y()], g.prototype, "_toggle", null), g = e$1W([n$2f("esri.widgets.NavigationToggle")], g);
const p$3 = g;
const c$2 = { button: "esri-widget--button esri-widget", disabled: "esri-disabled", interactive: "esri-interactive", iconText: "esri-icon-font-fallback-text", icon: "esri-icon" };
let n = class extends M$d {
  constructor() {
    super(...arguments), this.enabled = true, this.iconClass = "", this.title = "";
  }
  render() {
    const t2 = this.enabled ? 0 : -1, s2 = { [c$2.disabled]: !this.enabled, [c$2.interactive]: this.enabled }, i2 = { [this.iconClass]: !!this.iconClass };
    return n$1k("div", { bind: this, class: this.classes(c$2.button, s2), onclick: this._triggerAction, onkeydown: this._triggerAction, role: "button", tabIndex: t2, title: this.title }, n$1k("span", { "aria-hidden": "true", role: "presentation", class: this.classes(c$2.icon, i2) }), n$1k("span", { class: c$2.iconText }, this.title));
  }
  _triggerAction() {
    this.action.call(this);
  }
};
e$1W([y$1o()], n.prototype, "action", void 0), e$1W([y$1o()], n.prototype, "enabled", void 0), e$1W([y$1o()], n.prototype, "iconClass", void 0), e$1W([y$1o()], n.prototype, "title", void 0), e$1W([t$Y()], n.prototype, "_triggerAction", null), n = e$1W([n$2f("esri.widgets.IconButton")], n);
const a$3 = n;
let s = class extends m$1L {
  get canZoomIn() {
    if (!this.get("view.ready"))
      return false;
    const e2 = this.get("view.animation.target.scale") || this.get("view.scale"), t2 = this.get("view.constraints.effectiveMaxScale");
    return t2 === 0 || e2 > t2;
  }
  get canZoomOut() {
    if (!this.get("view.ready"))
      return false;
    const e2 = this.get("view.animation.target.scale") || this.get("view.scale"), t2 = this.get("view.constraints.effectiveMinScale");
    return t2 === 0 || e2 < t2;
  }
};
e$1W([y$1o({ readOnly: true })], s.prototype, "canZoomIn", null), e$1W([y$1o({ readOnly: true })], s.prototype, "canZoomOut", null), e$1W([y$1o()], s.prototype, "view", void 0), s = e$1W([n$2f("esri.widgets.Zoom.ZoomConditions2D")], s);
const i = s;
let t = class extends m$1L {
  get canZoomIn() {
    return !!this.view.ready;
  }
  get canZoomOut() {
    return !!this.view.ready;
  }
};
e$1W([y$1o({ readOnly: true })], t.prototype, "canZoomIn", null), e$1W([y$1o({ readOnly: true })], t.prototype, "canZoomOut", null), e$1W([y$1o()], t.prototype, "view", void 0), t = e$1W([n$2f("esri.widgets.Zoom.ZoomConditions3D")], t);
const c$1 = t;
let p$2 = class extends m$1L {
  constructor(o2) {
    super(o2);
  }
  destroy() {
    this.view = null;
  }
  get canZoomIn() {
    return r$1t(this._zoomConditions) && this._zoomConditions.canZoomIn;
  }
  get canZoomOut() {
    var _a2;
    return r$1t(this._zoomConditions) && ((_a2 = this._zoomConditions) == null ? void 0 : _a2.canZoomOut);
  }
  get state() {
    var _a2;
    return ((_a2 = this.view) == null ? void 0 : _a2.ready) ? "ready" : "disabled";
  }
  set view(o2) {
    o2 ? o2.type === "2d" ? this._zoomConditions = new i({ view: o2 }) : o2.type === "3d" && (this._zoomConditions = new c$1({ view: o2 })) : this._zoomConditions = null, this._set("view", o2);
  }
  zoomIn() {
    if (!this.canZoomIn)
      return;
    const o2 = this.view;
    o2.type === "2d" ? o2.mapViewNavigation.zoomIn() : g$12(o2.goTo({ zoomFactor: 2 }));
  }
  zoomOut() {
    if (!this.canZoomOut)
      return;
    const o2 = this.view;
    o2.type === "2d" ? o2.mapViewNavigation.zoomOut() : g$12(o2.goTo({ zoomFactor: 0.5 }));
  }
};
e$1W([y$1o()], p$2.prototype, "_zoomConditions", void 0), e$1W([y$1o()], p$2.prototype, "canZoomIn", null), e$1W([y$1o()], p$2.prototype, "canZoomOut", null), e$1W([y$1o({ readOnly: true })], p$2.prototype, "state", null), e$1W([y$1o()], p$2.prototype, "view", null), p$2 = e$1W([n$2f("esri.widgets.Zoom.ZoomViewModel")], p$2);
const a$2 = p$2;
const u$1 = { base: "esri-zoom esri-widget", horizontalLayout: "esri-zoom--horizontal", zoomInIcon: "esri-icon-plus", zoomOutIcon: "esri-icon-minus", widgetIcon: "esri-icon-zoom-in-magnifying-glass" };
let a$1 = class extends M$d {
  constructor(o2, t2) {
    super(o2, t2), this.iconClass = u$1.widgetIcon, this.messages = null, this.viewModel = new a$2();
  }
  initialize() {
    this._zoomInButton = new a$3({ action: this.zoomIn.bind(this), iconClass: u$1.zoomInIcon }), this._zoomOutButton = new a$3({ action: this.zoomOut.bind(this), iconClass: u$1.zoomOutIcon });
  }
  destroy() {
    this._zoomInButton = s$26(this._zoomInButton), this._zoomOutButton = s$26(this._zoomOutButton);
  }
  get label() {
    var _a2, _b2;
    return (_b2 = (_a2 = this.messages) == null ? void 0 : _a2.widgetLabel) != null ? _b2 : "";
  }
  set label(o2) {
    this._overrideIfSome("label", o2);
  }
  set layout(o2) {
    o2 !== "horizontal" && (o2 = "vertical"), this._set("layout", o2);
  }
  set view(o2) {
    this.viewModel.view = o2;
  }
  get view() {
    return this.viewModel.view;
  }
  render() {
    const o2 = this.viewModel, t2 = { [u$1.horizontalLayout]: this.layout === "horizontal" }, { canZoomIn: s2, canZoomOut: e2 } = o2;
    this._zoomInButton.enabled = s2, this._zoomOutButton.enabled = e2;
    const { zoomIn: i2, zoomOut: r2 } = this.messages;
    return this._zoomInButton.title = i2, this._zoomOutButton.title = r2, n$1k("div", { class: this.classes(u$1.base, t2) }, this._zoomInButton.render(), this._zoomOutButton.render());
  }
  zoomIn() {
    return this.viewModel.zoomIn();
  }
  zoomOut() {
    return this.viewModel.zoomOut();
  }
};
e$1W([y$1o()], a$1.prototype, "iconClass", void 0), e$1W([y$1o()], a$1.prototype, "label", null), e$1W([y$1o({ value: "vertical" })], a$1.prototype, "layout", null), e$1W([y$1o(), e$W("esri/widgets/Zoom/t9n/Zoom")], a$1.prototype, "messages", void 0), e$1W([y$1o()], a$1.prototype, "view", null), e$1W([y$1o({ type: a$2 })], a$1.prototype, "viewModel", void 0), a$1 = e$1W([n$2f("esri.widgets.Zoom")], a$1);
const c = a$1;
function m$1(t2) {
  return t2 && t2.view !== void 0;
}
let h = class extends L {
  constructor(t2) {
    super(t2), this._defaultPositionLookup = { attribution: "manual", compass: "top-left", "navigation-toggle": "top-left", zoom: "top-left" }, this.components = [];
  }
  initialize() {
    this._handles.add([l$1f(() => this.components, this._componentsWatcher.bind(this), h$S), l$1f(() => this.view, this._updateViewAwareWidgets.bind(this), h$S)]);
  }
  _add(t2, o2, e2, i2) {
    if (typeof t2 == "string" && this._defaultPositionLookup[t2]) {
      if (this._find(t2))
        return;
      t2 = this._createComponent(t2);
    }
    super._add(t2, o2, e2, i2);
  }
  _removeComponents(t2) {
    t2.forEach((t3) => {
      const o2 = this._find(t3);
      o2 && (this.remove(o2), o2.destroy());
    });
  }
  _updateViewAwareWidgets(t2) {
    this.components.forEach((o2) => {
      const e2 = this._find(o2), i2 = e2 && e2.widget;
      m$1(i2) && (i2.view = t2);
    });
  }
  _componentsWatcher(t2, o2) {
    this._removeComponents(o2), this._addComponents(t2), this._adjustPadding(t2);
  }
  _adjustPadding(t2) {
    if (!t2.includes("attribution") && !this._isOverridden("padding")) {
      const { top: t3 } = this.padding;
      this.padding = t3;
    }
  }
  _addComponents(t2) {
    this.constructed && t2.forEach((t3) => this.add(this._createComponent(t3), this._defaultPositionLookup[t3]));
  }
  _createComponent(t2) {
    const o2 = this._createWidget(t2);
    if (o2)
      return new l$3({ id: t2, node: o2 });
  }
  _createWidget(t2) {
    return t2 === "attribution" ? this._createAttribution() : t2 === "compass" ? this._createCompass() : t2 === "navigation-toggle" ? this._createNavigationToggle() : t2 === "zoom" ? this._createZoom() : void 0;
  }
  _createAttribution() {
    return new a$5({ view: this.view });
  }
  _createCompass() {
    return new p$4({ view: this.view });
  }
  _createNavigationToggle() {
    return new p$3({ view: this.view });
  }
  _createZoom() {
    return new c({ view: this.view });
  }
};
e$1W([y$1o()], h.prototype, "components", void 0), h = e$1W([n$2f("esri.views.ui.DefaultUI")], h);
const u = h;
let e = class extends u {
  constructor(o2) {
    super(o2), this.components = ["attribution", "zoom"];
  }
};
e$1W([y$1o()], e.prototype, "components", void 0), e = e$1W([n$2f("esri.views.ui.2d.DefaultUI2D")], e);
const p$1 = e;
var p;
let a = p = class extends l$1_ {
  constructor(o2) {
    super(o2), this.color = new l$1D([0, 0, 0, 1]);
  }
  clone() {
    return new p(y$1r({ color: this.color }));
  }
};
e$1W([y$1o({ type: l$1D, json: { write: true } })], a.prototype, "color", void 0), a = p = e$1W([n$2f("esri.webmap.background.ColorBackground")], a);
const m = a;
let pe, he, ce, de, ue, ge;
async function me() {
  const [, { GraphicsView2D: e2, GraphicContainer: t2, LabelManager: i2, MapViewNavigation: s2, MagnifierView2D: r2, Stage: n2 }] = await Promise.all([import("./webglDeps.js"), import("./mapViewDeps.js")]);
  he = e2, ce = t2, de = i2, ue = s2, ge = r2, pe = n2;
}
const ye = 160;
function we(e2) {
  return e2 && e2.declaredClass === "esri.Viewpoint";
}
let fe = class extends w$w(z$4(a$z(z$3))) {
  constructor(e2) {
    super(e2), this._magnifierView = null, this._stage = null, this._resolveWhenReady = [], this.rootLayerViews = new l$1g({ getCollections: () => {
      var _a2, _b2;
      return [(_a2 = this.basemapView) == null ? void 0 : _a2.baseLayerViews, this.layerViews, (_b2 = this.basemapView) == null ? void 0 : _b2.referenceLayerViews];
    }, getChildrenFunction: () => null }), this.featuresTilingScheme = null, this.fullOpacity = 1, this.graphicsView = null, this.labelManager = null, this.mapViewNavigation = null, this.renderingOptions = { samplingMode: "dynamic", edgeLabelsVisible: true, labelsAnimationTime: 125, labelCollisionsEnabled: true }, this.rendering = false, this.supersampleScreenshotsEnabled = false, this.supportsGround = false, this._stationaryTimer = null, this.frameTask = new s$d(this), this._pePromise = null, this.floors = new j$F(), this.highlightOptions = new c$9(), this.inputManager = new C$1({ view: this }), this.map = null, this.resizeAlign = "center", this.spatialReferenceLocked = false, this.timeline = new e$1(), this.type = "2d", this.ui = new p$1(), this._pixelFormat = { flipY: true, premultipliedAlpha: true }, this.constraints = new u$d(), this.padding = { top: 0, right: 0, bottom: 0, left: 0 }, this.handles.add([l$1f(() => this.viewpoint, () => {
      this._lastStationaryEventTimestamp = performance.now(), this._flipStationary(ye);
    }, U$i), this.on("resize", (e3) => this._resizeHandler(e3)), l$1f(() => {
      var _a2;
      return (_a2 = this.animationManager) == null ? void 0 : _a2.animation;
    }, (e3) => {
      this.animation = e3;
    })]), l$1d();
  }
  destroy() {
    this._set("preconditionsReady", false), this._gotoTask = this.frameTask = null, this.rootLayerViews.destroy(), this.inputManager.destroy(), this._set("inputManager", null);
  }
  get graphicsTileStore() {
    return new d$4(this.featuresTilingScheme);
  }
  get initialExtentRequired() {
    var _a2;
    const { scale: e2, constraints: t2, center: i2, viewpoint: s2, extent: r2 } = this;
    let n2 = this.zoom;
    return !(this.map && "initialViewProperties" in this.map && ((_a2 = this.map.initialViewProperties) == null ? void 0 : _a2.viewpoint)) && (!r2 && ((t2 == null ? void 0 : t2.effectiveLODs) || (n2 = -1), (!i2 || e2 === 0 && n2 === -1) && (!s2 || !r$1t(s2.targetGeometry) || s2.targetGeometry.type !== "extent" && !s2.scale)));
  }
  get resourceManager() {
    return this._stage.resourceManager;
  }
  get textureManager() {
    return this._stage.painter.textureManager;
  }
  get _defaultsFromMapSettings() {
    return { required: { tileInfo: true, heightModelInfo: false, extent: false }, requiresExtentInSpatialReference: this.spatialReferenceLocked };
  }
  get _projectionEngineLoaded() {
    return !!en() || (this._pePromise || (this._pePromise = tn().finally(() => {
      this._pePromise = null;
    })), false);
  }
  get typeSpecificPreconditionsReady() {
    const e2 = this._getDefaultViewpoint();
    if (!e2)
      return false;
    const t2 = this.spatialReference, i2 = e$1U(e2.targetGeometry);
    return !!An(i2.spatialReference, t2) || this._projectionEngineLoaded;
  }
  set animation(e2) {
    const t2 = this._get("animation");
    if (e2 === t2)
      return;
    if (t2 && t2.stop(), !e2 || e2.isFulfilled())
      return void this._set("animation", null);
    this._set("animation", e2), this.frameTask.animationInProgress = true;
    const i2 = () => {
      var _a2;
      e2 === this._get("animation") && (this._set("animation", null), (_a2 = this.frameTask) == null ? void 0 : _a2.requestFrame()), this.frameTask && (this.frameTask.animationInProgress = false);
    };
    e2.when(i2, i2);
  }
  get background() {
    return je(this.map) ? this.map.initialViewProperties.background : null;
  }
  set background(e2) {
    this._override("background", e2);
  }
  get center() {
    if (!this.ready)
      return this._get("center");
    const { center: e2, spatialReference: t2 } = this.state.paddedViewState;
    return new w$K({ x: e2[0], y: e2[1], spatialReference: t2 });
  }
  set center(e2) {
    if (e2 == null)
      return;
    if (!this.ready)
      return this._set("center", e2), void this.notifyChange("initialExtentRequired");
    let t2;
    try {
      t2 = this._project(e2, this.spatialReference);
    } catch (s2) {
      return void s$22.getLogger(this.declaredClass).error(new s$1Z("mapview:invalid-center", "could not project the value in the view's spatial reference", { input: e2, error: s2 }));
    }
    const i2 = this.viewpoint;
    xt(i2, i2, t2), this.viewpoint = i2;
  }
  set constraints(e2) {
    const t2 = this._get("constraints");
    t2 && (this.handles.remove("map-view-constraints"), t2.destroy()), this._set("constraints", e2), e2 && (e2.view = this, this.ready && (this.state.viewpoint = e2.fit(this.state.paddedViewState.viewpoint)), this.handles.add(l$1f(() => e2.version, () => {
      this.ready && this.state && (this.state.viewpoint = e2.fit(this.state.paddedViewState.viewpoint));
    }, U$i), "map-view-constraints"));
  }
  get extent() {
    return this.ready ? this.state.paddedViewState.extent.clone() : this._get("extent");
  }
  set extent(e2) {
    if (e2 == null)
      return;
    if (!e2.width || !e2.height)
      return void s$22.getLogger(this.declaredClass).error(new s$1Z("mapview:invalid-extent", "invalid extent size"));
    if (!this.ready)
      return this._set("extent", e2), this._set("center", null), this._set("viewpoint", null), this._set("scale", 0), this._set("zoom", -1), void this.notifyChange("initialExtentRequired");
    let t2;
    try {
      t2 = this._project(e2, this.spatialReference);
    } catch (s2) {
      return void s$22.getLogger(this.declaredClass).error(new s$1Z("mapview:invalid-extent", "could not project the value in the view's spatial reference", { error: s2 }));
    }
    const i2 = this.viewpoint;
    tt(i2, i2, t2, this.size, { constraints: this.constraints }), this.viewpoint = i2;
  }
  get padding() {
    return this.ready ? this.state.padding : this._get("padding");
  }
  set padding(e2) {
    this.ready ? (this.state.padding = e2, this._set("padding", this.state.padding)) : this._set("padding", e2);
  }
  get resolution() {
    return this.state ? this.state.resolution : 0;
  }
  get rotation() {
    return this.ready ? this.state.rotation : this._get("rotation");
  }
  set rotation(e2) {
    if (isNaN(e2))
      return;
    if (!this.ready)
      return void this._set("rotation", e2);
    const t2 = this.viewpoint;
    wt(t2, t2, e2), this.viewpoint = t2;
  }
  get scale() {
    return this.ready ? this.state.scale : this._get("scale");
  }
  set scale(e2) {
    if (!e2 || isNaN(e2))
      return;
    if (!this.ready) {
      this._set("scale", e2), this._set("zoom", -1);
      const t3 = this._get("extent");
      return t3 && (this._set("extent", null), this._set("center", t3.center)), void this.notifyChange("initialExtentRequired");
    }
    const t2 = this.viewpoint;
    jt(t2, t2, e2), this.viewpoint = t2;
  }
  get stationary() {
    return !(this.animation || this.navigating || this.resizing || this._stationaryTimer);
  }
  get updating() {
    var _a2, _b2, _c2;
    const e2 = !this.destroyed && (!this.layerViewManager || !this.labelManager || !this.graphicsView || this.layerViewManager.updating === true || this.labelManager.updating === true || this.graphicsView.updating === true || this.allLayerViews.some((e3) => !e3.destroyed && !("layerViews" in e3) && e3.updating === true));
    if (has("esri-2d-log-updating")) {
      const t2 = this.allLayerViews.reduce((e3, t3) => __spreadProps(__spreadValues({}, e3), { [t3.layer.id]: !t3.destroyed && !("layerViews" in t3) && t3.updating }), {});
      console.log(`Updating MapView: ${e2}
-> Null LayerViewManager: ${!this.layerViewManager}
-> Null LabelManager: ${!this.labelManager}
-> Null GraphicsView: ${!this.graphicsView}
-> layerViewManager.updating: ${(_a2 = this.layerViewManager) == null ? void 0 : _a2.updating}
-> labelManager.updating: ${(_b2 = this.labelManager) == null ? void 0 : _b2.updating}
-> graphicsView.updating: ${(_c2 = this.graphicsView) == null ? void 0 : _c2.updating}
-> allLayerViews: ${JSON.stringify(t2)}
`);
    }
    return e2;
  }
  get viewpoint() {
    if (!this.ready)
      return this._get("viewpoint");
    const e2 = this.state.paddedViewState;
    return e2 && e2.viewpoint.clone();
  }
  set viewpoint(e2) {
    if (e2 == null)
      return;
    if (!this.ready)
      return this._set("viewpoint", e2), this._set("extent", null), this._set("center", null), this._set("zoom", -1), this._set("scale", 0), void this.notifyChange("initialExtentRequired");
    let t2, s2;
    try {
      t2 = this._project(e2, this.spatialReference), !e2.scale || isNaN(e2.scale) ? s2 = new s$1Z("mapview:invalid-viewpoint", `invalid scale value of ${e2.scale}`) : t$1W(e2.targetGeometry) && (s2 = new s$1Z("mapview:invalid-viewpoint", "geometry not defined"));
    } catch (a2) {
      s2 = new s$1Z("mapview:invalid-viewpoint", "could not project the value in the view's spatial reference", { error: a2 });
    }
    if (s2)
      return void s$22.getLogger(this.declaredClass).error(s2);
    this._scaleBeforeChangingSpatialReference = null;
    const r2 = new u$17({ targetGeometry: new w$K(), scale: 0, rotation: 0 });
    Z(r2, t2), this.constraints.constrain(r2, this.state.paddedViewState.viewpoint), this.state.viewpoint = r2, this.frameTask.requestFrame(), this._set("viewpoint", r2);
  }
  get zoom() {
    return this.ready ? this.constraints.scaleToZoom(this.scale) : this._get("zoom");
  }
  set zoom(e2) {
    if (e2 == null)
      return;
    if (!this.ready) {
      this._set("zoom", e2), this._set("scale", 0);
      const t3 = this._get("extent");
      return t3 && (this._set("extent", null), this._set("center", t3.center)), void this.notifyChange("initialExtentRequired");
    }
    if (!this.constraints.effectiveLODs)
      return void this._set("zoom", -1);
    const t2 = this.viewpoint;
    jt(t2, t2, this.constraints.zoomToScale(e2)), this.viewpoint = t2, this._set("zoom", this.constraints.scaleToZoom(this.scale));
  }
  get navigating() {
    return !(!this.mapViewNavigation || !this.mapViewNavigation.interacting);
  }
  goTo(e2, t2) {
    if (e2)
      return this.animation && (this.animation = null), this._createAnimation(), j$u(() => this.ready, t2).then(() => {
        const i2 = __spreadValues({ animate: true }, t2), s2 = Y(e2, this);
        return this.animation.update(s2), this._gotoTask = {}, i2.animate ? this._gotoAnimated(s2, i2) : this._gotoImmediate(s2, i2);
      });
    s$22.getLogger(this.declaredClass).error("#goTo()", "target cannot be null or undefined");
  }
  async hitTest(e2, t2) {
    const i2 = o$h(e2) ? r$l(this, e2) : e2;
    if (!this.ready || isNaN(i2.x) || isNaN(i2.y))
      return { screenPoint: i2, results: [] };
    let s2 = new Set(), r2 = false, n2 = null, a2 = null;
    (t2 == null ? void 0 : t2.include) ? Se(t2.include, Ve(this, (e3) => s2.add(e3), (e3) => {
      n2 || (n2 = new Set()), n2.add(e3);
    }, (e3) => s2.add(e3), () => r2 = true)) : (r2 = true, s2 = new Set(this.allLayerViews)), (t2 == null ? void 0 : t2.exclude) && Se(t2.exclude, Ve(this, (e3) => s2.delete(e3), (e3) => {
      a2 || (a2 = new Set()), a2.add(e3);
    }));
    const o2 = this.allLayerViews.filter((e3) => !e3.suspended && s2.has(e3)).reverse(), p2 = this.toMap(i2);
    let h2 = [...r2 ? this.graphicsView.hitTest(p2).map((e3) => ({ type: "graphic", graphic: e3, layer: null, mapPoint: p2 })) : [], ...await Promise.all(o2.map((e3) => e3.hitTest(p2, i2)).toArray())].filter(r$1t).flat().filter(r$1t);
    return n2 && (h2 = h2.filter((e3) => !("graphic" in e3) || !e3.graphic || n2.has(ve(e3.graphic)))), a2 && (h2 = h2.filter((e3) => !("graphic" in e3) || !e3.graphic || a2.has(ve(e3.graphic)))), { screenPoint: i2, results: h2 };
  }
  async takeScreenshot(e2) {
    const t2 = this._createScreenshotPlan(e2), i2 = await this._stage.takeScreenshot(t2);
    return r$2(i2, { format: t2.format, quality: t2.quality, rotation: 0, disableDecorations: false }, this._pixelFormat);
  }
  async _takeScreenshot(e2) {
    const t2 = this._createScreenshotPlan(e2), i2 = await this._stage.takeScreenshot(t2);
    return l$6(i2, this._pixelFormat);
  }
  _createScreenshotPlan(e2) {
    e2 = e2 || {};
    const t2 = this.supersampleScreenshotsEnabled ? Math.min(4, w(this.size, Math.min(4096, this._stage.context.parameters.maxTextureSize))) : 1;
    let i2;
    e2.layers ? (i2 = [], e2.layers.forEach((e3) => {
      const t3 = this.allLayerViews.find((t4) => t4.layer.id === e3.id);
      t3 && "container" in t3 && t3.container && i2.push(t3.container);
    })) : i2 = this._stage.children;
    const { format: s2, quality: r2 } = s$2(e2.format, e2.quality);
    return t$1(e2, t2, this.size, this.padding, s2, r2, i2, e2.rotation);
  }
  get test() {
    return { takeScreenshot: (e2) => this._takeScreenshot(e2) };
  }
  toMap(e2) {
    if (!this.ready)
      return null;
    const t2 = o$h(e2) ? r$l(this, e2) : e2, i2 = [0, 0], [s2, r2] = this.state.toMap(i2, [t2.x, t2.y]), n2 = this.spatialReference;
    return new w$K({ x: s2, y: r2, spatialReference: n2 });
  }
  toScreen(e2) {
    if (!this.ready)
      return null;
    const t2 = this._project(e2, this.spatialReference), i2 = [t2.x, t2.y];
    return this.state.toScreen(i2, i2), c$2b(i2[0], i2[1]);
  }
  on(e2, t2, i2, s2) {
    const r2 = this.inputManager && this.viewEvents.on(e2, t2, i2, s2);
    return r2 || super.on(e2, t2);
  }
  hasEventListener(e2) {
    return super.hasEventListener(e2) || this.viewEvents.hasHandler(e2);
  }
  whenLayerView(e2) {
    return super.whenLayerView(e2);
  }
  graphicChanged(e2) {
    if (this.graphicsView) {
      this.graphicsView.graphicUpdateHandler(e2);
    }
  }
  whenReady() {
    return new Promise((e2) => {
      this.ready ? e2(this) : this._resolveWhenReady.push(e2);
    });
  }
  forceDOMReadyCycle() {
    this.forceReadyCycle();
  }
  getDefaultSpatialReference() {
    var _a2, _b2, _c2;
    return this.map && "initialViewProperties" in this.map && ((_b2 = (_a2 = this.map) == null ? void 0 : _a2.initialViewProperties) == null ? void 0 : _b2.spatialReference) || ((_c2 = this.defaultsFromMap) == null ? void 0 : _c2.spatialReference) || null;
  }
  hasLayerViewModule(e2) {
    return n$i.hasLayerViewModule(e2);
  }
  importLayerView(e2) {
    return n$i.importLayerView(e2);
  }
  pixelSizeAt() {
    return this.ready ? this.state.resolution : (s$22.getLogger(this.declaredClass).error("#pixelSizeAt()", "Map view cannot be used before it is ready"), null);
  }
  popupHitTest(e2) {
    return this.hitTest(e2).then((t2) => __spreadProps(__spreadValues({}, t2), { mapPoint: this.toMap(e2) }));
  }
  requestUpdate() {
    this.ready && this.frameTask.requestUpdate();
  }
  validate() {
    let e2 = i$2(this.type);
    return has("safari") && has("safari") < 9 && (e2 = new s$1Z("mapview:browser-not-supported", "This browser is not supported by MapView (Safari < 9)", { type: "safari", requiredVersion: 9, detectedVersion: has("safari") })), r$1t(e2) ? (s$22.getLogger(this.declaredClass).warn("#validate()", e2.message), Promise.reject(e2)) : me();
  }
  _createAnimation() {
    return this.animation && !this.animation.done || (this.animation = new p$i()), this.animation;
  }
  _cancellableGoTo(e2, t2, i2) {
    const s2 = () => e2 === this._gotoTask, r2 = i2.then(() => {
      s2() && (this.animation = null);
    }).catch((e3) => {
      throw s2() && (this.animation = null, t2.done || (t2.stop(), this.frameTask.animationInProgress = false)), e3;
    }), n2 = new Promise((e3) => e3(r2));
    return t2.when().catch(() => {
      s2() && n2.cancel && n2.cancel();
    }), n2;
  }
  _gotoImmediate(e2, t2) {
    const i2 = this._gotoTask, s2 = this.animation, r2 = e2.then((e3) => {
      if (f$1x(t2), i2 !== this._gotoTask)
        throw new s$1Z("view:goto-interrupted", "Goto was interrupted");
      this.viewpoint = s2.target = e3, s2.finish();
    });
    return this._cancellableGoTo(i2, s2, r2);
  }
  _flipStationary(e2) {
    return this._stationaryTimer !== null || (this._stationaryTimer = setTimeout(() => {
      this._stationaryTimer = null;
      const e3 = performance.now() - this._lastStationaryEventTimestamp;
      e3 < ye && (this._stationaryTimer = this._flipStationary(e3));
    }, e2)), this._stationaryTimer;
  }
  _getDefaultViewpoint() {
    var _a2, _b2, _c2, _d2;
    const { constraints: e2, initialExtent: t2, map: s2, padding: r2, size: n2 } = this;
    if (!e2)
      return null;
    const a2 = s2 && "initialViewProperties" in s2 && s2.initialViewProperties, o2 = { zoom: this._get("zoom"), scale: this._get("scale"), center: this._get("center"), extent: this._get("extent"), rotation: this._get("rotation"), viewpoint: this._get("viewpoint"), spatialReference: this._userSpatialReference };
    e2.effectiveLODs ? o2.zoom !== -1 && (o2.scale = e2.zoomToScale(o2.zoom)) : o2.zoom = -1;
    let h2 = null, c2 = null, d2 = 0;
    const u2 = o2.viewpoint && o2.viewpoint.rotation, g2 = o2.viewpoint && o2.viewpoint.targetGeometry;
    r$1t(g2) && (g2.type === "extent" ? h2 = g2 : g2.type === "point" && (c2 = g2, d2 = o2.viewpoint.scale));
    const m2 = o2.extent || h2 || ((_b2 = e$1U((_a2 = a2 == null ? void 0 : a2.viewpoint) == null ? void 0 : _a2.targetGeometry)) == null ? void 0 : _b2.extent) || t2, y2 = o2.center || c2 || (m2 == null ? void 0 : m2.center), w2 = o2.scale || d2 || ((_c2 = a2 == null ? void 0 : a2.viewpoint) == null ? void 0 : _c2.scale) || m2 && H(m2, [n2[0] - r2.left - r2.right, n2[1] - r2.top - r2.bottom]), f2 = o2.rotation || u2 || ((_d2 = a2 == null ? void 0 : a2.viewpoint) == null ? void 0 : _d2.rotation) || 0;
    return y2 && w2 ? new u$17({ targetGeometry: y2, scale: w2, rotation: f2 }) : null;
  }
  _gotoAnimated(e2, t2) {
    const i2 = this._gotoTask, s2 = this.animation, r2 = e2.then((e3) => {
      if (f$1x(t2), i2 !== this._gotoTask)
        throw new s$1Z("view:goto-interrupted", "Goto was interrupted");
      return s2.update(e3), this.animationManager.animate(s2, this.viewpoint, t2), s2.when().then(() => {
      }, () => {
      });
    });
    return this._cancellableGoTo(i2, s2, r2);
  }
  _project(e2, t2) {
    var _a2;
    const i2 = e2 && e2.targetGeometry || e2;
    if (!t2)
      return e2;
    if (!i2)
      return null;
    if (t2.imageCoordinateSystem || ((_a2 = i2.spatialReference) == null ? void 0 : _a2.imageCoordinateSystem))
      return e2;
    if (E$u(t2, i2.spatialReference))
      return e2;
    const s2 = rn(i2, t2);
    if (!s2)
      throw new s$1Z("mapview:projection-not-possible", "projecting input geometry to target spatial reference returned a null value", { geometry: i2, spatialReference: t2 });
    return we(e2) ? (e2.targetGeometry = s2, e2) : s2;
  }
  _resizeHandler(e2) {
    if (!this.ready)
      return;
    const t2 = this.state;
    let i2 = this.state.paddedViewState.viewpoint;
    const s2 = this.state.paddedViewState.size.concat();
    t2.size = [e2.width, e2.height], ht(i2, i2, s2, this.state.paddedViewState.size, this.resizeAlign), i2 = this.constraints.constrain(i2, null), this.state.viewpoint = i2;
  }
  _startup() {
    var _a2, _b2;
    this.timeline.begin("MapView Startup");
    const e2 = this._getDefaultViewpoint(), t2 = e2.targetGeometry;
    try {
      this._project(e2, this.spatialReference);
    } catch (l2) {
      s$22.getLogger(this.declaredClass).warn(new t$1Q("mapview:startup-projection-error", "projection of initial viewpoint to the view's spatial reference, defaulting to the initial viewpoint.", { center: t2.toJSON(), spatialReference: this.spatialReference, error: l2 })), e2.targetGeometry = ((_a2 = this.defaultsFromMap.extent) == null ? void 0 : _a2.center) || new w$K({ x: 0, y: 0, spatialReference: this.spatialReference });
    }
    (_b2 = this.constraints) == null ? void 0 : _b2.fit(e2), this._set("state", new f$5({ padding: this._get("padding"), size: this.size, viewpoint: e2 })), this.graphics.owner = this;
    const i2 = new pe(this.surface, { canvas: this.renderCanvas, supersampleScreenshots: this.supersampleScreenshotsEnabled, contextOptions: { disabledExtensions: this.deactivatedWebGLExtensions, debugWebGLExtensions: this.debugWebGLExtensions }, renderingOptions: this.renderingOptions, timeline: this.timeline });
    this._stage = i2, this._magnifierView = new ge(), this._magnifierView.magnifier = this.magnifier;
    const s2 = new de({ view: this });
    this._set("labelManager", s2);
    const r2 = new d$8({ view: this });
    this._set("animationManager", r2);
    const n2 = new ue({ view: this, animationManager: r2 });
    this._set("mapViewNavigation", n2), this._setupSpatialReferenceDependentProperties(), this.handles.add([this.rootLayerViews.on("change", () => this._updateStageChildren()), i2.on("post-render", () => this._set("rendering", i2.renderRequested)), i2.on("will-render", () => this._set("rendering", i2.renderRequested)), i2.on("webgl-error", (e3) => this.fatalError = e3.error), l$1f(() => this.stationary, (e3) => i2.stationary = e3, w$A), l$1f(() => this.background, (e3) => {
      i2.background = e3, this._magnifierView.background = e3;
    }, w$A), l$1f(() => this.magnifier, (e3) => this._magnifierView.magnifier = e3, w$A), l$1f(() => this.renderingOptions, (e3) => i2.renderingOptions = e3, w$A), l$1f(() => this.highlightOptions, (e3) => i2.highlightOptions = e3, w$A), l$1f(() => this.state.id, () => i2.state = this.state, w$A)], "map-view"), this._updateStageChildren();
    const a2 = this._resolveWhenReady;
    this._resolveWhenReady = [], a2.forEach((e3) => e3(this)), this.timeline.end("MapView Startup"), this.frameTask && this.frameTask.start(), this._set("ready", true);
  }
  _teardown() {
    this._destroySpatialReferenceDependentProperties(), this.handles.remove("map-view"), this.mapViewNavigation.destroy(), this._set("mapViewNavigation", null), this.animationManager.destroy(), this._set("animationManager", null), this.layerViewManager.clear(), this.labelManager.destroy(), this._magnifierView.destroy(), this._stage.destroy(), this._stage = null, this._set("graphicsView", null), this._magnifierView = null, this._set("labelManager", null), this._set("mapViewNavigation", null), this.graphics.owner = null, this.frameTask && this.frameTask.stop(), this._stationaryTimer && (clearTimeout(this._stationaryTimer), this._stationaryTimer = null), this._set("ready", false);
    const { center: [e2, t2], spatialReference: i2, rotation: s2, scale: r2 } = this.state.paddedViewState, n2 = new w$K({ x: e2, y: t2, spatialReference: i2 });
    this._set("viewpoint", null), this._set("extent", null), this._set("center", n2), this._set("zoom", -1), this._set("rotation", s2), this._set("scale", r2), this._set("spatialReference", i2), this._set("state", null), this.animation = null;
  }
  _updateStageChildren() {
    this._stage.removeAllChildren(), this.rootLayerViews.forEach((e3) => {
      this._stage.addChild(e3.container);
    });
    const e2 = this.graphicsView;
    this._stage.addChild(e2.container), this._stage.addChild(this._magnifierView);
  }
  _setupSpatialReferenceDependentProperties() {
    const e2 = new h$7(j$q.create({ spatialReference: this.spatialReference, size: 512, numLODs: 36 }));
    this._set("featuresTilingScheme", e2);
    const t2 = new he({ view: this, graphics: this.graphics, requestUpdateCallback: () => this.requestUpdate(), container: new ce(e2) });
    this.frameTask.graphicsView = t2, this._set("graphicsView", t2);
  }
  _destroySpatialReferenceDependentProperties() {
    const e2 = this.graphicsView;
    this._set("graphicsView", null), this.frameTask.graphicsView = null, e2.destroy(), this._set("featuresTilingScheme", null);
  }
  _spatialReferenceChanged(e2) {
    if (!this.ready)
      return;
    this.frameTask.stop();
    for (const i2 of this.allLayerViews)
      i2.processDetach();
    this._destroySpatialReferenceDependentProperties();
    const t2 = this.state.paddedViewState.clone();
    if (t$1W(this._scaleBeforeChangingSpatialReference))
      this._scaleBeforeChangingSpatialReference = t2.scale;
    else {
      const e3 = t2.viewpoint.clone();
      e3.scale = this._scaleBeforeChangingSpatialReference, t2.viewpoint = e3;
    }
    const s2 = t2.clone(), [r2, n2] = t2.center;
    let a2 = null;
    try {
      a2 = this._project(new w$K({ x: r2, y: n2, spatialReference: t2.spatialReference }), e2);
    } catch (p2) {
      en() || s$22.getLogger(this.declaredClass).warn(new t$1Q("mapview:spatial-reference-change", "could not project the view's center to the new spatial reference", { center: a2.toJSON(), spatialReference: e2, error: p2 }));
    }
    a2 || (a2 = new w$K({ x: 0, y: 0, spatialReference: e2 }));
    const l2 = xt(new u$17({ targetGeometry: new w$K(), scale: 0, rotation: 0 }), t2.viewpoint, a2);
    s2.viewpoint = l2;
    try {
      const i2 = 20, r3 = [t2.size[0] / 2, t2.size[1] / 2], n3 = [r3[0] + i2, r3[1]], a3 = t2.toMap([0, 0], n3), { x: o2, y: p2 } = this._project(new w$K({ x: a3[0], y: a3[1], spatialReference: t2.spatialReference }), e2);
      a3[0] = o2, a3[1] = p2, s2.toScreen(a3, a3);
      const h2 = pt(r3, a3, n3), c2 = Math.hypot(a3[0] - r3[0], a3[1] - r3[1]) / i2;
      !Number.isFinite(c2) || Math.abs(c2) > 4 ? (l2.rotation = 0, l2.targetGeometry = new w$K({ x: 0, y: 0, spatialReference: e2 })) : (l2.scale *= c2, l2.scale > has("mapview-srswitch-adjust-rotation-scale-threshold") ? l2.rotation = 0 : l2.rotation += Number.isFinite(h2) ? h2 : 0);
    } catch {
    }
    this._get("constraints").constrain(l2, null), this._get("state").viewpoint = l2, this._stage.state = this.state, this._setupSpatialReferenceDependentProperties();
    for (const i2 of this.allLayerViews)
      i2.processAttach();
    this.frameTask.requestFrame(), this.frameTask.start(), this._updateStageChildren();
  }
};
fe.type = "2d", e$1W([y$1o({ readOnly: true })], fe.prototype, "animationManager", void 0), e$1W([y$1o({ constructOnly: true })], fe.prototype, "deactivatedWebGLExtensions", void 0), e$1W([y$1o({ constructOnly: true })], fe.prototype, "debugWebGLExtensions", void 0), e$1W([y$1o({ readOnly: true })], fe.prototype, "featuresTilingScheme", void 0), e$1W([y$1o({ readOnly: true })], fe.prototype, "fullOpacity", void 0), e$1W([y$1o({ readOnly: true })], fe.prototype, "graphicsTileStore", null), e$1W([y$1o()], fe.prototype, "graphicsView", void 0), e$1W([y$1o({ readOnly: true })], fe.prototype, "state", void 0), e$1W([y$1o()], fe.prototype, "initialExtentRequired", null), e$1W([y$1o()], fe.prototype, "labelManager", void 0), e$1W([y$1o({ readOnly: true })], fe.prototype, "resourceManager", null), e$1W([y$1o({ readOnly: true })], fe.prototype, "textureManager", null), e$1W([y$1o({ readOnly: true })], fe.prototype, "mapViewNavigation", void 0), e$1W([y$1o({ constructOnly: true })], fe.prototype, "renderCanvas", void 0), e$1W([y$1o()], fe.prototype, "renderingOptions", void 0), e$1W([y$1o({ readOnly: true })], fe.prototype, "rendering", void 0), e$1W([y$1o({ constructOnly: true })], fe.prototype, "supersampleScreenshotsEnabled", void 0), e$1W([y$1o({ readOnly: true })], fe.prototype, "supportsGround", void 0), e$1W([y$1o()], fe.prototype, "_stationaryTimer", void 0), e$1W([y$1o()], fe.prototype, "_defaultsFromMapSettings", null), e$1W([y$1o()], fe.prototype, "_pePromise", void 0), e$1W([y$1o({ readOnly: true })], fe.prototype, "typeSpecificPreconditionsReady", null), e$1W([y$1o()], fe.prototype, "animation", null), e$1W([y$1o({ type: m })], fe.prototype, "background", null), e$1W([y$1o({ value: null, type: w$K, dependsOn: ["state.id", "ready"] })], fe.prototype, "center", null), e$1W([y$1o({ type: u$d })], fe.prototype, "constraints", null), e$1W([y$1o({ value: null, type: w$J, dependsOn: ["state.id", "ready"] })], fe.prototype, "extent", null), e$1W([y$1o()], fe.prototype, "floors", void 0), e$1W([y$1o({ type: c$9 })], fe.prototype, "highlightOptions", void 0), e$1W([y$1o({ readOnly: true })], fe.prototype, "inputManager", void 0), e$1W([y$1o()], fe.prototype, "map", void 0), e$1W([y$1o({ value: { top: 0, right: 0, bottom: 0, left: 0 }, cast: (e2) => __spreadValues({ top: 0, right: 0, bottom: 0, left: 0 }, e2) })], fe.prototype, "padding", null), e$1W([y$1o()], fe.prototype, "resizeAlign", void 0), e$1W([y$1o({ readOnly: true, dependsOn: ["state.id"] })], fe.prototype, "resolution", null), e$1W([y$1o({ value: 0, type: Number, dependsOn: ["state.id", "ready"] })], fe.prototype, "rotation", null), e$1W([y$1o({ value: 0, type: Number, dependsOn: ["state.id", "ready"] })], fe.prototype, "scale", null), e$1W([y$1o({ constructOnly: true })], fe.prototype, "spatialReferenceLocked", void 0), e$1W([y$1o()], fe.prototype, "stationary", null), e$1W([y$1o({ type: e$1, readOnly: true })], fe.prototype, "timeline", void 0), e$1W([y$1o({ readOnly: true })], fe.prototype, "type", void 0), e$1W([y$1o({ readOnly: true })], fe.prototype, "updating", null), e$1W([y$1o({ value: null, type: u$17, dependsOn: ["state.id", "ready"] })], fe.prototype, "viewpoint", null), e$1W([y$1o({ value: -1, dependsOn: ["state.id", "ready"] })], fe.prototype, "zoom", null), e$1W([y$1o({ readOnly: true })], fe.prototype, "navigating", null), e$1W([y$1o({ type: p$1 })], fe.prototype, "ui", void 0), fe = e$1W([n$2f("esri.views.MapView")], fe);
const _e = fe;
function ve(e2) {
  var _a2, _b2, _c2, _d2;
  const t2 = e2.getObjectId();
  return t2 ? `${(_d2 = (_c2 = (_a2 = e2.layer) == null ? void 0 : _a2.uid) != null ? _c2 : (_b2 = e2.sourceLayer) == null ? void 0 : _b2.uid) != null ? _d2 : "MapView"}/${t2}` : `"MapView/${e2.uid}`;
}
function Ve(e2, i2, s2, r2, n2) {
  return (a2) => {
    if (a2 instanceof g$J) {
      if (a2.layer === e2)
        n2 == null ? void 0 : n2();
      else {
        const t2 = e2.allLayerViews.find((e3) => e3.layer === a2.layer);
        t2 && (r2 == null ? void 0 : r2(t2));
      }
      s2(ve(a2));
    } else {
      const t2 = e2.allLayerViews.find((e3) => e3.layer === a2);
      t2 && i2(t2);
    }
  };
}
function Se(e2, t2) {
  if (e2)
    if (t$1O(e2))
      for (const i2 of e2)
        if (t$1O(i2))
          for (const e3 of i2)
            t2(e3);
        else
          t2(i2);
    else
      t2(e2);
}
function je(e2) {
  return (e2 == null ? void 0 : e2.declaredClass) === "esri.WebMap";
}
var index_vue_vue_type_style_index_0_scoped_true_lang = "";
var index_vue_vue_type_style_index_1_lang = "";
const _sfc_main = /* @__PURE__ */ defineComponent({
  props: {
    basemap: null
  },
  setup(__props, { expose }) {
    const props = __props;
    const refMap = ref();
    const init = (options) => {
      const map = new L$4({
        basemap: props.basemap || "satellite"
      });
      const view = new _e({
        container: refMap.value,
        map,
        center: (options == null ? void 0 : options.center) || [117.09, 30.64],
        zoom: (options == null ? void 0 : options.zoom) || 5,
        highlightOptions: {
          fillOpacity: 0,
          haloOpacity: 0.7
        }
      });
      view.ui.remove("attribution");
      view.ui.remove("zoom");
      view.ui.padding = {
        bottom: 15,
        left: 15,
        right: 15,
        top: 15
      };
      return view;
    };
    expose({
      init
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        id: "viewDiv",
        ref: (_value, _refs) => {
          _refs["refMap"] = _value;
          refMap.value = _value;
        },
        class: "viewDiv"
      }, null, 512);
    };
  }
});
var ArcMap = /* @__PURE__ */ _export_sfc(_sfc_main, [["__scopeId", "data-v-4e3312b8"]]);
const ArcMapPlugin = {
  install(app) {
    app.component("ms-arc-map", ArcMap);
  }
};
const MYKitPlugin = {
  install(app) {
    var _a2, _b2;
    (_a2 = ButtonPlugin.install) == null ? void 0 : _a2.call(ButtonPlugin, app);
    (_b2 = ArcMapPlugin.install) == null ? void 0 : _b2.call(ArcMapPlugin, app);
  }
};
export { e$1W as $, u$1r as A, n$e as B, d$1x as C, D$s as D, n$1X as E, e$b as F, o$1m as G, l$h as H, f$7 as I, h$9 as J, r$h as K, r$13 as L, M, n$26 as N, e$1 as O, A$o as P, r$1j as Q, l$1f as R, h$S as S, m$4 as T, U$k as U, a$21 as V, i$12 as W, m$G as X, a$1s as Y, m$1L as Z, e$11 as _, r$1t as a, u$G as a$, y$1o as a0, n$2f as a1, P$5 as a2, c$2b as a3, s$1r as a4, g$R as a5, u$17 as a6, w$K as a7, f$10 as a8, St as a9, t$O as aA, i$6 as aB, U$b as aC, E$n as aD, e$1e as aE, c$2y as aF, s$1u as aG, l$4 as aH, s$1n as aI, l$1v as aJ, k$p as aK, w$O as aL, f$1j as aM, u$1D as aN, g$X as aO, s$1E as aP, l$1S as aQ, O$4 as aR, j$7 as aS, N$2 as aT, r$f as aU, i$e as aV, t$a as aW, y$1r as aX, d$K as aY, n$1e as aZ, e$O as a_, i$1P as aa, r$14 as ab, nt as ac, s$f as ad, Gt as ae, n$j as af, $ as ag, bt as ah, pt as ai, a$q as aj, Rt as ak, t$1N as al, j$o as am, It$1 as an, R$n as ao, u$1p as ap, v$O as aq, c$2v as ar, et$1 as as, y$1a as at, r$1d as au, q$c as av, C$d as aw, ht$1 as ax, at$1 as ay, $$4 as az, s$24 as b, rt$1 as b$, l$1D as b0, f$1F as b1, e$1K as b2, o$1Z as b3, i$2y as b4, U$q as b5, t$1V as b6, M$q as b7, s$1H as b8, u$1H as b9, I$v as bA, E$u as bB, g$_ as bC, ln as bD, e$9 as bE, Gt$1 as bF, nt$1 as bG, o$1j as bH, f$g as bI, c$X as bJ, w$g as bK, b$i as bL, p$16 as bM, j$y as bN, j$B as bO, c$1_ as bP, d$w as bQ, r$u as bR, s$x as bS, y$f as bT, p$2W as bU, e$C as bV, m$A as bW, t$D as bX, c$z as bY, m$n as bZ, d$k as b_, i$2d as ba, G$h as bb, o$1z as bc, s$1J as bd, g$W as be, h$e as bf, n$w as bg, o$p as bh, z$2 as bi, i$y as bj, e$l as bk, a$D as bl, o$1f as bm, e$1h as bn, m$1p as bo, o$1v as bp, c$2T as bq, p$2N as br, k$q as bs, r$D as bt, s$T as bu, m$1F as bv, i$1d as bw, y$1d as bx, d$1s as by, _n as bz, a$2y as c, g$g as c$, v$N as c0, tt$1 as c1, lt$1 as c2, ot$1 as c3, e$L as c4, Mt as c5, pt$1 as c6, A$u as c7, E$x as c8, r$q as c9, a$1I as cA, m$1h as cB, g$J as cC, o$1H as cD, x$j as cE, _$t as cF, g$12 as cG, u$12 as cH, l$b as cI, w$e as cJ, y$j as cK, g$l as cL, T$n as cM, v$L as cN, x$i as cO, i$26 as cP, W$a as cQ, D$o as cR, j$E as cS, O$l as cT, z$p as cU, h$1c as cV, w$H as cW, xe$1 as cX, x$L as cY, f$n as cZ, b$b as c_, f$8 as ca, b$2 as cb, K$3 as cc, J$3 as cd, s$b as ce, s$q as cf, b$X as cg, $$a as ch, e$17 as ci, a$1G as cj, s$1F as ck, X$6 as cl, nt$2 as cm, s$1N as cn, l$1_ as co, m$1D as cp, u$1I as cq, w$J as cr, E$v as cs, h$7 as ct, y$2 as cu, r$a as cv, p$2R as cw, j$F as cx, n$1N as cy, w$A as cz, d$1F as d, x$7 as d$, j$u as d0, C$n as d1, f$1c as d2, j$q as d3, k$o as d4, t$E as d5, p$19 as d6, t$1f as d7, U$i as d8, d$O as d9, i$29 as dA, T$b as dB, v$V as dC, r$1h as dD, t$1u as dE, v$s as dF, s$U as dG, i$1e as dH, y$Z as dI, r$1r as dJ, f$X as dK, r$1m as dL, c$23 as dM, un as dN, c$i as dO, S$A as dP, o$b as dQ, s$1L as dR, l$1g as dS, o$1w as dT, i$28 as dU, j$v as dV, r$1a as dW, r$e as dX, a$$ as dY, e$g as dZ, t$s as d_, i$q as da, m$1v as db, en as dc, tn as dd, rn as de, An as df, E$i as dg, s$1a as dh, P$f as di, a$1z as dj, O$d as dk, sn as dl, mt as dm, N$h as dn, a$1S as dp, L$j as dq, f$N as dr, I$o as ds, S$y as dt, s$1k as du, Bt as dv, a$1X as dw, C$k as dx, f$1m as dy, f$1b as dz, a$2z as e, x$A as e$, b$h as e0, d$t as e1, j$H as e2, w$E as e3, M$s as e4, c$2W as e5, y$1i as e6, t$16 as e7, b$w as e8, R$k as e9, v$P as eA, l$1T as eB, e$1x as eC, o$1B as eD, Z$7 as eE, r$1e as eF, i$2f as eG, X$4 as eH, o$1F as eI, It as eJ, F$8 as eK, D$8 as eL, O$8 as eM, l$1Q as eN, o$1W as eO, l$22 as eP, x$N as eQ, a$9 as eR, p$32 as eS, n$2o as eT, r$12 as eU, P$m as eV, _$x as eW, l$1E as eX, H$c as eY, e$1k as eZ, z$o as e_, p$2S as ea, y$p as eb, m$B as ec, a$20 as ed, m$I as ee, p$1o as ef, M$o as eg, s$R as eh, c$2F as ei, Ut as ej, D$j as ek, G$d as el, gt$1 as em, h$F as en, r$H as eo, h$1s as ep, s$26 as eq, w$D as er, F$2 as es, x$M as et, b$W as eu, l$D as ev, o$x as ew, S$9 as ex, e$N as ey, te$3 as ez, c$2V as f, Ie$1 as f$, u$1t as f0, r$11 as f1, i$1Q as f2, b$K as f3, P$g as f4, h$N as f5, O$j as f6, O$f as f7, Zn as f8, u$10 as f9, Y$8 as fA, n$1W as fB, r$w as fC, d$M as fD, i$2x as fE, g$n as fF, x$k as fG, n$2k as fH, f$L as fI, a$1i as fJ, it$1 as fK, c$1h as fL, s$11 as fM, t$$ as fN, S$j as fO, c$1z as fP, y$14 as fQ, A$p as fR, c$1F as fS, v$a as fT, x$e as fU, i$1f as fV, X$1 as fW, p$2M as fX, ie$3 as fY, ae$2 as fZ, fe$2 as f_, xn as fa, C$h as fb, F$j as fc, B$b as fd, t$1q as fe, u$1M as ff, P$p as fg, s$1O as fh, a$l as fi, c$2D as fj, g$4 as fk, B$1 as fl, i$1w as fm, L$h as fn, E$k as fo, a$23 as fp, a$22 as fq, s$1q as fr, l$1F as fs, y$16 as ft, j$C as fu, x$z as fv, q$d as fw, v$J as fx, D$l as fy, E$p as fz, s$1Z as g, closestElementCrossShadowBoundary as g$, A$j as g0, o$15 as g1, y$H as g2, n$Z as g3, e$1E as g4, t$N as g5, q$5 as g6, c$1i as g7, d$F as g8, ft$1 as g9, u$H as gA, n$X as gB, r$y as gC, g$F as gD, L$l as gE, t$1U as gF, o$1N as gG, n$2e as gH, ht$2 as gI, z$m as gJ, mt$2 as gK, i$2a as gL, t$1J as gM, proxyCustomElement as gN, H$8 as gO, h$K as gP, Build as gQ, createEvent as gR, toAriaBoolean as gS, forceUpdate as gT, queryElementRoots as gU, Host as gV, isPrimaryPointerButton as gW, focusElement as gX, Fragment as gY, getElementDir as gZ, getAssetPath as g_, h$R as ga, y$o as gb, L$r as gc, w$n as gd, M$7 as ge, _$i as gf, s$1M as gg, o$K as gh, m$1U as gi, d$4 as gj, q$i as gk, ut$1 as gl, e$K as gm, o$1Y as gn, E$q as go, T$r as gp, p$1m as gq, a$1q as gr, s$17 as gs, p$2r as gt, A$l as gu, q$e as gv, v$K as gw, t$1H as gx, o$e as gy, u$1v as gz, has as h, d$s as h$, C$s as h0, p$U as h1, c$G as h2, v$b as h3, O$6 as h4, w$R as h5, v$h as h6, f$r as h7, m$1T as h8, y$1h as h9, Q$9 as hA, n$1M as hB, C$q as hC, h$1g as hD, e$D as hE, F$h as hF, t$1h as hG, c$21 as hH, S$x as hI, o$1d as hJ, a$1u as hK, t$P as hL, c$1y as hM, d$B as hN, r$A as hO, v$p as hP, K$4 as hQ, a$1g as hR, m$1g as hS, i$O as hT, o$1X as hU, p$1y as hV, l$q as hW, s$25 as hX, Ze as hY, o$l as hZ, o$A as h_, G$c as ha, kt$1 as hb, m$v as hc, w$f as hd, p$1f as he, Ot as hf, c$1N as hg, p$21 as hh, a$1O as hi, setRequestedIcon as hj, getSlotted as hk, b$U as hl, o$M as hm, e$W as hn, M$d as ho, n$1k as hp, s$1f as hq, v$A as hr, e$R as hs, p$31 as ht, y$12 as hu, Z$4 as hv, t$1e as hw, F$g as hx, J$9 as hy, t$1T as hz, i$2w as i, y$t as i$, n$1q as i0, l$Q as i1, n$N as i2, t$u as i3, p$D as i4, S$c as i5, y$h as i6, p$z as i7, n$T as i8, p$P as i9, t$j as iA, y$9 as iB, e$1Q as iC, G$i as iD, c$O as iE, m$1q as iF, n$1C as iG, S$t as iH, c$E as iI, o$B as iJ, n$F as iK, p$S as iL, a$I as iM, F$k as iN, x$B as iO, m$q as iP, j$6 as iQ, i$A as iR, w$d as iS, p$15 as iT, l$J as iU, p$A as iV, n$A as iW, j$f as iX, s$P as iY, j$N as iZ, e$p as i_, s$t as ia, t$1Q as ib, i$u as ic, t$1l as id, i$N as ie, n$t as ig, b$e as ih, d$n as ii, j$9 as ij, y$k as ik, h$m as il, L$a as im, b$f as io, u$1Y as ip, f$1E as iq, p$2a as ir, f$18 as is, u$1N as it, l$1R as iu, s$1h as iv, a$2w as iw, on as ix, l$o as iy, d$c as iz, c$2d as j, L$9 as j$, j$g as j0, n$$ as j1, M$9 as j2, T$8 as j3, N$5 as j4, m$F as j5, _$g as j6, a$13 as j7, C$9 as j8, a$1d as j9, K$8 as jA, p$1R as jB, ft$2 as jC, n$2m as jD, i$1W as jE, Ct as jF, l$29 as jG, o$F as jH, a$V as jI, t$F as jJ, t$A as jK, p$I as jL, r$$ as jM, I$9 as jN, v$g as jO, s$1W as jP, M$i as jQ, t$Q as jR, y$l as jS, p$1n as jT, a$N as jU, u$u as jV, c$K as jW, M$3 as jX, F$4 as jY, x$d as jZ, P$8 as j_, n$U as ja, S$b as jb, mn as jc, d$1B as jd, m$1j as je, R$j as jf, t$1L as jg, K$7 as jh, U$l as ji, V$a as jj, s$1_ as jk, d$1b as jl, x$w as jm, u$1X as jn, y$1u as jo, u$1o as jp, c$22 as jq, m$1o as jr, s$21 as js, c$1k as jt, p$N as ju, n$2d as jv, a$v as jw, m$17 as jx, h$13 as jy, I$q as jz, e$1U as k, request as k$, O$5 as k0, v$f as k1, E$9 as k2, I$8 as k3, T$3 as k4, j$8 as k5, M$4 as k6, D$4 as k7, G$4 as k8, v$R as k9, c$h as kA, i$d as kB, t$b as kC, e$1T as kD, c$1Z as kE, d$1e as kF, q$b as kG, G$7 as kH, f$1g as kI, c$1I as kJ, e$Q as kK, l$m as kL, e$Y as kM, A$i as kN, Y$7 as kO, p$1T as kP, f$W as kQ, gn as kR, _$v as kS, l$1H as kT, it$2 as kU, d$1i as kV, MYKitPlugin as kW, ButtonPlugin as kX, Button as kY, ArcMapPlugin as kZ, ArcMap as k_, a$2x as ka, H$b as kb, C$j as kc, a$1R as kd, y$11 as ke, u$1u as kf, h$17 as kg, i$1S as kh, e$1m as ki, c$2f as kj, u$w as kk, I$a as kl, g$$ as km, O$o as kn, r$1g as ko, s$1c as kp, s$M as kq, x$c as kr, n$23 as ks, L$p as kt, S$B as ku, m$1A as kv, _$e as kw, x$9 as kx, n$H as ky, m$O as kz, f$1x as l, query as l0, FeatureSet as l1, visualVariableUtils as l2, DictionaryLoader as l3, FeatureLayer as l4, j$K as m, n$2a as n, o, f$1d as p, b$T as q, r$1 as r, s$22 as s, t$1W as t, n$19 as u, v$S as v, a$2p as w, l$e as x, s$23 as y, r$i as z };
