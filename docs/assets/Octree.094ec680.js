import{fY as et,gs as nt,jb as Ot,g0 as v,aJ as y,gg as A,jz as Rt,hg as mt,hn as At,ho as Et,gk as Nt,jH as bt,ai as gt,fQ as S,jI as pt,gz as F,ag as N,bN as Ft,iD as H,O as U,jJ as w,gq as rt,jK as K,g4 as ot,jL as $,jM as st,g2 as it,gn as x,f2 as Mt,aP as T}from"./vendor.1bde3be2.js";import{c as ht}from"./Util.96d35f9a.js";function V(r){return r?{ray:nt(r.ray),c0:r.c0,c1:r.c1}:{ray:nt(),c0:0,c1:Number.MAX_VALUE}}function Dt(r,t=V()){return Ot(r,t.ray),t.c0=0,t.c1=Number.MAX_VALUE,t}function vt(r,t){return at(r,r.c0,t)}function yt(r,t){return at(r,r.c1,t)}function at(r,t,e){return v(e,r.ray.origin,y(e,r.ray.direction,t))}new et(()=>V());function wt(r){return r?[A(r[0]),A(r[1]),A(r[2]),A(r[3]),A(r[4]),A(r[5])]:[A(),A(),A(),A(),A(),A()]}function Bt(){return[N(),N(),N(),N(),N(),N(),N(),N()]}function qt(r,t){for(let e=0;e<z.NUM;e++)Rt(r[e],t[e])}function kt(r,t,e,n=St){const o=mt(At.get(),t,r);Et(o,o);for(let s=0;s<W.NUM;++s){const h=Nt(bt.get(),It[s],o);gt(n[s],h[0]/h[3],h[1]/h[3],h[2]/h[3])}jt(e,n)}function jt(r,t){S(t[i.FAR_BOTTOM_LEFT],t[i.NEAR_BOTTOM_LEFT],t[i.NEAR_TOP_LEFT],r[M.LEFT]),S(t[i.NEAR_BOTTOM_RIGHT],t[i.FAR_BOTTOM_RIGHT],t[i.FAR_TOP_RIGHT],r[M.RIGHT]),S(t[i.FAR_BOTTOM_LEFT],t[i.FAR_BOTTOM_RIGHT],t[i.NEAR_BOTTOM_RIGHT],r[M.BOTTOM]),S(t[i.NEAR_TOP_LEFT],t[i.NEAR_TOP_RIGHT],t[i.FAR_TOP_RIGHT],r[M.TOP]),S(t[i.NEAR_BOTTOM_LEFT],t[i.NEAR_BOTTOM_RIGHT],t[i.NEAR_TOP_RIGHT],r[M.NEAR]),S(t[i.FAR_BOTTOM_RIGHT],t[i.FAR_BOTTOM_LEFT],t[i.FAR_TOP_LEFT],r[M.FAR])}function q(r,t){for(let e=0;e<z.NUM;e++){const n=r[e];if(n[0]*t[0]+n[1]*t[1]+n[2]*t[2]+n[3]>=t[3])return!1}return!0}function Ct(r,t){for(let e=0;e<z.NUM;e++){const n=r[e];if(!pt(n,t))return!1}return!0}var M,i;(function(r){r[r.LEFT=0]="LEFT",r[r.RIGHT=1]="RIGHT",r[r.BOTTOM=2]="BOTTOM",r[r.TOP=3]="TOP",r[r.NEAR=4]="NEAR",r[r.FAR=5]="FAR"})(M||(M={})),function(r){r[r.NEAR_BOTTOM_LEFT=0]="NEAR_BOTTOM_LEFT",r[r.NEAR_BOTTOM_RIGHT=1]="NEAR_BOTTOM_RIGHT",r[r.NEAR_TOP_RIGHT=2]="NEAR_TOP_RIGHT",r[r.NEAR_TOP_LEFT=3]="NEAR_TOP_LEFT",r[r.FAR_BOTTOM_LEFT=4]="FAR_BOTTOM_LEFT",r[r.FAR_BOTTOM_RIGHT=5]="FAR_BOTTOM_RIGHT",r[r.FAR_TOP_RIGHT=6]="FAR_TOP_RIGHT",r[r.FAR_TOP_LEFT=7]="FAR_TOP_LEFT"}(i||(i={}));i.FAR_BOTTOM_RIGHT,i.NEAR_BOTTOM_RIGHT,i.NEAR_BOTTOM_LEFT,i.FAR_BOTTOM_LEFT,i.NEAR_BOTTOM_LEFT,i.NEAR_BOTTOM_RIGHT,i.NEAR_TOP_RIGHT,i.NEAR_TOP_LEFT,i.FAR_BOTTOM_RIGHT,i.FAR_BOTTOM_LEFT,i.FAR_TOP_LEFT,i.FAR_TOP_RIGHT,i.NEAR_BOTTOM_RIGHT,i.FAR_BOTTOM_RIGHT,i.FAR_TOP_RIGHT,i.NEAR_TOP_RIGHT,i.FAR_BOTTOM_LEFT,i.NEAR_BOTTOM_LEFT,i.NEAR_TOP_LEFT,i.FAR_TOP_LEFT,i.FAR_TOP_LEFT,i.NEAR_TOP_LEFT,i.NEAR_TOP_RIGHT,i.FAR_TOP_RIGHT;var z,W;(function(r){r[r.NUM=6]="NUM"})(z||(z={})),function(r){r[r.NUM=8]="NUM"}(W||(W={}));const It=[F(-1,-1,-1,1),F(1,-1,-1,1),F(1,1,-1,1),F(-1,1,-1,1),F(-1,-1,1,1),F(1,-1,1,1),F(1,1,1,1),F(-1,1,1,1)];new et(V);const St=Bt();class L{constructor(t,e){this._objectToBoundingSphere=t,this._maximumObjectsPerNode=10,this._maximumDepth=20,this._degenerateObjects=new Set,this._root=new l,this._objectCount=0,e&&(e.maximumObjectsPerNode!==void 0&&(this._maximumObjectsPerNode=e.maximumObjectsPerNode),e.maximumDepth!==void 0&&(this._maximumDepth=e.maximumDepth))}get bounds(){return this._root.bounds}get halfSize(){return this._root.halfSize}get root(){return this._root.node}get maximumObjectsPerNode(){return this._maximumObjectsPerNode}get maximumDepth(){return this._maximumDepth}get objectCount(){return this._objectCount}destroy(){this._degenerateObjects.clear(),l.clearPool(),X[0]=null,j.prune(),I.prune()}add(t,e=t.length){this._objectCount+=e,this._grow(t,e);const n=l.acquire();for(let o=0;o<e;o++){const s=t[o];this._isDegenerate(s)?this._degenerateObjects.add(s):(n.init(this._root),this._add(s,n))}l.release(n)}remove(t,e=null){this._objectCount-=t.length;const n=l.acquire();for(const o of t){const s=U(e)?e:w(this._objectToBoundingSphere(o),Ht);D(s[3])?(n.init(this._root),this._remove(o,s,n)):this._degenerateObjects.delete(o)}l.release(n),this._shrink()}update(t,e){if(!D(e[3])&&this._isDegenerate(t))return;const n=Gt(t);this.remove(n,e),this.add(n)}forEachAlongRay(t,e,n){const o=rt(t,e);this._forEachNode(this._root,s=>{if(!this._intersectsNode(o,s))return!1;const h=s.node;return h.terminals.forAll(a=>{this._intersectsObject(o,a)&&n(a)}),h.residents!==null&&h.residents.forAll(a=>{this._intersectsObject(o,a)&&n(a)}),!0})}forEachAlongRayWithVerticalOffset(t,e,n,o){const s=rt(t,e);this._forEachNode(this._root,h=>{if(!this._intersectsNodeWithOffset(s,h,o))return!1;const a=h.node;return a.terminals.forAll(d=>{this._intersectsObjectWithOffset(s,d,o)&&n(d)}),a.residents!==null&&a.residents.forAll(d=>{this._intersectsObjectWithOffset(s,d,o)&&n(d)}),!0})}forEach(t){this._forEachNode(this._root,e=>{const n=e.node;return n.terminals.forAll(t),n.residents!==null&&n.residents.forAll(t),!0}),this._degenerateObjects.forEach(t)}forEachDegenerateObject(t){this._degenerateObjects.forEach(t)}findClosest(t,e,n,o=()=>!0,s=1/0){let h=1/0,a=1/0,d=null;const u=J(t,e),f=c=>{if(--s,!o(c))return;const m=this._objectToBoundingSphere(c);if(!q(n,m))return;const g=B(t,e,$(m)),P=g-m[3],_=g+m[3];P<h&&(h=P,a=_,d=c)};return this._forEachNodeDepthOrdered(this._root,c=>{if(s<=0||!q(n,c.bounds)||(y(E,u,c.halfSize),v(E,E,c.bounds),B(t,e,E)>a))return!1;const m=c.node;return m.terminals.forAll(g=>f(g)),m.residents!==null&&m.residents.forAll(g=>f(g)),!0},t,e),d}forEachInDepthRange(t,e,n,o,s,h,a){let d=-1/0,u=1/0;const f={setRange:_=>{n===L.DepthOrder.FRONT_TO_BACK?(d=Math.max(d,_.near),u=Math.min(u,_.far)):(d=Math.max(d,-_.far),u=Math.min(u,-_.near))}};f.setRange(o);const c=B(e,n,t),m=J(e,n),g=J(e,-n),P=_=>{if(!a(_))return;const p=this._objectToBoundingSphere(_),G=$(p),tt=B(e,n,G)-c,ft=tt-p[3],Tt=tt+p[3];ft>u||Tt<d||!q(h,p)||s(_,f)};this._forEachNodeDepthOrdered(this._root,_=>{if(!q(h,_.bounds)||(y(E,m,_.halfSize),v(E,E,_.bounds),B(e,n,E)-c>u)||(y(E,g,_.halfSize),v(E,E,_.bounds),B(e,n,E)-c<d))return!1;const p=_.node;return p.terminals.forAll(G=>P(G)),p.residents!==null&&p.residents.forAll(G=>P(G)),!0},e,n)}forEachNode(t){this._forEachNode(this._root,e=>t(e.node,e.bounds,e.halfSize))}forEachNeighbor(t,e){const n=K(e),o=$(e),s=d=>{const u=this._objectToBoundingSphere(d),f=K(u),c=n+f;return!(ot($(u),o)-c*c<=0)||t(d)};let h=!0;const a=d=>{h&&(h=s(d))};this._forEachNode(this._root,d=>{const u=K(d.bounds),f=n+u;if(ot($(d.bounds),o)-f*f>0)return!1;const c=d.node;return c.terminals.forAll(a),h&&c.residents!==null&&c.residents.forAll(a),h}),h&&this.forEachDegenerateObject(a)}_intersectsNode(t,e){return k(e.bounds,2*-e.halfSize,O),k(e.bounds,2*e.halfSize,R),ht(t.origin,t.direction,O,R)}_intersectsNodeWithOffset(t,e,n){return k(e.bounds,2*-e.halfSize,O),k(e.bounds,2*e.halfSize,R),n.applyToMinMax(O,R),ht(t.origin,t.direction,O,R)}_intersectsObject(t,e){const n=this._objectToBoundingSphere(e);return!(n[3]>0)||st(n,t)}_intersectsObjectWithOffset(t,e,n){const o=this._objectToBoundingSphere(e);return!(o[3]>0)||st(n.applyToBoundingSphere(o),t)}_forEachNode(t,e){let n=l.acquire().init(t);const o=[n];for(;o.length!==0;){if(n=o.pop(),e(n)&&!n.isLeaf())for(let s=0;s<n.node.children.length;s++)n.node.children[s]&&o.push(l.acquire().init(n).advance(s));l.release(n)}}_forEachNodeDepthOrdered(t,e,n,o=L.DepthOrder.FRONT_TO_BACK){let s=l.acquire().init(t);const h=[s];for(Pt(n,o,_t);h.length!==0;){if(s=h.pop(),e(s)&&!s.isLeaf())for(let a=7;a>=0;--a){const d=_t[a];s.node.children[d]&&h.push(l.acquire().init(s).advance(d))}l.release(s)}}_remove(t,e,n){j.clear();const o=n.advanceTo(e,(s,h)=>{j.push(s.node),j.push(h)})?n.node.terminals:n.node.residents;if(o.removeUnordered(t),o.length===0)for(let s=j.length-2;s>=0;s-=2){const h=j.data[s],a=j.data[s+1];if(!this._purge(h,a))break}}_nodeIsEmpty(t){if(t.terminals.length!==0)return!1;if(t.residents!==null)return t.residents.length===0;for(let e=0;e<t.children.length;e++)if(t.children[e])return!1;return!0}_purge(t,e){return e>=0&&(t.children[e]=null),!!this._nodeIsEmpty(t)&&(t.residents===null&&(t.residents=new H({shrink:!0})),!0)}_add(t,e){e.advanceTo(this._objectToBoundingSphere(t))?e.node.terminals.push(t):(e.node.residents.push(t),e.node.residents.length>this._maximumObjectsPerNode&&e.depth<this._maximumDepth&&this._split(e))}_split(t){const e=t.node.residents;t.node.residents=null;for(let n=0;n<e.length;n++){const o=l.acquire().init(t);this._add(e.getItemAt(n),o),l.release(o)}}_grow(t,e){if(e!==0&&(dt(t,e,n=>this._objectToBoundingSphere(n),b),D(b[3])&&!this._fitsInsideTree(b)))if(this._nodeIsEmpty(this._root.node))w(b,this._root.bounds),this._root.halfSize=1.25*b[3];else{const n=this._rootBoundsForRootAsSubNode(b);this._placingRootViolatesMaxDepth(n)?this._rebuildTree(b,n):this._growRootAsSubNode(n),l.release(n)}}_rebuildTree(t,e){it(Y,e.bounds),Y[3]=e.halfSize,dt([t,Y],2,o=>o,Z);const n=l.acquire().init(this._root);this._root.initFrom(null,Z,1.25*Z[3]),this._forEachNode(n,o=>(this.add(o.node.terminals.data,o.node.terminals.length),o.node.residents!==null&&this.add(o.node.residents.data,o.node.residents.length),!0)),l.release(n)}_placingRootViolatesMaxDepth(t){const e=Math.log(t.halfSize/this._root.halfSize)*Math.LOG2E;let n=0;return this._forEachNode(this._root,o=>(n=Math.max(n,o.depth),n+e<=this._maximumDepth)),n+e>this._maximumDepth}_rootBoundsForRootAsSubNode(t){const e=t[3],n=t;let o=-1/0;const s=this._root.bounds,h=this._root.halfSize;for(let a=0;a<3;a++){const d=s[a]-h-(n[a]-e),u=n[a]+e-(s[a]+h),f=Math.max(0,Math.ceil(d/(2*h))),c=Math.max(0,Math.ceil(u/(2*h)))+1,m=2**Math.ceil(Math.log(f+c)*Math.LOG2E);o=Math.max(o,m),C[a].min=f,C[a].max=c}for(let a=0;a<3;a++){let d=C[a].min,u=C[a].max;const f=(o-(d+u))/2;d+=Math.ceil(f),u+=Math.floor(f);const c=s[a]-h-d*h*2;Q[a]=c+(u+d)*h}return Q[3]=o*h*ut,l.acquire().initFrom(null,Q,o*h,0)}_growRootAsSubNode(t){const e=this._root.node;it(b,this._root.bounds),b[3]=this._root.halfSize,this._root.init(t),t.advanceTo(b,null,!0),t.node.children=e.children,t.node.residents=e.residents,t.node.terminals=e.terminals}_shrink(){for(;;){const t=this._findShrinkIndex();if(t===-1)break;this._root.advance(t),this._root.depth=0}}_findShrinkIndex(){if(this._root.node.terminals.length!==0||this._root.isLeaf())return-1;let t=null;const e=this._root.node.children;let n=0,o=0;for(;o<e.length&&t==null;)n=o++,t=e[n];for(;o<e.length;)if(e[o++])return-1;return n}_isDegenerate(t){return!D(this._objectToBoundingSphere(t)[3])}_fitsInsideTree(t){const e=this._root.bounds,n=this._root.halfSize;return t[3]<=n&&t[0]>=e[0]-n&&t[0]<=e[0]+n&&t[1]>=e[1]-n&&t[1]<=e[1]+n&&t[2]>=e[2]-n&&t[2]<=e[2]+n}}class l{constructor(){this.bounds=x(),this.halfSize=0,this.initFrom(null,null,0,0)}init(t){return this.initFrom(t.node,t.bounds,t.halfSize,t.depth)}initFrom(t,e,n,o=this.depth){return this.node=U(t)?t:l.createEmptyNode(),U(e)&&w(e,this.bounds),this.halfSize=n,this.depth=o,this}advance(t){let e=this.node.children[t];e||(e=l.createEmptyNode(),this.node.children[t]=e),this.node=e,this.halfSize/=2,this.depth++;const n=lt[t];return this.bounds[0]+=n[0]*this.halfSize,this.bounds[1]+=n[1]*this.halfSize,this.bounds[2]+=n[2]*this.halfSize,this.bounds[3]=this.halfSize*ut,this}advanceTo(t,e,n=!1){for(;;){if(this.isTerminalFor(t))return e&&e(this,-1),!0;if(this.isLeaf()){if(!n)return e&&e(this,-1),!1;this.node.residents=null}const o=this._childIndex(t);e&&e(this,o),this.advance(o)}}isLeaf(){return this.node.residents!=null}isTerminalFor(t){return t[3]>this.halfSize/2}_childIndex(t){const e=this.bounds;return(e[0]<t[0]?1:0)+(e[1]<t[1]?2:0)+(e[2]<t[2]?4:0)}static createEmptyNode(){return{children:[null,null,null,null,null,null,null,null],terminals:new H({shrink:!0}),residents:new H({shrink:!0})}}static acquire(){return l._pool.acquire()}static release(t){l._pool.release(t)}static clearPool(){l._pool.prune()}}function xt(r,t){r[0]=Math.min(r[0],t[0]-t[3]),r[1]=Math.min(r[1],t[1]-t[3]),r[2]=Math.min(r[2],t[2]-t[3])}function Lt(r,t){r[0]=Math.max(r[0],t[0]+t[3]),r[1]=Math.max(r[1],t[1]+t[3]),r[2]=Math.max(r[2],t[2]+t[3])}function k(r,t,e){e[0]=r[0]+t,e[1]=r[1]+t,e[2]=r[2]+t}function dt(r,t,e,n){if(t===1){const o=e(r[0]);w(o,n)}else{O[0]=1/0,O[1]=1/0,O[2]=1/0,R[0]=-1/0,R[1]=-1/0,R[2]=-1/0;for(let o=0;o<t;o++){const s=e(r[o]);D(s[3])&&(xt(O,s),Lt(R,s))}Mt(n,O,R,.5),n[3]=Math.max(R[0]-O[0],R[1]-O[1],R[2]-O[2])/2}}function Pt(r,t,e){if(!I.length)for(let n=0;n<8;++n)I.push({index:0,distance:0});for(let n=0;n<8;++n){const o=lt[n];I.data[n].index=n,I.data[n].distance=B(r,t,o)}I.sort((n,o)=>n.distance-o.distance);for(let n=0;n<8;++n)e[n]=I.data[n].index}function J(r,t){let e,n=1/0;for(let o=0;o<8;++o){const s=B(r,t,ct[o]);s<n&&(n=s,e=ct[o])}return e}function B(r,t,e){return t*(r[0]*e[0]+r[1]*e[1]+r[2]*e[2])}function D(r){return!isNaN(r)&&r!==-1/0&&r!==1/0&&r>0}l._pool=new Ft(l),function(r){var t;(t=r.DepthOrder||(r.DepthOrder={}))[t.FRONT_TO_BACK=1]="FRONT_TO_BACK",t[t.BACK_TO_FRONT=-1]="BACK_TO_FRONT"}(L||(L={}));const lt=[T(-1,-1,-1),T(1,-1,-1),T(-1,1,-1),T(1,1,-1),T(-1,-1,1),T(1,-1,1),T(-1,1,1),T(1,1,1)],ct=[T(-1,-1,-1),T(-1,-1,1),T(-1,1,-1),T(-1,1,1),T(1,-1,-1),T(1,-1,1),T(1,1,-1),T(1,1,1)],ut=Math.sqrt(3),X=[null];function Gt(r){return X[0]=r,X}const Q=x(),E=N(),O=N(),R=N(),j=new H,Ht=x(),b=x(),Y=x(),Z=x(),C=[{min:0,max:0},{min:0,max:0},{min:0,max:0}],I=new H,_t=[0,0,0,0,0,0,0,0],Ut=L;export{yt as A,Ut as G,wt as H,M as U,Ct as a,kt as b,Dt as p,V as s,qt as u,vt as v};
