var ue=Object.defineProperty,le=Object.defineProperties;var ce=Object.getOwnPropertyDescriptors;var Ct=Object.getOwnPropertySymbols;var pe=Object.prototype.hasOwnProperty,he=Object.prototype.propertyIsEnumerable;var Et=(t,e,a)=>e in t?ue(t,e,{enumerable:!0,configurable:!0,writable:!0,value:a}):t[e]=a,C=(t,e)=>{for(var a in e||(e={}))pe.call(e,a)&&Et(t,a,e[a]);if(Ct)for(var a of Ct(e))he.call(e,a)&&Et(t,a,e[a]);return t},E=(t,e)=>le(t,ce(e));import{aq as l,ar as p,as as x,dC as mt,dB as fe,E as S,dy as dt,A as j,m$ as W,bt as M,oK as me,lz as gt,oL as de,ly as st,M as ge,J as _t,ay as Ot,eg as ye}from"./vendor.150443b7.js";import{o as xe,c as we,a as Ae,x as yt,u as ve,d as $e}from"./RasterSymbolizer.8f9c8505.js";import{r as Ne,g,h as Fe,o as Gt,i as Lt,k as be,y as Se,w as Te,c as Vt,x as Re}from"./pixelUtils.e6b9584d.js";let ct=class extends mt{constructor(){super(...arguments),this.raster=void 0}};l([p({json:{write:!0}})],ct.prototype,"raster",void 0),ct=l([x("esri.layers.support.rasterFunctions.AspectFunctionArguments")],ct);const R=ct;var xt;let wt=xt=class extends R{clone(){return new xt({raster:this.raster})}};wt=xt=l([x("esri.layers.support.rasterFunctions.AspectFunctionArguments")],wt);const Ie=wt;let B=class extends mt{constructor(){super(...arguments),this.functionArguments=null,this.readingBufferSize=0}bind(t,e=!1){const a=this._getRasterValues();for(let o=0;o<a.length;o++){const r=a[o];if(r&&typeof r=="object"&&"bind"in r&&(!r.rasterInfo||e)){const s=r.bind(t,e);if(!s.success)return s}}return!this.rasterInfo||e?(this.sourceRasterInfos=this._getSourceRasterInfos(t),this._bindSourceRasters()):{success:!0}}process(t){const e=this._getRasterValues().map(a=>this._readRasterValue(a,t));return this._processPixels(E(C({},t),{pixelBlocks:e}))}getPrimaryRasters(){const t=[],e=[];return this._getPrimaryRasters(this,t,e),{rasters:t,rasterIds:e}}_getOutputPixelType(t){var e;return this.outputPixelType==="unknown"?t:(e=this.outputPixelType)!=null?e:t}_getRasterValues(){const{rasterArgumentNames:t}=this;return t[0]==="rasters"&&Array.isArray(this.functionArguments.rasters)?this.functionArguments.rasters:t.map(e=>this.functionArguments[e])}_getSourceRasterInfos(t){const e=this._getRasterValues(),{rasterInfos:a,rasterIds:o}=t;return e.map(r=>r&&typeof r=="object"&&"bind"in r&&r.rasterInfo?r.rasterInfo:typeof r=="string"&&o.includes(r)?a[o.indexOf(r)]:a[0])}_getPrimaryRasterId(t){return t==null?void 0:t.url}_getPrimaryRasters(t,e=[],a=[]){for(let o=0;o<t.sourceRasters.length;o++){const r=t.sourceRasters[o];if(typeof r!="number")if("bind"in r)this._getPrimaryRasters(r,e,a);else{const s=r,i=this._getPrimaryRasterId(s);if(i==null)continue;a.includes(i)||(this.mainPrimaryRasterId===i?(e.unshift(s),a.unshift(i)):(e.push(s),a.push(i)))}}}_readRasterValue(t,e){const{primaryPixelBlocks:a}=e;if(S(t)||t==="$$"){const o=a[0];return S(o)?null:o.clone()}if(typeof t=="string"){const o=e.primaryRasterIds.indexOf(t);return o===-1?null:a[o]}if(typeof t=="number"){const o=a[0];if(S(o))return null;const r=new Float32Array(o.width*o.height);r.fill(t);const s=o.clone();return s.pixels=s.pixels.map(()=>r),s}return t.process(e)}};l([p({json:{write:!0}})],B.prototype,"functionName",void 0),l([p({json:{write:!0}})],B.prototype,"functionArguments",void 0),l([p()],B.prototype,"rasterArgumentNames",void 0),l([p({json:{write:!0}}),fe(t=>t==null?void 0:t.toLowerCase())],B.prototype,"outputPixelType",void 0),l([p({json:{write:!0}})],B.prototype,"mainPrimaryRasterId",void 0),l([p()],B.prototype,"sourceRasters",void 0),l([p({json:{write:!0}})],B.prototype,"sourceRasterInfos",void 0),l([p({json:{write:!0}})],B.prototype,"rasterInfo",void 0),l([p({json:{write:!0}})],B.prototype,"readingBufferSize",void 0),B=l([x("esri.layers.support.rasterFunctions.BaseRasterFunction")],B);const I=B;let _=class extends I{constructor(){super(...arguments),this.functionName="Aspect",this.functionArguments=null,this.rasterArgumentNames=["raster"],this.isGCS=!1}_bindSourceRasters(){const t=this.sourceRasterInfos[0];this.isGCS=t.spatialReference.isGeographic,this.outputPixelType=this._getOutputPixelType("f32");const e=t.clone();return e.pixelType=this.outputPixelType,e.statistics=null,e.histograms=null,this.rasterInfo=e,{success:!0}}_processPixels(t){var r;const e=(r=t.pixelBlocks)==null?void 0:r[0];if(S(e))return null;const{extent:a}=t,o=a?{x:a.width/e.width,y:a.height/e.height}:{x:1,y:1};return xe(e,{resolution:o})}};l([p({json:{write:!0,name:"rasterFunction"}})],_.prototype,"functionName",void 0),l([p({type:Ie,json:{write:!0,name:"rasterFunctionArguments"}})],_.prototype,"functionArguments",void 0),l([p()],_.prototype,"rasterArgumentNames",void 0),l([p({json:{write:!0}})],_.prototype,"isGCS",void 0),_=l([x("esri.layers.support.rasterFunctions.AspectFunction")],_);const Be=_,Pe=new Set(["+","-","*","/","(",")"]);function je(t,e){(t=t.replace(/ /g,"")).startsWith("-")&&(t="0"+t),t.startsWith("+")&&(t=t.slice(1,t.length));const a=t.split(""),o=[],r=[];let s="";for(let i=0;i<a.length;i++){const n=a[i];if(Pe.has(n))s!==""&&r.push(parseFloat(s)),o.push(n),s="";else{if(n.toLowerCase()==="b"){i++,s=n.concat(a[i]),r.push(e[parseInt(s[1],10)-1]),s="";continue}s=s.concat(n),i===a.length-1&&r.push(parseFloat(s))}}return{ops:o,nums:r}}function Me(t,e,a,o){if(typeof a=="number"&&typeof o=="number")return a+o;let r;if(typeof a=="number"){r=o.length;const i=a;(a=new Float32Array(r)).fill(i)}else if(r=a.length,o.constructor===Number){const i=o;(o=new Float32Array(r)).fill(i)}const s=new Float32Array(r);switch(e){case"+":for(let i=0;i<r;i++)(t==null||t[i])&&(s[i]=a[i]+o[i]);break;case"-":for(let i=0;i<r;i++)(t==null||t[i])&&(s[i]=a[i]-o[i]);break;case"*":for(let i=0;i<r;i++)(t==null||t[i])&&(s[i]=a[i]*o[i]);break;case"/":for(let i=0;i<r;i++)(t==null||t[i])&&o[i]&&(s[i]=a[i]/o[i]);break;case"(":case")":throw"encountered error with custom band index equation"}return s}function ke(t,e){t.splice(e,1);let a=0,o=0;do{a=0,o=0;for(let r=0;r<t.length;r++)if(t[r]==="(")a=r;else if(t[r]===")"){o=r;break}o===a+1&&t.splice(a,2)}while(o===a+1);return t}function De(t){if(t.length===1)return{opIndex:0,numIndex:0};let e=0,a=0;for(let i=0;i<t.length;i++)if(t[i]==="(")e=i;else if(t[i]===")"){a=i;break}const o=a===0?t:t.slice(e+1,a);let r=-1;for(let i=0;i<o.length;i++)if(o[i]==="*"||o[i]==="/"){r=i;break}if(r>-1)a>0&&(r+=e+1);else{for(let i=0;i<o.length;i++)if(o[i]==="+"||o[i]==="-"){r=i;break}a>0&&(r+=e+1)}let s=0;for(let i=0;i<r;i++)t[i]==="("&&s++;return{opIndex:r,numIndex:r-s}}function Ce(t,e,a){let o,{ops:r,nums:s}=je(a,e);if(r.length===0){const i=s.length===1?s[0]:e[0];if(i instanceof Float32Array)return[i];const n=new Float32Array(e[0].length);return typeof i=="number"?n.fill(i):n.set(i),[n]}for(;r.length>0;){const{numIndex:i,opIndex:n}=De(r);if(o=Me(t,r[n],s[i],s[i+1]),r.length===1)break;r=ke(r,n),s.splice(i,2,o)}return[o]}const Ee=new dt({0:"custom",1:"ndvi",2:"savi",3:"tsavi",4:"msavi",5:"gemi",6:"pvi",7:"gvitm",8:"sultan",9:"vari",10:"gndvi",11:"sr",12:"ndvi-re",13:"sr-re",14:"mtvi2",15:"rtvi-core",16:"ci-re",17:"ci-g",18:"ndwi",19:"evi",20:"iron-oxide",21:"ferrous-minerals",22:"clay-minerals",23:"wndwi",24:"bai",25:"nbr",26:"ndbi",27:"ndmi",28:"ndsi",29:"mndwi"},{useNumericKeys:!0});function _e(t,e){var h;if(!Ne(t))return t;const{equation:a,method:o}=e,r=e.bandIndexes.map(f=>f-1),{pixels:s,mask:i}=t;let n;switch(o){case"gndvi":case"nbr":case"ndbi":case"ndvi":case"ndvi-re":case"ndsi":case"ndmi":case"mndwi":n=zt(i,s[r[0]],s[r[1]]);break;case"ndwi":n=zt(i,s[r[1]],s[r[0]]);break;case"sr":case"sr-re":case"iron-oxide":case"ferrous-minerals":case"clay-minerals":n=Ge(i,s[r[0]],s[r[1]]);break;case"ci-g":case"ci-re":n=Le(i,s[r[0]],s[r[1]]);break;case"savi":n=Ve(i,s[r[0]],s[r[1]],r[2]+1);break;case"tsavi":n=ze(i,s[r[0]],s[r[1]],r[2]+1,r[3]+1,r[4]+1);break;case"msavi":n=qe(i,s[r[0]],s[r[1]]);break;case"gemi":n=He(i,s[r[0]],s[r[1]]);break;case"pvi":n=Ue(i,s[r[0]],s[r[1]],r[2]+1,r[3]+1);break;case"gvitm":n=Xe(i,[s[r[0]],s[r[1]],s[r[2]],s[r[3]],s[r[4]],s[r[5]]]);break;case"sultan":n=We(i,[s[r[0]],s[r[1]],s[r[2]],s[r[3]],s[r[4]],s[r[5]]]);break;case"vari":n=Je(i,[s[r[0]],s[r[1]],s[r[2]]]);break;case"mtvi2":n=Ye(i,[s[r[0]],s[r[1]],s[r[2]]]);break;case"rtvi-core":n=Ke(i,[s[r[0]],s[r[1]],s[r[2]]]);break;case"evi":n=Qe(i,[s[r[0]],s[r[1]],s[r[2]]]);break;case"wndwi":n=Ze(i,[s[r[0]],s[r[1]],s[r[2]]],(h=r[3])!=null?h:.5);break;case"bai":n=tn(i,s[r[0]],s[r[1]]);break;case"custom":n=Ce(i,s,a);break;default:return t}const u=j(i)?new Uint8Array(i.length):null;j(i)&&j(u)&&u.set(i);const c=new g({width:t.width,height:t.height,pixelType:"f32",pixels:n,mask:u});return c.updateStatistics(),c}function Oe(t,e,a,o){const{mask:r,pixels:s,width:i,height:n}=t,u=s[a],c=s[e],h=c.length,f=o?new Uint8Array(h):new Float32Array(h),m=o?100:1,v=o?100:0;for(let A=0;A<h;A++)if(r==null||r[A]){const F=u[A],kt=c[A],Dt=F+kt;Dt&&(f[A]=(F-kt)/Dt*m+v)}const w=new g({width:i,height:n,mask:r,pixelType:o?"u8":"f32",pixels:[f]});return w.updateStatistics(),w}function zt(t,e,a){const o=a.length,r=new Float32Array(o);for(let s=0;s<o;s++)if(t==null||t[s]){const i=e[s],n=a[s],u=i+n;u&&(r[s]=(i-n)/u)}return[r]}function Ge(t,e,a){const o=a.length,r=new Float32Array(o);for(let s=0;s<o;s++)if(t==null||t[s]){const i=e[s],n=a[s];n&&(r[s]=i/n)}return[r]}function Le(t,e,a){const o=e.length,r=new Float32Array(o);for(let s=0;s<o;s++)if(t==null||t[s]){const i=e[s],n=a[s];n&&(r[s]=i/n-1)}return[r]}function Ve(t,e,a,o){const r=a.length,s=new Float32Array(r);for(let i=0;i<r;i++)if(t==null||t[i]){const n=a[i],u=e[i],c=u+n+o;c&&(s[i]=(u-n)/c*(1+o))}return[s]}function ze(t,e,a,o,r,s){const i=a.length,n=new Float32Array(i),u=-r*o+s*(1+o*o);for(let c=0;c<i;c++)if(t==null||t[c]){const h=a[c],f=e[c],m=r*f+h+u;m&&(n[c]=o*(f-o*h-r)/m)}return[n]}function qe(t,e,a){const o=a.length,r=new Float32Array(o);for(let s=0;s<o;s++)if(t==null||t[s]){const i=a[s],n=e[s];r[s]=.5*(2*(n+1)-Math.sqrt((2*n+1)**2-8*(n-i)))}return[r]}function He(t,e,a){const o=a.length,r=new Float32Array(o);for(let s=0;s<o;s++)if(t==null||t[s]){const i=a[s],n=e[s];if(i!==1){const u=(2*(n*n-i*i)+1.5*n+.5*i)/(n+i+.5);r[s]=u*(1-.25*u)-(i-.125)/(1-i)}}return[r]}function Ue(t,e,a,o,r){const s=a.length,i=new Float32Array(s),n=Math.sqrt(1+o*o);for(let u=0;u<s;u++)if(t==null||t[u]){const c=a[u],h=e[u];i[u]=(h-o*c-r)/n}return[i]}function Xe(t,e){const[a,o,r,s,i,n]=e,u=a.length,c=new Float32Array(u);for(let h=0;h<u;h++)(t==null||t[h])&&(c[h]=-.2848*a[h]-.2435*o[h]-.5436*r[h]+.7243*s[h]+.084*i[h]-1.18*n[h]);return[c]}function We(t,e){const[a,,o,r,s,i]=e,n=a.length,u=new Float32Array(n),c=new Float32Array(n),h=new Float32Array(n);for(let f=0;f<n;f++)(t==null||t[f])&&(u[f]=i[f]?s[f]/i[f]*100:0,c[f]=a[f]?s[f]/a[f]*100:0,h[f]=r[f]?o[f]/r[f]*(s[f]/r[f])*100:0);return[u,c,h]}function Je(t,e){const[a,o,r]=e,s=a.length,i=new Float32Array(s);for(let n=0;n<s;n++)if(t==null||t[n])for(n=0;n<s;n++){const u=a[n],c=o[n],h=c+u-r[n];h&&(i[n]=(c-u)/h)}return[i]}function Ye(t,e){const[a,o,r]=e,s=a.length,i=new Float32Array(s);for(let n=0;n<s;n++)if(t==null||t[n])for(n=0;n<s;n++){const u=a[n],c=o[n],h=r[n],f=Math.sqrt((2*u+1)**2-6*u-5*Math.sqrt(c)-.5);i[n]=1.5*(1.2*(u-h)-2.5*(c-h))*f}return[i]}function Ke(t,e){const[a,o,r]=e,s=a.length,i=new Float32Array(s);for(let n=0;n<s;n++)if(t==null||t[n])for(n=0;n<s;n++){const u=a[n],c=o[n],h=r[n];i[n]=100*(u-c)-10*(u-h)}return[i]}function Qe(t,e){const[a,o,r]=e,s=a.length,i=new Float32Array(s);for(let n=0;n<s;n++)if(t==null||t[n])for(n=0;n<s;n++){const u=a[n],c=o[n],h=u+6*c-7.5*r[n]+1;h&&(i[n]=2.5*(u-c)/h)}return[i]}function Ze(t,e,a=.5){const[o,r,s]=e,i=r.length,n=new Float32Array(i);for(let u=0;u<i;u++)if(t==null||t[u])for(u=0;u<i;u++){const c=o[u],h=r[u],f=s[u],m=c+a*h+(1-a)*f;m&&(n[u]=(c-a*h-(1-a)*f)/m)}return[n]}function tn(t,e,a){const o=a.length,r=new Float32Array(o);for(let s=0;s<o;s++)if(t==null||t[s])for(s=0;s<o;s++){const i=(.1-e[s])**2+(.06-a[s])**2;i&&(r[s]=1/i)}return[r]}var At;let rt=At=class extends R{constructor(){super(...arguments),this.method="custom"}clone(){return new At({method:this.method,bandIndexes:this.bandIndexes,raster:M(this.raster)})}};l([p({json:{type:String,write:!0}})],rt.prototype,"bandIndexes",void 0),l([W(Ee)],rt.prototype,"method",void 0),rt=At=l([x("esri.layers.support.rasterFunctions.BandArithmeticFunctionArguments")],rt);const en=rt;let J=class extends I{constructor(){super(...arguments),this.functionName="BandArithmetic",this.functionArguments=null,this.rasterArgumentNames=["raster"]}_bindSourceRasters(){this.outputPixelType=this._getOutputPixelType("f32");const t=this.sourceRasterInfos[0],e=t.clone();return e.pixelType=this.outputPixelType,e.statistics=null,e.histograms=null,e.bandCount=this.functionArguments.method==="sultan"?t.bandCount:1,this.rasterInfo=e,{success:!0}}_processPixels(t){var s;const e=(s=t.pixelBlocks)==null?void 0:s[0];if(S(e))return e;const{method:a,bandIndexes:o}=this.functionArguments,r=o.split(" ").map(i=>parseFloat(i));return _e(e,{method:a,bandIndexes:r,equation:o})}};l([p({json:{write:!0,name:"rasterFunction"}})],J.prototype,"functionName",void 0),l([p({type:en,json:{write:!0,name:"rasterFunctionArguments"}})],J.prototype,"functionArguments",void 0),l([p()],J.prototype,"rasterArgumentNames",void 0),J=l([x("esri.layers.support.rasterFunctions.BandArithmeticFunction")],J);const nn=J;var vt;let k=vt=class extends R{readColorRamp(t){return de(t)}clone(){var t;return new vt({colormap:M(this.colormap),colormapName:this.colormapName,colorRamp:(t=this.colorRamp)==null?void 0:t.clone(),colorRampName:this.colorRampName})}};l([p({type:[[Number]],json:{write:!0}})],k.prototype,"colormap",void 0),l([p({type:String,json:{write:!0}})],k.prototype,"colormapName",void 0),l([p({types:me,json:{write:!0}})],k.prototype,"colorRamp",void 0),l([gt("colorRamp")],k.prototype,"readColorRamp",null),l([p({type:String,json:{write:!0}})],k.prototype,"colorRampName",void 0),k=vt=l([x("esri.layers.support.rasterFunctions.ColormapFunctionArguments")],k);const sn=k;let O=class extends I{constructor(){super(...arguments),this.functionName="Colormap",this.functionArguments=null,this.rasterArgumentNames=["raster"]}_bindSourceRasters(){const t=this.sourceRasterInfos[0];if(t.bandCount>1)return{success:!1,error:"colormap-function: source data must be single band"};let{colormap:e,colorRamp:a}=this.functionArguments;if((e==null?void 0:e.length)||a&&(e=we(a,256,!0)),!(e==null?void 0:e.length))return{success:!1,error:"colormap-function: missing colormap argument"};this.outputPixelType=this._getOutputPixelType("u8");const o=t.clone();return o.pixelType=this.outputPixelType,o.colormap=e,this.rasterInfo=o,{success:!0}}_processPixels(t){var e;return(e=t.pixelBlocks)==null?void 0:e[0]}};l([p({json:{write:!0,name:"rasterFunction"}})],O.prototype,"functionName",void 0),l([p({type:sn,json:{write:!0,name:"rasterFunctionArguments"}})],O.prototype,"functionArguments",void 0),l([p()],O.prototype,"rasterArgumentNames",void 0),l([p({json:{write:!0}})],O.prototype,"indexedColormap",void 0),O=l([x("esri.layers.support.rasterFunctions.ColormapFunction")],O);const rn=O;var $t;let ot=$t=class extends R{writeRasters(t,e){e.rasters=t.map(a=>typeof a=="number"||typeof a=="string"?a:a.toJSON())}clone(){return new $t({rasters:M(this.rasters)})}};l([p({json:{write:!0}})],ot.prototype,"rasters",void 0),l([st("rasters")],ot.prototype,"writeRasters",null),ot=$t=l([x("esri.layers.support.rasterFunctions.CompositeBandFunctionArguments")],ot);const on=ot;let Y=class extends I{constructor(){super(...arguments),this.functionName="CompositeBand",this.functionArguments=null,this.rasterArgumentNames=["rasters"]}_bindSourceRasters(){const{sourceRasterInfos:t}=this,e=t[0];this.outputPixelType=this._getOutputPixelType(e.pixelType);const a=e.clone();if(a.attributeTable=null,a.colormap=null,a.pixelType=this.outputPixelType,a.bandCount=t.map(({bandCount:o})=>o).reduce((o,r)=>o+r),t.every(({statistics:o})=>j(o)&&o.length)){const o=[];t.forEach(({statistics:r})=>j(r)&&o.push(...r)),a.statistics=o}if(t.every(({histograms:o})=>j(o)&&o.length)){const o=[];t.forEach(({histograms:r})=>j(r)&&o.push(...r)),a.histograms=o}return this.rasterInfo=a,{success:!0}}_processPixels(t){const{pixelBlocks:e}=t;if(!e)return null;const a=e==null?void 0:e[0];return S(a)?null:Fe(e)}};l([p({json:{write:!0,name:"rasterFunction"}})],Y.prototype,"functionName",void 0),l([p({type:on,json:{write:!0,name:"rasterFunctionArguments"}})],Y.prototype,"functionArguments",void 0),l([p()],Y.prototype,"rasterArgumentNames",void 0),Y=l([x("esri.layers.support.rasterFunctions.CompositeBandFunction")],Y);const an=Y;var y;(function(t){t[t.UserDefined=-1]="UserDefined",t[t.LineDetectionHorizontal=0]="LineDetectionHorizontal",t[t.LineDetectionVertical=1]="LineDetectionVertical",t[t.LineDetectionLeftDiagonal=2]="LineDetectionLeftDiagonal",t[t.LineDetectionRightDiagonal=3]="LineDetectionRightDiagonal",t[t.GradientNorth=4]="GradientNorth",t[t.GradientWest=5]="GradientWest",t[t.GradientEast=6]="GradientEast",t[t.GradientSouth=7]="GradientSouth",t[t.GradientNorthEast=8]="GradientNorthEast",t[t.GradientNorthWest=9]="GradientNorthWest",t[t.SmoothArithmeticMean=10]="SmoothArithmeticMean",t[t.Smoothing3x3=11]="Smoothing3x3",t[t.Smoothing5x5=12]="Smoothing5x5",t[t.Sharpening3x3=13]="Sharpening3x3",t[t.Sharpening5x5=14]="Sharpening5x5",t[t.Laplacian3x3=15]="Laplacian3x3",t[t.Laplacian5x5=16]="Laplacian5x5",t[t.SobelHorizontal=17]="SobelHorizontal",t[t.SobelVertical=18]="SobelVertical",t[t.Sharpen=19]="Sharpen",t[t.Sharpen2=20]="Sharpen2",t[t.PointSpread=21]="PointSpread",t[t.None=255]="None"})(y||(y={}));const $=new Map;function un(t){const e=Math.sqrt(t.length),a=t.slice(0,e),o=[1];for(let r=1;r<e;r++){let s=null;for(let i=0;i<e;i++){const n=t[i+r*e],u=t[i];if(s==null)if(u===0){if(n)return{separable:!1,row:null,col:null}}else s=n/u;else if(n/u!==s)return{separable:!1,row:null,col:null}}if(s==null)return{separable:!1,row:null,col:null};o.push(s)}return{separable:!0,row:a,col:o}}function qt(t,e,a,o,r,s,i){const n=new Float32Array(e*a),u=s.length,c=i?0:o,h=i?o:0,f=i?1:e;for(let m=c;m<a-c;m++){const v=m*e;for(let w=h;w<e-h;w++){if(r&&!r[v+w])continue;let A=0;for(let F=0;F<u;F++)A+=t[v+w+(F-o)*f]*s[F];n[v+w]=A}}return n}function ln(t,e,a,o,r,s,i){const n=new Float32Array(e*a),u=Math.floor(o/2),c=Math.floor(r/2);for(let h=u;h<a-u;h++){const f=h*e;for(let m=c;m<e-c;m++){if(s&&!s[f+m])continue;let v=0;for(let w=0;w<o;w++)for(let A=0;A<r;A++)v+=t[f+m+(w-u)*e+A-c]*i[w*r+A];n[f+m]=v}}return n}function cn(t,e,a=!0){const{pixels:o,width:r,height:s,pixelType:i,mask:n}=t,u=o.length,c=[],{kernel:h,rows:f,cols:m}=e;for(let v=0;v<u;v++){const w=ln(o[v],r,s,f,m,n,h);a&&Ht(w,r,s,f,m),c.push(w)}return new g({width:r,height:s,pixelType:i,pixels:c,mask:n})}function Ht(t,e,a,o,r){const s=Math.floor(o/2);for(let n=0;n<s;n++)for(let u=0;u<e;u++)t[n*e+u]=t[(r-1-n)*e+u],t[(a-1-n)*e+u]=t[(a-r+n)*e+u];const i=Math.floor(r/2);for(let n=0;n<a;n++){const u=n*e;for(let c=0;c<i;c++)t[u+c]=t[u+r-1-c],t[u+e-c-1]=t[u+e+c-r]}}function pn(t,e,a,o=!0){const{pixels:r,width:s,height:i,pixelType:n,mask:u}=t,c=r.length,h=[],f=e.length,m=a.length,v=Math.floor(f/2),w=Math.floor(m/2);for(let A=0;A<c;A++){let F=qt(r[A],s,i,v,u,e,!0);F=qt(F,s,i,w,u,a,!1),o&&Ht(F,s,i,f,m),h.push(F)}return new g({width:s,height:i,pixelType:n,pixels:h,mask:u})}function hn(t,e){const a=un(e.kernel),o=e.mirrorEdges!==!1,r=a.separable?pn(t,a.row,a.col,o):cn(t,e,o),{outputPixelType:s}=e;return s&&r.clamp(s),r}$.set(y.None,[0,0,0,0,1,0,0,0,0]),$.set(y.LineDetectionHorizontal,[-1,-1,-1,2,2,2,-1,-1,-1]),$.set(y.LineDetectionVertical,[-1,2,-1,-1,2,-1,-1,2,-1]),$.set(y.LineDetectionLeftDiagonal,[2,-1,-1,-1,2,-1,-1,-1,2]),$.set(y.LineDetectionRightDiagonal,[-1,-1,2,-1,2,-1,2,-1,-1]),$.set(y.GradientNorth,[-1,-2,-1,0,0,0,1,2,1]),$.set(y.GradientWest,[-1,0,1,-2,0,2,-1,0,1]),$.set(y.GradientEast,[1,0,-1,2,0,-2,1,0,-1]),$.set(y.GradientSouth,[1,2,1,0,0,0,-1,-2,-1]),$.set(y.GradientNorthEast,[0,-1,-2,1,0,-1,2,1,0]),$.set(y.GradientNorthWest,[-2,-1,0,-1,0,1,0,1,2]),$.set(y.SmoothArithmeticMean,[.111111111111,.111111111111,.111111111111,.111111111111,.111111111111,.111111111111,.111111111111,.111111111111,.111111111111]),$.set(y.Smoothing3x3,[.0625,.125,.0625,.125,.25,.125,.0625,.125,.0625]),$.set(y.Smoothing5x5,[1,1,1,1,1,1,4,4,4,1,1,4,12,4,1,1,4,4,4,1,1,1,1,1,1]),$.set(y.Sharpening3x3,[-1,-1,-1,-1,9,-1,-1,-1,-1]),$.set(y.Sharpening5x5,[-1,-3,-4,-3,-1,-3,0,6,0,-3,-4,6,21,6,-4,-3,0,6,0,-3,-1,-3,-4,-3,-1]),$.set(y.Laplacian3x3,[0,-1,0,-1,4,-1,0,-1,0]),$.set(y.Laplacian5x5,[0,0,-1,0,0,0,-1,-2,-1,0,-1,-2,17,-2,-1,0,-1,-2,-1,0,0,0,-1,0,0]),$.set(y.SobelHorizontal,[-1,-2,-1,0,0,0,1,2,1]),$.set(y.SobelVertical,[-1,0,1,-2,0,2,-1,0,1]),$.set(y.Sharpen,[0,-.25,0,-.25,2,-.25,0,-.25,0]),$.set(y.Sharpen2,[-.25,-.25,-.25,-.25,3,-.25,-.25,-.25,-.25]),$.set(y.PointSpread,[-.627,.352,-.627,.352,2.923,.352,-.627,.352,-.627]);var Nt;let G=Nt=class extends R{constructor(){super(...arguments),this.rows=3,this.cols=3,this.kernel=[0,0,0,0,1,0,0,0,0]}set kernelType(t){this._set("kernelType",t);const e=$.get(t);if(!e||t===y.UserDefined||t===y.None)return;const a=Math.sqrt(e.length);this._set("kernel",e),this._set("cols",a),this._set("rows",a)}clone(){return new Nt({cols:this.cols,rows:this.rows,kernel:[...this.kernel],kernelType:this.kernelType,raster:M(this.raster)})}};l([p({json:{type:Number,write:!0}})],G.prototype,"rows",void 0),l([p({json:{type:Number,write:!0}})],G.prototype,"cols",void 0),l([p({json:{name:"type",type:Number,write:!0}})],G.prototype,"kernelType",null),l([p({json:{type:[Number],write:!0}})],G.prototype,"kernel",void 0),G=Nt=l([x("esri.layers.support.rasterFunctions.ConvolutionFunctionArguments")],G);const fn=G;let K=class extends I{constructor(){super(...arguments),this.functionName="Convolution",this.rasterArgumentNames=["raster"]}_bindSourceRasters(){const{kernelType:t,rows:e,cols:a,kernel:o}=this.functionArguments;if(!$.has(t))return{success:!1,error:`convolution-function: the specified kernel type is not supported ${t}`};if(t!==y.None&&e*a!==o.length)return{success:!1,error:"convolution-function: the specified rows and cols do not match the length of the kernel"};const r=this.sourceRasterInfos[0];this.outputPixelType=this._getOutputPixelType(r.pixelType);const s=r.clone();s.pixelType=this.outputPixelType;const i=[y.None,y.Sharpen,y.Sharpen2,y.Sharpening3x3,y.Sharpening5x5];return this.outputPixelType==="u8"||i.includes(t)||(s.statistics=null,s.histograms=null),this.rasterInfo=s,{success:!0}}_processPixels(t){var i;const e=(i=t.pixelBlocks)==null?void 0:i[0];if(S(e)||this.functionArguments.kernelType===y.None)return e;let{kernel:a,rows:o,cols:r}=this.functionArguments;const s=a.reduce((n,u)=>n+u);return s!==0&&s!==1&&(a=a.map(n=>n/s)),hn(e,{kernel:a,rows:o,cols:r,outputPixelType:this.outputPixelType})}};l([p({json:{write:!0,name:"rasterFunction"}})],K.prototype,"functionName",void 0),l([p({type:fn,json:{write:!0,name:"rasterFunctionArguments"}})],K.prototype,"functionArguments",void 0),l([p()],K.prototype,"rasterArgumentNames",void 0),K=l([x("esri.layers.support.rasterFunctions.ConvolutionFunction")],K);const mn=K;var Ft;let it=Ft=class extends R{constructor(){super(...arguments),this.bandIDs=[],this.missingBandAction=Gt.bestMatch}clone(){return new Ft({bandIDs:[...this.bandIDs],missingBandAction:this.missingBandAction})}};l([p({json:{write:!0}})],it.prototype,"bandIDs",void 0),l([p({json:{write:!0}})],it.prototype,"missingBandAction",void 0),it=Ft=l([x("esri.layers.support.rasterFunctions.ExtractBandFunctionArguments")],it);const dn=it;let Q=class extends I{constructor(){super(...arguments),this.functionName="ExtractBand",this.functionArguments=null,this.rasterArgumentNames=["raster"]}_bindSourceRasters(){const{sourceRasterInfos:t}=this,e=t[0],{bandCount:a}=e,{bandIDs:o,missingBandAction:r}=this.functionArguments;if(r===Gt.fail&&o.some(u=>u<0||u>=a))return{success:!1,error:"extract-band-function: invalid bandIDs"};this.outputPixelType=this._getOutputPixelType("f32");const s=e.clone();s.pixelType=this.outputPixelType;const{statistics:i,histograms:n}=s;return j(i)&&i.length&&(s.statistics=o.map(u=>i[u]||i[i.length-1])),j(n)&&n.length&&(s.histograms=o.map(u=>n[u]||n[n.length-1])),this.rasterInfo=s,{success:!0}}_processPixels(t){var r;const e=(r=t.pixelBlocks)==null?void 0:r[0];if(S(e))return null;const a=e.pixels.length,o=this.functionArguments.bandIDs.map(s=>s>=a?a-1:s);return e.extractBands(o)}};l([p({json:{write:!0,name:"rasterFunction"}})],Q.prototype,"functionName",void 0),l([p({type:dn,json:{write:!0,name:"rasterFunctionArguments"}})],Q.prototype,"functionArguments",void 0),l([p()],Q.prototype,"rasterArgumentNames",void 0),Q=l([x("esri.layers.support.rasterFunctions.ExtractBandFunction")],Q);const gn=Q;var bt;let L=bt=class extends R{constructor(){super(...arguments),this.rasters=[],this.processAsMultiband=!1}writeRasters(t,e){e.rasters=t.map(a=>typeof a=="number"||typeof a=="string"?a:a.toJSON())}clone(){return new bt({method:this.operation,processAsMultiband:this.processAsMultiband,rasters:M(this.rasters)})}};l([p({json:{write:!0}})],L.prototype,"operation",void 0),l([p({json:{write:!0}})],L.prototype,"rasters",void 0),l([st("rasters")],L.prototype,"writeRasters",null),l([p({json:{write:!0}})],L.prototype,"processAsMultiband",void 0),L=bt=l([x("esri.layers.support.rasterFunctions.LocalFunctionArguments")],L);const yn=L;var pt;(function(t){t[t.Plus=1]="Plus",t[t.Minus=2]="Minus",t[t.Times=3]="Times",t[t.SquareRoot=4]="SquareRoot",t[t.Power=5]="Power",t[t.ACos=6]="ACos",t[t.ASin=7]="ASin",t[t.ATan=8]="ATan",t[t.ATanH=9]="ATanH",t[t.Abs=10]="Abs",t[t.BitwiseAnd=11]="BitwiseAnd",t[t.BitwiseLeftShift=12]="BitwiseLeftShift",t[t.BitwiseNot=13]="BitwiseNot",t[t.BitwiseOr=14]="BitwiseOr",t[t.BitwiseRightShift=15]="BitwiseRightShift",t[t.BitwiseXOr=16]="BitwiseXOr",t[t.BooleanAnd=17]="BooleanAnd",t[t.BooleanNot=18]="BooleanNot",t[t.BooleanOr=19]="BooleanOr",t[t.BooleanXOr=20]="BooleanXOr",t[t.Cos=21]="Cos",t[t.CosH=22]="CosH",t[t.Divide=23]="Divide",t[t.EqualTo=24]="EqualTo",t[t.Exp=25]="Exp",t[t.Exp10=26]="Exp10",t[t.Exp2=27]="Exp2",t[t.GreaterThan=28]="GreaterThan",t[t.GreaterThanEqual=29]="GreaterThanEqual",t[t.Int=30]="Int",t[t.IsNull=31]="IsNull",t[t.Float=32]="Float",t[t.LessThan=33]="LessThan",t[t.LessThanEqual=34]="LessThanEqual",t[t.Ln=35]="Ln",t[t.Log10=36]="Log10",t[t.Log2=37]="Log2",t[t.Majority=38]="Majority",t[t.Max=39]="Max",t[t.Mean=40]="Mean",t[t.Med=41]="Med",t[t.Min=42]="Min",t[t.Minority=43]="Minority",t[t.Mod=44]="Mod",t[t.Negate=45]="Negate",t[t.NotEqual=46]="NotEqual",t[t.Range=47]="Range",t[t.RoundDown=48]="RoundDown",t[t.RoundUp=49]="RoundUp",t[t.SetNull=50]="SetNull",t[t.Sin=51]="Sin",t[t.SinH=52]="SinH",t[t.Square=53]="Square",t[t.Std=54]="Std",t[t.Sum=55]="Sum",t[t.Tan=56]="Tan",t[t.TanH=57]="TanH",t[t.Variety=58]="Variety",t[t.ACosH=59]="ACosH",t[t.ASinH=60]="ASinH",t[t.ATan2=61]="ATan2",t[t.FloatDivide=64]="FloatDivide",t[t.FloorDivide=65]="FloorDivide",t[t.MajorityIgnoreNoData=66]="MajorityIgnoreNoData",t[t.MaxIgnoreNoData=67]="MaxIgnoreNoData",t[t.MeanIgnoreNoData=68]="MeanIgnoreNoData",t[t.MedIgnoreNoData=69]="MedIgnoreNoData",t[t.MinIgnoreNoData=70]="MinIgnoreNoData",t[t.MinorityIgnoreNoData=71]="MinorityIgnoreNoData",t[t.RangeIgnoreNoData=72]="RangeIgnoreNoData",t[t.StdIgnoreNoData=73]="StdIgnoreNoData",t[t.SumIgnoreNoData=74]="SumIgnoreNoData",t[t.VarietyIgnoreNoData=75]="VarietyIgnoreNoData",t[t.Con=76]="Con"})(pt||(pt={}));function xn(t){const e=t.map(i=>i.mask).filter(i=>j(i));if(e.length===0)return null;const a=e[0].length,o=new Uint8Array(a);if(e.length===1)return o.set(e[0]),o;let r,s=e[0];for(let i=1;i<e.length;i++){r=e[i];for(let n=0;n<a;n++)o[n]=s[n]|r[n];s=r}return o}function wn(t,e,a){const[o,r]=t,s=o.length,i=g.createEmptyBand(a,s);for(let n=0;n<s;n++)e&&!e[n]||(i[n]=o[n]+r[n]);return i}function An(t,e,a){const[o]=t,r=o.length,s=g.createEmptyBand("f32",r);return s.set(o),s}function vn(t,e,a){const[o,r]=t,s=o.length,i=g.createEmptyBand(a,s);for(let n=0;n<s;n++)e&&!e[n]||(i[n]=o[n]-r[n]);return i}function $n(t,e,a){const[o,r]=t,s=o.length,i=g.createEmptyBand(a,s);for(let n=0;n<s;n++)e&&!e[n]||(i[n]=o[n]*r[n]);return i}function Ut(t,e,a){const[o,r]=t,s=o.length,i=g.createEmptyBand(a,s);for(let n=0;n<s;n++)e&&!e[n]||(i[n]=r[n]===0?0:o[n]/r[n]);return i}function Nn(t,e,a){return Ut(t,e,"f32")}function Fn(t,e,a){const[o,r]=t,s=o.length,i=g.createEmptyBand(a,s);for(let n=0;n<s;n++)e&&!e[n]||(i[n]=r[n]===0?0:Math.floor(o[n]/r[n]));return i}function bn(t,e,a,o){const[r]=t,s=r.length,i=g.createEmptyBand(a,s);for(let n=0;n<s;n++)e&&!e[n]||(i[n]=o(r[n]));return i}function Sn(t,e,a,o){const[r,s]=t,i=r.length,n=g.createEmptyBand(a,i);for(let u=0;u<i;u++)e&&!e[u]||(n[u]=o(r[u],s[u]));return n}function Tn(t,e,a){const[o,r]=t,s=o.length,i=g.createEmptyBand(a,s);for(let n=0;n<s;n++)e&&!e[n]||(i[n]=o[n]&r[n]);return i}function Xt(t,e,a){const[o,r]=t,s=o.length,i=g.createEmptyBand(a,s);for(let n=0;n<s;n++)e&&!e[n]||(i[n]=o[n]<<r[n]);return i}function Rn(t,e,a){const[o]=t,r=o.length,s=g.createEmptyBand(a,r);for(let i=0;i<r;i++)e&&!e[i]||(s[i]=~o[i]);return s}function In(t,e,a){const[o,r]=t,s=o.length,i=g.createEmptyBand(a,s);for(let n=0;n<s;n++)e&&!e[n]||(i[n]=o[n]|r[n]);return i}function Bn(t,e,a){const[o,r]=t,s=o.length,i=g.createEmptyBand(a,s);for(let n=0;n<s;n++)e&&!e[n]||(i[n]=o[n]>>r[n]);return i}function Pn(t,e,a){const[o,r]=t,s=o.length,i=g.createEmptyBand(a,s);for(let n=0;n<s;n++)e&&!e[n]||(i[n]=o[n]^r[n]);return i}function jn(t,e,a){const[o,r]=t,s=o.length,i=g.createEmptyBand(a,s);for(let n=0;n<s;n++)e&&!e[n]||(i[n]=o[n]&&r[n]?1:0);return i}function Mn(t,e,a){const[o]=t,r=o.length,s=g.createEmptyBand(a,r);for(let i=0;i<r;i++)e&&!e[i]||(s[i]=o[i]?0:1);return s}function kn(t,e,a){const[o,r]=t,s=o.length,i=g.createEmptyBand(a,s);for(let n=0;n<s;n++)e&&!e[n]||(i[n]=o[n]||r[n]?1:0);return i}function Dn(t,e,a){const[o,r]=t,s=o.length,i=g.createEmptyBand(a,s);for(let n=0;n<s;n++)e&&!e[n]||(i[n]=(o[n]?1:0)^(r[n]?1:0));return i}function Cn(t,e,a){const[o,r]=t,s=o.length,i=g.createEmptyBand(a,s);for(let n=0;n<s;n++)e&&!e[n]||(i[n]=o[n]===r[n]?1:0);return i}function Wt(t,e,a,o){const[r]=t,s=r.length,i=g.createEmptyBand(a,s);for(let n=0;n<s;n++)e&&!e[n]||(i[n]=o**r[n]);return i}function En(t,e,a){return Wt(t,e,a,10)}function _n(t,e,a){return Wt(t,e,a,2)}function On(t,e,a){const[o,r]=t,s=o.length,i=g.createEmptyBand(a,s);for(let n=0;n<s;n++)e&&!e[n]||(i[n]=o[n]>r[n]?1:0);return i}function Gn(t,e,a){const[o,r]=t,s=o.length,i=g.createEmptyBand(a,s);for(let n=0;n<s;n++)e&&!e[n]||(i[n]=o[n]>=r[n]?1:0);return i}function Ln(t,e,a){const[o,r]=t,s=o.length,i=g.createEmptyBand(a,s);for(let n=0;n<s;n++)e&&!e[n]||(i[n]=o[n]<r[n]?1:0);return i}function Vn(t,e,a){const[o,r]=t,s=o.length,i=g.createEmptyBand(a,s);for(let n=0;n<s;n++)e&&!e[n]||(i[n]=o[n]<=r[n]?1:0);return i}function zn(t,e,a){const[o]=t,r=o.length,s=g.createEmptyBand(a,r);if(!e)return s;for(let i=0;i<r;i++)s[i]=e[i]?0:1;return s}function qn(t,e,a){const[o,r]=t,s=o.length,i=g.createEmptyBand(a,s);for(let n=0;n<s;n++)e&&!e[n]||(i[n]=o[n]%r[n]);return i}function Hn(t,e,a){const[o]=t,r=o.length,s=g.createEmptyBand(a,r);for(let i=0;i<r;i++)e&&!e[i]||(s[i]=-o[i]);return s}function Un(t,e,a){const[o,r]=t,s=o.length,i=g.createEmptyBand(a,s);for(let n=0;n<s;n++)e&&!e[n]||(i[n]=o[n]===r[n]?0:1);return i}function Xn(t,e,a){const[o,r]=t,s=o.length,i=g.createEmptyBand(a,s),n=new Uint8Array(s);for(let u=0;u<s;u++)e!=null&&!e[u]||o[u]!==0||(i[u]=r[u],n[u]=255);return{band:i,mask:n}}function Wn(t,e,a){const[o,r,s]=t,i=o.length,n=g.createEmptyBand(a,i);for(let u=0;u<i;u++)e&&!e[u]||(n[u]=o[u]?r[u]:s[u]);return n}function Jt(t,e,a){const o=t.length;if(o<2)return t[0];const[r]=t,s=r.length,i=g.createEmptyBand(a,s);i.set(r);for(let n=0;n<s;n++)if(!e||e[n])for(let u=1;u<o;u++){const c=t[u];i[n]<c[n]&&(i[n]=c[n])}return i}function Yt(t,e,a){const o=t.length;if(o<2)return t[0];const[r]=t,s=r.length,i=g.createEmptyBand(a,s);i.set(r);for(let n=0;n<s;n++)if(!e||e[n])for(let u=1;u<o;u++){const c=t[u];i[n]>c[n]&&(i[n]=c[n])}return i}function Kt(t,e,a){const o=t.length;if(o<2)return t[0];const[r]=t,s=r.length,i=g.createEmptyBand(a,s);i.set(r);for(let n=0;n<s;n++)if(!e||e[n]){let u=i[n];for(let c=1;c<o;c++){const h=t[c];i[n]<h[n]&&(i[n]=h[n]),u>h[n]&&(u=h[n])}i[n]-=u}return i}function Qt(t,e,a){const o=t.length;if(o<2)return t[0];const[r]=t,s=r.length,i=g.createEmptyBand(a,s);i.set(r);for(let n=0;n<s;n++)if(!e||e[n]){for(let u=1;u<o;u++){const c=t[u];i[n]+=c[n]}i[n]/=o}return i}function Zt(t,e,a){const o=t.length;if(o<2)return t[0];const[r]=t,s=r.length,i=g.createEmptyBand(a,s);i.set(r);for(let n=0;n<s;n++)if(!e||e[n])for(let u=1;u<o;u++){const c=t[u];i[n]+=c[n]}return i}function te(t,e,a){const o=t.length;if(o<2)return t[0];const[r]=t,s=r.length,i=g.createEmptyBand(a,s);for(let n=0;n<s;n++)if(!e||e[n]){const u=new Float32Array(o);let c=0;for(let f=0;f<o;f++){const m=t[f];c+=m[n],u[f]=m[n]}c/=o;let h=0;for(let f=0;f<o;f++)h+=(u[f]-c)*u[f]-c;i[n]=Math.sqrt(h/o-1)}return i}function ee(t,e,a){const o=t.length;if(o<2)return t[0];const r=Math.floor(o/2),[s]=t,i=s.length,n=g.createEmptyBand(a,i),u=new Float32Array(o);for(let c=0;c<i;c++)if(!e||e[c]){for(let h=0;h<o;h++)u[h]=t[h][c];u.sort(),n[c]=u[r]}return n}function ne(t,e,a){const o=t.length;if(o<2)return t[0];const[r]=t,s=r.length,i=g.createEmptyBand(a,s),n=new Map;for(let u=0;u<s;u++)if(!e||e[u]){let c;n.clear();for(let m=0;m<o;m++)c=t[m][u],n.set(c,n.has(c)?n.get(c)+1:1);let h=0,f=0;for(const m of n.keys())h=n.get(m),h>f&&(f=h,c=m);i[u]=c}return i}function se(t,e,a){const o=t.length;if(o<2)return t[0];const[r]=t,s=r.length,i=g.createEmptyBand(a,s),n=new Map;for(let u=0;u<s;u++)if(!e||e[u]){let c;n.clear();for(let m=0;m<o;m++)c=t[m][u],n.set(c,n.has(c)?n.get(c)+1:1);let h=0,f=t.length;for(const m of n.keys())h=n.get(m),h<f&&(f=h,c=m);i[u]=c}return i}function re(t,e,a){const o=t.length;if(o<2)return t[0];const[r]=t,s=r.length,i=g.createEmptyBand(a,s),n=new Set;for(let u=0;u<s;u++)if(!e||e[u]){let c;n.clear();for(let h=0;h<o;h++)c=t[h][u],n.add(c);i[u]=n.size}return i}function Jn(t,e,a){return ne(t,null,a)}function Yn(t,e,a){return se(t,null,a)}function Kn(t,e,a){return re(t,null,a)}function Qn(t,e,a){return Jt(t,null,a)}function Zn(t,e,a){return Yt(t,null,a)}function ts(t,e,a){return te(t,null,a)}function es(t,e,a){return Zt(t,null,a)}function ns(t,e,a){return Qt(t,null,a)}function ss(t,e,a){return ee(t,null,a)}function rs(t,e,a){return Kt(t,null,a)}const N=new Map,ht=new Map,d=new Map;function os(){N.size||(N.set(4,Math.sqrt),N.set(6,Math.acos),N.set(7,Math.asin),N.set(8,Math.atan),N.set(9,Math.atanh),N.set(10,Math.abs),N.set(21,Math.cos),N.set(22,Math.cosh),N.set(25,Math.exp),N.set(30,Math.floor),N.set(35,Math.log),N.set(36,Math.log10),N.set(37,Math.log2),N.set(48,Math.floor),N.set(49,Math.ceil),N.set(51,Math.sin),N.set(52,Math.sinh),N.set(56,Math.tan),N.set(57,Math.tanh),N.set(59,Math.acosh),N.set(60,Math.asinh),N.set(65,Math.floor),ht.set(5,Math.pow),ht.set(61,Math.atan2),d.set(1,wn),d.set(2,vn),d.set(3,$n),d.set(11,Tn),d.set(12,Xt),d.set(12,Xt),d.set(13,Rn),d.set(14,In),d.set(15,Bn),d.set(16,Pn),d.set(17,jn),d.set(18,Mn),d.set(19,kn),d.set(20,Dn),d.set(23,Ut),d.set(24,Cn),d.set(26,En),d.set(27,_n),d.set(28,On),d.set(29,Gn),d.set(31,zn),d.set(32,An),d.set(33,Ln),d.set(34,Vn),d.set(44,qn),d.set(45,Hn),d.set(46,Un),d.set(64,Nn),d.set(65,Fn),d.set(76,Wn),d.set(38,ne),d.set(39,Jt),d.set(40,Qt),d.set(41,ee),d.set(42,Yt),d.set(43,se),d.set(47,Kt),d.set(54,te),d.set(55,Zt),d.set(58,re),d.set(66,Jn),d.set(67,Qn),d.set(68,ns),d.set(69,ss),d.set(70,Zn),d.set(71,Yn),d.set(72,rs),d.set(73,ts),d.set(74,es),d.set(75,Kn))}function is(t,e,a={}){os();const o=ge(xn(t)),{processAsMultiband:r,outputPixelType:s="f32"}=a,i=r?t[0].pixels.length:1,n=[];let u;for(let h=0;h<i;h++){const f=t.map(v=>v.pixels[h]);let m;if(e===pt.SetNull){const v=Xn(f,o,s);m=v.band,u=v.mask}else d.has(e)?m=d.get(e)(f,o,s):N.has(e)?m=bn(f,o,s,N.get(e)):ht.has(e)&&(m=Sn(f,o,s,ht.get(e)));if(m==null)return null;n.push(m)}u||e===pt.IsNull||(u=o);const c=t[0];return new g({width:c.width,height:c.height,pixelType:s,mask:u,pixels:n})}let Z=class extends I{constructor(){super(...arguments),this.functionName="Local",this.functionArguments=null,this.rasterArgumentNames=["rasters"]}_bindSourceRasters(){const{sourceRasterInfos:t}=this,e=t[0],{bandCount:a}=e,{processAsMultiband:o}=this.functionArguments;if(o&&t.some(s=>s.bandCount!==a))return{success:!1,error:"local-function: input rasters do not have same band count"};this.outputPixelType=this._getOutputPixelType("f32");const r=e.clone();return r.pixelType=this.outputPixelType,r.statistics=null,r.histograms=null,o||(r.bandCount=1),this.rasterInfo=r,{success:!0}}_processPixels(t){var a;const{pixelBlocks:e}=t;return S(e)||e.some(o=>S(o))?null:is(e,this.functionArguments.operation,{processAsMultiband:this.functionArguments.processAsMultiband,outputPixelType:(a=this.outputPixelType)!=null?a:void 0})}};l([p({json:{write:!0,name:"rasterFunction"}})],Z.prototype,"functionName",void 0),l([p({type:yn,json:{write:!0,name:"rasterFunctionArguments"}})],Z.prototype,"functionArguments",void 0),l([p()],Z.prototype,"rasterArgumentNames",void 0),Z=l([x("esri.layers.support.rasterFunctions.LocalFunction")],Z);const as=Z;var St;let tt=St=class extends R{constructor(){super(...arguments),this.includedRanges=null,this.noDataValues=null,this.noDataInterpretation=Lt.matchAny}clone(){var t,e,a,o;return new St({includedRanges:(e=(t=this.includedRanges)==null?void 0:t.slice())!=null?e:[],noDataValues:(o=(a=this.noDataValues)==null?void 0:a.slice())!=null?o:[],noDataInterpretation:this.noDataInterpretation})}};l([p({json:{write:!0}})],tt.prototype,"includedRanges",void 0),l([p({json:{write:!0}})],tt.prototype,"noDataValues",void 0),l([p({json:{write:!0}})],tt.prototype,"noDataInterpretation",void 0),tt=St=l([x("esri.layers.support.rasterFunctions.MaskFunctionArguments")],tt);const us=tt;let V=class extends I{constructor(){super(...arguments),this.functionName="Mask",this.functionArguments=null,this.rasterArgumentNames=["raster"],this.lookup=null}_bindSourceRasters(){const t=this.sourceRasterInfos[0].clone(),{pixelType:e}=t;this.outputPixelType=this._getOutputPixelType(e),t.pixelType=this.outputPixelType,this.rasterInfo=t;const{includedRanges:a,noDataValues:o}=this.functionArguments;return(a==null?void 0:a.length)||(o==null?void 0:o.length)?(this.lookup=be(e,this.functionArguments.includedRanges,this.functionArguments.noDataValues),{success:!0}):{success:!1,error:"missing includedRanges or noDataValues argument"}}_processPixels(t){var u;const e=(u=t.pixelBlocks)==null?void 0:u[0];if(S(e))return null;const{outputPixelType:a,lookup:o}=this,{includedRanges:r,noDataValues:s,noDataInterpretation:i}=this.functionArguments,n=i===Lt.matchAll;return Se(e,{includedRanges:r,noDataValues:s,outputPixelType:a,matchAll:n,lookup:o})}};l([p({json:{write:!0,name:"rasterFunction"}})],V.prototype,"functionName",void 0),l([p({type:us,json:{write:!0,name:"rasterFunctionArguments"}})],V.prototype,"functionArguments",void 0),l([p()],V.prototype,"rasterArgumentNames",void 0),l([p({json:{write:!0}})],V.prototype,"lookup",void 0),V=l([x("esri.layers.support.rasterFunctions.MaskFunction")],V);const ls=V;var Tt;let et=Tt=class extends R{constructor(){super(...arguments),this.visibleBandID=0,this.infraredBandID=1,this.scaled=!0}clone(){const{visibleBandID:t,infraredBandID:e,scaled:a}=this;return new Tt({visibleBandID:t,infraredBandID:e,scaled:a})}};l([p({json:{write:!0}})],et.prototype,"visibleBandID",void 0),l([p({json:{write:!0}})],et.prototype,"infraredBandID",void 0),l([p({json:{write:!0}})],et.prototype,"scaled",void 0),et=Tt=l([x("esri.layers.support.rasterFunctions.NDVIFunctionArguments")],et);const cs=et;let nt=class extends I{constructor(){super(...arguments),this.functionName="NDVI",this.functionArguments=null,this.rasterArgumentNames=["raster"]}_bindSourceRasters(){const{scaled:t}=this.functionArguments;this.outputPixelType=this._getOutputPixelType(t?"u8":"f32");const e=this.sourceRasterInfos[0].clone();e.pixelType=this.outputPixelType,e.colormap=null,e.histograms=null;const[a,o,r,s]=t?[0,200,100,10]:[-1,1,0,.1];return e.statistics=[{min:a,max:o,avg:r,stddev:s}],this.rasterInfo=e,{success:!0}}_processPixels(t){var s;const e=(s=t.pixelBlocks)==null?void 0:s[0];if(S(e))return null;const{visibleBandID:a,infraredBandID:o,scaled:r}=this.functionArguments;return Oe(e,a,o,r)}};l([p({json:{write:!0,name:"rasterFunction"}})],nt.prototype,"functionName",void 0),l([p({type:cs,json:{write:!0,name:"rasterFunctionArguments"}})],nt.prototype,"functionArguments",void 0),l([p()],nt.prototype,"rasterArgumentNames",void 0),nt=l([x("esri.layers.support.rasterFunctions.NDVIFunction")],nt);const ps=nt;var Rt;let z=Rt=class extends R{constructor(){super(...arguments),this.inputRanges=null,this.outputValues=null,this.noDataRanges=null,this.allowUnmatched=!1}clone(){return new Rt({inputRanges:[...this.inputRanges],outputValues:[...this.outputValues],noDataRanges:[...this.noDataRanges],allowUnmatched:this.allowUnmatched})}};l([p({json:{write:!0}})],z.prototype,"inputRanges",void 0),l([p({json:{write:!0}})],z.prototype,"outputValues",void 0),l([p({json:{write:!0}})],z.prototype,"noDataRanges",void 0),l([p({json:{write:!0}})],z.prototype,"allowUnmatched",void 0),z=Rt=l([x("esri.layers.support.rasterFunctions.RemapFunctionArguments")],z);const hs=z;let q=class extends I{constructor(){super(...arguments),this.functionName="Remap",this.functionArguments=null,this.rasterArgumentNames=["raster"],this.lookup=null}_bindSourceRasters(){const t=this.sourceRasterInfos[0].clone(),{pixelType:e}=t;this.outputPixelType=this._getOutputPixelType(e),t.pixelType=this.outputPixelType,t.colormap=null,t.histograms=null;const{statistics:a}=t,{allowUnmatched:o,outputValues:r}=this.functionArguments;if(j(a)&&a.length&&!o){let s=r[0],i=s;for(let n=0;n<r.length;n++)s=s>r[n]?r[n]:s,i=i>r[n]?i:r[n];for(let n=0;n<a.length;n++)a[n]=E(C({},a[n]),{min:s,max:i})}return this.rasterInfo=t,this.lookup=o?null:Te(e,this.functionArguments.inputRanges,r),{success:!0}}_processPixels(t){var u;const e=(u=t.pixelBlocks)==null?void 0:u[0];if(S(e))return null;const{lookup:a,outputPixelType:o}=this;if(a)return Vt(e,{lut:[a.lut],offset:a.offset,outputPixelType:o});const{inputRanges:r,outputValues:s,noDataRanges:i,allowUnmatched:n}=this.functionArguments;return Re(e,{inputRanges:r,outputValues:s,noDataRanges:i,allowUnmatched:n,outputPixelType:o})}};l([p({json:{write:!0,name:"rasterFunction"}})],q.prototype,"functionName",void 0),l([p({type:hs,json:{write:!0,name:"rasterFunctionArguments"}})],q.prototype,"functionArguments",void 0),l([p()],q.prototype,"rasterArgumentNames",void 0),l([p({json:{write:!0}})],q.prototype,"lookup",void 0),q=l([x("esri.layers.support.rasterFunctions.RemapFunction")],q);const fs=q;var It;const ms=new dt({0:"degree",1:"percent-rise",2:"adjusted"},{useNumericKeys:!0});let H=It=class extends R{constructor(){super(...arguments),this.slopeType="degree",this.zFactor=1,this.pixelSizePower=.664,this.pixelSizeFactor=.024}clone(){return new It({slopeType:this.slopeType,zFactor:this.zFactor,pixelSizePower:this.pixelSizePower,pixelSizeFactor:this.pixelSizeFactor,raster:this.raster})}};l([W(ms)],H.prototype,"slopeType",void 0),l([p({type:Number,json:{write:!0}})],H.prototype,"zFactor",void 0),l([p({type:Number,json:{name:"psPower",write:!0}})],H.prototype,"pixelSizePower",void 0),l([p({type:Number,json:{name:"psFactor",write:!0}})],H.prototype,"pixelSizeFactor",void 0),H=It=l([x("esri.layers.support.rasterFunctions.SlopeFunctionArguments")],H);const ds=H;let U=class extends I{constructor(){super(...arguments),this.functionName="Slope",this.functionArguments=null,this.rasterArgumentNames=["raster"],this.isGCS=!1}_bindSourceRasters(){this.outputPixelType=this._getOutputPixelType("f32");const t=this.sourceRasterInfos[0].clone();return t.pixelType=this.outputPixelType,t.statistics=null,t.histograms=null,this.rasterInfo=t,this.isGCS=t.spatialReference.isGeographic,{success:!0}}_processPixels(t){var c;const e=(c=t.pixelBlocks)==null?void 0:c[0];if(S(e))return null;const{zFactor:a,slopeType:o,pixelSizePower:r,pixelSizeFactor:s}=this.functionArguments,{isGCS:i}=this,{extent:n}=t,u=n?{x:n.width/e.width,y:n.height/e.height}:{x:1,y:1};return Ae(e,{zFactor:a,slopeType:o,pixelSizePower:r,pixelSizeFactor:s,isGCS:i,resolution:u})}};l([p({json:{write:!0,name:"rasterFunction"}})],U.prototype,"functionName",void 0),l([p({type:ds,json:{write:!0,name:"rasterFunctionArguments"}})],U.prototype,"functionArguments",void 0),l([p()],U.prototype,"rasterArgumentNames",void 0),l([p({json:{write:!0}})],U.prototype,"isGCS",void 0),U=l([x("esri.layers.support.rasterFunctions.SlopeFunction")],U);const gs=U;var Bt;let at=Bt=class extends R{constructor(){super(...arguments),this.statistics=null,this.histograms=null}clone(){return new Bt({statistics:M(this.statistics),histograms:M(this.histograms)})}};l([p({json:{write:!0}})],at.prototype,"statistics",void 0),l([p({json:{write:!0}})],at.prototype,"histograms",void 0),at=Bt=l([x("esri.layers.support.rasterFunctions.StatisticsHistogramsFunctionArguments")],at);const ys=at;let X=class extends I{constructor(){super(...arguments),this.functionName="StatisticsHistograms",this.functionArguments=null,this.rasterArgumentNames=["raster"]}_bindSourceRasters(){const t=this.sourceRasterInfos[0];this.outputPixelType=this._getOutputPixelType("u8");const e=t.clone(),{statistics:a,histograms:o}=this.functionArguments;return e.histograms=o,a&&(e.statistics=a.map(([r,s,i,n])=>({min:r,max:s,avg:i,stddev:n}))),this.rasterInfo=e,{success:!0}}_processPixels(t){var e;return(e=t.pixelBlocks)==null?void 0:e[0]}};l([p({json:{write:!0,name:"rasterFunction"}})],X.prototype,"functionName",void 0),l([p({type:ys,json:{write:!0,name:"rasterFunctionArguments"}})],X.prototype,"functionArguments",void 0),l([p()],X.prototype,"rasterArgumentNames",void 0),l([p({json:{write:!0}})],X.prototype,"indexedColormap",void 0),X=l([x("esri.layers.support.rasterFunctions.StatisticsHistogramsFunction")],X);const xs=X;var Pt;const ws=new dt({0:"none",3:"standard-deviation",4:"histogram-equalization",5:"min-max",6:"percent-clip",7:"sigmoid"},{useNumericKeys:!0});let b=Pt=class extends R{constructor(){super(...arguments),this.computeGamma=!1,this.dynamicRangeAdjustment=!1,this.gamma=[],this.histograms=null,this.statistics=null,this.stretchType="none",this.useGamma=!1}writeStatistics(t,e,a){(t==null?void 0:t.length)&&(Array.isArray(t[0])||(t=t.map(o=>[o.min,o.max,o.avg,o.stddev])),e[a]=t)}clone(){return new Pt({stretchType:this.stretchType,outputMin:this.outputMin,outputMax:this.outputMax,useGamma:this.useGamma,computeGamma:this.computeGamma,statistics:M(this.statistics),gamma:M(this.gamma),sigmoidStrengthLevel:this.sigmoidStrengthLevel,numberOfStandardDeviations:this.numberOfStandardDeviations,minPercent:this.minPercent,maxPercent:this.maxPercent,histograms:M(this.histograms),dynamicRangeAdjustment:this.dynamicRangeAdjustment,raster:this.raster})}};l([p({type:Boolean,json:{write:!0}})],b.prototype,"computeGamma",void 0),l([p({type:Boolean,json:{name:"dra",write:!0}})],b.prototype,"dynamicRangeAdjustment",void 0),l([p({type:[Number],json:{write:!0}})],b.prototype,"gamma",void 0),l([p()],b.prototype,"histograms",void 0),l([p({type:Number,json:{write:!0}})],b.prototype,"maxPercent",void 0),l([p({type:Number,json:{write:!0}})],b.prototype,"minPercent",void 0),l([p({type:Number,json:{write:!0}})],b.prototype,"numberOfStandardDeviations",void 0),l([p({type:Number,json:{name:"max",write:!0}})],b.prototype,"outputMax",void 0),l([p({type:Number,json:{name:"min",write:!0}})],b.prototype,"outputMin",void 0),l([p({type:Number,json:{write:!0}})],b.prototype,"sigmoidStrengthLevel",void 0),l([p({json:{type:[[Number]],write:!0}})],b.prototype,"statistics",void 0),l([st("statistics")],b.prototype,"writeStatistics",null),l([W(ws)],b.prototype,"stretchType",void 0),l([p({type:Boolean,json:{write:!0}})],b.prototype,"useGamma",void 0),b=Pt=l([x("esri.layers.support.rasterFunctions.StretchFunctionArguments")],b);const As=b;let D=class extends I{constructor(){super(...arguments),this.functionName="Stretch",this.functionArguments=null,this.rasterArgumentNames=["raster"],this.lookup=null,this.cutOffs=null}_bindSourceRasters(){this.lookup=null,this.cutOffs=null;const t=this.sourceRasterInfos[0],{pixelType:e}=t,{functionArguments:a}=this,{dynamicRangeAdjustment:o,gamma:r,useGamma:s}=a;if(!o&&["u8","u16","s8","s16"].includes(e)){const n=yt(a.toJSON(),{rasterInfo:t});this.lookup=ve(E(C({pixelType:e},n),{gamma:s?r:null}))}else o&&(this.cutOffs=yt(a.toJSON(),{rasterInfo:t}));this.outputPixelType=this._getOutputPixelType(e);const i=t.clone();return i.pixelType=this.outputPixelType,i.statistics=null,i.histograms=null,this.outputPixelType==="u8"&&(i.keyProperties.DataType="processed"),this.rasterInfo=i,{success:!0}}_processPixels(t){var i;const e=(i=t.pixelBlocks)==null?void 0:i[0];if(S(e))return e;const{lookup:a}=this;if(a)return Vt(e,E(C({},a),{outputPixelType:this.rasterInfo.pixelType}));const{functionArguments:o}=this,r=this.cutOffs||yt(o.toJSON(),{rasterInfo:this.sourceRasterInfos[0],pixelBlock:e}),s=o.useGamma?o.gamma:null;return $e(e,E(C({},r),{gamma:s,outputPixelType:this.outputPixelType}))}};l([p({json:{write:!0,name:"rasterFunction"}})],D.prototype,"functionName",void 0),l([p({type:As,json:{write:!0,name:"rasterFunctionArguments"}})],D.prototype,"functionArguments",void 0),l([p()],D.prototype,"rasterArgumentNames",void 0),l([p({json:{write:!0}})],D.prototype,"lookup",void 0),l([p({json:{write:!0}})],D.prototype,"cutOffs",void 0),D=l([x("esri.layers.support.rasterFunctions.StretchFunction")],D);const vs=D,T=new Map;function js(t,e){if("rasterFunction"in t)return oe(t,e!=null?e:{});throw new _t("raster-function-helper","unsupported raster function json.")}function $s(t,e){return e[0]==="rasters"&&Array.isArray(t.rasters)?t.rasters:e.map(a=>t[a])}function oe(t,e){var m,v;const{rasterFunction:a,rasterFunctionArguments:o}=t,r=(m=t.outputPixelType)==null?void 0:m.toLowerCase();if(a==null||!T.has(a))throw new _t("raster-function-helper",`unsupported raster function: ${a}`);const s=T.get(a),i=(typeof s.ctor=="function"?s.ctor:s.ctor.default).fromJSON(E(C({},t),{outputPixelType:r})),{rasterArgumentNames:n}=i,u=[],c=$s(o,n),h=n[0]==="rasters",f=[];for(let w=0;w<c.length;w++){const A=c[w];let F;A==null||typeof A=="string"&&A.startsWith("$")?u.push(e==null?void 0:e.raster):typeof A=="string"?e[A]&&u.push(e[A]):typeof A!="number"&&"rasterFunction"in A&&(F=oe(A,e),h||(i.functionArguments[n[w]]=F),u.push(F)),h&&f.push(F!=null?F:A)}if(h&&(i.functionArguments.rasters=f),e){i.sourceRasters=u;const w=(v=e.raster)==null?void 0:v.url;w&&(i.mainPrimaryRasterId=w)}return i}T.set("Aspect",{desc:"Aspect Function",ctor:Be,rasterArgumentNames:["raster"]}),T.set("BandArithmetic",{desc:"Band Arithmetic Function",ctor:nn,rasterArgumentNames:["raster"]}),T.set("Colormap",{desc:"Colormap Function",ctor:rn,rasterArgumentNames:["raster"]}),T.set("CompositeBand",{desc:"CompositeBand Function",ctor:an,rasterArgumentNames:["rasters"]}),T.set("Convolution",{desc:"Convolution Function",ctor:mn,rasterArgumentNames:["raster"]}),T.set("ExtractBand",{desc:"ExtractBand Function",ctor:gn,rasterArgumentNames:["raster"]}),T.set("Local",{desc:"Local Function",ctor:as,rasterArgumentNames:["rasters"]}),T.set("Mask",{desc:"Mask Function",ctor:ls,rasterArgumentNames:["raster"]}),T.set("NDVI",{desc:"NDVI Function",ctor:ps,rasterArgumentNames:["raster"]}),T.set("Remap",{desc:"Remap Function",ctor:fs,rasterArgumentNames:["raster"]}),T.set("Slope",{desc:"Slope Function",ctor:gs,rasterArgumentNames:["raster"]}),T.set("StatisticsHistograms",{desc:"Statistics Histograms Function",ctor:xs,rasterArgumentNames:["raster"]}),T.set("Stretch",{desc:"Stretch Function",ctor:vs,rasterArgumentNames:["raster"]});let ut=class extends mt{get affectsPixelSize(){return!1}forwardTransform(t){return t}inverseTransform(t){return t}};l([p()],ut.prototype,"affectsPixelSize",null),l([p({json:{write:!0}})],ut.prototype,"spatialReference",void 0),ut=l([x("esri.layers.support.rasterTransforms.BaseRasterTransform")],ut);const jt=ut;let lt=class extends jt{constructor(){super(...arguments),this.type="gcs-shift",this.tolerance=1e-8}forwardTransform(t){return(t=t.clone()).type==="point"?(t.x>180+this.tolerance&&(t.x-=360),t):(t.xmin>=180-this.tolerance?(t.xmax-=360,t.xmin-=360):t.xmax>180+this.tolerance&&(t.xmin=-180,t.xmax=180),t)}inverseTransform(t){return(t=t.clone()).type==="point"?(t.x<-this.tolerance&&(t.x+=360),t):(t.xmin<-this.tolerance&&(t.xmin+=360,t.xmax+=360),t)}};l([W({GCSShiftXform:"gcs-shift"})],lt.prototype,"type",void 0),l([p()],lt.prototype,"tolerance",void 0),lt=l([x("esri.layers.support.rasterTransforms.GCSShiftTransform")],lt);const Ns=lt;let ft=class extends jt{constructor(){super(...arguments),this.type="identity"}};l([W({IdentityXform:"identity"})],ft.prototype,"type",void 0),ft=l([x("esri.layers.support.rasterTransforms.IdentityTransform")],ft);const Fs=ft;function Mt(t,e,a){const{x:o,y:r}=e;if(a<2)return{x:t[0]+o*t[2]+r*t[4],y:t[1]+o*t[3]+r*t[5]};if(a===2){const m=o*o,v=r*r,w=o*r;return{x:t[0]+o*t[2]+r*t[4]+m*t[6]+w*t[8]+v*t[10],y:t[1]+o*t[3]+r*t[5]+m*t[7]+w*t[9]+v*t[11]}}const s=o*o,i=r*r,n=o*r,u=s*o,c=s*r,h=o*i,f=r*i;return{x:t[0]+o*t[2]+r*t[4]+s*t[6]+n*t[8]+i*t[10]+u*t[12]+c*t[14]+h*t[16]+f*t[18],y:t[1]+o*t[3]+r*t[5]+s*t[7]+n*t[9]+i*t[11]+u*t[13]+c*t[15]+h*t[17]+f*t[19]}}function ie(t,e,a){const{xmin:o,ymin:r,xmax:s,ymax:i,spatialReference:n}=e;let u=[];if(a<2)u.push({x:o,y:i}),u.push({x:s,y:i}),u.push({x:o,y:r}),u.push({x:s,y:r});else{let f=10;for(let m=0;m<f;m++)u.push({x:o,y:r+(i-r)*m/(f-1)}),u.push({x:s,y:r+(i-r)*m/(f-1)});f=8;for(let m=1;m<=f;m++)u.push({x:o+(s-o)*m/f,y:r}),u.push({x:o+(s-o)*m/f,y:i})}u=u.map(f=>Mt(t,f,a));const c=u.map(f=>f.x),h=u.map(f=>f.y);return new ye({xmin:Math.min.apply(null,c),xmax:Math.max.apply(null,c),ymin:Math.min.apply(null,h),ymax:Math.max.apply(null,h),spatialReference:n})}function bs(t){const[e,a,o,r,s,i]=t,n=o*i-s*r,u=s*r-o*i;return[(s*a-e*i)/n,(o*a-e*r)/u,i/n,r/u,-s/n,-o/u]}let P=class extends jt{constructor(){super(...arguments),this.polynomialOrder=1,this.type="polynomial"}readForwardCoefficients(t,e){const{coeffX:a,coeffY:o}=e;if(!(a==null?void 0:a.length)||!(o==null?void 0:o.length)||a.length!==o.length)return null;const r=[];for(let s=0;s<a.length;s++)r.push(a[s]),r.push(o[s]);return r}writeForwardCoefficients(t,e,a){const o=[],r=[];for(let s=0;s<(t==null?void 0:t.length);s++)s%2==0?o.push(t[s]):r.push(t[s]);e.coeffX=o,e.coeffY=r}get inverseCoefficients(){let t=this._get("inverseCoefficients");const e=this._get("forwardCoefficients");return!t&&e&&this.polynomialOrder<2&&(t=bs(e)),t}set inverseCoefficients(t){this._set("inverseCoefficients",t)}readInverseCoefficients(t,e){const{inverseCoeffX:a,inverseCoeffY:o}=e;if(!(a==null?void 0:a.length)||!(o==null?void 0:o.length)||a.length!==o.length)return null;const r=[];for(let s=0;s<a.length;s++)r.push(a[s]),r.push(o[s]);return r}writeInverseCoefficients(t,e,a){const o=[],r=[];for(let s=0;s<(t==null?void 0:t.length);s++)s%2==0?o.push(t[s]):r.push(t[s]);e.inverseCoeffX=o,e.inverseCoeffY=r}get affectsPixelSize(){return this.polynomialOrder>0}forwardTransform(t){if(t.type==="point"){const e=Mt(this.forwardCoefficients,t,this.polynomialOrder);return new Ot({x:e.x,y:e.y,spatialReference:t.spatialReference})}return ie(this.forwardCoefficients,t,this.polynomialOrder)}inverseTransform(t){if(t.type==="point"){const e=Mt(this.inverseCoefficients,t,this.polynomialOrder);return new Ot({x:e.x,y:e.y,spatialReference:t.spatialReference})}return ie(this.inverseCoefficients,t,this.polynomialOrder)}};l([p({json:{write:!0}})],P.prototype,"polynomialOrder",void 0),l([p()],P.prototype,"forwardCoefficients",void 0),l([gt("forwardCoefficients",["coeffX","coeffY"])],P.prototype,"readForwardCoefficients",null),l([st("forwardCoefficients")],P.prototype,"writeForwardCoefficients",null),l([p({json:{write:!0}})],P.prototype,"inverseCoefficients",null),l([gt("inverseCoefficients",["inverseCoeffX","inverseCoeffY"])],P.prototype,"readInverseCoefficients",null),l([st("inverseCoefficients")],P.prototype,"writeInverseCoefficients",null),l([p()],P.prototype,"affectsPixelSize",null),l([W({PolynomialXform:"polynomial"})],P.prototype,"type",void 0),P=l([x("esri.layers.support.rasterTransforms.PolynomialTransform")],P);const Ss=P,ae={GCSShiftXform:Ns,IdentityXform:Fs,PolynomialXform:Ss},Ts=Object.keys(ae);function Ms(t){const e=t==null?void 0:t.type;return!t||Ts.includes(e)}function ks(t){if(!(t==null?void 0:t.type))return null;const a=ae[t==null?void 0:t.type];if(a){const o=new a;return o.read(t),o}return null}export{Ns as c,Ms as f,ks as i,js as l,Ss as m};
