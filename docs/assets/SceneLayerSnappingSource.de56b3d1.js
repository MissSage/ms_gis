import{C as b,aq as i,ar as a,as as y,hM as f,a3 as k,pq as L,pf as w,pj as C,hO as H,kb as E,E as _,gt as v,bD as j,d1 as x,ao as I,W as A,A as O}from"./vendor.150443b7.js";import{h as S}from"./WorkerHandle.93617749.js";import{D as h}from"./workerHelper.2d33c03b.js";import{f as V}from"./edgeProcessing.a4751821.js";import{o as P}from"./VertexSnappingCandidate.9af5b217.js";import"./BufferView.8b09f266.js";import"./InterleavedLayout.b9f1279a.js";import"./types.44c7402c.js";import"./deduplicate.e7a51a71.js";import"./VertexAttribute.42396f25.js";import"./glUtil.b02793dc.js";import"./enums.2d9e6f64.js";import"./VertexElementDescriptor.1fdca6da.js";class $ extends S{constructor(e){super("EdgeProcessingWorker","extract",{extract:r=>[r.dataBuffer],extractComponentsEdgeLocations:r=>[r.dataBuffer],extractEdgeLocations:r=>[r.dataBuffer]},e)}async process(e,r,s){if(s)return V(e);const n=await this.invoke(new g(e),r);return this._unpackOutput(n)}async extractEdgeLocations(e,r){const s=await this.invokeMethod("extractEdgeLocations",new g(e),r);return h(s)}async extractComponentsEdgeLocations(e,r){const s=await this.invokeMethod("extractComponentsEdgeLocations",new g(e),r);return h(s)}_unpackOutput(e){return{regular:{instancesData:h(e.regular.instancesData),lodInfo:{lengths:new Float32Array(e.regular.lodInfo.lengths)}},silhouette:{instancesData:h(e.silhouette.instancesData),lodInfo:{lengths:new Float32Array(e.silhouette.lodInfo.lengths)}},averageEdgeLength:e.averageEdgeLength}}}class g{constructor(e){this.dataBuffer=e.data.buffer,this.writerSettings=e.writerSettings,this.skipDeduplicate=e.skipDeduplicate,this.indices=Array.isArray(e.indices)?e.indices:e.indices.buffer,this.indicesType=Array.isArray(e.indices)?"Array":b(e.indices)?"Uint32Array":"Uint16Array",this.indicesLength=e.indicesLength}}let c=class extends f{constructor(t){super(t),this.availability=0,this._ids=new Set,this._tmpP=k()}destroy(){this._workerHandle.destroy(),this._workerHandle=null}initialize(){this._workerHandle=new D(this.schedule,{fetchAllEdgeLocations:(t,e)=>this._fetchAllEdgeLocations(t,e)})}async fetchCandidates(t,e){const r=t.coordinateHelper,s=r.toXYZ(t.point);this.renderCoordsHelper.toRenderCoords(s,r.spatialReference,s);const n=t.distance,p=typeof n=="number"?n:n.distance,o=await this._workerHandle.invoke({bounds:L(s[0],s[1],s[2],p),types:t.types},e);return o.candidates.sort((u,m)=>u.distance-m.distance),o.candidates.map(u=>this._convertCandidate(r,u))}async add(t,e){this._ids.add(t.id),await this._workerHandle.invokeMethod("add",t,e)}async remove(t,e){this._ids.delete(t.id),await this._workerHandle.invokeMethod("remove",t,e)}_convertCandidate(t,e){switch(e.type){case"edge":return new C({coordinateHelper:t,objectId:e.objectId,targetPoint:this._convertRenderCoordinate(t,e.target),edgeStart:this._convertRenderCoordinate(t,e.start),edgeEnd:this._convertRenderCoordinate(t,e.end),elevationInfo:w});case"vertex":return new P({coordinateHelper:t,objectId:e.objectId,targetPoint:this._convertRenderCoordinate(t,e.target),elevationInfo:w})}}_convertRenderCoordinate(t,e){return this.renderCoordsHelper.fromRenderCoords(e,this._tmpP,t.spatialReference),t.fromXYZ(this._tmpP)}async _fetchAllEdgeLocations(t,e){const r=[],s=[];for(const{id:n,uid:p}of t.components)this._ids.has(n)&&r.push((async()=>{const o=await this.fetchEdgeLocations(n,e.signal);return s.push(o.locations.buffer),{id:n,uid:p,objectIds:o.objectIds,locations:o.locations.buffer,origin:o.origin,type:o.type}})());return{result:{components:(await Promise.all(r)).filter(({id:n})=>this._ids.has(n))},transferList:s}}};i([a({constructOnly:!0})],c.prototype,"renderCoordsHelper",void 0),i([a({constructOnly:!0})],c.prototype,"fetchEdgeLocations",void 0),i([a({constructOnly:!0})],c.prototype,"schedule",void 0),i([a({readOnly:!0})],c.prototype,"availability",void 0),c=i([y("esri.views.interactive.snapping.featureSources.sceneLayerSource.SceneLayerSnappingSourceWorker")],c);class D extends S{constructor(e,r){super("SceneLayerSnappingSourceWorker","fetchCandidates",{},e,{strategy:"dedicated",client:r})}}let d=class extends f{constructor(t){super(t),this.availability=1,this._abortController=new AbortController}get updating(){return this.updatingHandles.updating}destroy(){this._tracker=H(this._tracker),this._abortController=E(this._abortController)}initialize(){const{view:t}=this,e=t.resourceController;this._edgeWorker=new $(r=>e.schedule(r)),this._workerHandle=new c({renderCoordsHelper:this.view.renderCoordsHelper,schedule:r=>e.schedule(r),fetchEdgeLocations:async(r,s)=>{if(_(this._tracker))throw new Error("tracker-not-initialized");return this._tracker.fetchEdgeLocations(r,this._edgeWorker,s)}}),this.updatingHandles.addPromise(this._setupLayerView()),this.handles.add([v(this._workerHandle),v(this._edgeWorker)])}async fetchCandidates(t,e){return this._workerHandle.fetchCandidates(t,e)}refresh(){}async _setupLayerView(){if(this.destroyed)return;const t=j(this._abortController,r=>r.signal),e=await this.getLayerView();_(e)||x(t)||(this._tracker=e.trackSnappingSources({add:(r,s)=>{this.updatingHandles.addPromise(this._workerHandle.add({id:r,bounds:s},t))},remove:r=>{this.updatingHandles.addPromise(this._workerHandle.remove({id:r},t))}}))}};i([a({constructOnly:!0})],d.prototype,"getLayerView",void 0),i([a({constructOnly:!0})],d.prototype,"view",void 0),i([a({readOnly:!0})],d.prototype,"updating",null),i([a({readOnly:!0})],d.prototype,"availability",void 0),d=i([y("esri.views.interactive.snapping.featureSources.I3SSnappingSource")],d);let l=class extends I{constructor(t){super(t),this.availability=1,this._i3sSources=[]}get updating(){return this._i3sSources.some(t=>t.updating)}destroy(){this._i3sSources.forEach(t=>t.destroy()),this._i3sSources.length=0}initialize(){const{view:t}=this,e=this.layerSource.layer;this._i3sSources=e.type==="building-scene"?this._getBuildingSceneI3SSources(t,e):[this._getSceneLayerI3SSource(t,e)]}async fetchCandidates(t,e){const r=await Promise.all(this._i3sSources.map(s=>s.fetchCandidates(t,e)));return A(e),r.flat()}refresh(){this._i3sSources.forEach(t=>t.refresh())}_getBuildingSceneI3SSources(t,e){return e.allSublayers.toArray().map(r=>r.type==="building-component"?new d({getLayerView:async()=>(await t.whenLayerView(e)).whenSublayerView(r),view:t}):null).filter(O)}_getSceneLayerI3SSource(t,e){return new d({getLayerView:async()=>{const r=await t.whenLayerView(e);return r.type==="scene-layer-graphics-3d"?void 0:r},view:t})}};i([a({constructOnly:!0})],l.prototype,"layerSource",void 0),i([a({constructOnly:!0})],l.prototype,"view",void 0),i([a({readOnly:!0})],l.prototype,"updating",null),i([a({readOnly:!0})],l.prototype,"availability",void 0),l=i([y("esri.views.interactive.snapping.featureSources.SceneLayerSnappingSource")],l);export{l as SceneLayerSnappingSource};
