import{A as m,E as x,jd as O,bb as A,gG as R,jj as j,ji as k}from"./vendor.f59460b9.js";import{I as D,g as F,f as U,c as V,e as B}from"./I3SBinaryReader.4deb9b13.js";import{r as z,n as S}from"./vec3f32.1121a836.js";import{a as J,b as N,d as q}from"./PointCloudUniqueValueRenderer.6795cc04.js";import"./VertexAttribute.42396f25.js";function E(s,t,l,o){const{rendererJSON:u,isRGBRenderer:d}=s;let n=null,a=null;if(t&&d)n=t;else if(t&&u.type==="pointCloudUniqueValueRenderer"){a=J.fromJSON(u);const e=a.colorUniqueValueInfos;n=new Uint8Array(3*o);const f=v(a.fieldTransformType);for(let r=0;r<o;r++){const c=(f?f(t[r]):t[r])+"";for(let i=0;i<e.length;i++)if(e[i].values.includes(c)){n[3*r]=e[i].color.r,n[3*r+1]=e[i].color.g,n[3*r+2]=e[i].color.b;break}}}else if(t&&u.type==="pointCloudStretchRenderer"){a=N.fromJSON(u);const e=a.stops;n=new Uint8Array(3*o);const f=v(a.fieldTransformType);for(let r=0;r<o;r++){const c=f?f(t[r]):t[r],i=e.length-1;if(c<e[0].value)n[3*r]=e[0].color.r,n[3*r+1]=e[0].color.g,n[3*r+2]=e[0].color.b;else if(c>=e[i].value)n[3*r]=e[i].color.r,n[3*r+1]=e[i].color.g,n[3*r+2]=e[i].color.b;else for(let b=1;b<e.length;b++)if(c<e[b].value){const p=(c-e[b-1].value)/(e[b].value-e[b-1].value);n[3*r]=e[b].color.r*p+e[b-1].color.r*(1-p),n[3*r+1]=e[b].color.g*p+e[b-1].color.g*(1-p),n[3*r+2]=e[b].color.b*p+e[b-1].color.b*(1-p);break}}}else if(t&&u.type==="pointCloudClassBreaksRenderer"){a=q.fromJSON(u);const e=a.colorClassBreakInfos;n=new Uint8Array(3*o);const f=v(a.fieldTransformType);for(let r=0;r<o;r++){const c=f?f(t[r]):t[r];for(let i=0;i<e.length;i++)if(c>=e[i].minValue&&c<=e[i].maxValue){n[3*r]=e[i].color.r,n[3*r+1]=e[i].color.g,n[3*r+2]=e[i].color.b;break}}}else{n=new Uint8Array(3*o);for(let e=0;e<n.length;e++)n[e]=255}if(l&&a&&a.colorModulation){const e=a.colorModulation.minValue,f=a.colorModulation.maxValue,r=.3;for(let c=0;c<o;c++){const i=l[c],b=i>=f?1:i<=e?r:r+(1-r)*(i-e)/(f-e);n[3*c]=b*n[3*c],n[3*c+1]=b*n[3*c+1],n[3*c+2]=b*n[3*c+2]}}return n}function T(s,t){if(s.encoding==null||s.encoding===""){const l=F(t,s);if(x(l.vertexAttributes.position))return;const o=U(t,l.vertexAttributes.position),u=l.header.fields,d=[u.offsetX,u.offsetY,u.offsetZ],n=[u.scaleX,u.scaleY,u.scaleZ],a=o.length/3,e=new Float64Array(3*a);for(let f=0;f<a;f++)e[3*f]=o[3*f]*n[0]+d[0],e[3*f+1]=o[3*f+1]*n[1]+d[1],e[3*f+2]=o[3*f+2]*n[2]+d[2];return e}if(s.encoding==="lepcc-xyz")return V(t).result}function g(s,t,l){return m(s)&&s.attributeInfo.useElevation?_(t,l):m(s)?D(s.attributeInfo.storageInfo,s.buffer,l):null}function _(s,t){const l=new Float64Array(t);for(let o=0;o<t;o++)l[o]=s[3*o+2];return l}function P(s,t,l,o,u){const d=s.length/3;let n=0;for(let a=0;a<d;a++){let e=!0;for(let f=0;f<o.length&&e;f++){const{filterJSON:r}=o[f],c=u[f].values[a];switch(r.type){case"pointCloudValueFilter":{const i=r.mode==="exclude";r.values.includes(c)===i&&(e=!1);break}case"pointCloudBitfieldFilter":{const i=M(r.requiredSetBits),b=M(r.requiredClearBits);(c&i)===i&&(c&b)==0||(e=!1);break}case"pointCloudReturnFilter":{const i=15&c,b=c>>>4&15,p=b>1,C=i===1,y=i===b;let I=!1;for(const h of r.includedReturns)if(h==="last"&&y||h==="firstOfMany"&&C&&p||h==="lastOfMany"&&y&&p||h==="single"&&!p){I=!0;break}I||(e=!1);break}}}e&&(l[n]=a,s[3*n]=s[3*a],s[3*n+1]=s[3*a+1],s[3*n+2]=s[3*a+2],t[3*n]=t[3*a],t[3*n+1]=t[3*a+1],t[3*n+2]=t[3*a+2],n++)}return n}function v(s){return s==null||s==="none"?null:s==="low-four-bit"?t=>15&t:s==="high-four-bit"?t=>(240&t)>>4:s==="absolute-value"?t=>Math.abs(t):s==="modulo-ten"?t=>t%10:null}function M(s){let t=0;for(const l of s||[])t|=1<<l;return t}class G{transform(t){const l=this._transform(t),o=[l.points.buffer,l.rgb.buffer];m(l.pointIdFilterMap)&&o.push(l.pointIdFilterMap.buffer);for(const u of l.attributes)"buffer"in u.values&&O(u.values.buffer)&&u.values.buffer!==l.rgb.buffer&&o.push(u.values.buffer);return Promise.resolve({result:l,transferList:o})}_transform(t){const l=T(t.schema,t.geometryBuffer);let o=l.length/3,u=null;const d=[],n=g(t.primaryAttributeData,l,o);m(t.primaryAttributeData)&&n&&d.push({attributeInfo:t.primaryAttributeData.attributeInfo,values:n});const a=g(t.modulationAttributeData,l,o);m(t.modulationAttributeData)&&a&&d.push({attributeInfo:t.modulationAttributeData.attributeInfo,values:a});let e=E(t.rendererInfo,n,a,o);if(t.filterInfo&&t.filterInfo.length>0&&m(t.filterAttributesData)){const r=t.filterAttributesData.map(c=>{const i=g(c,l,o),b={attributeInfo:c.attributeInfo,values:i};return d.push(b),b});u=new Uint32Array(o),o=P(l,e,u,t.filterInfo,r)}for(const r of t.userAttributesData){const c=g(r,l,o);d.push({attributeInfo:r.attributeInfo,values:c})}3*o<e.length&&(e=new Uint8Array(e.buffer.slice(0,3*o))),this._applyElevationOffsetInPlace(l,o,t.elevationOffset);const f=this._transformCoordinates(l,o,t.obb,A.fromJSON(t.inSR),A.fromJSON(t.outSR));return{obb:t.obb,points:f,rgb:e,attributes:d,pointIdFilterMap:u}}_transformCoordinates(t,l,o,u,d){if(!R(t,u,0,t,d,0,l))throw new Error("Can't reproject");const n=z(o.center[0],o.center[1],o.center[2]),a=S(),e=S();j(w,o.quaternion);const f=new Float32Array(3*l);for(let r=0;r<l;r++)a[0]=t[3*r]-n[0],a[1]=t[3*r+1]-n[1],a[2]=t[3*r+2]-n[2],k(e,a,w),o.halfSize[0]=Math.max(o.halfSize[0],Math.abs(e[0])),o.halfSize[1]=Math.max(o.halfSize[1],Math.abs(e[1])),o.halfSize[2]=Math.max(o.halfSize[2],Math.abs(e[2])),f[3*r]=a[0],f[3*r+1]=a[1],f[3*r+2]=a[2];return f}_applyElevationOffsetInPlace(t,l,o){if(o!==0)for(let u=0;u<l;u++)t[3*u+2]+=o}}const w=B();function K(){return new G}export{K as default};
