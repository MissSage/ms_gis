var g=Object.defineProperty,C=Object.defineProperties;var F=Object.getOwnPropertyDescriptors;var v=Object.getOwnPropertySymbols;var J=Object.prototype.hasOwnProperty,N=Object.prototype.propertyIsEnumerable;var L=(r,a,e)=>a in r?g(r,a,{enumerable:!0,configurable:!0,writable:!0,value:e}):r[a]=e,f=(r,a)=>{for(var e in a||(a={}))J.call(a,e)&&L(r,e,a[e]);if(v)for(var e of v(a))N.call(a,e)&&L(r,e,a[e]);return r},m=(r,a)=>C(r,F(a));import{A as p,ew as U,E as O,J as j,eA as x,eB as M,cX as V}from"./vendor.f59460b9.js";import{a as i,r as E}from"./fetchService.ce8dc8a2.js";import{a as A}from"./lazyLayerLoader.f8301daa.js";async function Q(r){var n;const a=(n=r.properties)==null?void 0:n.customParameters,e=await B(r.url,a),t=m(f({},r.properties),{url:r.url});if(!e.sublayerIds)return e.layerOrTableId!=null&&(t.layerId=e.layerOrTableId,t.sourceJSON=e.sourceJSON),new e.Constructor(t);const l=new(await import("./GroupLayer.7f80a0ce.js")).default({title:e.parsedUrl.title});return k(l,e,t),l}function P(r,a){return r?r.find(e=>e.id===a):null}function k(r,a,e){function t(l,n){const o=m(f({},e),{layerId:l,sublayerTitleMode:"service-name"});return p(n)&&(o.sourceJSON=n),new a.Constructor(o)}a.sublayerIds.forEach(l=>{const n=t(l,P(a.sublayerInfos,l));r.add(n)}),a.tableIds.forEach(l=>{const n=t(l,P(a.tableInfos,l));r.tables.add(n)})}async function B(r,a){var S,b;let e=U(r);if(O(e)&&(e=await z(r,a)),O(e))throw new j("arcgis-layers:url-mismatch","The url '${url}' is not a valid arcgis resource",{url:r});const{serverType:t,sublayer:l}=e;let n;const o={FeatureServer:"FeatureLayer",StreamServer:"StreamLayer",VectorTileServer:"VectorTileLayer"};switch(t){case"MapServer":n=l!=null?"FeatureLayer":X(r,a).then(s=>s?"TileLayer":"MapImageLayer");break;case"ImageServer":n=i(r,{customParameters:a}).then(s=>{const y=s.tileInfo&&s.tileInfo.format;return s.tileInfo?(y==null?void 0:y.toUpperCase())!=="LERC"||s.cacheType&&s.cacheType.toLowerCase()!=="elevation"?"ImageryTileLayer":"ElevationLayer":"ImageryLayer"});break;case"SceneServer":n=i(e.url.path,{customParameters:a}).then(s=>{var y;if(s){if((s==null?void 0:s.layerType)==="Voxel")return"VoxelLayer";if((s==null?void 0:s.layers)&&Array.isArray(s.layers)&&s.layers.length>0){const h={Point:"SceneLayer","3DObject":"SceneLayer",IntegratedMesh:"IntegratedMeshLayer",PointCloud:"PointCloudLayer",Building:"BuildingSceneLayer"},w=(y=s.layers[0])==null?void 0:y.layerType;if(h[w]!=null)return h[w]}}return"SceneLayer"});break;default:n=o[t]}const u={FeatureLayer:!0,SceneLayer:!0},d=t==="FeatureServer",c={parsedUrl:e,Constructor:null,layerOrTableId:d?l:null,sublayerIds:null,tableIds:null},I=await n;if(u[I]&&l==null){const s=await G(r,t,a);d&&(c.sublayerInfos=s.layerInfos,c.tableInfos=s.tableInfos),s.layerIds.length+s.tableIds.length!==1?(c.sublayerIds=s.layerIds,c.tableIds=s.tableIds):d&&(c.layerOrTableId=(S=s.layerIds[0])!=null?S:s.tableIds[0],c.sourceJSON=(b=s.layerInfos[0])!=null?b:s.tableInfos[0])}return c.Constructor=await R(I),c}async function z(r,a){var u;const e=await i(r,{customParameters:a});let t=null,l=null;const n=e.type;if(n==="Feature Layer"||n==="Table"?(t="FeatureServer",l=e.id):n==="indexedVector"?t="VectorTileServer":e.hasOwnProperty("mapName")?t="MapServer":e.hasOwnProperty("bandCount")&&e.hasOwnProperty("pixelSizeX")?t="ImageServer":e.hasOwnProperty("maxRecordCount")&&e.hasOwnProperty("allowGeometryUpdates")?t="FeatureServer":e.hasOwnProperty("streamUrls")?t="StreamServer":T(e)?(t="SceneServer",l=e.id):e.hasOwnProperty("layers")&&T((u=e.layers)==null?void 0:u[0])&&(t="SceneServer"),!t)return null;const o=l!=null?x(r):null;return{title:p(o)&&e.name||M(r),serverType:t,sublayer:l,url:{path:p(o)?o.serviceUrl:V(r).path}}}function T(r){return(r==null?void 0:r.hasOwnProperty("store"))&&r.hasOwnProperty("id")&&typeof r.id=="number"}async function G(r,a,e){let t,l=!1;if(a==="FeatureServer"){const u=await E(r,{customParameters:e});l=!!u.layersJSON,t=u.layersJSON||u.serviceJSON}else t=await i(r,{customParameters:e});const n=t==null?void 0:t.layers,o=t==null?void 0:t.tables;return{layerIds:(n==null?void 0:n.map(u=>u.id).reverse())||[],tableIds:(o==null?void 0:o.map(u=>u.id).reverse())||[],layerInfos:l?n:[],tableInfos:l?o:[]}}async function R(r){return(0,A[r])()}async function X(r,a){return(await i(r,{customParameters:a})).tileInfo}export{Q as fromUrl};
