var ve=Object.defineProperty,Te=Object.defineProperties;var Se=Object.getOwnPropertyDescriptors;var Z=Object.getOwnPropertySymbols;var we=Object.prototype.hasOwnProperty,Fe=Object.prototype.propertyIsEnumerable;var ee=(e,t,r)=>t in e?ve(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,g=(e,t)=>{for(var r in t||(t={}))we.call(t,r)&&ee(e,r,t[r]);if(Z)for(var r of Z(t))Fe.call(t,r)&&ee(e,r,t[r]);return e},b=(e,t)=>Te(e,Se(t));import{x as te,I as A,b8 as P,J as c,cQ as re,A as E,d3 as Ee,d4 as Ie,M as U,$ as se,d5 as ie,E as ne,bE as ze,d6 as Ve,d7 as Oe}from"./vendor.150443b7.js";import{k as R,S as x,r as Me}from"./Utils.eb4237a0.js";import{c as Ne}from"./utils.9098e95e.js";import{l as $e}from"./visualVariablesUtils.feab36b0.js";import{createSymbolSchema as h}from"./createSymbolSchema.b2543046.js";import{t as Le}from"./cimAnalyzer.ec0c3ab9.js";import{A as Be}from"./definitions.d3c1cadf.js";import"./alignmentUtils.6849a0a8.js";import"./number.30628ef2.js";import"./ExpandedCIM.6c0ca00a.js";import{e as le}from"./util.cb1e83e1.js";function Ce(e){if(!e)return R.NONE;let t=0;for(const r of e)if(r.type==="size"){const s=$e(r);t|=s,r.target==="outline"&&(t|=s<<4)}else r.type==="color"?t|=R.COLOR:r.type==="opacity"?t|=R.OPACITY:r.type==="rotation"&&(t|=R.ROTATION);return t}function Ae(e,t){if(!("visualVariables"in e)||!e.hasVisualVariables("size"))return 0;const r=e.getVisualVariablesForType("size");if(!r[0])return 0;const s=r[0];if(t&&s.field==="cluster_count"&&t.type==="cluster")return t.clusterMaxSize;if(s.target==="outline")return 0;if(s.transformationType==="stops")return s.stops.map(i=>i.size).reduce(j,0);if(s.transformationType==="clamped-linear"){let i=-1/0,n=-1/0;return i=typeof s.maxSize=="number"?s.maxSize:s.maxSize.stops.map(l=>l.size).reduce(j,0),n=typeof s.minSize=="number"?s.minSize:s.minSize.stops.map(l=>l.size).reduce(j,0),Math.max(i,n)}return s.transformationType==="real-world-size"?30:void 0}Be.metrics,new Le(0,0,24,24);function j(e,t){return Math.max(e,t)}const k=8,ae=k-2,D=te.getLogger("esri.views.2d.layers.features.support.rendererUtils"),gt=e=>{if(!("visualVariables"in e)||!e.visualVariables||!e.visualVariables.length)return e;const t=e.clone(),r=t.visualVariables.map(s=>oe(s)?ue(s):s);return t.visualVariables=r,t};function Re(e){return e.map(t=>oe(t)?ue(t.clone()):t)}function oe(e){return(e.type==="size"||e.type==="color"||e.type==="opacity")&&e.stops!=null}function ue(e){return e.stops=Pe(e.type,e.stops),e}function V(e,t,r){return(1-r)*e+r*t}function ke(e,t){const[r,...s]=t,i=s.pop(),n=s[0].value,l=s[s.length-1].value,u=(l-n)/ae,o=[];for(let a=n;a<l;a+=u){let p=0;for(;a>=s[p].value;)p++;const d=s[p],f=t[p-1],I=a-f.value,F=d.value===f.value?1:I/(d.value-f.value);if(e==="color"){const v=s[p],T=t[p-1],m=v.color.clone();m.r=V(T.color.r,m.r,F),m.g=V(T.color.g,m.g,F),m.b=V(T.color.b,m.b,F),m.a=V(T.color.a,m.a,F),o.push({value:a,color:m,label:v.label})}else if(e==="size"){const v=s[p],T=t[p-1],m=re(v.size),S=V(re(T.size),m,F);o.push({value:a,size:S,label:v.label})}else{const v=s[p],T=V(t[p-1].opacity,v.opacity,F);o.push({value:a,opacity:T,label:v.label})}}return[r,...o,i]}function De(e){const[t,...r]=e,s=r.pop();for(;r.length>ae;){let i=0,n=0;for(let l=1;l<r.length;l++){const u=r[l-1],o=r[l],a=Math.abs(o.value-u.value);a>n&&(n=a,i=l)}r.splice(i,1)}return[t,...r,s]}function Pe(e,t){return t.length<=k?t:(D.warn(`Found ${t.length} Visual Variable stops, but MapView only supports ${k}. Displayed stops will be simplified.`),t.length>2*k?ke(e,t):De(t))}function J(){if(A("heatmap-force-raster"))return"raster";const{supportsTextureFloat:e,supportsTextureHalfFloat:t,supportsColorBufferFloat:r,supportsColorBufferFloatBlend:s,supportsColorBufferHalfFloat:i}=P("2d");return e&&r&&s||t&&i?"symbol":A("heatmap-allow-raster-fallback")?"raster":"none"}function bt(e){if(!e)return!0;switch(e.type){case"dot-density":if(!P("2d").supportsTextureFloat)return D.error(new c("webgl-missing-extension","Missing WebGL extension OES_Texture_Float which is required for DotDensity")),!1;break;case"heatmap":{const t=J();if(t==="none"||t==="raster"&&!A("heatmap-force-raster")){const r=P("2d"),s=["supportsTextureFloat","supportsTextureHalfFloat","supportsColorBufferFloat","supportsColorBufferFloatBlend","supportsColorBufferHalfFloat"].filter(i=>!r[i]).join(", ");if(t==="none")return D.errorOnce(new c("webgl-missing-extension",`Missing WebGL${r.type} requirements for Heatmap: ${s}`)),!1;t==="raster"&&D.warnOnce(`Missing WebGL${r.type} requirements for accelerated Heatmap: ${s}. Feature support may be limited.`)}break}}return!0}const O=te.getLogger("esri.views.2d.layers.features.schemaUtils"),y="ValidationError";function pe(e){return e}function H(e,t){let r=0,s=0,i=x.DEFAULT;if(E(e)){if(s=Ae(e,t),"visualVariables"in e&&(r=Ce(e.visualVariables||[]),e.type==="dot-density"&&(i=x.DOT_DENSITY)),e.type==="heatmap"&&(i=x.HEATMAP),e.type==="dictionary")return{maxVVSize:s,vvFlags:r,symbologyType:x.DEFAULT};if(e.type==="pie-chart")return{maxVVSize:s,vvFlags:r,symbologyType:x.PIE_CHART};if(i!==x.DOT_DENSITY&&i!==x.HEATMAP){const n=e.getSymbols();"backgroundFillSymbol"in e&&e.backgroundFillSymbol&&n.push(e.backgroundFillSymbol);let l=!0,u=!0;for(const o of n)if(o.type==="cim"&&(u=!1),o.type==="simple-fill"||o.type==="picture-fill"){const a=o.outline,p=a&&a.style!=="none"&&a.style!=="solid",d=o.type==="simple-fill"&&o.style!=="none"&&o.style!=="solid",f=o.type==="picture-fill"||d||p;p&&(l=!1),f&&(u=!1)}l?i=u?x.OUTLINE_FILL_SIMPLE:x.OUTLINE_FILL:u&&(i=x.SIMPLE)}}return{vvFlags:r,maxVVSize:s,symbologyType:i}}let fe=null;function xt(e){if(A("esri-2d-update-debug")){const t=de(e,!0);console.debug("Created new schema",t),console.debug("Schema diff",Ee(fe,t)),fe=t}return de(e)}function de(e,t=!1){var r,s;try{const i=He(e,t),n=Ge(e),l={};i.map(a=>Ue(l,e,a));const u=E(e.subtypeCode)?`${e.subtypeField} = ${e.subtypeCode}`:null;return{source:{definitionExpression:Ie(e.definitionExpression,u),fields:e.fields.map(a=>a.toJSON()),gdbVersion:e.gdbVersion,historicMoment:(r=e.historicMoment)==null?void 0:r.getTime(),outFields:e.availableFields,pixelBuffer:e.pixelBuffer,spatialReference:e.spatialReference.toJSON(),timeExtent:(s=e.timeExtent)==null?void 0:s.toJSON(),customParameters:e.customParameters},attributes:{fields:{},indexCount:0},processors:i,tileRenderer:n,targets:l}}catch(i){if(i.fieldName===y)return O.error(i),null;throw i}}function Ue(e,t,r){switch(r.target){case"feature":return void G(e,q(t),r);case"aggregate":{if(!("featureReduction"in t))return;const s=t.featureReduction;switch(s.type){case"selection":throw new c(y,"Mapview does not support `selection` reduction type",s);case"binning":return G(e,q(t),r),void je(e,s,t.fields.map(i=>i.toJSON()),r);case"cluster":return G(e,q(t),r),void Je(e,s,t.fields.map(i=>i.toJSON()),r)}}}}function _(e,t){for(const r in t){const s=t[r];if(s.target!==e.name)continue;const i=e.attributes[r];i?(i.context.mesh=i.context.mesh||s.context.mesh,i.context.storage=i.context.storage||s.context.storage):e.attributes[r]=s}return e}function q(e){var t,r,s,i,n;return[(r=(t=U(e.filter))==null?void 0:t.toJSON())!=null?r:null,(n=(i=U((s=U(e.featureEffect))==null?void 0:s.filter))==null?void 0:i.toJSON())!=null?n:null]}function G(e,t,r){return e.feature||(e.feature={name:"feature",input:"source",filters:t,attributes:{}}),_(e.feature,r.attributes.fields),e}function ce(e,t){const{onStatisticExpression:r,onStatisticField:s,statisticType:i}=e;switch(i){case"min":case"max":case"avg":case"avg_angle":case"sum":case"count":return"esriFieldTypeDouble";case"mode":{if(r){const{returnType:l}=r;return l?l==="string"?"esriFieldTypeString":"esriFieldTypeDouble":(O.error(new c(y,"Unable to infer type of aggregateField with onStatisticExpression. ReturnType is not defined",e)),"esriFieldTypeString")}const n=t.find(l=>l.name===s);return n?n.type:(O.error(new c(y,"Unable to infer type of aggregateField with onStatisticExpression. ReturnType is not defined",e)),"esriFieldTypeString")}}}function je(e,t,r,s){var i;return e.aggregate||(e.aggregate={name:"aggregate",type:"bin",filters:null,input:"feature",params:{fixedBinLevel:t.fixedBinLevel,fields:((i=t.fields)!=null?i:[]).map(n=>b(g({},n.toJSON()),{type:ce(n,r)}))},attributes:{}}),_(e.aggregate,s.attributes.fields),e}function Je(e,t,r,s){var i,n;return e.aggregate||(e.aggregate={name:"aggregate",type:"cluster",input:"feature",filters:null,attributes:{},params:{clusterRadius:se(t.clusterRadius/2),clusterPixelBuffer:64*Math.ceil(se(t.clusterMaxSize)/64),fields:(n=(i=t.fields)!=null?i:[])==null?void 0:n.map(l=>b(g({},l.toJSON()),{type:ce(l,r)}))}}),_(e.aggregate,s.attributes.fields),e}function w(e,t){return t.field?z(e,b(g({},t),{type:"field",field:t.field})):t.valueExpression?z(e,b(g({},t),{type:"expression",valueExpression:t.valueExpression})):{field:null,fieldIndex:null}}function z(e,t){switch(t.type){case"expression":{const r=pe(t.valueExpression);if(!e.fields[r]){const s=e.indexCount++;e.fields[r]=b(g({},t),{name:r,fieldIndex:s})}return{fieldIndex:e.fields[r].fieldIndex}}case"label-expression":{const r=pe(JSON.stringify(t.label));if(!e.fields[r]){const s=e.indexCount++;e.fields[r]=b(g({},t),{name:r,fieldIndex:s})}return{fieldIndex:e.fields[r].fieldIndex}}case"field":{const r=t.field;return t.target==="aggregate"&&e.fields[r]||(e.fields[r]=b(g({},t),{name:r})),{field:r}}case"statistic":return e.fields[t.name]=g({},t),{field:t.name}}}function He(e,t=!1){const r=new Array;let s=0;return r.push(qe(e,s++,t)),r}function W(e,t,r,s,i,n=!1){const l=z(e,{type:"label-expression",target:r,context:{mesh:!0},resultType:"string",label:{labelExpression:t.labelExpression,labelExpressionInfo:t.labelExpressionInfo?{expression:t.labelExpressionInfo.expression}:null,symbol:!!t.symbol,where:t.where}}),{fieldIndex:u}=l;return b(g({},h(t,i,n)),{fieldIndex:u,target:r,index:s})}function _e(e,t,r){var p,d;const s="featureReduction"in t&&t.featureReduction;if(!s)return{fields:[],labels:[],matcher:null,rendererOverride:null};const i="aggregate",n=[];let l=null,u=le(t.geometryType),o=[],a=null;if(s)switch(s.type){case"selection":return O.error(new c(y,"Mapview does not support `selection` reduction type",s)),{fields:[],labels:[],matcher:null,rendererOverride:null};case"cluster":case"binning":if(n.push(...(p=s.fields)!=null?p:[]),s.type==="cluster"?u="esriGeometryPoint":s.type==="binning"&&(u="esriGeometryPolygon"),s.renderer&&!((d=s.renderer.authoringInfo)==null?void 0:d.isAutoGenerated)){if(s.type==="cluster"){const{renderer:I}=Ve(s.renderer,s,null);a=I}else a=s.renderer;const f=H(s.renderer,s);l=Y(null,i,s.renderer,f,r),o=s&&s.labelsVisible&&s.labelingInfo||[]}else if(s.type==="cluster"){if(a=Oe(n,t.renderer,s,null,!0),s.symbol){const f=H(a,s);l={type:"simple",symbol:h(s.symbol,f,r),symbologyType:f.symbologyType}}o=s&&s.labelsVisible&&s.labelingInfo||[]}}return Ye(e,n),{labels:ie(o,s.type==="binning"?"esriGeometryPolygon":u),matcher:l,fields:n,rendererOverride:a}}function qe(e,t,r=!1){var m;const s={indexCount:0,fields:{}},i="featureReduction"in e&&e.featureReduction,n=i?"aggregate":"feature";if("sublayers"in e){const S={type:"subtype",subtypeField:e.subtypeField,renderers:{},symbologyType:x.DEFAULT},B={type:"subtype",mapping:{},target:"feature"},C={type:"subtype",classes:{}},me={type:"symbol",target:"feature",aggregateFields:[],attributes:s,storage:B,mesh:{matcher:S,aggregateMatcher:null,labels:C,sortKey:null}},K=new Set;let ge=0;for(const{renderer:M,subtypeCode:N,labelingInfo:be,labelsVisible:xe}of e.sublayers){const Q={symbologyType:x.DEFAULT,vvFlags:0,maxVVSize:0},$=Y(s,n,M,Q,r),L=ye(s,n,M),X=xe&&be;if("visualVariables"in M&&M.visualVariables&&M.visualVariables.length)throw new c(y,"Visual variables are currently not supported for subtype layers");if($.type==="dictionary")throw new c(y,"Dictionary renderer is not supported in subtype layers");if($.type==="subtype")throw new c(y,"Nested subtype renderers is not supported");if(E(L)&&L.type==="subtype")throw new c(y,"Nested subtype storage is not supported");if(E(L)&&E(L.attributeMapping))throw new c(y,"Non-visual-variable attributes are not supported in subtype layers");if($.type==="heatmap")throw new c(y,"Heatmaps are not supported in subtype layers");if($.type==="pie-chart")throw new c(y,"Pie-charts are not supported in subtype layers");if(K.has(N))throw new c(y,"Subtype codes for sublayers must be unique");K.add(N),S.renderers[N]=$,B.mapping[N]=L,X&&(C.classes[N]=X.map(he=>W(s,he,"feature",ge++,Q,r)))}return me}if(e.renderer.type==="heatmap"&&J()==="raster"){const{radius:S,fieldOffset:B,field:C}=e.renderer;return{type:"heatmap",aggregateFields:[],attributes:s,target:n,storage:null,mesh:{radius:S,fieldOffset:B,field:w(s,{target:n,field:C,resultType:"numeric"}).field}}}const l=_e(s,e,r),u=le(e.geometryType),o=(m=l.rendererOverride)!=null?m:e.renderer,a=H(o,i),p=Y(s,n,o,a,r),d=ye(s,n,o),f=We(s,e.orderBy,i),I=e.labelsVisible&&e.labelingInfo||[],F=ie(I,u);let v=0;const T=[...F.map(S=>W(s,S,"feature",v++,a,r)),...l.labels.map(S=>W(s,S,"aggregate",v++,a,r))];return{type:"symbol",target:n,attributes:s,aggregateFields:l.fields,storage:d,mesh:{matcher:p,labels:{type:"simple",classes:T},aggregateMatcher:l.matcher,sortKey:f}}}function Ge(e){var t;return((t=e.renderer)==null?void 0:t.type)==="heatmap"&&J()==="raster"?{type:"heatmap"}:{type:"symbol"}}function We(e,t,r){if(E(r)||ne(t)||!t.length)return null;t.length>1&&O.warn(`Layer rendering currently only supports ordering by 1 orderByInfo, but found ${t.length}. All but the first will be discarded`);const s=t[0],i=s.order==="ascending"?"asc":"desc";return s.field?{field:s.field,order:i}:s.valueExpression?{fieldIndex:z(e,{type:"expression",target:"feature",valueExpression:s.valueExpression,resultType:"numeric"}).fieldIndex,order:i}:(O.error(new c(y,"Expected to find a field or valueExpression for OrderByInfo",s)),null)}function Ye(e,t){const r={mesh:!0,storage:!0};for(const s of t){const{name:i,onStatisticField:n,onStatisticExpression:l,statisticType:u}=s;let o=null,a=null;const p="numeric",d="feature";l?a=z(e,{type:"expression",target:d,valueExpression:l.expression,resultType:p}).fieldIndex:o=z(e,{type:"field",target:d,field:n,resultType:p}).field,z(e,{type:"statistic",target:"aggregate",name:i,context:r,inField:o,inFieldIndex:a,statisticType:u})}}function ye(e,t,r){let s;switch(r.type){case"simple":case"class-breaks":case"unique-value":case"dictionary":s={visualVariables:!0,attributes:null};break;default:s=Ne(r).getStorageSpec(r)}return Ke(e,t,s,r)}function Ke(e,t,r,s){if(ne(r))return null;const{visualVariables:i,attributes:n}=r;let l=null;i&&"visualVariables"in s&&(l=Qe(e,t,s.visualVariables));const u=E(l)?4:0;let o=null;return E(n)&&(o=n.map((a,p)=>{const{field:d,fieldIndex:f}=w(e,{valueExpression:a.valueExpression,field:a.field,resultType:"numeric",target:t});return{binding:p+u,field:d,fieldIndex:f}})),{type:"simple",target:t,attributeMapping:o,vvMapping:l}}function Qe(e,t,r){if(!r||!r.length)return[];const s={storage:!0},i="numeric";return Re(r).map(n=>{var a;const l=Me(n.type),{field:u,fieldIndex:o}=w(e,{target:t,valueExpression:n.valueExpression,field:n.field,context:s,resultType:i});switch(n.type){case"size":return n.valueExpression==="$view.scale"?null:{type:"size",binding:l,field:u,fieldIndex:o,normalizationField:w(e,{target:t,field:n.normalizationField,context:s,resultType:i}).field,valueRepresentation:(a=n.valueRepresentation)!=null?a:null};case"color":return{type:"color",binding:l,field:u,fieldIndex:o,normalizationField:w(e,{target:t,field:n.normalizationField,context:s,resultType:i}).field};case"opacity":return{type:"opacity",binding:l,field:u,fieldIndex:o,normalizationField:w(e,{target:t,field:n.normalizationField,context:s,resultType:i}).field};case"rotation":return{type:"rotation",binding:l,field:u,fieldIndex:o}}}).filter(n=>n)}function Y(e,t,r,s,i=!1){const n=ze(e,{indexCount:0,fields:{}});switch(r.type){case"simple":case"dot-density":return Xe(n,r,s,i);case"class-breaks":return et(n,t,r,s,i);case"unique-value":return tt(n,t,r,s,i);case"dictionary":return rt(n,r,s,i);case"heatmap":return st(n,r,s,i);case"pie-chart":return Ze(n,r,s,i)}}function Xe(e,t,r,s=!1){const i=t.getSymbols(),n=i.length?i[0]:null;return{type:"simple",symbol:h(n,r,s),symbologyType:r.symbologyType}}function Ze(e,t,r,s=!1){const i=t.getSymbols(),n=i[0],l=i.length>1?i[1]:null;return{type:"pie-chart",markerSymbol:h(n,r,s),fillSymbol:h(l,r,s),symbologyType:r.symbologyType}}function et(e,t,r,s,i=!1){const n={mesh:!0,use:"renderer.field"},l=r.backgroundFillSymbol,{field:u,fieldIndex:o}=w(e,{target:t,field:r.field,valueExpression:r.valueExpression,resultType:"numeric",context:n}),a=r.normalizationType,p=a==="log"?"esriNormalizeByLog":a==="percent-of-total"?"esriNormalizeByPercentOfTotal":a==="field"?"esriNormalizeByField":null,d=r.classBreakInfos.map(f=>({symbol:h(f.symbol,s,i),min:f.minValue,max:f.maxValue})).sort((f,I)=>f.min-I.min);return{type:"interval",attributes:e.fields,field:u,fieldIndex:o,backgroundFillSymbol:h(l,s,i),defaultSymbol:h(r.defaultSymbol,s,i),intervals:d,normalizationField:r.normalizationField,normalizationTotal:r.normalizationTotal,normalizationType:p,isMaxInclusive:r.isMaxInclusive,symbologyType:s.symbologyType}}function tt(e,t,r,s,i=!1){const n=[],l=r.backgroundFillSymbol,u={target:t,context:{mesh:!0},resultType:"string"};if(r.field&&typeof r.field!="string")throw new c(y,"Expected renderer.field to be a string",r);const{field:o,fieldIndex:a}=w(e,b(g({},u),{field:r.field,valueExpression:r.valueExpression}));for(const p of r.uniqueValueInfos)n.push({value:""+p.value,symbol:h(p.symbol,s,i)});return{type:"map",attributes:e.fields,field:o,fieldIndex:a,field2:w(e,b(g({},u),{field:r.field2})).field,field3:w(e,b(g({},u),{field:r.field3})).field,fieldDelimiter:r.fieldDelimiter,backgroundFillSymbol:h(l,s),defaultSymbol:h(r.defaultSymbol,s),map:n,symbologyType:s.symbologyType}}function rt(e,t,r,s=!1){return{type:"dictionary",config:t.config,fieldMap:t.fieldMap,scaleExpression:t.scaleExpression,url:t.url,symbolOptions:r,symbologyType:r.symbologyType}}function st(e,t,r,s=!1){const i=t.getSymbols(),n=i.length?i[0]:null;return{type:"heatmap",symbol:h(n,r,s),symbologyType:r.symbologyType}}export{Y as $,xt as F,bt as h,gt as n,H as w};
