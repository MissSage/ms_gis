var g=Object.defineProperty,C=Object.defineProperties;var F=Object.getOwnPropertyDescriptors;var w=Object.getOwnPropertySymbols;var N=Object.prototype.hasOwnProperty,U=Object.prototype.propertyIsEnumerable;var L=(r,a,e)=>a in r?g(r,a,{enumerable:!0,configurable:!0,writable:!0,value:e}):r[a]=e,f=(r,a)=>{for(var e in a||(a={}))N.call(a,e)&&L(r,e,a[e]);if(w)for(var e of w(a))U.call(a,e)&&L(r,e,a[e]);return r},m=(r,a)=>C(r,F(a));import{O as p,eJ as J,U as O,Y as j,eN as x,eO as M,d8 as V}from"./vendor.1bde3be2.js";import{a as i,r as E}from"./fetchService.5de1e2a6.js";import{a as k}from"./lazyLayerLoader.d9bf30da.js";async function K(r){var n;const a=(n=r.properties)==null?void 0:n.customParameters,e=await A(r.url,a),t=m(f({},r.properties),{url:r.url});if(!e.sublayerIds)return e.layerOrTableId!=null&&(t.layerId=e.layerOrTableId,t.sourceJSON=e.sourceJSON),new e.Constructor(t);const l=new(await import("./GroupLayer.a7d11b5c.js")).default({title:e.parsedUrl.title});return z(l,e,t),l}function P(r,a){return r?r.find(e=>e.id===a):null}function z(r,a,e){function t(l,n){const o=m(f({},e),{layerId:l,sublayerTitleMode:"service-name"});return p(n)&&(o.sourceJSON=n),new a.Constructor(o)}a.sublayerIds.forEach(l=>{const n=t(l,P(a.sublayerInfos,l));r.add(n)}),a.tableIds.forEach(l=>{const n=t(l,P(a.tableInfos,l));r.tables.add(n)})}async function A(r,a){var b,S;let e=J(r);if(O(e)&&(e=await B(r,a)),O(e))throw new j("arcgis-layers:url-mismatch","The url '${url}' is not a valid arcgis resource",{url:r});const{serverType:t,sublayer:l}=e;let n;const o={FeatureServer:"FeatureLayer",StreamServer:"StreamLayer",VectorTileServer:"VectorTileLayer"};switch(t){case"MapServer":n=l!=null?"FeatureLayer":D(r,a).then(s=>s?"TileLayer":"MapImageLayer");break;case"ImageServer":n=i(r,{customParameters:a}).then(s=>{const c=s.tileInfo&&s.tileInfo.format;return s.tileInfo?(c==null?void 0:c.toUpperCase())!=="LERC"||s.cacheType&&s.cacheType.toLowerCase()!=="elevation"?"ImageryTileLayer":"ElevationLayer":"ImageryLayer"});break;case"SceneServer":n=i(e.url.path,{customParameters:a}).then(s=>{var c;if(s){if((s==null?void 0:s.layerType)==="Voxel")return"VoxelLayer";if((s==null?void 0:s.layers)&&Array.isArray(s.layers)&&s.layers.length>0){const h={Point:"SceneLayer","3DObject":"SceneLayer",IntegratedMesh:"IntegratedMeshLayer",PointCloud:"PointCloudLayer",Building:"BuildingSceneLayer"},v=(c=s.layers[0])==null?void 0:c.layerType;if(h[v]!=null)return h[v]}}return"SceneLayer"});break;default:n=o[t]}const u={FeatureLayer:!0,SceneLayer:!0},d=t==="FeatureServer",y={parsedUrl:e,Constructor:null,layerOrTableId:d?l:null,sublayerIds:null,tableIds:null},I=await n;if(u[I]&&l==null){const s=await G(r,t,a);d&&(y.sublayerInfos=s.layerInfos,y.tableInfos=s.tableInfos),s.layerIds.length+s.tableIds.length!==1?(y.sublayerIds=s.layerIds,y.tableIds=s.tableIds):d&&(y.layerOrTableId=(b=s.layerIds[0])!=null?b:s.tableIds[0],y.sourceJSON=(S=s.layerInfos[0])!=null?S:s.tableInfos[0])}return y.Constructor=await R(I),y}async function B(r,a){var u;const e=await i(r,{customParameters:a});let t=null,l=null;const n=e.type;if(n==="Feature Layer"||n==="Table"?(t="FeatureServer",l=e.id):n==="indexedVector"?t="VectorTileServer":e.hasOwnProperty("mapName")?t="MapServer":e.hasOwnProperty("bandCount")&&e.hasOwnProperty("pixelSizeX")?t="ImageServer":e.hasOwnProperty("maxRecordCount")&&e.hasOwnProperty("allowGeometryUpdates")?t="FeatureServer":e.hasOwnProperty("streamUrls")?t="StreamServer":T(e)?(t="SceneServer",l=e.id):e.hasOwnProperty("layers")&&T((u=e.layers)==null?void 0:u[0])&&(t="SceneServer"),!t)return null;const o=l!=null?x(r):null;return{title:p(o)&&e.name||M(r),serverType:t,sublayer:l,url:{path:p(o)?o.serviceUrl:V(r).path}}}function T(r){return(r==null?void 0:r.hasOwnProperty("store"))&&r.hasOwnProperty("id")&&typeof r.id=="number"}async function G(r,a,e){let t,l=!1;if(a==="FeatureServer"){const u=await E(r,{customParameters:e});l=!!u.layersJSON,t=u.layersJSON||u.serviceJSON}else t=await i(r,{customParameters:e});const n=t==null?void 0:t.layers,o=t==null?void 0:t.tables;return{layerIds:(n==null?void 0:n.map(u=>u.id).reverse())||[],tableIds:(o==null?void 0:o.map(u=>u.id).reverse())||[],layerInfos:l?n:[],tableInfos:l?o:[]}}async function R(r){return(0,k[r])()}async function D(r,a){return(await i(r,{customParameters:a})).tileInfo}export{K as fromUrl};
