var zi=Object.defineProperty,Ii=Object.defineProperties;var $i=Object.getOwnPropertyDescriptors;var Pe=Object.getOwnPropertySymbols;var Wi=Object.prototype.hasOwnProperty,Ci=Object.prototype.propertyIsEnumerable;var Te=(n,t,e)=>t in n?zi(n,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):n[t]=e,ot=(n,t)=>{for(var e in t||(t={}))Wi.call(t,e)&&Te(n,e,t[e]);if(Pe)for(var e of Pe(t))Ci.call(t,e)&&Te(n,e,t[e]);return n},yt=(n,t)=>Ii(n,$i(t));import{Y as tt,cY as Ei,bN as Ai,U as B,O as E,cZ as jt,c_ as Yt,$ as Ht,ac as x,c$ as Ri,cM as V,K as lt,ax as ze,ca as qt,d0 as Fi,bC as ki,ce as Bi,ab as Lt,cc as Pt,ad as Qt,bO as Tt,bY as zt,b5 as Vi,bL as Ie,cO as It,ae as Oi,d1 as Di,a8 as Jt,d2 as Gi,d3 as $e,d4 as We,d5 as Zi,d6 as Ki,d7 as Ni,d8 as Ui,d9 as Xi,da as ji,db as Ce,dc as Ee,dd as Ae,a9 as Yi,de as Re,df as Hi,cI as qi}from"./vendor.ad8aa1ba.js";import{c as te,h as Qi,o as et,f as Ji,j as Fe,a as C,k as ts,g as es,p as is,n as it,i as ss,l as rs,e as I,m as ke,X as ns,q as as,t as Be,u as $t,v as Ve}from"./definitions.d3c1cadf.js";import{f as os,p as ls}from"./visualVariablesUtils.8e59fa54.js";import{b as P,G as ee,e as U,f as $,S as Wt,j as hs,t as cs}from"./Utils.4c2feac4.js";import{l as us}from"./tileUtils.eab69325.js";import{n as Oe,r as fs,c as _s,i as ds}from"./TileClipper.51ce0e42.js";import{s as ms,r as De,n as Ge,i as ps,a as ys,c as xs,o as gs}from"./alignmentUtils.6849a0a8.js";import{x as A,w as M}from"./number.30628ef2.js";import{U as ie,Z as Ms,N as se,C as Ct,w as ht,O as Et,b as Ze,P as vs,f as re}from"./MaterialKey.6f6162d1.js";import{g as ws,d as bs,j as Ss,f as ne,n as Ke,m as Ls,T as Ps}from"./cimAnalyzer.209d4429.js";import{M as ae}from"./GeometryUtils.51c4032a.js";import"./earcut.afc1d357.js";import{s as Ne}from"./Geometry.d049a63c.js";import{i as Ts}from"./callExpressionWithFeature.ebb41fc5.js";import{l as zs}from"./ExpandedCIM.a759c9e9.js";function k(n,t){if(n&&"name"in n){const e=n;return t&&t.error(new tt(e.name,e.message,e.details)),!1}return!0}const Is=1.25;class At{constructor(t,e){this._pos=0;const i=e?this._roundToNearest(e,t.BYTES_PER_ELEMENT):40;this._array=new ArrayBuffer(i),this._buffer=new t(this._array),this._ctor=t,this._i16View=new Int16Array(this._array)}get length(){return this._pos}_roundToNearest(t,e){const i=Math.round(t);return i+(e-i%e)}_ensureSize(t){if(this._pos+t>=this._buffer.length){const e=this._roundToNearest((this._array.byteLength+t*this._buffer.BYTES_PER_ELEMENT)*Is,this._buffer.BYTES_PER_ELEMENT),i=new ArrayBuffer(e),s=new this._ctor(i);s.set(this._buffer,0),this._array=i,this._buffer=s,this._i16View=new Int16Array(this._array)}}ensureSize(t){this._ensureSize(t)}writeF32(t){this._ensureSize(1);const e=this._pos;return new Float32Array(this._array,4*this._pos,1)[0]=t,this._pos++,e}push(t){this._ensureSize(1);const e=this._pos;return this._buffer[this._pos++]=t,e}writeFixed(t){this._buffer[this._pos++]=t}setValue(t,e){this._buffer[t]=e}i1616Add(t,e,i){this._i16View[2*t]+=e,this._i16View[2*t+1]+=i}getValue(t){return this._buffer[t]}incr(t){if(this._buffer.length<t)throw new Error("Increment index overflows the target buffer");this._buffer[t]++}decr(t){this._buffer[t]--}writeRegion(t){this._ensureSize(t.length);const e=this._pos;return this._buffer.set(t,this._pos),this._pos+=t.length,e}writeManyFrom(t,e,i){this._ensureSize(i-e);for(let s=e;s!==i;s++)this.writeFixed(t._buffer[s])}buffer(){const t=this._array.slice(0,4*this._pos);return this.destroy(),t}toArray(){const t=this._array,e=[];for(let i=0;i<t.byteLength/4;i++)e.push(t[i]);return e}seek(t){this._pos=t}destroy(){this._array=null,this._buffer=null}}const ct=new Map;function $s(n,t,e){const{indicesPerRecord:i,multiplier:s,verticesPerRecord:r}=ct.get(n);return{recordBytes:e*te*Uint32Array.BYTES_PER_ELEMENT,indexBytes:s*i*e*Uint32Array.BYTES_PER_ELEMENT,vertexBytes:s*r*e*t}}ct.set(P.MARKER,{multiplier:1,indicesPerRecord:6,verticesPerRecord:4}),ct.set(P.LINE,{multiplier:1,indicesPerRecord:24,verticesPerRecord:8}),ct.set(P.FILL,{multiplier:1,indicesPerRecord:10,verticesPerRecord:10}),ct.set(P.TEXT,{multiplier:8,indicesPerRecord:6,verticesPerRecord:4}),ct.set(P.LABEL,{multiplier:8,indicesPerRecord:6,verticesPerRecord:4});class Ue{constructor(t,e,i){this._start={index:0,vertex:0};const s=$s(t,e,i),r=e/4;this.geometryType=t,this._records=new At(Int32Array,s.recordBytes),this._indices=new At(Uint32Array,s.indexBytes),this._vertices=new At(Uint32Array,s.vertexBytes),this._metrics=new At(Float32Array,0),this._strideInt=r}serialize(t){const e=this._records.buffer(),i=this._indices.buffer(),s=this._vertices.buffer(),r=this._metrics.length?this._metrics.buffer():null,a=4*this._strideInt;return t.push(e,i,s),{stride:a,records:e,indices:i,vertices:s,metrics:r}}get strideInt(){return this._strideInt}get recordCount(){return this._records.length/te}get vertexCount(){return this._vertices.length/this._strideInt}get indexCount(){return this._indices.length}get indexWriter(){return this._indices}get vertexWriter(){return this._vertices}get metricWriter(){return this._metrics}vertexEnsureSize(t){this._vertices.ensureSize(t)}indexEnsureSize(t){this._indices.ensureSize(t)}recordStart(){this._start.index=this._indices.length,this._start.vertex=this._vertices.length}recordEnd(t,e,i,s,r,a,o,l){this._records.push(t),this._records.push(e),this._records.push(i),this._records.push(s),this._records.push(r),this._records.push(a),this._records.push(o),this._records.writeF32(l)}writeIndex(t){this._indices.push(t)}writeVertex(t){this._vertices.push(t)}writeVertexF32(t){this._vertices.writeF32(t)}copyLastFrom(t,e,i){const s=t._records.length-te,r=t._records.getValue(s),a=t._records.getValue(s+1),o=t._records.getValue(s+2),l=t._records.getValue(s+4),h=t._records.getValue(s+6),u=t._records.getValue(s+7),c=this._vertices.length,_=(t._start.vertex-this._vertices.length)/this._strideInt,f=this._indices.length,m=this.vertexCount;for(let d=t._start.index;d!==t._indices.length;d++){const y=t._indices.getValue(d);this._indices.push(y-_)}for(let d=t._start.vertex;d!==t._vertices.length;d++){const y=t._vertices.getValue(d);this._vertices.push(y)}for(let d=c;d<=this._vertices.length;d+=this._strideInt)this._vertices.i1616Add(d,e,i);this._records.push(r),this._records.push(a),this._records.push(o),this._records.push(f),this._records.push(l),this._records.push(m),this._records.push(h),this._records.push(u)}}const Rt=1,oe=2,Ft=4,le=8,he=16,kt=32,ce=64,Bt=128;function Xe(n){switch(n){case Rt:case le:case kt:return-1;case oe:case ce:return 0;case Ft:case he:case Bt:return 1}}function je(n){switch(n){case Rt:case oe:case Ft:return-1;case le:case he:return 0;case kt:case ce:case Bt:return 1}}const Ye=Rt|le|kt,He=Ft|he|Bt,qe=Rt|oe|Ft,Qe=kt|ce|Bt;class qr{constructor(t,e,i,s,r,a=0){this._hasAggregate=!1,this.hasRecords=!1,this._data={self:new Map,neighbors:new Array},this._version=0,this._current={geometryType:0,writer:null,overlaps:0,start:0,insertAfter:0,sortKey:0,id:0,materialKey:0,indexStart:0,vertStart:0,isDotDensity:!1,bufferingEnabled:!1,metricBoxLenPointer:0},this.hint=e,this.tileKey=t,this._hasAggregate=s,this._pixelBufferEnabled=r,this._version=a,this._symbologyType=i}get hasAggregates(){return this._hasAggregate}get hasPixelBufferEnabled(){return this._pixelBufferEnabled}serialize(t){const e=[];return e.push(this._serializeTileVertexData(this.tileKey,this.tileKey,this._data.self)),this._data.neighbors.forEach((i,s)=>{const r=1<<s,a=Xe(r),o=je(r),l=us(new Ei(this.tileKey),a,o,t),h=this._serializeTileVertexData(this.tileKey,l.id,i.vertexData);h.message.bufferIds=i.displayIds,e.push(h)}),e}_serializeTileVertexData(t,e,i){var r,a,o,l,h;const s=new Array;return{message:{tileKeyOrigin:t,tileKey:e,data:{[P.MARKER]:(r=i.get(P.MARKER))==null?void 0:r.serialize(s),[P.FILL]:(a=i.get(P.FILL))==null?void 0:a.serialize(s),[P.LINE]:(o=i.get(P.LINE))==null?void 0:o.serialize(s),[P.TEXT]:(l=i.get(P.TEXT))==null?void 0:l.serialize(s),[P.LABEL]:(h=i.get(P.LABEL))==null?void 0:h.serialize(s)},version:this._version},transferList:s}}featureStart(t,e){this._current.insertAfter=t,this._current.sortKey=e}featureEnd(){}recordStart(t,e,i,s){this._current.writer=this._getVertexWriter(i),this._current.overlaps=0,this._current.indexStart=this._current.writer.indexCount,this._current.vertStart=this._current.writer.vertexCount,this._current.bufferingEnabled=s,this._current.id=t,this._current.materialKey=e,this._current.geometryType=i,this._current.isDotDensity=!1,this._current.writer.recordStart()}recordCount(){return this._current.writer.recordCount}vertexCount(){return this._current.writer.vertexCount}indexCount(){return this._current.writer.indexCount}vertexEnsureSize(t){this._current.writer.vertexEnsureSize(t)}indexEnsureSize(t){this._current.writer.indexEnsureSize(t)}vertexBounds(t,e,i,s){this._current.bufferingEnabled&&this._addOverlap(t,e,i,s)}vertexWrite(t){this._current.writer.writeVertex(t)}vertexWriteF32(t){this._current.writer.writeVertexF32(t)}vertexEnd(){}vertexWriter(){return this._current.writer.vertexWriter}indexWrite(t){this._current.writer.writeIndex(t)}indexWriter(){return this._current.writer.indexWriter}metricWriter(){return this._current.writer.metricWriter}metricStart(t,e,i,s,r,a,o,l){this._current.writer=this._getVertexWriter(P.LABEL);const h=this._current.writer.metricWriter;h.push(os(t)),h.push(e),h.push(i),h.push(s),h.push(r),h.push(a),h.push(o),h.push(l),h.push(255),this._current.metricBoxLenPointer=h.push(0)}metricEnd(){const t=this._current.writer.metricWriter;t.getValue(this._current.metricBoxLenPointer)===0&&t.seek(t.length-10)}metricBoxWrite(t,e,i,s){const r=this._current.writer.metricWriter;r.incr(this._current.metricBoxLenPointer),r.push(0),r.push(0),r.push(t),r.push(e),r.push(i),r.push(s)}recordEnd(){const t=this._current.vertStart,e=this._current.writer.vertexCount-t;if(!e)return!1;this.hasRecords=!0;const i=this._current.indexStart,s=this._current.writer.indexCount-i;if(this._current.writer.recordEnd(this._current.id,this._current.materialKey,this._current.insertAfter,i,s,t,e,this._current.sortKey),!this._pixelBufferEnabled||this._hasAggregate||this._current.overlaps===0||this._current.geometryType===P.LABEL)return!0;const r=this._current.writer;for(let a=0;a<8;a++){const o=1<<a;if(this._current.overlaps&o){this._data.neighbors[a]||(this._data.neighbors[a]={vertexData:new Map,displayIds:new Set});const l=this._data.neighbors[a],h=this._current.geometryType;if(!l.vertexData.has(h)){const m=ee(h,this._symbologyType).geometry,d=new Ue(h,m,Qi);l.vertexData.set(h,d)}const u=l.vertexData.get(this._current.geometryType),c=8,_=512*-Xe(o)*c,f=512*-je(o)*c;u.copyLastFrom(r,_,f),l.displayIds.add(this._current.id)}}return!0}_addOverlap(t,e,i,s){const r=255^((t<0+i?He:t>=et-i?Ye:He|Ye)|(e<0+s?Qe:e>=et-s?qe:Qe|qe));this._current.overlaps|=r}_getVertexWriter(t){if(!this._data.self.has(t)){const e=this._data.self,i=ee(t,this._symbologyType).geometry;e.set(t,new Ue(t,i,this.hint.records))}return this._data.self.get(t)}}const D=0,G=100;function Je(n,t,e){return n[0]=t[0]-e[0],n[1]=t[1]-e[1],n}function ti(n,t){return Math.sqrt(n*n+t*t)}function ei(n){const t=ti(n[0],n[1]);n[0]/=t,n[1]/=t}function Ws(n,t){return ti(n[0]-t[0],n[1]-t[1])}function w(n){return typeof n=="function"}function ue(n=2){return 1/Math.max(n,1)}function Q(n,t){return[!!n.minScale&&t.scaleToZoom(n.minScale)||D,!!n.maxScale&&t.scaleToZoom(n.maxScale)||G]}function Cs(n,t){return n[t+1]}function ii(n){return n.length-1}function Es(n){let t=0;for(let e=0;e<ii(n);e++)t+=As(n,e);return t}function As(n,t,e=1){const[i,s]=Cs(n,t);return Math.sqrt(i*i+s*s)*e}class Vt{constructor(t,e,i,s,r){this._segments=t,this._index=e,this._distance=i,this._xStart=s,this._yStart=r,this._done=!1}static create(t){return new Vt(t,0,0,t[0][0],t[0][1])}clone(){return new Vt(this._segments,this._index,this._distance,this.xStart,this.yStart)}equals(t){return this._index===t._index||t._index===this._index-1&&(this._distance===0||t._distance===1)||t._index===this._index+1&&(this._distance===1||t._distance===0)}leq(t){return this._index<t._index||this._index===t._index&&this._distance<=t._distance}geq(t){return this._index>t._index||this._index===t._index&&this._distance>=t._distance}get _segment(){return this._segments[this._index+1]}get angle(){const t=this.dy,e=(0*t+-1*-this.dx)/(1*this.length);let i=Math.acos(e);return t>0&&(i=2*Math.PI-i),i}get xStart(){return this._xStart}get yStart(){return this._yStart}get x(){return this.xStart+this.distance*this.dx}get y(){return this.yStart+this.distance*this.dy}get dx(){return this._segment[0]}get dy(){return this._segment[1]}get xMidpoint(){return this.xStart+.5*this.dx}get yMidpoint(){return this.yStart+.5*this.dy}get xEnd(){return this.xStart+this.dx}get yEnd(){return this.yStart+this.dy}get length(){const{dx:t,dy:e}=this;return Math.sqrt(t*t+e*e)}get remainingLength(){return this.length*(1-this._distance)}get backwardLength(){return this.length*this._distance}get distance(){return this._distance}get done(){return this._done}hasPrev(){return this._index-1>=0}hasNext(){return this._index+1<ii(this._segments)}next(){return this.hasNext()?(this._xStart+=this.dx,this._yStart+=this.dy,this._distance=0,this._index+=1,this):null}prev(){return this.hasPrev()?(this._index-=1,this._xStart-=this.dx,this._yStart-=this.dy,this._distance=1,this):(this._done=!0,null)}_seekBackwards(t,e){const i=this.backwardLength;if(t<=i)return this._distance=(i-t)/this.length,this;let s=this.backwardLength;for(;this.prev();){if(s+this.length>t)return this._seekBackwards(t-s);s+=this.length}return this._distance=0,e?this:null}seek(t,e=!1){if(t<0)return this._seekBackwards(Math.abs(t),e);if(t<=this.remainingLength)return this._distance=(this.backwardLength+t)/this.length,this;let i=this.remainingLength;for(;this.next();){if(i+this.length>t)return this.seek(t-i,e);i+=this.length}return this._distance=1,e?this:null}}function Rs(n,t,e,i=!0){const s=Es(n),r=Vt.create(n),a=s/2;if(!i)return r.seek(a),void e(r.clone(),0,a+0*t,s);const o=Math.max((s-t)/2,0),l=Math.floor(o/t),h=a-l*t;r.seek(h);for(let u=-l;u<=l;u++)r.x<512&&r.x>=0&&r.y<512&&r.y>=0&&e(r.clone(),u,a+u*t,s),r.seek(t)}function Fs(n,t){const e=t;for(let i=0;i<n.length;i++){let s=n[i];const r=[];r.push(s[0]);for(let o=1;o<s.length;o++){let[l,h]=r[o-1];l+=s[o][0],h+=s[o][1],r.push([l,h])}ks(r,e);const a=[];a.push(r[0]);for(let o=1;o<r.length;o++){const[l,h]=r[o-1],[u,c]=r[o],_=Math.round(u-l),f=Math.round(c-h);a.push([_,f])}n[i]=a,s=a}return n}function ks(n,t){const e=1e-6;if(t<=0)return;const i=n.length;if(i<3)return;const s=[];let r=0;s.push(0);for(let c=1;c<i;c++)r+=Ws(n[c],n[c-1]),s.push(r);t=Math.min(t,.2*r);const a=[];a.push(n[0][0]),a.push(n[0][1]);const o=n[i-1][0],l=n[i-1][1],h=Je([0,0],n[0],n[1]);ei(h),n[0][0]+=t*h[0],n[0][1]+=t*h[1],Je(h,n[i-1],n[i-2]),ei(h),n[i-1][0]+=t*h[0],n[i-1][1]+=t*h[1];for(let c=1;c<i;c++)s[c]+=t;s[i-1]+=t;const u=.5*t;for(let c=1;c<i-1;c++){let _=0,f=0,m=0;for(let d=c-1;d>=0&&!(s[d+1]<s[c]-u);d--){const y=u+s[d+1]-s[c],p=s[d+1]-s[d],g=s[c]-s[d]<u?1:y/p;if(Math.abs(g)<e)break;const v=g*g,b=g*y-.5*v*p,L=g*p/t,S=n[d+1],T=n[d][0]-S[0],z=n[d][1]-S[1];_+=L/b*(S[0]*g*y+.5*v*(y*T-p*S[0])-v*g*p*T/3),f+=L/b*(S[1]*g*y+.5*v*(y*z-p*S[1])-v*g*p*z/3),m+=L}for(let d=c+1;d<i&&!(s[d-1]>s[c]+u);d++){const y=u-s[d-1]+s[c],p=s[d]-s[d-1],g=s[d]-s[c]<u?1:y/p;if(Math.abs(g)<e)break;const v=g*g,b=g*y-.5*v*p,L=g*p/t,S=n[d-1],T=n[d][0]-S[0],z=n[d][1]-S[1];_+=L/b*(S[0]*g*y+.5*v*(y*T-p*S[0])-v*g*p*T/3),f+=L/b*(S[1]*g*y+.5*v*(y*z-p*S[1])-v*g*p*z/3),m+=L}a.push(_/m),a.push(f/m)}a.push(o),a.push(l);for(let c=0,_=0;c<i;c++)n[c][0]=a[_++],n[c][1]=a[_++]}class si{static getPlacement(t,e,i,s){const r=ws(e);if(!r)return null;const a=bs(t);return r.execute(a,e,i,s)}}const Ot=8,ri=n=>class extends n{constructor(...t){super(...t),this._isCIM=!1,this._vertexBoundsScale=1,this.geometryType=P.TEXT,this._aux=A(0,0,this._referenceSize,this._bitset)}bindTextInfo(t,e){t&&t.length?this._shapingInfo=Ai(t,i=>Ss(i,e,{scale:this._scale,angle:this._angle,xOffset:this._xOffset,yOffset:this._yOffset,hAlign:this._xAlignD,vAlign:this._yAlignD,maxLineWidth:Math.max(32,Math.min(this._lineWidth,512)),lineHeight:Ji*Math.max(.25,Math.min(this._lineHeight,4)),decoration:this._decoration,isCIM:this._isCIM})):this._shapingInfo=null}_write(t,e,i,s){const r=e.getDisplayId();this._writeGeometry(t,e,r,i,s)}_writeGeometry(t,e,i,s,r){const a=this._shapingInfo;if(B(a))return;if(E(this._textPlacement)){const l=r!=null?r:e.readLegacyGeometryForDisplay();return this._writePlacedText(t,i,l,a,s)}const o=r?jt(Yt(r),2):e.geometryType==="esriGeometryPolygon"?e.readCentroid():e.readGeometryForDisplay();if(!B(o)){if(o.isPoint){const[l,h]=o.coords;return!t.hasAggregates&&t.hasPixelBufferEnabled&&(l<0||l>=512||h<0||h>=512)?void 0:this._writeGlyphs(t,i,{x:l,y:h},a)}o.forEachVertex((l,h)=>this._writeGlyphs(t,i,{x:l,y:h},a))}}_writePlacedText(t,e,i,s,r){const a=Ht(this._textPlacement),o=si.getPlacement(i,a,x(1),r.geometryEngine);if(!o)return;let l=o.next();for(;l!=null;){const h=-l.getAngle();s.setRotation(h);const u=l.tx,c=-l.ty;u<0||u>=512||c<0||c>=512||(this._writeGlyphs(t,e,{x:u,y:c},s),s.setRotation(-h)),l=o.next()}}_writeGlyphs(t,e,i,s){const r=ie.load(this._materialKey),a=M(Math.round(Ot*i.x),Math.round(Ot*i.y)),o=this._vertexBoundsScale,l=s.bounds,h=2*Math.max(l.width,l.height);for(const u of s.glyphs)r.textureBinding=u.textureBinding,t.recordStart(e,r.data,this.geometryType,!0),t.vertexBounds(i.x+l.x+this._xOffset,i.y+l.y-this._yOffset,h*o,h*o),this._writeVertices(t,e,a,u),t.recordEnd()}_writeGlyph(t,e,i,s,r){const a=ie.load(this._materialKey),o=M(Math.round(Ot*i),Math.round(Ot*s));a.textureBinding=r.textureBinding,t.recordStart(e,a.data,this.geometryType,!0);const l=r.bounds,h=this._vertexBoundsScale;t.vertexBounds(i+l.x*h,s+l.y*h,l.width*h,l.height*h),this._writeVertices(t,e,o,r),t.recordEnd()}_writeVertices(t,e,i,s){const r=t.vertexCount();this._writeVertexCommon(t,e,i,s),t.vertexWrite(s.offsets.upperLeft),t.vertexWrite(s.texcoords.upperLeft),t.vertexEnd(),this._writeVertexCommon(t,e,i,s),t.vertexWrite(s.offsets.upperRight),t.vertexWrite(s.texcoords.upperRight),t.vertexEnd(),this._writeVertexCommon(t,e,i,s),t.vertexWrite(s.offsets.lowerLeft),t.vertexWrite(s.texcoords.lowerLeft),t.vertexEnd(),this._writeVertexCommon(t,e,i,s),t.vertexWrite(s.offsets.lowerRight),t.vertexWrite(s.texcoords.lowerRight),t.vertexEnd(),t.indexWrite(r+0),t.indexWrite(r+1),t.indexWrite(r+2),t.indexWrite(r+1),t.indexWrite(r+3),t.indexWrite(r+2)}_writeVertexCommon(t,e,i,s){const r=this._color,a=this._haloColor,o=A(0,0,this._referenceSize,this._bitset),l=A(0,0,this._size,this._haloSize);t.vertexWrite(i),t.vertexWrite(e),t.vertexWrite(r),t.vertexWrite(a),t.vertexWrite(l),t.vertexWrite(o),t.vertexWrite(this._minMaxZoom)}};class xt{bindFeature(t,e,i){}write(t,e,i,s){var o;if(B(this._effects)||((o=this._effects)==null?void 0:o.length)===0)return this._write(t,e,s);const r=ne.executeEffects(this._effects,e.readLegacyGeometryForDisplay(),s.geometryEngine);let a=ne.next(r);for(;a;)this._write(t,e,s,a),a=ne.next(r)}_write(t,e,i,s){}}const Bs=5;class ut extends ri(xt){constructor(t,e,i,s,r,a,o,l,h,u,c,_,f,m,d,y,p,g,v=!1,b,L){super(),this._xOffset=x(f),this._yOffset=x(m),this._decoration=u||"none",this._color=r,this._haloColor=a,this._haloSize=Math.min(Math.floor(Bs*x(Ri(i))),127),this._size=Math.min(Math.round(x(e)),127);const S=Math.min(Math.round(x(s||e)),127);this._referenceSize=Math.round(Math.sqrt(256*S)),this._scale=this._size/Fe,this._angle=_,this._justify=ms(o||"center"),this._xAlignD=De(o||"center"),this._yAlignD=Ge(l||"baseline"),this._baseline=(l||"baseline")==="baseline",this._bitset=(h===V.MAP?1:0)|(c?1:0)<<1;const T=ie.load(t);T.sdf=!0,this._materialKey=T.data,this._lineWidth=x(d)||512,this._lineHeight=y||1,this._textPlacement=p,this._effects=g,this._isCIM=v,this._minMaxZoom=M(Math.round(b*C),Math.round(L*C))}static fromText(t,e){const i=new ut(t.materialKey,t.font.size,t.haloSize||0,t.font.size,t.color&&U(t.color)||0,t.haloColor&&U(t.haloColor)||0,t.horizontalAlignment,t.verticalAlignment,V.SCREEN,t.font.decoration,!1,t.angle||0,t.xoffset,t.yoffset,t.lineWidth,t.lineHeight,null,null,!1,D,G),[,s]=Ke(t.text);return i.bindTextInfo(e,s),i._vertexBoundsScale=t.maxVVSize?t.maxVVSize/t.font.size:1,i}static fromCIMText(t,e,i){const s=t.scaleFactor||1,r=t.size*t.sizeRatio*s,[a,o]=Q(t.scaleInfo,i),l=new ut(t.materialKey,r,t.outlineSize*t.sizeRatio,t.referenceSize,$(t.color),$(t.outlineColor),t.horizontalAlignment,t.verticalAlignment,t.alignment,t.decoration,t.colorLocked,t.angle,t.offsetX*t.sizeRatio*s,t.offsetY*t.sizeRatio*s,512,1,t.markerPlacement,t.effects,!0,a,o),[,h]=Ke(t.text);return l.bindTextInfo(e,h),l._vertexBoundsScale=t.maxVVSize?t.maxVVSize/r:1,l}}const Vs=lt.getLogger("esri.views.2d.engine.webgl.WGLLabelTemplate"),Os=(n,t="mapview-labeling")=>Vs.error(new tt(t,n)),Dt=1,ft=0,Ds=4,ni=25;function Gs(n,t){const e=!!n.minScale&&t.scaleToZoom(n.minScale)||0;return ze(e,0,25.5)}function Zs(n,t){const e=!!n.maxScale&&t.scaleToZoom(n.maxScale)||255;return ze(e,0,25.5)}function Ks(n){const t=new Map;return e=>(t.has(e)||t.set(e,n(e)),t.get(e))}const Ns=Ks(n=>{let t=0;if(n===0)return 1/0;for(;!(n%2);)t++,n/=2;return t}),Gt=n=>Math.floor(127*n+127),gt=n=>Math.floor(10*n),_t=n=>Math.round(n*(254/360));class Zt extends ut{constructor(t,e,i,s){var c,_,f;super(t,i.font.size,i.haloSize||0,i.font.size,i.color&&U(i.color)||0,i.haloColor&&U(i.haloColor)||0,i.horizontalAlignment,i.verticalAlignment,ps(e.labelPlacement)?V.MAP:V.SCREEN,i.font.decoration,!1,i.angle||0,i.xoffset,i.yoffset,i.lineWidth,i.lineHeight,null,null,null,null,null),this._outLineLabelAngle=0,this._refPlacementPadding=0,this._refPlacementDirX=0,this._refPlacementDirY=0,this._refOffsetX=0,this._refOffsetY=0,this._zoomLevel=0,this.geometryType=P.LABEL,this._allowOverrun=(c=e.allowOverrun)!=null?c:!1,this._repeatLabel=(_=e.repeatLabel)!=null?_:!0,this._labelPosition=(f=e.labelPosition)!=null?f:"curved";const r=Gs(e,s),a=Zs(e,s),o=e.labelPlacement,[l,h]=ys(o);this._xAlignD=l,this._yAlignD=h,this._minZoom=r,this._maxZoom=a,this._refPlacementPadding=x(i.haloSize)+ts,this._repeatLabelDistance=e.repeatLabelDistance?x(e.repeatLabelDistance):128;const u=Ms.load(t);u.sdf=!0,this._materialKey=u.data}static fromLabelClass(t,e){if(t.labelPlacement==="esriServerLinePlacementCenterAlong"){const i=t.symbol;i.xoffset=0,i.yoffset=0,i.angle=0,i.font.decoration="none"}return new Zt(t.materialKey,t,t.symbol,e)}get _shapedBox(){return Ht(this._shapingInfo).bounds}setZoomLevel(t){this._zoomLevel=t}bindReferenceTemplate(t){let e=xs(this._xAlignD),i=gs(this._yAlignD);if(this._refOffsetX=0,this._refOffsetY=0,B(t))return void(this._refSymbolAndPlacementOffset=A(0,0,Gt(e),Gt(i)));if(t.boundsType==="circle"&&(e||i)){const a=Math.sqrt(e*e+i*i);e/=a,i/=a}const s=Math.max(t.height,t.width),r=this._refPlacementPadding*Ds;this._refSymbolAndPlacementOffset=A(r,s,Gt(e),Gt(i)),this._referenceSize=s,this._refPlacementDirX=e,this._refPlacementDirY=i,this._refOffsetX=t.xOffset,this._refOffsetY=t.yOffset}_write(t,e){if(B(this._shapingInfo))return;const i=this._shapingInfo,s=e.getDisplayId(),r=e.geometryType==="esriGeometryPolygon"?e.readLegacyCentroid():e.readLegacyGeometry();if(r)switch(this._current={out:t,inId:s,inShaping:i,zoomLevel:this._zoomLevel},e.geometryType){case"esriGeometryPolyline":this._placeLineLabels(r);break;case"esriGeometryPoint":case"esriGeometryPolygon":this._placePointLabels(r);break;default:Os("mapview-labeling",`Geometry of type ${e.geometryType} is not supported`)}}_isVisible(t,e){const i=gt(this._current.zoomLevel);return gt(t)<=i&&i<=gt(e)}_placePointLabels(t){const{out:e,inId:i,inShaping:s}=this._current;this._writeGlyphs(e,i,t,s)}_placeLineLabels(t){const e=Fs(t.paths,this._current.inShaping.bounds.width),i=this._placeSubdivGlyphs.bind(this),s=(this._shapedBox.width+this._repeatLabelDistance)/(1<<Dt);for(const r of e)Rs(r,s,i,this._repeatLabel)}_placeSubdivGlyphs(t,e,i,s){const r=Ns(e),a=this._shapedBox.width/(1<<Dt),o=Math.sqrt(this._repeatLabelDistance)/(1<<Dt),l=Math.min(i,s-i),h=this._current.inShaping.isMultiline?ni:Math.log2(l/(o+a/2)),u=e===0?h:Math.min(r,h),c=Math.max(this._minZoom,this._current.zoomLevel+Dt-u),_=this._current.zoomLevel-c,f=this._shapedBox.width/2*2**_;this._current.inShaping.isMultiline?e===0&&this._placeStraight(t,c):this._allowOverrun&&_<0?this._placeStraightAlong(t,this._minZoom):this._labelPosition==="parallel"?this._placeStraightAlong(t,c):this._labelPosition==="curved"&&this._placeCurved(t,c,f)}_placeStraight(t,e){const{out:i,inId:s,inShaping:r}=this._current,a=Math.ceil(t.angle*(180/Math.PI)%360),o=Math.ceil((t.angle*(180/Math.PI)+180)%360);this._outLineLabelAngle=_t(a),this._writeGlyphs(i,s,t,r,e),this._outLineLabelAngle=_t(o),this._writeGlyphs(i,s,t,r,e)}_placeCurved(t,e,i){const{out:s,inId:r}=this._current;s.metricStart(r,e,t.x,t.y,0,0,0,0);const a=t.clone(),o=t.angle*(180/Math.PI)%360,l=(t.angle*(180/Math.PI)+180)%360;this._outLineLabelAngle=_t(o),this._placeFirst(a,e,1),this._placeBack(t,a,e,i,1),this._placeForward(t,a,e,i,1),this._outLineLabelAngle=_t(l),this._placeFirst(a,e,0),this._placeBack(t,a,e,i,0),this._placeForward(t,a,e,i,0),s.metricEnd()}_placeStraightAlong(t,e){const{out:i,inId:s}=this._current;i.metricStart(s,e,t.x,t.y,0,0,0,0);const r=t.clone(),a=t.angle*(180/Math.PI)%360,o=(t.angle*(180/Math.PI)+180)%360;this._outLineLabelAngle=_t(a),this._placeFirst(r,e,1,!0),this._outLineLabelAngle=_t(o),this._placeFirst(r,e,0,!0),i.metricEnd()}_placeBack(t,e,i,s,r){const a=t.clone();let o=t.backwardLength+ft;for(;a.prev()&&!(o>=s);)this._placeOnSegment(a,e,o,i,-1,r),o+=a.length+ft}_placeForward(t,e,i,s,r){const a=t.clone();let o=t.remainingLength+ft;for(;a.next()&&!(o>=s);)this._placeOnSegment(a,e,o,i,1,r),o+=a.length+ft}_placeFirst(t,e,i,s=!1){const r=t,a=this._current.inShaping,o=a.glyphs,l=this._current.zoomLevel,{out:h,inId:u}=this._current;for(const c of o){const _=c.x>a.bounds.x?i:1-i,f=_*t.remainingLength+(1-_)*t.backwardLength,m=Math.abs(c.x+c.width/2-a.bounds.x),d=Math.max(0,l+Math.log2(m/(f+ft))),y=Math.max(e,s?0:d);if(c.maxZoom=ni,c.angle=t.angle+(1-i)*Math.PI,c.minZoom=y,this._writeGlyph(h,u,r.x,r.y,c),i&&this._isVisible(c.minZoom,c.maxZoom)){const p=c.bounds;h.metricBoxWrite(p.center[0],p.center[1],p.width,p.height)}}}_placeOnSegment(t,e,i,s,r,a){const o=this._current.inShaping.glyphs,{out:l,inId:h}=this._current,u=this._current.inShaping,c=this._current.zoomLevel,_=t.dx/t.length,f=t.dy/t.length,m={x:t.x+i*-r*_,y:t.y+i*-r*f};for(const d of o){const y=d.x>u.bounds.x?a:1-a;if(!(y&&r===1||!y&&r===-1))continue;const p=Math.abs(d.x+d.width/2-u.bounds.x),g=Math.max(0,c+Math.log2(p/i)-.1),v=Math.max(s,c+Math.log2(p/(i+t.length+ft)));if(g!==0&&(d.angle=t.angle+(1-a)*Math.PI,d.minZoom=v,d.maxZoom=g,this._writeGlyph(l,h,m.x,m.y,d),a&&this._isVisible(d.minZoom,d.maxZoom))){const b=d.bounds,L=t.x-e.x,S=t.y-e.y;l.metricBoxWrite(b.center[0]+L,b.center[1]+S,b.width,b.height)}}}_writeGlyphs(t,e,i,s,r=this._minZoom){if(i.x<0||i.x>=512||i.y<0||i.y>=512)return;const a=i.x+this._refOffsetX,o=i.y-this._refOffsetY;for(const c of s.glyphs)c.minZoom=r,c.maxZoom=this._maxZoom,this._writeGlyph(t,e,a,o,c);const l=this._refPlacementDirX,h=this._refPlacementDirY,u=s.boundsT;t.metricStart(e,r,a,o,l,h,this._referenceSize,this._materialKey),t.metricBoxWrite(u.center[0],u.center[1],u.width,u.height),t.metricEnd()}_writeVertexCommon(t,e,i,s){const r=this._color,a=this._haloColor,o=A(0,0,this._size,this._haloSize),l=Math.max(s.minZoom,this._minZoom),h=Math.min(s.maxZoom,this._maxZoom),u=A(gt(l),gt(h),this._outLineLabelAngle,0);t.vertexWrite(i),t.vertexWrite(e),t.vertexWrite(r),t.vertexWrite(a),t.vertexWrite(o),t.vertexWrite(this._refSymbolAndPlacementOffset),t.vertexWrite(u)}}const ai=3.14159265359/180,oi=8,li=n=>class extends n{constructor(...t){super(...t),this.angle=0,this.xOffset=0,this.yOffset=0,this.width=0,this.height=0,this.boundsType="square",this._anchorX=0,this._anchorY=0,this._computedWidth=0,this._computedHeight=0,this._vertexBoundsScaleX=1,this._vertexBoundsScaleY=1,this._offsets={xUpperLeft:0,yUpperLeft:0,xUpperRight:0,yUpperRight:0,xBottomLeft:0,yBottomLeft:0,xBottomRight:0,yBottomRight:0},this.geometryType=P.MARKER}_write(t,e,i,s){const r=e.getDisplayId();t.recordStart(r,this._materialKey,this.geometryType,!0),this._writeGeometry(t,e,r,i,s),t.recordEnd()}_writeGeometry(t,e,i,s,r){if(E(this._markerPlacement))return this._writePlacedMarkers(t,e,s,r);if(!r&&e.geometryType==="esriGeometryPoint"){const o=e.getX(),l=e.getY();return!t.hasAggregates&&t.hasPixelBufferEnabled&&(o<0||o>=513||l<0||l>=513)?void 0:this._writeVertices(t,i,this._getPos(o,l),o,l)}const a=r?jt(Yt(r),2):e.geometryType==="esriGeometryPolygon"?e.readCentroid():e.readGeometryForDisplay();if(!B(a)){if(a.isPoint){const[o,l]=a.coords;return!t.hasAggregates&&t.hasPixelBufferEnabled&&(o<0||o>=512||l<0||l>=512)?void 0:this._writeVertices(t,i,this._getPos(o,l),o,l)}a.forEachVertex((o,l)=>{const h=2*et;o<-h||o>=h||l<-h||l>=h||this._writeVertices(t,i,this._getPos(o,l),o,l)})}}_writePlacedMarkers(t,e,i,s){const r=s!=null?s:e.readLegacyGeometryForDisplay(),a=si.getPlacement(r,Ht(this._markerPlacement),x(1),i.geometryEngine);if(!a)return;const o=e.getDisplayId(),l=Qt(),h=qt(),u=-128,c=640;let _=a.next();for(;_!=null;){const f=_.tx,m=-_.ty;f>=u&&f<=c&&m>=u&&m<=c&&(this._applyTransformation(h,l,-_.getAngle()/ai),this._writeVertices(t,o,this._getPos(f,m),f,m)),_=a.next()}}_writeVertices(t,e,i,s,r){const a=se.load(this._materialKey);return a.symbologyType===Wt.HEATMAP?this._writeHeatmapVertices(t,e,i):this._writeMarkerVertices(t,e,a,i,s,r)}_writeMarkerVertices(t,e,i,s,r,a){const o=i.vvRotation,l=t.vertexCount();let h=this._computedWidth*this._vertexBoundsScaleX,u=this._computedHeight*this._vertexBoundsScaleY;if(this.angle){const c=Math.max(h,u);h=c,u=c}if(o){const c=Math.max(this.xOffset,this.yOffset);h+=c,u+=c}t.vertexBounds(r+this.xOffset,a-this.yOffset,h,u),t.vertexWrite(s),t.vertexWrite(this._offsetUpperLeft),t.vertexWrite(this._texUpperLeft),t.vertexWrite(this._bitestAndDistRatio),t.vertexWrite(e),t.vertexWrite(this._fillColor),t.vertexWrite(this._outlineColor),t.vertexWrite(this._sizeOutlineWidth),t.vertexWrite(this._minMaxZoom),t.vertexEnd(),t.vertexWrite(s),t.vertexWrite(this._offsetUpperRight),t.vertexWrite(this._texUpperRight),t.vertexWrite(this._bitestAndDistRatio),t.vertexWrite(e),t.vertexWrite(this._fillColor),t.vertexWrite(this._outlineColor),t.vertexWrite(this._sizeOutlineWidth),t.vertexWrite(this._minMaxZoom),t.vertexEnd(),t.vertexWrite(s),t.vertexWrite(this._offsetBottomLeft),t.vertexWrite(this._texBottomLeft),t.vertexWrite(this._bitestAndDistRatio),t.vertexWrite(e),t.vertexWrite(this._fillColor),t.vertexWrite(this._outlineColor),t.vertexWrite(this._sizeOutlineWidth),t.vertexWrite(this._minMaxZoom),t.vertexEnd(),t.vertexWrite(s),t.vertexWrite(this._offsetBottomRight),t.vertexWrite(this._texBottomRight),t.vertexWrite(this._bitestAndDistRatio),t.vertexWrite(e),t.vertexWrite(this._fillColor),t.vertexWrite(this._outlineColor),t.vertexWrite(this._sizeOutlineWidth),t.vertexWrite(this._minMaxZoom),t.vertexEnd(),this._writeIndices(t,l)}_writeHeatmapVertices(t,e,i){const s=t.vertexCount();t.vertexWrite(i),t.vertexWrite(this._offsetUpperLeft),t.vertexWrite(e),t.vertexEnd(),t.vertexWrite(i),t.vertexWrite(this._offsetUpperRight),t.vertexWrite(e),t.vertexEnd(),t.vertexWrite(i),t.vertexWrite(this._offsetBottomLeft),t.vertexWrite(e),t.vertexEnd(),t.vertexWrite(i),t.vertexWrite(this._offsetBottomRight),t.vertexWrite(e),t.vertexEnd(),this._writeIndices(t,s)}_writeIndices(t,e){t.indexWrite(e+0),t.indexWrite(e+1),t.indexWrite(e+2),t.indexWrite(e+1),t.indexWrite(e+3),t.indexWrite(e+2)}_applyTransformation(t,e,i=0){Fi(t,ki(this.xOffset,-this.yOffset)),this.angle+i!==0&&Bi(t,t,ai*(this.angle+i));const s=this._computedWidth,r=this._computedHeight,a=-(.5+this._anchorX)*s,o=-(.5-this._anchorY)*r;Lt(e,a,o),Pt(e,e,t),this._offsetUpperLeft=M(16*e[0],16*e[1]),this._offsets.xUpperLeft=e[0],this._offsets.yUpperLeft=e[1],Lt(e,a+s,o),Pt(e,e,t),this._offsetUpperRight=M(16*e[0],16*e[1]),this._offsets.xUpperRight=e[0],this._offsets.yUpperRight=e[1],Lt(e,a,o+r),Pt(e,e,t),this._offsetBottomLeft=M(16*e[0],16*e[1]),this._offsets.xBottomLeft=e[0],this._offsets.yBottomLeft=e[1],Lt(e,a+s,o+r),Pt(e,e,t),this._offsetBottomRight=M(16*e[0],16*e[1]),this._offsets.xBottomRight=e[0],this._offsets.yBottomRight=e[1]}_getPos(t,e){return M(Math.round(oi*t),Math.round(oi*e))}};class Z extends li(xt){constructor(t,e,i,s,r,a,o,l,h,u,c,_,f,m,d,y,p,g,v,b,L,S,T){super(),this.angle=s,this.height=o,this.width=a,this.xOffset=e*v,this.yOffset=i*v,this._markerPlacement=b,this._effects=L,this._anchorX=y,this._anchorY=p,this._minMaxZoom=M(Math.round(S*C),Math.round(T*C));const z=(m===V.MAP?es:is)|(c?it:0)|(f?ss:0)|(_?rs:0),N=d&&d.sdf,H=se.load(t);H.sdf=N,H.pattern=!0,H.textureBinding=d.textureBinding,this._materialKey=H.data,this._fillColor=r,this._outlineColor=h,this._sizeOutlineWidth=A(Math.round(Math.min(Math.sqrt(128*a),255)),Math.round(Math.min(Math.sqrt(128*o),255)),Math.round(Math.min(Math.sqrt(128*u),255)),Math.round(Math.min(Math.sqrt(128*l),255)));const q=d.rect.x+I,O=d.rect.y+I,nt=q+d.width,at=O+d.height;this._offsets.xUpperLeft=q,this._offsets.yUpperLeft=O,this._offsets.xUpperRight=nt,this._offsets.yUpperRight=O,this._offsets.xBottomLeft=q,this._offsets.yBottomLeft=at,this._offsets.xBottomRight=nt,this._offsets.yBottomRight=at,H.symbologyType===Wt.PIE_CHART?(this._texUpperLeft=M(0,1),this._texUpperRight=M(1,1),this._texBottomLeft=M(0,0),this._texBottomRight=M(1,0)):(this._texUpperLeft=M(q,O),this._texUpperRight=M(nt,O),this._texBottomLeft=M(q,at),this._texBottomRight=M(nt,at)),a*=g,o*=g,a*=v,o*=v;const Li=Math.round(64*g);this._bitestAndDistRatio=M(z,Li),this._computedWidth=a,this._computedHeight=o;const Pi=Qt(),Ti=qt();this._applyTransformation(Ti,Pi)}static fromCIMMarker(t,e,i){const s=e&&e.width||1,r=e&&e.height||1,a=t.size,o=s/r*t.scaleX,l=t.scaleSymbolsProportionally&&t.frameHeight?a/t.frameHeight:1;let h=$(t.color);const u=$(t.outlineColor),c=x(a),_=c*o,f=x(t.offsetX||0),m=x(t.offsetY||0),d=x(t.outlineWidth||0)*l,y=t.alignment||V.SCREEN,p=x(t.referenceSize),[g,v]=Q(t.scaleInfo,i);e.sdf||h!==0||(h=-1);let b=t.rotation||0;t.rotateClockwise||(b=-b);let L=0,S=0;const T=t.anchorPoint;T&&(t.isAbsoluteAnchorPoint?a&&(L=T.x/(a*o),S=T.y/a):(L=T.x,S=T.y));const z=new Z(t.materialKey,f,m,b,h,_,c,p,u,d,t.colorLocked,t.scaleSymbolsProportionally,!1,y,e,L,S,t.sizeRatio,Tt(t.scaleFactor,1),t.markerPlacement,t.effects,g,v);return z._vertexBoundsScaleX=t.maxVVSize?t.maxVVSize/_:1,z._vertexBoundsScaleY=t.maxVVSize?t.maxVVSize/c:1,z}static fromPictureMarker(t,e){const i=Math.round(x(t.width)),s=Math.round(x(t.height)),r=ke,a=Math.round(x(t.xoffset||0)),o=Math.round(x(t.yoffset||0)),l=new Z(t.materialKey,a,o,t.angle,r,i,s,s,0,0,!1,!1,!1,V.SCREEN,e,0,0,1,1,null,null,D,G);return l._vertexBoundsScaleX=t.maxVVSize?t.maxVVSize/t.width:1,l._vertexBoundsScaleY=t.maxVVSize?t.maxVVSize/t.height:1,l}static fromSimpleMarker(t,e){const i=U(t.color),s=Math.round(x(t.size)),r=s,a=Math.round(x(t.xoffset||0)),o=Math.round(x(t.yoffset||0)),l=t.style,h=t.outline,u=0|(h&&h.color&&U(h.color)),c=0|(h&&h.width&&Math.round(x(h.width))),_=new Z(t.materialKey,a,o,t.angle,i,s,r,r,u,c,!1,!1,l==="esriSMSCross"||l==="esriSMSX",V.SCREEN,e,0,0,126/64,1,null,null,D,G);return _.boundsType=l==="esriSMSCircle"?"circle":"square",_._vertexBoundsScaleX=t.maxVVSize?t.maxVVSize/t.size:1,_._vertexBoundsScaleY=t.maxVVSize?t.maxVVSize/t.size:1,_}static fromLineSymbolMarker(t,e){const i=U(t.color),s=6,r=Math.round(x(s*t.lineWidth)),a=r,o=t.style==="cross"||t.style==="x";let l;switch(t.placement){case"begin-end":l=zt.Both;break;case"begin":l=zt.JustBegin;break;case"end":l=zt.JustEnd;break;default:l=zt.None}const h={type:"CIMMarkerPlacementAtExtremities",angleToLine:!0,offset:0,extremityPlacement:l,offsetAlongLine:0},u=new Z(t.materialKey,0,0,0,i,r,a,a/s,i,o?Math.round(x(t.lineWidth)):0,!1,!1,o,V.MAP,e,0,0,126/64,1,h,null,D,G);return u.boundsType=t.style==="circle"?"circle":"square",u}}function Us(n,t,e,i,s,r,a){de=0;const o=(i-e)*r,l=s&&s.length,h=l?(s[0]-e)*r:o;let u,c,_,f,m,d=hi(t,e,i,0,h,r,!0);if(d&&d.next!==d.prev){if(l&&(d=Hs(t,e,i,s,d,r)),o>80*r){u=_=t[0+e*r],c=f=t[1+e*r];for(let y=r;y<h;y+=r){const p=t[y+e*r],g=t[y+1+e*r];u=Math.min(u,p),c=Math.min(c,g),_=Math.max(_,p),f=Math.max(f,g)}m=Math.max(_-u,f-c),m=m!==0?1/m:0}vt(d,n,r,u,c,m,a,0)}}function hi(n,t,e,i,s,r,a){let o;if(a===er(n,t,e,i,s,r)>0)for(let l=i;l<s;l+=r)o=ci(l+t*r,n[l+t*r],n[l+1+t*r],o);else for(let l=s-r;l>=i;l-=r)o=ci(l+t*r,n[l+t*r],n[l+1+t*r],o);return o&&st(o,o.next)&&(wt(o),o=o.next),o}function Mt(n,t=n){if(!n)return n;let e,i=n;do if(e=!1,i.steiner||!st(i,i.next)&&W(i.prev,i,i.next)!==0)i=i.next;else{if(wt(i),i=t=i.prev,i===i.next)break;e=!0}while(e||i!==t);return t}function vt(n,t,e,i,s,r,a,o){if(!n)return;!o&&r&&(n=ui(n,i,s,r));let l=n;for(;n.prev!==n.next;){const h=n.prev,u=n.next;if(r?js(n,i,s,r):Xs(n))t.push(h.index/e+a),t.push(n.index/e+a),t.push(u.index/e+a),wt(n),n=u.next,l=u.next;else if((n=u)===l){o?o===1?vt(n=sr(n,t,e,a),t,e,i,s,r,a,2):o===2&&rr(n,t,e,i,s,r,a):vt(Mt(n),t,e,i,s,r,a,1);break}}}function Xs(n){const t=n.prev,e=n,i=n.next;if(W(t,e,i)>=0)return!1;let s=n.next.next;const r=s;let a=0;for(;s!==n.prev&&(a===0||s!==r);){if(a++,dt(t.x,t.y,e.x,e.y,i.x,i.y,s.x,s.y)&&W(s.prev,s,s.next)>=0)return!1;s=s.next}return!0}function js(n,t,e,i){const s=n.prev,r=n,a=n.next;if(W(s,r,a)>=0)return!1;const o=s.x<r.x?s.x<a.x?s.x:a.x:r.x<a.x?r.x:a.x,l=s.y<r.y?s.y<a.y?s.y:a.y:r.y<a.y?r.y:a.y,h=s.x>r.x?s.x>a.x?s.x:a.x:r.x>a.x?r.x:a.x,u=s.y>r.y?s.y>a.y?s.y:a.y:r.y>a.y?r.y:a.y,c=fe(o,l,t,e,i),_=fe(h,u,t,e,i);let f=n.prevZ,m=n.nextZ;for(;f&&f.z>=c&&m&&m.z<=_;){if(f!==n.prev&&f!==n.next&&dt(s.x,s.y,r.x,r.y,a.x,a.y,f.x,f.y)&&W(f.prev,f,f.next)>=0||(f=f.prevZ,m!==n.prev&&m!==n.next&&dt(s.x,s.y,r.x,r.y,a.x,a.y,m.x,m.y)&&W(m.prev,m,m.next)>=0))return!1;m=m.nextZ}for(;f&&f.z>=c;){if(f!==n.prev&&f!==n.next&&dt(s.x,s.y,r.x,r.y,a.x,a.y,f.x,f.y)&&W(f.prev,f,f.next)>=0)return!1;f=f.prevZ}for(;m&&m.z<=_;){if(m!==n.prev&&m!==n.next&&dt(s.x,s.y,r.x,r.y,a.x,a.y,m.x,m.y)&&W(m.prev,m,m.next)>=0)return!1;m=m.nextZ}return!0}function ci(n,t,e,i){const s=mt.create(n,t,e);return i?(s.next=i.next,s.prev=i,i.next.prev=s,i.next=s):(s.prev=s,s.next=s),s}function wt(n){n.next.prev=n.prev,n.prev.next=n.next,n.prevZ&&(n.prevZ.nextZ=n.nextZ),n.nextZ&&(n.nextZ.prevZ=n.prevZ)}function Ys(n){let t=n,e=n;do(t.x<e.x||t.x===e.x&&t.y<e.y)&&(e=t),t=t.next;while(t!==n);return e}function Hs(n,t,e,i,s,r){const a=new Array;for(let o=0,l=i.length;o<l;o++){const h=hi(n,t,e,i[o]*r,o<l-1?i[o+1]*r:e*r,r,!1);h===h.next&&(h.steiner=!0),a.push(Ys(h))}a.sort(ir);for(const o of a)s=qs(o,s);return s}function qs(n,t){const e=Qs(n,t);if(!e)return t;const i=_i(e,n);return Mt(i,i.next),Mt(e,e.next)}function Qs(n,t){let e=t;const i=n.x,s=n.y;let r,a=-1/0;do{if(s<=e.y&&s>=e.next.y&&e.next.y!==e.y){const _=e.x+(s-e.y)*(e.next.x-e.x)/(e.next.y-e.y);if(_<=i&&_>a){if(a=_,_===i){if(s===e.y)return e;if(s===e.next.y)return e.next}r=e.x<e.next.x?e:e.next}}e=e.next}while(e!==t);if(!r)return null;if(i===a)return r.prev;const o=r,l=r.x,h=r.y;let u,c=1/0;for(e=r.next;e!==o;)i>=e.x&&e.x>=l&&i!==e.x&&dt(s<h?i:a,s,l,h,s<h?a:i,s,e.x,e.y)&&(u=Math.abs(s-e.y)/(i-e.x),(u<c||u===c&&e.x>r.x)&&bt(e,n)&&(r=e,c=u)),e=e.next;return r}function ui(n,t,e,i){for(let s;s!==n;s=s.next){if(s=s||n,s.z===null&&(s.z=fe(s.x,s.y,t,e,i)),s.prev.next!==s||s.next.prev!==s)return s.prev.next=s,s.next.prev=s,ui(n,t,e,i);s.prevZ=s.prev,s.nextZ=s.next}return n.prevZ.nextZ=null,n.prevZ=null,Js(n)}function Js(n){let t,e=1;for(;;){let i,s=n;n=null,t=null;let r=0;for(;s;){r++,i=s;let a=0;for(;a<e&&i;a++)i=i.nextZ;let o=e;for(;a>0||o>0&&i;){let l;a===0?(l=i,i=i.nextZ,o--):o!==0&&i?s.z<=i.z?(l=s,s=s.nextZ,a--):(l=i,i=i.nextZ,o--):(l=s,s=s.nextZ,a--),t?t.nextZ=l:n=l,l.prevZ=t,t=l}s=i}if(t.nextZ=null,e*=2,r<2)return n}}function W(n,t,e){return(t.y-n.y)*(e.x-t.x)-(t.x-n.x)*(e.y-t.y)}function fi(n,t,e,i){return!!(st(n,t)&&st(e,i)||st(n,i)&&st(e,t))||W(n,t,e)>0!=W(n,t,i)>0&&W(e,i,n)>0!=W(e,i,t)>0}function tr(n,t){let e=n;do{if(e.index!==n.index&&e.next.index!==n.index&&e.index!==t.index&&e.next.index!==t.index&&fi(e,e.next,n,t))return!0;e=e.next}while(e!==n);return!1}function er(n,t,e,i,s,r){let a=0;for(let o=i,l=s-r;o<s;o+=r)a+=(n[l+t*r]-n[o+t*r])*(n[o+1+t*r]+n[l+1+t*r]),l=o;return a}function dt(n,t,e,i,s,r,a,o){return(s-a)*(t-o)-(n-a)*(r-o)>=0&&(n-a)*(i-o)-(e-a)*(t-o)>=0&&(e-a)*(r-o)-(s-a)*(i-o)>=0}function bt(n,t){return W(n.prev,n,n.next)<0?W(n,t,n.next)>=0&&W(n,n.prev,t)>=0:W(n,t,n.prev)<0||W(n,n.next,t)<0}function fe(n,t,e,i,s){return(n=1431655765&((n=858993459&((n=252645135&((n=16711935&((n=32767*(n-e)*s)|n<<8))|n<<4))|n<<2))|n<<1))|(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=32767*(t-i)*s)|t<<8))|t<<4))|t<<2))|t<<1))<<1}function st(n,t){return n.x===t.x&&n.y===t.y}function ir(n,t){return n.x-t.x}function sr(n,t,e,i){let s=n;do{const r=s.prev,a=s.next.next;!st(r,a)&&fi(r,s,s.next,a)&&bt(r,a)&&bt(a,r)&&(t.push(r.index/e+i),t.push(s.index/e+i),t.push(a.index/e+i),wt(s),wt(s.next),s=n=a),s=s.next}while(s!==n);return s}function rr(n,t,e,i,s,r,a){let o=n;do{let l=o.next.next;for(;l!==o.prev;){if(o.index!==l.index&&nr(o,l)){let h=_i(o,l);return o=Mt(o,o.next),h=Mt(h,h.next),vt(o,t,e,i,s,r,a,0),void vt(h,t,e,i,s,r,a,0)}l=l.next}o=o.next}while(o!==n)}function nr(n,t){return n.next.index!==t.index&&n.prev.index!==t.index&&!tr(n,t)&&bt(n,t)&&bt(t,n)&&ar(n,t)}function ar(n,t){let e=n,i=!1;const s=(n.x+t.x)/2,r=(n.y+t.y)/2;do e.y>r!=e.next.y>r&&e.next.y!==e.y&&s<(e.next.x-e.x)*(r-e.y)/(e.next.y-e.y)+e.x&&(i=!i),e=e.next;while(e!==n);return i}function _i(n,t){const e=mt.create(n.index,n.x,n.y),i=mt.create(t.index,t.x,t.y),s=n.next,r=t.prev;return n.next=t,t.prev=n,e.next=s,s.prev=e,i.next=e,e.prev=i,r.next=i,i.prev=r,i}class mt{constructor(){this.index=0,this.x=0,this.y=0,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}static create(t,e,i){const s=de<_e.length?_e[de++]:new mt;return s.index=t,s.x=e,s.y=i,s.prev=null,s.next=null,s.z=null,s.prevZ=null,s.nextZ=null,s.steiner=!1,s}}const _e=new Array,or=8096;let de=0;for(let n=0;n<or;n++)_e.push(new mt);const lr=1e-5,rt=new Oe(0,0,0,1,0),me=new Oe(0,0,0,1,0);function di(n,t,e){let i=0;for(let s=1;s<e;s++){const r=n[2*(t+s-1)],a=n[2*(t+s-1)+1];i+=(n[2*(t+s)]-r)*(n[2*(t+s)+1]+a)}return i}function hr(n,t,e,i,s){let r=0;const a=2;for(let o=e;o<i;o+=3){const l=(n[o]-s)*a,h=(n[o+1]-s)*a,u=(n[o+2]-s)*a;r+=Math.abs((t[l]-t[u])*(t[h+1]-t[l+1])-(t[l]-t[h])*(t[u+1]-t[l+1]))}return r}function cr(n,t){const{coords:e,lengths:i,hasIndeterminateRingOrder:s}=t,r=0,a=n;if(s)return!1;let o=0;for(let l=0;l<i.length;){let h=l,u=i[l],c=di(e,o,u);const _=[];for(;++h<i.length;){const y=i[h],p=di(e,o+u,y);if(!(p>0))break;c+=p,_.push(o+u),u+=y}const f=a.length;Us(a,e,o,o+u,_,2,r);const m=hr(a,e,f,a.length,r),d=Math.abs(c);if(Math.abs((m-d)/Math.max(1e-7,d))>lr)return a.length=0,!1;l=h,o+=u}return!0}function ur(n){const{coords:t,lengths:e}=n,{buffer:i}=fs(t,e);return i}function fr(n,t,e){let i=0;for(let s=0;s<n.lengths.length;s++){const r=n.lengths[s];for(let a=0;a<r;a++){const o=n.coords[2*(a+i)],l=n.coords[2*(a+i)+1];if(o<t||o>e||l<t||l>e)return!0}i+=r}return!1}function _r(n,t){if(B(n))return null;if(!fr(n,-128,et+128))return n;rt.setPixelMargin(t),rt.reset(Ne.Polygon);let e=0;for(let a=0;a<n.lengths.length;a++){const o=n.lengths[a];let l=n.coords[2*(0+e)],h=n.coords[2*(0+e)+1];rt.moveTo(l,h);for(let u=1;u<o;u++)l=n.coords[2*(u+e)],h=n.coords[2*(u+e)+1],rt.lineTo(l,h);rt.close(),e+=o}const i=rt.result(!1);if(!i)return null;const s=[],r=[];for(const a of i){let o=0;for(const l of a)r.push(l.x),r.push(l.y),o++;s.push(o)}return new Vi(s,r)}function dr(n,t){me.setPixelMargin(t);const e=me,i=-t,s=et+t;let r=[],a=!1,o=0;for(;o<n.length;){const l=[],h=n[o];if(!h)return null;e.reset(Ne.LineString);let[u,c]=h[0];if(a)e.moveTo(u,c);else{if(u<i||u>s||c<i||c>s){a=!0;continue}l.push({x:u,y:c})}let _=!1;const f=h.length;for(let m=1;m<f;++m)if(u+=h[m][0],c+=h[m][1],a)e.lineTo(u,c);else{if(u<i||u>s||c<i||c>s){_=!0;break}l.push({x:u,y:c})}if(_)a=!0;else{if(a){const m=e.resultWithStarts();if(m)for(const d of m)r.push(d)}else r.push({line:l,start:0});o++,a=!1}}return r=r.filter(l=>l.line.length>1),r.length===0?null:r}rt.setExtent(et),me.setExtent(et);const Kt=8,R=16,mi=65535,pi=n=>class extends n{constructor(...t){super(...t),this.tessellationProperties={},this._tessellationOptions={halfWidth:0,pixelCoordRatio:1,offset:0},this.geometryType=P.LINE}writeGeometry(t,e,i,s){this._writeGeometry(t,e,i,s)}_initializeTessellator(t){const e=Ct.load(this._materialKey),i=ht.load(this._materialKey),s=this._tessellationOptions,r=e.vvSizeFieldStops||e.vvSizeMinMaxValue||e.vvSizeScaleStops||e.vvSizeUnitValue,a=this.tessellationProperties._halfWidth<ns&&!t&&!r;this.tessellationProperties.minMaxZoom=this._minMaxZoom,s.wrapDistance=mi,s.textured=this._isDashed||this._hasPattern,s.offset=this.tessellationProperties.offset,s.halfWidth=this.tessellationProperties._halfWidth;const o=a?0:1,l=Et(i)?pr:mr;this._lineTessellator=new _s(l(this.tessellationProperties,o,o),yr(this.tessellationProperties),a)}_write(t,e,i,s){const r=e.geometryType==="esriGeometryPoint";t.recordStart(e.getDisplayId(),this._materialKey,this.geometryType,r),this._writeGeometry(t,e,s,r),t.recordEnd()}_writeGeometry(t,e,i,s){const r=i!=null?i:e.readLegacyGeometryForDisplay(),a=this._getLines(r,s);B(a)||this._writeVertices(t,e,a)}_getLines(t,e){if(B(t))return null;const i=t.paths||t.rings;return B(i)?null:dr(i,e?256:16)}_writeVertices(t,e,i){const s=e.getDisplayId(),r=t.vertexCount(),a=this.tessellationProperties,o=this._tessellationOptions;a.out=t,a.id=s,a.indexCount=0,a.vertexCount=0,a.offset=r,o.capType=this._capType,o.joinType=this._joinType;const l=ht.load(this._materialKey);this.tessellationProperties.key=Et(l)?l:Ct.load(this._materialKey);for(const{line:h,start:u}of i)o.initialDistance=u%mi,this._lineTessellator.tessellate(h,o)}},mr=(n,t,e)=>(i,s,r,a,o,l,h,u,c,_,f)=>{const m=M(f,Math.ceil(R*n._halfWidth)),d=A(Math.round(R*h),Math.round(R*u),Math.round(R*c),Math.round(R*_)),y=A(R*o,R*l,0,n._bitset),p=n.out;return p.vertexBounds(i,s,t,e),p.vertexWrite(M(Kt*i,Kt*s)),p.vertexWrite(n.id),p.vertexWrite(n._fillColor),p.vertexWrite(d),p.vertexWrite(m),p.vertexWrite(n._tl),p.vertexWrite(n._br),p.vertexWrite(y),p.vertexWrite(M(Math.ceil(R*n._halfReferenceWidth),0)),p.vertexWrite(n.minMaxZoom),p.vertexEnd(),n.offset+n.vertexCount++},pr=(n,t,e)=>(i,s,r,a,o,l,h,u,c,_,f)=>{const m=M(R*n._halfWidth,R*n._halfReferenceWidth),d=A(R*h+128,R*u+128,R*c+128,R*_+128),y=n.out,p=n._bitset<<24|n.id;y.vertexBounds(i,s,t,e),y.vertexWrite(M(Kt*i,Kt*s)),y.vertexWrite(p),y.vertexWrite(n._fillColor);const g=Ze(n.key);return g||(y.vertexWrite(0),y.vertexWrite(0)),y.vertexWrite(0),y.vertexWrite(m),y.vertexWrite(d),g||y.vertexWrite(n.minMaxZoom),y.vertexEnd(),n.offset+n.vertexCount++},yr=n=>(t,e,i)=>{const s=n.out;s.indexWrite(t),s.indexWrite(e),s.indexWrite(i),n.indexCount+=3};class X extends pi(xt){constructor(t,e,i,s,r,a,o,l,h,u,c,_,f,m,d,y,p,g,v,b){super();const L=Ct.load(t);e&&(L.sdf=e.sdf,L.pattern=!0,L.textureBinding=e.textureBinding),this._capType=s,this._joinType=r,this._miterLimitCosine=ue(a),this.tessellationProperties._fillColor=o,this.tessellationProperties._tl=l,this.tessellationProperties._br=h,this._hasPattern=u,this._isDashed=c,this._zOrder=p,this._effects=g,this._minMaxZoom=M(Math.round(v*C),Math.round(b*C)),this._materialKey=L.data;const S=(f?it:0)|(m?as:0)|(_?Be:0)|(d?$t:0);this.tessellationProperties._bitset=S,this.tessellationProperties._halfWidth=.5*i,this.tessellationProperties._halfReferenceWidth=.5*y,this.tessellationProperties.offset=0,this._initializeTessellator(!1)}static fromCIMLine(t,e,i){const s=t.color,r=t.scaleFactor||1,a=!!t.dashTemplate;let o=t.cap;a&&o===Ie.ROUND&&(o=Ie.SQUARE);const l=t.join,h=x(t.width)*r,u=x(t.referenceWidth),c=x(t.miterLimit),_=s&&$(s)||0,[f,m]=Q(t.scaleInfo,i),d=!1;if(!e)return new X(t.materialKey,e,h,o,l,c,_,0,0,!1,a,t.scaleDash,t.colorLocked,d,t.sampleAlphaOnly,u,t.zOrder,t.effects,f,m);const{rect:y,width:p,height:g}=e,v=y.x+I,b=y.y+I,L=v+p,S=b+g,T=M(v,b),z=M(L,S),N=!1;return new X(t.materialKey,e,h,o,l,c,_,T,z,!0,a,t.scaleDash,t.colorLocked,N,t.sampleAlphaOnly,u,t.zOrder,t.effects,f,m)}static fromFillOutline(t){var i;const e=ht.load(t.materialKey);return Et(e)&&t.outline&&((i=t.outline)==null?void 0:i.style)==="esriSLSSolid"?X.fromSimpleLine(ot({hash:"",materialKey:t.materialKey},t.outline),null,!0):null}static fromSimpleLine(t,e,i=!1){const{color:s}=t,r=t.style!=="esriSLSSolid"&&t.style!=="esriSLSNull",a=hs(t.cap||"round"),o=cs(t.join||"round");let l=s&&t.style!=="esriSLSNull"&&U(s)||0;t.style==="esriSLSNull"&&(l=0);const h=x(t.width),u=t.miterLimit;if(!e)return new X(t.materialKey,e,h,a,o,u,l,0,0,!1,r,!0,!1,i,!1,h,0,null,D,G);const{rect:c,width:_,height:f}=e,m=c.x+I,d=c.y+I,y=m+_,p=d+f,g=M(m,d),v=M(y,p);return new X(t.materialKey,e,h,a,o,u,l,g,v,!0,r,!0,!1,i,!1,h,0,null,D,G)}static fromPictureLineSymbol(t,e,i,s){return lt.getLogger("esri.views.2d.engine.webgl.WGLLineTemplate").error("PictureLineSymbol support does not exist!"),null}}const xr=100,yi=1,xi=n=>class extends n{constructor(...t){super(...t),this.forceLibtess=!1,this._bitset=0,this._lineTemplate=null,this.geometryType=P.FILL}_maybeAddLineTemplate(t){this._lineTemplate=X.fromFillOutline(t)}_write(t,e,i,s){const r=e.geometryType==="esriGeometryPoint",a=ht.load(this._materialKey);t.recordStart(e.getDisplayId(),this._materialKey,this.geometryType,r),this._writeGeometry(t,e,a,s,r),Et(a)&&E(this._lineTemplate)&&this._lineTemplate.writeGeometry(t,e,s,r),t.recordEnd()}_writeGeometry(t,e,i,s,r){const a=this._getGeometry(e,s,r);if(B(a))return;const o=[];if(!(a.maxLength>xr)&&!this.forceLibtess&&cr(o,a))return void(o.length&&this._writeVertices(t,e,a.coords,a.lengths,i,o));const l=ur(a);this._writeVertices(t,e,l,[l.length/2],i)}_writeVertex(t,e,i,s,r,a){const o=M(yi*s,yi*r);if(t.vertexBounds(s,r,0,0),t.vertexWrite(o),t.vertexWrite(e),i.symbologyType===Wt.DOT_DENSITY)t.vertexWriteF32(1/Math.abs(a.readGeometryArea()));else{t.vertexWrite(this.fillColor);const l=Ze(i);l||(t.vertexWrite(this.tl),t.vertexWrite(this.br)),t.vertexWrite(this.aux21),t.vertexWrite(this.aux22),t.vertexWrite(this.aux3),l||t.vertexWrite(this._minMaxZoom)}}_writeVertices(t,e,i,s,r,a){const o=e.getDisplayId(),l=this._bitset<<24|o,h=s.reduce((f,m)=>f+m),u=ee(r.geometryType,r.symbologyType).geometry/4,c=t.vertexCount();t.vertexEnsureSize(u*h);let _=0;if(a)for(const f of a){const m=i[2*f],d=i[2*f+1];this._writeVertex(t,l,r,m,d,e),_++}else for(let f=0;f<i.length;f+=2){const m=Math.round(i[f]),d=Math.round(i[f+1]);this._writeVertex(t,l,r,m,d,e),_++}t.indexEnsureSize(_);for(let f=0;f<_;f++)t.indexWrite(f+c)}_getGeometry(t,e,i){const s=e?jt(Yt(e),2):t.readGeometryForDisplay();return s?_r(s,i?256:8):null}},gi=lt.getLogger("esri.views.2d.engine.webgl.WGLDynamicMeshTemplate");class Nt extends xt{constructor(t){super(),this._ongoingMaterialRequestMap=new Map,this._materialCache=new Map,this._dynamicPropertyMap=new Map,this._cimLayer=t}analyze(t,e,i,s,r){if(r&&r.length===0)return null;const a=r&&r.length>0,o=e.readLegacyFeature(),l=e.getObjectId(),h=this._materialCache,u=this._cimLayer.materialHash;if(!u)return gi.error("A Dynamic mesh template must have a material hash value or function!"),Promise.reject(null);const c=typeof u=="function"?u(o,i,s,l):u;if(h.has(c)){const v=h.get(c);return Promise.resolve(v)}const _=this._ongoingMaterialRequestMap.get(c);if(_)return _;const f=this._cimLayer,m=Ls(f.cim,this._cimLayer.materialOverrides);m.mosaicHash=c;const{type:d,url:y}=f,p={cim:m,type:d,mosaicHash:c,url:y,size:null,dashTemplate:null,text:null,fontName:null,objectId:l,animatedSymbolProperties:null};switch(d){case"marker":p.size=It(f.size,o,i,s),p.animatedSymbolProperties=It(f.animatedSymbolProperties,o,i,s);break;case"line":p.dashTemplate=f.dashTemplate;break;case"text":p.text=It(f.text,o,i,s),p.fontName=It(f.fontName,o,i,s)}const g=t.getMosaicItem(p,r).then(v=>(a||(this._ongoingMaterialRequestMap.delete(c),h.set(c,v)),v)).catch(v=>(this._ongoingMaterialRequestMap.delete(c),gi.error(".analyze()",v.message),null));return a||this._ongoingMaterialRequestMap.set(c,g),g}}const Mi=128;class pe extends xi(Nt){constructor(t,e,i){var u;if(super(t),this._minMaxZoom=M(Math.round(e*C),Math.round(i*C)),w(t.color)){const c=(_,f,m)=>{const d=t.color(_,f,m);return d&&$(d)||0};this._dynamicPropertyMap.set("fillColor",c)}else{const c=t.color;this.fillColor=c&&$(c)||0}const s=((u=t.cim.placement)==null?void 0:u.type)==="CIMMarkerPlacementInsidePolygon"&&t.cim.placement.shiftOddRows?2:1,r=t.height;if(w(r)){const c=(_,f,m)=>r(_,f,m)*s;this._dynamicPropertyMap.set("_height",c)}else this._height=(r||0)*s;const a=t.offsetX;if(w(a)){const c=(_,f,m)=>x(a(_,f,m));this._dynamicPropertyMap.set("_offsetX",c)}else this._offsetX=x(a||0);const o=t.offsetY;if(w(o)){const c=(_,f,m)=>x(-o(_,f,m));this._dynamicPropertyMap.set("_offsetY",c)}else this._offsetY=x(-o||0);const l=t.scaleX;w(l)?this._dynamicPropertyMap.set("_scaleX",l):this._scaleX=l||1;const h=t.angle;if(w(h)){const c=(_,f,m)=>ae(h(_,f,m));this._dynamicPropertyMap.set("_angle",c)}else this._angle=ae(h)||0;if(E(t.effects)){const c=t.effects;w(c)?this._dynamicPropertyMap.set("_effects",c):this._effects=c}this._cimFillLayer=t,this._bitset=(t.colorLocked?it:0)|(t.applyRandomOffset?Ve:0)|(t.sampleAlphaOnly?$t:0),this._fillMaterialKey=t.materialKey}static fromCIMFill(t,e){const[i,s]=Q(t.scaleInfo,e);return new pe(t,i,s)}bindFeature(t,e,i){const s=t.readLegacyFeature();this._dynamicPropertyMap.forEach((u,c)=>{this[c]=u(s,e,i)});const r=ht.load(this._fillMaterialKey),a=this._materialCache,o=(0,this._cimFillLayer.materialHash)(s,e,i),l=a.get(o);let h=null;if(l&&k(l.spriteMosaicItem)&&(h=l.spriteMosaicItem),h){const{rect:u,width:c,height:_}=h,f=u.x+I,m=u.y+I,d=f+c,y=m+_;let p=Math.round(x(this._height));p<=0&&(p=y-m);let g=Math.round(x(this._height/_*c||0));g<=0&&(g=d-f);const v=this._scaleX,b=1;this.tl=M(f,m),this.br=M(d,y),this.aux21=M(g,p),this.aux22=M(this._offsetX,this._offsetY),this.aux3=A(v*Mi,b*Mi,this._angle,0),r.sdf=h.sdf,r.pattern=!0,r.textureBinding=h.textureBinding}else this.tl=0,this.br=0,this.aux21=0,this.aux22=0,this.aux3=0,r.sdf=!1,r.pattern=!1,r.textureBinding=0;this._materialKey=r.data}}class ye extends pi(Nt){constructor(t,e,i){super(t),this._minMaxZoom=M(Math.round(e*C),Math.round(i*C)),this._cimLineLayer=t;let s=0;w(t.width)||(s=.5*x(t.width));const r=(c,_,f)=>w(t.width)?.5*x(t.width(c,_,f)):s;this._dynamicPropertyMap.set("_halfWidth",r),w(t.cap)?this._dynamicPropertyMap.set("_capType",t.cap):this._capType=t.cap,w(t.join)?this._dynamicPropertyMap.set("_joinType",t.join):this._joinType=t.join;const a=t.color;if(w(a)){const c=(_,f,m)=>$(a(_,f,m));this._dynamicPropertyMap.set("_fillColor",c)}else this._fillColor=a&&$(a)||0;const o=t.miterLimit;if(w(o)){const c=(_,f,m)=>ue(o(_,f,m));this._dynamicPropertyMap.set("_miterLimitCosine",c)}else this._miterLimitCosine=ue(o);if(E(t.effects)){const c=t.effects;w(c)?this._dynamicPropertyMap.set("_effects",c):this._effects=c}this._scaleFactor=t.scaleFactor||1,this._isDashed=t.dashTemplate!=null;const l=t.colorLocked?it:0,h=t.scaleDash?Be:0,u=t.sampleAlphaOnly?$t:0;this.tessellationProperties._bitset=l|h|u,this._materialKey=t.materialKey,this._initializeTessellator(!0)}static fromCIMLine(t,e){const[i,s]=Q(t.scaleInfo,e);return new ye(t,i,s)}bindFeature(t,e,i){const s=t.readLegacyFeature();this._dynamicPropertyMap.forEach((u,c)=>{this[c]=u(s,e,i)}),this._halfWidth*=this._scaleFactor;const r=this._materialCache,a=(0,this._cimLineLayer.materialHash)(s,e,i),o=r.get(a);let l=null;if(o&&k(o.spriteMosaicItem)&&(l=o.spriteMosaicItem),l){this._hasPattern=!0;const{rect:u,width:c,height:_}=l,f=u.x+I,m=u.y+I,d=f+c,y=m+_;this.tessellationProperties._tl=M(f,m),this.tessellationProperties._br=M(d,y)}else this._hasPattern=!1,this.tessellationProperties._tl=0,this.tessellationProperties._br=0;this.tessellationProperties._fillColor=this._fillColor,this.tessellationProperties._halfWidth=this._halfWidth,this.tessellationProperties.offset=0,this.tessellationProperties._halfReferenceWidth=this.tessellationProperties._halfWidth;const h=Ct.load(this._materialKey);l&&(h.sdf=l.sdf,h.pattern=!0,h.textureBinding=l.textureBinding),this._materialKey=h.data}}const gr=Qt(),Mr=qt();class xe extends li(Nt){constructor(t,e,i){super(t),this._cimMarkerLayer=t,this._minMaxZoom=M(Math.round(e*C),Math.round(i*C));const s=t.color;if(w(s)){const _=(f,m,d)=>$(s(f,m,d));this._dynamicPropertyMap.set("_fillColor",_)}else this._fillColor=$(s);const r=t.outlineColor;if(w(r)){const _=(f,m,d)=>$(r(f,m,d));this._dynamicPropertyMap.set("_outlineColor",_)}else this._outlineColor=$(r);const a=t.size;if(w(a)){const _=(f,m,d)=>x(a(f,m,d));this._dynamicPropertyMap.set("_size",_)}else this._size=x(a)||0;const o=t.scaleX;w(o)?this._dynamicPropertyMap.set("_scaleX",o):this._scaleX=o;const l=t.offsetX;if(w(l)){const _=(f,m,d)=>x(l(f,m,d));this._dynamicPropertyMap.set("xOffset",_)}else this.xOffset=x(l)||0;const h=t.offsetY;if(w(h)){const _=(f,m,d)=>x(h(f,m,d));this._dynamicPropertyMap.set("yOffset",_)}else this.yOffset=x(h)||0;const u=t.outlineWidth;if(w(u)){const _=(f,m,d)=>x(u(f,m,d));this._dynamicPropertyMap.set("_outlineWidth",_)}else this._outlineWidth=x(u)||0;const c=t.rotation;if(w(c)?this._dynamicPropertyMap.set("_angle",c):this._angle=c||0,E(t.effects)){const _=t.effects;w(_)?this._dynamicPropertyMap.set("_effects",_):this._effects=_}if(E(t.markerPlacement)){const _=t.markerPlacement;w(_)?this._dynamicPropertyMap.set("_markerPlacement",_):this._markerPlacement=_}this._scaleFactor=Tt(t.scaleFactor,1),this._bitSet=(t.alignment===V.MAP?1:0)|(t.colorLocked?1:0)<<1|(t.scaleSymbolsProportionally?1:0)<<3,this._materialKey=t.materialKey}static fromCIMMarker(t,e){const[i,s]=Q(t.scaleInfo,e);return new xe(t,i,s)}bindFeature(t,e,i){const s=t.readLegacyFeature(),r=t.getObjectId();this._dynamicPropertyMap.forEach((nt,at)=>{this[at]=nt(s,e,i)});const a=this._cimMarkerLayer.materialHash,o=typeof a=="function"?a(s,e,i,r):a,l=this._materialCache.get(o);if(!l||!k(l.spriteMosaicItem)||!l.spriteMosaicItem)return void lt.getLogger("esri.views.2d.engine.webgl.WGLDynamicMarkerTemplate").error(new tt("mapview-cim","Encountered an error when binding feature"));const h=l.spriteMosaicItem,u=this._cimMarkerLayer.sizeRatio,c=h.width/h.height*this._scaleX,_=this._cimMarkerLayer.rotateClockwise?this._angle:-this._angle;let f=this._size,m=f*c;const d=this.xOffset,y=this.yOffset;this.xOffset*=this._scaleFactor,this.yOffset*=this._scaleFactor;const p=this._cimMarkerLayer.scaleSymbolsProportionally&&this._cimMarkerLayer.frameHeight?this._size/x(this._cimMarkerLayer.frameHeight):1,g=this._outlineWidth*p,v=x(this._cimMarkerLayer.referenceSize);let b=0,L=0;const S=this._cimMarkerLayer.anchorPoint;S&&(this._cimMarkerLayer.isAbsoluteAnchorPoint?this._size&&(b=x(S.x)/(this._size*c),L=x(S.y)/this._size):(b=S.x,L=S.y)),this._anchorX=b,this._anchorY=L,this._sizeOutlineWidth=A(Math.round(Math.min(Math.sqrt(128*m),255)),Math.round(Math.min(Math.sqrt(128*f),255)),Math.round(Math.min(Math.sqrt(128*g),255)),Math.round(Math.min(Math.sqrt(128*v),255))),this.angle=_;const T=Math.round(64*u);this._bitestAndDistRatio=M(this._bitSet,T);const z=h.rect.x+I,N=h.rect.y+I,H=z+h.width,q=N+h.height;this._texUpperLeft=M(z,N),this._texUpperRight=M(H,N),this._texBottomLeft=M(z,q),this._texBottomRight=M(H,q);const O=se.load(this._materialKey);O.sdf=h.sdf,O.pattern=!0,O.textureBinding=h.textureBinding,this._materialKey=O.data,m*=u,f*=u,m*=this._scaleFactor,f*=this._scaleFactor,m*=h.rect.width/h.width,f*=h.rect.height/h.height,this._computedWidth=m,this._computedHeight=f,this._applyTransformation(Mr,gr),this.xOffset=d,this.yOffset=y}}function vi(n){const t=new Array(n.length);for(let e=0;e<n.length;e++)t[e]=n.charCodeAt(e);return t}const wi=5;function vr(n,t,e,i){return typeof n.text=="string"?n.text:typeof n.text=="function"?n.text(t,e,i):""}class ge extends ri(Nt){constructor(t,e,i){super(t),this._horizontalAlignment="center",this._verticalAlignment="middle",this._textToGlyphs=new Map,this._minMaxZoom=M(Math.round(e*C),Math.round(i*C));const s=t.scaleFactor||1;this._cimTextLayer=t;const r=t.color;if(w(r)){const d=(y,p,g)=>$(r(y,p,g));this._dynamicPropertyMap.set("_color",d)}else this._color=$(r);const a=t.outlineColor;if(w(a)){const d=(y,p,g)=>$(a(y,p,g));this._dynamicPropertyMap.set("_haloColor",d)}else this._haloColor=$(a);let o;w(t.size)||(o=Math.min(Math.round(x(t.size*t.sizeRatio)),127));const l=(d,y,p)=>w(t.size)?Math.min(Math.round(x(t.size(d,y,p)*t.sizeRatio)),127):o;if(this._dynamicPropertyMap.set("_size",l),w(t.outlineSize)){const d=(y,p,g)=>Math.min(Math.floor(wi*x(t.outlineSize(y,p,g)*t.sizeRatio)),127);this._dynamicPropertyMap.set("_haloSize",d)}else this._haloSize=Math.min(Math.floor(wi*x(t.outlineSize*t.sizeRatio)),127);let h;w(t.offsetX)||(h=Math.round(x(t.offsetX*t.sizeRatio)));const u=(d,y,p)=>w(t.offsetX)?Math.round(x(t.offsetX(d,y,p)*t.sizeRatio)):h;let c;this._dynamicPropertyMap.set("_xOffset",u),w(t.offsetY)||(c=Math.round(x(t.offsetY*t.sizeRatio)));const _=(d,y,p)=>w(t.offsetY)?Math.round(x(t.offsetY(d,y,p)*t.sizeRatio)):c;if(this._dynamicPropertyMap.set("_yOffset",_),w(t.angle)?this._dynamicPropertyMap.set("_angle",t.angle):this._angle=t.angle,w(t.horizontalAlignment)?this._dynamicPropertyMap.set("_horizontalAlignment",t.horizontalAlignment):this._horizontalAlignment=t.horizontalAlignment,w(t.verticalAlignment)?this._dynamicPropertyMap.set("_verticalAlignment",t.verticalAlignment):this._verticalAlignment=t.verticalAlignment,E(t.effects)){const d=t.effects;w(d)?this._dynamicPropertyMap.set("_effects",d):this._effects=d}if(E(t.markerPlacement)){const d=t.markerPlacement;w(d)?this._dynamicPropertyMap.set("_markerPlacement",d):this._textPlacement=d}w(t.text)?this._dynamicPropertyMap.set("_text",t.text):this._text=t.text,this._scaleFactor=s;const f=Math.min(Math.round(x(t.referenceSize*t.sizeRatio)),127);this._referenceSize=Math.round(Math.sqrt(256*f)),this._materialKey=t.materialKey;const m=vs.load(this._materialKey);m.sdf=!0,this._bitset=(t.alignment===V.MAP?1:0)|(t.colorLocked?1:0)<<1,this._materialKey=m.data,this._decoration="none",this._lineHeight=1,this._lineWidth=512,this._isCIM=!0}static fromCIMText(t,e){const[i,s]=Q(t.scaleInfo,e);return new ge(t,i,s)}async analyze(t,e,i,s){const r=e.readLegacyFeature(),a=vr(this._cimTextLayer,r,i,s),o=await super.analyze(t,e,i,s,vi(a));return o&&o.glyphMosaicItems&&this._textToGlyphs.set(a,o.glyphMosaicItems),o}bindFeature(t,e,i){const s=t.readLegacyFeature();if(this._dynamicPropertyMap.forEach((a,o)=>{this[o]=a(s,e,i)}),!this._text||this._text.length===0)return void(this._shapingInfo=null);this._size*=this._scaleFactor,this._scale=this._size/Fe,this._xOffset*=this._scaleFactor,this._yOffset*=this._scaleFactor,this._xAlignD=De(Tt(this._horizontalAlignment,"center")),this._yAlignD=Ge(Tt(this._verticalAlignment,"baseline"));const r=this._textToGlyphs.get(this._text);this.bindTextInfo(r,!1)}}const pt=128;class j extends xi(xt){constructor(t,e,i,s,r,a,o,l,h,u,c,_,f,m,d,y){super(),this._effects=m;const p=ht.load(t);e&&(p.sdf=e.sdf,p.pattern=!0,p.textureBinding=e.textureBinding),this.fillColor=i,this.tl=s,this.br=r,this.aux21=M(a,o),this.aux22=M(l,h),this.aux3=A(u,c,_,0),this._bitset=f,this._minMaxZoom=M(Math.round(d*C),Math.round(y*C)),this._materialKey=p.data}static fromCIMFill(t,e,i){const s=t.color,r=s&&$(s)||0,a=t.materialKey,[o,l]=Q(t.scaleInfo,i),h=(t.colorLocked?it:0)|(t.applyRandomOffset?Ve:0)|(t.sampleAlphaOnly?$t:0);if(!e)return new j(a,null,r,0,0,0,0,0,0,0,0,0,h,t.effects,o,l);const{rect:u,width:c,height:_}=e,f=t.scaleX||1,m=u.x+I,d=u.y+I,y=m+c,p=d+_,g=x(t.height),v=f*g;let b=Math.round(g);b<=0&&(b=p-d);let L=Math.round(v);L<=0&&(L=y-m);const S=x(t.offsetX||0),T=x(-t.offsetY||0),z=M(m,d),N=M(y,p);return new j(a,e,r,z,N,L,b,S,T,pt,pt,ae(t.angle),h,t.effects,o,l)}static fromSimpleFill(t,e,i=!1){const{color:s}=t,r=s&&t.style!=="esriSFSNull"&&U(s)||0,a=i?it:0,o=t.materialKey;let l;if(e){const{rect:h,width:u,height:c,pixelRatio:_}=e,f=h.x+I,m=h.y+I,d=f+u,y=m+c,p=M(f,m),g=M(d,y);l=new j(o,e,r,p,g,u/_,c/_,0,0,pt,pt,0,a,null,D,G)}else l=new j(o,null,r,0,0,0,0,0,0,0,0,0,a,null,D,G);return l._maybeAddLineTemplate(t),l}static fromPictureFill(t,e,i=!1){const s=ke,{rect:r,width:a,height:o}=e,l=r.x+I,h=r.y+I,u=l+a,c=h+o,_=M(l,h),f=M(u,c),m=Math.round(x(t.width)),d=Math.round(x(t.height)),y=x(t.xoffset),p=x(-t.yoffset),g=t.materialKey,v=i?it:0,b=new j(g,e,s,_,f,m,d,y,p,pt*t.xscale,pt*t.yscale,0,v,null,D,G);return b._maybeAddLineTemplate(t),b}}class wr{constructor(){this._resolver=null}isHeld(){return!!this._resolver}async acquire(){this._resolver?(await this._resolver.promise,await this.acquire()):this._resolver=Oi()}release(){const t=this._resolver;this._resolver=null,t==null||t.resolve()}}async function br(n,t,e){try{await n.acquire(),await t(e),n.release()}catch(i){throw n.release(),i}}async function Sr(n,t,e){if(!n.name)throw new tt("style-symbol-reference-name-missing","Missing name in style symbol reference");if(n.styleName&&n.styleName==="Esri2DPointSymbolsStyle")return Lr(n,e);try{return Pr(await Di(n,t,e),n.name,t,e)}catch(i){return Jt(i),null}}async function Lr(n,t){const e=Gi.replace(/\{SymbolName\}/gi,n.name);try{const i=await $e(e,t);return We(i.data)}catch(i){return Jt(i),null}}async function Pr(n,t,e,i){const s=n.data,r={portal:e&&E(e.portal)?e.portal:Zi.getDefault(),url:Ki(n.baseUrl),origin:"portal-item"},a=s.items.find(l=>l.name===t);if(!a)throw new tt("symbolstyleutils:symbol-name-not-found",`The symbol name '${t}' could not be found`,{symbolName:t});let o=Ni(Ui(a,"cimRef"),r);Xi()&&(o=ji(o));try{const l=await $e(o,i);return We(l.data)}catch(l){return Jt(l),null}}const bi=async(n,t,e)=>new zs(await Ps(n.data,t,e),n.data,n.rendererKey,n.maxVVSize),K=async(n,t,e,i)=>{if(!n)return null;if(n.type==="cim")return bi(n,t,e);if(n.type==="web-style"){const s={type:"cim",data:await Sr(n,null,i),rendererKey:n.rendererKey,maxVVSize:n.maxVVSize};return bi(s,t,e)}return n};function Ut(n){if(!n)return null;const{type:t,cim:e,url:i,materialHash:s}=n,r={cim:e,type:t,mosaicHash:s,url:i,size:null,dashTemplate:null,path:null,text:null,fontName:null,animatedSymbolProperties:null};switch(t){case"marker":r.size=n.size,r.path=n.path,r.animatedSymbolProperties=n.animatedSymbolProperties;break;case"line":r.dashTemplate=n.dashTemplate;break;case"text":r.text=n.text,r.fontName=n.fontName}return r}const F=lt.getLogger("esri.views.2d.engine.webgl.mesh.templates.WGLTemplateStore"),Si=new Array,Me={isOutline:!1,placement:null,symbologyType:Wt.DEFAULT,vvFlags:0},Tr=yt(ot({},Ce),{hash:JSON.stringify(Ce),materialKey:re(P.MARKER,Me)}),zr=yt(ot({},Ee),{hash:JSON.stringify(Ee),materialKey:re(P.LINE,Me)}),Ir=yt(ot({},Ae),{hash:JSON.stringify(Ae),materialKey:re(P.FILL,Me)});function Y(n,t){const e=n.length;return n.push(null),t.then(i=>n[e]=i),n}function St(n){return!!(1&n)}function $r(n){return n.name==="worker:port-closed"}class Qr{constructor(t,e){this._idCounter=1,this._templateIdCounter=1,this._idToTemplateGroup=new Map,this._symbolToTemplate=new Map,this._fetchQueue=[],this._idToResolver=new Map,this._cimTemplateCache=new Map,this._cimAnalyses=[],this._lock=new wr,this._fetchResource=t,this._tileInfo=e}get _markerError(){return this._errorTemplates.marker[0]}get _fillError(){return this._errorTemplates.fill[0]}get _lineError(){return this._errorTemplates.line[0]}get _textError(){return this._errorTemplates.line[0]}createTemplateGroup(t,e){this._initErrorTemplates();const i=t.hash;if(this._symbolToTemplate.has(i))return this._symbolToTemplate.get(i);const s=new Array;e&&this._createMeshTemplates(s,e,!0),this._createMeshTemplates(s,t,!1);const r=this._createGroupId(t.type==="expanded-cim"&&Wr(t));return this._idToTemplateGroup.set(r,s),this._symbolToTemplate.set(i,r),r}getTemplateGroup(t){return this._idToTemplateGroup.has(t)?this._idToTemplateGroup.get(t):Si}getDynamicTemplateGroup(t){return this._idToTemplateGroup.has(t)?(St(t)||F.error("mapview-template-store",`Id ${t} does not refer to a dynamic template`),this._idToTemplateGroup.get(t)):Si}getMosaicItem(t,e){const i=this._createTemplateId(),s=new Promise(r=>this._idToResolver.set(i,r));return this._fetchQueue.push({symbol:t,id:i,glyphIds:e}),s}finalize(t){return this._fetchQueue.length||this._lock.isHeld()?br(this._lock,this._fetchAllQueuedResources.bind(this),t):Promise.resolve()}_initErrorTemplates(){this._errorTemplates||(this._errorTemplates={fill:this._createMeshTemplates([],Ir,!1),marker:this._createMeshTemplates([],Tr,!1),line:this._createMeshTemplates([],zr,!1)})}_fetchAllQueuedResources(t){if(!this._fetchQueue.length)return Promise.resolve();const e=this._fetchQueue,i=this._cimAnalyses;return this._fetchQueue=[],this._cimAnalyses=[],Promise.all(i).then(()=>this._fetchResource(e,t).then(s=>{for(const{id:r,mosaicItem:a}of s)this._idToResolver.get(r)(a),this._idToResolver.delete(r)})).catch(s=>{Yi(s)?this._fetchQueue=this._fetchQueue.concat(e):$r(s)||F.error(new tt("mapview-template-store","Unable to fetch requested texture resources",s))})}_createGroupId(t){return this._idCounter++<<1|(t?1:0)}_createTemplateId(){return this._templateIdCounter++}async _createSMS(t){const{spriteMosaicItem:e}=await this.getMosaicItem(t);return k(e,F)?Z.fromSimpleMarker(t,e):this._markerError}async _createPMS(t){const{spriteMosaicItem:e}=await this.getMosaicItem(t);return k(e,F)?Z.fromPictureMarker(t,e):this._markerError}async _createSFS(t,e){const{spriteMosaicItem:i}=await this.getMosaicItem(t);return k(i,F)?j.fromSimpleFill(t,i,e):this._fillError}async _createPFS(t,e){const{spriteMosaicItem:i}=await this.getMosaicItem(t);return k(i,F)?j.fromPictureFill(t,i,e):this._fillError}async _createSLS(t,e){const{spriteMosaicItem:i}=await this.getMosaicItem(t);return k(i,F)?X.fromSimpleLine(t,i):this._lineError}async _createLMS(t){const{spriteMosaicItem:e}=await this.getMosaicItem(t);return k(e,F)?Z.fromLineSymbolMarker(t,e):this._markerError}async _createTS(t){const{glyphMosaicItems:e}=await this.getMosaicItem(t);return ut.fromText(t,e)}async _createCIMText(t){const{glyphMosaicItems:e}=await this.getMosaicItem(Ut(t),vi(t.text));return k(e,F)?ut.fromCIMText(t,e,this._tileInfo):this._textError}async _createCIMFill(t){const{spriteMosaicItem:e}=await this.getMosaicItem(Ut(t));return k(e,F)?j.fromCIMFill(t,e,this._tileInfo):this._fillError}async _createCIMLine(t){const{spriteMosaicItem:e}=await this.getMosaicItem(Ut(t));return k(e,F)?X.fromCIMLine(t,e,this._tileInfo):this._lineError}async _createCIMMarker(t){const{spriteMosaicItem:e}=await this.getMosaicItem(Ut(t));return k(e,F)?Z.fromCIMMarker(t,e,this._tileInfo):this._markerError}async _createCIM(t){const e=t.templateHash;if(this._cimTemplateCache.has(e))return this._cimTemplateCache.get(e);let i;switch(t.type){case"marker":i=await this._createCIMMarker(t);break;case"line":i=await this._createCIMLine(t);break;case"fill":i=await this._createCIMFill(t);break;case"text":i=await this._createCIMText(t)}return this._cimTemplateCache.set(e,i),i}async _createDynamicCIM(t){const e=t.templateHash;if(this._cimTemplateCache.has(e))return this._cimTemplateCache.get(e);let i;switch(t.type){case"marker":i=xe.fromCIMMarker(t,this._tileInfo);break;case"line":i=ye.fromCIMLine(t,this._tileInfo);break;case"fill":i=pe.fromCIMFill(t,this._tileInfo);break;case"text":i=ge.fromCIMText(t,this._tileInfo)}return this._cimTemplateCache.set(e,i),i}_createPrimitiveMeshTemplates(t,e,i){switch(e.type){case"esriSMS":return Y(t,this._createSMS(e));case"esriPMS":return Y(t,this._createPMS(e));case"esriSFS":return Y(t,this._createSFS(e,i));case"line-marker":return Y(t,this._createLMS(e));case"esriPFS":return Y(t,this._createPFS(e,i));case"esriSLS":return Y(t,this._createSLS(e,!1));case"esriTS":return Y(t,this._createTS(e));default:return F.error("Unable to create mesh template for unknown symbol type {: $ }{symbol.type}"),t}}_createMeshTemplates(t,e,i){if(e.type.includes("3d"))return F.error("3D symbols are not supported with MapView"),t;if(e.type==="expanded-cim"){for(const s of e.layers)typeof s.materialHash=="function"?Y(t,this._createDynamicCIM(s)):Y(t,this._createCIM(s));return t}if(e.type==="composite-symbol"){for(const s of e.layers)this._createPrimitiveMeshTemplates(t,s,i);return t}return e.type==="cim"||e.type==="label"||e.type==="web-style"?t:this._createPrimitiveMeshTemplates(t,e,i)}}const Wr=n=>{if(!n.layers)return!1;for(const t of n.layers)if(typeof t.materialHash=="function")return!0;return!1};class Jr{constructor(t,e,i){this._loadPromise=ds(),this._geometryType=t,this._idField=e,this._templateStore=i}update(t,e){E(t.mesh.labels)&&(this._labelTemplates=this._createLabelTemplates(t.mesh.labels,e)),this._schema=t}_createLabelTemplates(t,e){const i=new Map;if(t.type==="simple"){for(const s of t.classes){const r=Zt.fromLabelClass(s,e);i.set(s.index,r)}return i}for(const s in t.classes){const r=t.classes[s];for(const a of r){const o=Zt.fromLabelClass(a,e);i.set(a.index,o)}}return i}get templates(){return this._templateStore}async analyze(t,e,i,s,r,a,o){if(Re(o))return;let l;i.type==="dictionary"&&(l=await i.analyze(this._idField,t.copy(),e,r,a,o));let h=0;for(;t.next();){let u;if(u=l?l[h++]:E(s)&&ls(t.getDisplayId())&&t.readAttribute("cluster_count")!==1?s.match(this._idField,t,this._geometryType,r,a):i.match(this._idField,t,this._geometryType,r,a),t.setGroupId(u),St(u)){const c=this._templateStore.getDynamicTemplateGroup(u);for(const _ of c)_&&_.analyze&&_.analyze(this._templateStore,t,r,a)}}return await this._loadPromise,this._templateStore.finalize(o)}async analyzeGraphics(t,e,i,s,r,a){if(Re(a))return;const o=t.getCursor();for(i&&await i.analyze(this._idField,o.copy(),e,s,r,a);o.next();){let l=o.getGroupId();if(l!=null&&l!==-1||(l=i.match(this._idField,o,o.geometryType,s,r),o.setGroupId(l)),St(l)){const h=this._templateStore.getDynamicTemplateGroup(l);for(const u of h)u&&u.analyze&&u.analyze(this._templateStore,o,s,r)}o.setGroupId(l)}return await this._loadPromise,this._templateStore.finalize(a)}writeGraphic(t,e,i,s){const r=e.getGroupId(),a=e.getDisplayId(),o=this._templateStore.getTemplateGroup(r);if(t.featureStart(e.insertAfter,0),a!=null){if(St(r))for(const l of o)l&&l.bindFeature(e,null,null);if(o){for(const l of o)l&&l.write(t,e,i,s);t.featureEnd()}}}writeCursor(t,e,i,s,r,a,o){const l=e.getGroupId(),h=e.getDisplayId(),u=this._templateStore.getTemplateGroup(l),c=this._schema.mesh.sortKey;let _=0;if(E(c)&&(_=c.fieldIndex!=null?e.getComputedNumericAtIndex(c.fieldIndex):c.field!=null?e.readAttribute(c.field):e.readAttribute(this._idField),_*=c.order==="asc"?1:-1),t.featureStart(0,_==null||isNaN(_)?0:_),h!=null&&u){if(St(l))for(const f of u)f.bindFeature(e,i,s);for(const f of u)f.write(t,e,r,o);if(E(a)&&t.hasRecords){const f=a&&this._findLabelRef(u);this._writeLabels(t,e,a,f,r,o)}t.featureEnd()}}_findLabelRef(t){for(const e of t)if(e instanceof Z)return e;return null}_writeLabels(t,e,i,s,r,a){for(const o of i)if(E(o)&&o){const{glyphs:l,rtl:h,index:u}=o,c=this._labelTemplates.get(u);c.setZoomLevel(r),c.bindReferenceTemplate(s),c.bindTextInfo(l,h),c.write(t,e,null,a)}}}const ve=lt.getLogger("esri/views/2d/engine/webgl/util/Matcher");async function Cr(n,t,e,i){switch(n.type){case"simple":case"heatmap":return J.fromBasicRenderer(n,t,e,i);case"map":return be.fromUVRenderer(n,t,e,i);case"interval":return we.fromCBRenderer(n,t,e,i);case"dictionary":return Le.fromDictionaryRenderer(n,t,e,i);case"pie-chart":return Xt.fromPieChartRenderer(n,t,e,i);case"subtype":return Xt.fromSubtypes(n,t,e,i)}}class J{constructor(){this.type="feature",this._defaultResult=null}static async fromBasicRenderer(t,e,i,s){const r=new J;if(t.symbol){const a=await K(t.symbol,i,s),o=e.createTemplateGroup(a,null);r.setDefault(o)}return r}static async fromPieChartRenderer(t,e,i,s){const r=new J;if(t.markerSymbol){const a=await K(t.markerSymbol,i,s);let o;t.fillSymbol&&(o=await K(t.fillSymbol,i,s));const l=e.createTemplateGroup(a,o);r.setDefault(l)}return r}size(){return 1}getDefault(){return this._defaultResult}setDefault(t){this._defaultResult=t}match(t,e,i,s,r){return this.getDefault()}async analyze(t,e,i,s,r,a){return null}}class Xt extends J{constructor(t,e){super(),this._subMatchers=t,this._subtypeField=e}static async fromSubtypes(t,e,i,s){const r=new Map,a=[];for(const o in t.renderers){const l=parseInt(o,10),h=Cr(t.renderers[o],e,i,s).then(u=>r.set(l,u));a.push(h)}return await Promise.all(a),new Xt(r,t.subtypeField)}match(t,e,i,s,r){const a=e.readAttribute(this._subtypeField),o=this._subMatchers.get(a);return o?o.match(t,e,i,s,r):null}}class we extends J{constructor(t,e,i,s){super(),this.type="interval",this._intervals=[],this._isMaxInclusive=e,this._fieldIndex=s,this._field=t,this._normalizationInfo=i}static async fromCBRenderer(t,e,i,s){const{isMaxInclusive:r,normalizationField:a,normalizationTotal:o,normalizationType:l}=t,h=t.field,u=new we(h,r,{normalizationField:a,normalizationTotal:o,normalizationType:l},t.fieldIndex),c=await K(t.backgroundFillSymbol,i,s);await Promise.all(t.intervals.map(async f=>{const m=await K(f.symbol,i,s),d=await e.createTemplateGroup(m,c),y={min:f.min,max:f.max};u.add(y,d)}));const _=await K(t.defaultSymbol,i,s);if(_){const f=await e.createTemplateGroup(_,c);u.setDefault(f)}return u}add(t,e){this._intervals.push({interval:t,result:e}),this._intervals.sort((i,s)=>i.interval.min-s.interval.min)}size(){return super.size()+this._intervals.length}match(t,e,i,s,r){if(this._fieldIndex==null&&!this._field)return this.getDefault();const a=this._fieldIndex!=null?e.getComputedNumericAtIndex(this._fieldIndex):this._getValueFromField(e);if(a==null||isNaN(a)||a===1/0||a===-1/0)return this.getDefault();for(let o=0;o<this._intervals.length;o++){const{interval:l,result:h}=this._intervals[o],u=a>=l.min,c=this._isMaxInclusive?a<=l.max:a<l.max;if(u&&c)return h}return this.getDefault()}_needsNormalization(){const t=this._normalizationInfo;return t&&(t.normalizationField||t.normalizationTotal||t.normalizationType)}_getValueFromField(t){const e=t.readAttribute(this._field);if(!this._needsNormalization()||e==null)return e;const{normalizationField:i,normalizationTotal:s,normalizationType:r}=this._normalizationInfo,a=!!i&&t.readAttribute(i);if(r)switch(r){case"esriNormalizeByField":return a?e/a:void 0;case"esriNormalizeByLog":return Math.log(e)*Math.LOG10E;case"esriNormalizeByPercentOfTotal":return e/s*100;default:return void ve.error(`Found unknown normalization type: ${r}`)}else ve.error("Normalization is required, but no type was set!")}}class be extends J{constructor(t,e,i){super(),this.type="map",this._nullResult=null,this._resultsMap=new Map,this._fieldsIndex=i,this._fields=t,this._seperator=e||""}static async fromUVRenderer(t,e,i,s){const r=t.fieldDelimiter,a=[t.field];t.field2&&a.push(t.field2),t.field3&&a.push(t.field3);const o=await K(t.backgroundFillSymbol,i,s),l=new be(a,r,t.fieldIndex);await Promise.all(t.map.map(async u=>{const c=await K(u.symbol,i,s),_=await e.createTemplateGroup(c,o);u.value==="<Null>"?l.setNullResult(_):l.add(u.value,_)}));const h=await K(t.defaultSymbol,i,s);if(h){const u=await e.createTemplateGroup(h,o);l.setDefault(u)}return l}setNullResult(t){this._nullResult=t}add(t,e){this._resultsMap.set(t.toString(),e)}size(){return super.size()+this._resultsMap.size}match(t,e,i,s,r){if(this._fieldsIndex==null&&!this._fields)return this.getDefault();const a=this._fieldsIndex!=null?e.getComputedStringAtIndex(this._fieldsIndex):this._getValueFromFields(e);if(this._nullResult!==null&&(a==null||a===""||a==="<Null>"))return this._nullResult;if(a==null)return this.getDefault();const o=a.toString();return this._resultsMap.has(o)?this._resultsMap.get(o):this.getDefault()}_getValueFromFields(t){const e=[];for(const i of this._fields){const s=t.readAttribute(i);s==null||s===""?e.push("<Null>"):e.push(s)}return e.join(this._seperator)}}async function Er(n,t){const e=n||1;if(typeof e=="number")return(s,r,a)=>e;const i=await qi(e,t.spatialReference,t.fields);return(s,r,a)=>Ts(i,s,{$view:a},t.geometryType,r)||1}let Se;async function Ar(){return Se||(Se=import("./createSymbolSchema.85d3f514.js")),Se}class Le extends J{constructor(t,e,i,s,r,a){super(),this.type="dictionary",this._groupIdCache=new Hi(100),this._loader=t,this._fieldMap=t.fieldMap,this._symbolFields=t.getSymbolFields(),this._templates=e,this._info=i,this._scaleFn=s,this._schemaUtilsModule=r,this._symbolOptions=a}static async fromDictionaryRenderer(t,e,i,s){const[{DictionaryLoader:r},a]=await Promise.all([import("./vendor.ad8aa1ba.js").then(function(h){return h.ss}),Ar()]),o=new r(t.url,t.config,t.fieldMap);await o.fetchResources({spatialReference:i.spatialReference,fields:i.fields});const l=await Er(t.scaleExpression,i);return new Le(o,e,i,l,a,t.symbolOptions)}async _analyzeFeature(t,e,i,s,r){const a=t.readLegacyFeature(),o=this._scaleFn(a,i,s),l=this._attributeHash(a)+"-"+o,h=this._groupIdCache.get(l);if(h)return h;const u=yt(ot({},s),{spatialReference:this._info.spatialReference,abortOptions:r,fields:this._info.fields}),c=await this._loader.getSymbolAsync(a,u),_=this._schemaUtilsModule.createSymbolSchema(c,this._symbolOptions),f=K(_,this._info,e,r).then(m=>{if(m.type!=="expanded-cim")return ve.error(new tt("mapview-bad-type",`Found unexpected type ${m.type} in dictionary response`)),null;m.hash+="-"+o;for(const d of m.layers)d.scaleFactor=o,d.templateHash+="-"+o;return this._templates.createTemplateGroup(m,null)});return this._groupIdCache.put(l,f,1),f}async analyze(t,e,i,s,r,a){const o=e.getCursor(),l=[];for(;o.next();)l.push(this._analyzeFeature(o,i,s,r,a));return Promise.all(l)}match(t,e,i,s,r){return null}_attributeHash(t){let e="";for(const i of this._symbolFields){const s=this._fieldMap[i];s&&(e+=t.attributes[s]+"-")}return e}}export{qr as E,At as a,Jr as b,k as e,Cr as l,K as n,vi as t,Qr as x};
