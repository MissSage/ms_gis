import{b1 as P,cY as z,aD as d,aE as m,aF as E,aB as W,e6 as R,a8 as S,b0 as H,bp as $,el as N,mH as b,nc as q,mL as B}from"./vendor.ad8aa1ba.js";import{R as T}from"./Bitmap.11b33ab6.js";const j=Math.PI/180;function C(e){return e*j}function I(e,i){const s=C(i.rotation),t=Math.abs(Math.cos(s)),r=Math.abs(Math.sin(s)),[a,h]=i.size;return e[0]=Math.round(h*r+a*t),e[1]=Math.round(h*t+a*r),e}function O(e,i,s,t){const[r,a]=i,[h,o]=t,l=.5*s;return e[0]=r-l*h,e[1]=a-l*o,e[2]=r+l*h,e[3]=a+l*o,e}const u=P(),c=[0,0],_=new z(0,0,0,0),f={container:null,fetchSource:null,requestUpdate:null,imageMaxWidth:2048,imageMaxHeight:2048,imageRotationSupported:!1,imageNormalizationSupported:!1,hidpi:!1};let p=class extends W{constructor(e){super(e),this._imagePromise=null,this.bitmaps=[],this.hidpi=f.hidpi,this.imageMaxWidth=f.imageMaxWidth,this.imageMaxHeight=f.imageMaxHeight,this.imageRotationSupported=f.imageRotationSupported,this.imageNormalizationSupported=f.imageNormalizationSupported,this.update=R(async(i,s)=>{if(S(s),!i.stationary||this.destroyed)return;const t=i.state,r=H(t.spatialReference),a=this.hidpi?i.pixelRatio:1,h=this.imageNormalizationSupported&&t.worldScreenWidth&&t.worldScreenWidth<t.size[0];h?(c[0]=t.worldScreenWidth,c[1]=t.size[1]):this.imageRotationSupported?(c[0]=t.size[0],c[1]=t.size[1]):I(c,t);const o=Math.floor(c[0]*a)>this.imageMaxWidth||Math.floor(c[1]*a)>this.imageMaxHeight,l=r&&(t.extent.xmin<r.valid[0]||t.extent.xmax>r.valid[1]),x=!this.imageNormalizationSupported&&l,y=!o&&!x,M=this.imageRotationSupported?t.rotation:0,v=this.container.children.slice();if(y){const n=h?t.paddedViewState.center:t.center;this._imagePromise&&console.error("Image promise was not defined!"),this._imagePromise=this._singleExport(t,c,n,t.resolution,M,a,s)}else{let n=Math.min(this.imageMaxWidth,this.imageMaxHeight);x&&(n=Math.min(t.worldScreenWidth,n)),this._imagePromise=this._tiledExport(t,n,a,s)}try{const n=await this._imagePromise;S(s);const w=[];if(this._imagePromise=null,this.destroyed)return;this.bitmaps=n!=null?n:[];for(const g of v)n.includes(g)||w.push(g.fadeOut().then(()=>{g.remove(),g.destroy()}));for(const g of n)w.push(g.fadeIn());await Promise.all(w)}catch(n){this._imagePromise=null,$(n)}},5e3),this.updateExports=R(async i=>{const s=[];for(const t of this.container.children){if(!t.visible||!t.stage)return;s.push(i(t).then(()=>{t.invalidateTexture(),t.requestRender()}))}this._imagePromise=N(s).then(()=>this._imagePromise=null),await this._imagePromise})}destroy(){this.bitmaps.forEach(e=>e.destroy()),this.bitmaps=[]}get updating(){return!this.destroyed&&this._imagePromise!==null}async _export(e,i,s,t,r,a){const h=await this.fetchSource(e,Math.floor(i*r),Math.floor(s*r),{rotation:t,pixelRatio:r,signal:a});S(a);const o=new T(null,{immutable:!0,requestRenderOnSourceChangedEnabled:!0});return o.x=e.xmin,o.y=e.ymax,o.resolution=e.width/i,o.rotation=t,o.pixelRatio=r,o.opacity=0,this.container.addChild(o),await o.setSourceAsync(h,a),S(a),o}async _singleExport(e,i,s,t,r,a,h){O(u,s,t,i);const o=b(u,e.spatialReference);return[await this._export(o,i[0],i[1],r,a,h)]}_tiledExport(e,i,s,t){const r=q.create({size:i,spatialReference:e.spatialReference,scales:[e.scale]}),a=new B(r),h=a.getTileCoverage(e);if(!h)return null;const o=[];return h.forEach((l,x,y,M)=>{_.set(l,x,y,0),a.getTileBounds(u,_);const v=b(u,e.spatialReference);o.push(this._export(v,i,i,0,s,t).then(n=>(M!==0&&(_.set(l,x,y,M),a.getTileBounds(u,_),n.x=u[0],n.y=u[3]),n)))}),Promise.all(o)}};d([m()],p.prototype,"_imagePromise",void 0),d([m()],p.prototype,"bitmaps",void 0),d([m()],p.prototype,"container",void 0),d([m()],p.prototype,"fetchSource",void 0),d([m()],p.prototype,"hidpi",void 0),d([m()],p.prototype,"imageMaxWidth",void 0),d([m()],p.prototype,"imageMaxHeight",void 0),d([m()],p.prototype,"imageRotationSupported",void 0),d([m()],p.prototype,"imageNormalizationSupported",void 0),d([m()],p.prototype,"requestUpdate",void 0),d([m()],p.prototype,"updating",null),p=d([E("esri.views.2d.layers.support.ExportStrategy")],p);const D=p;export{D as v};
