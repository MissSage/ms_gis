var Ve=Object.defineProperty,Je=Object.defineProperties;var Ye=Object.getOwnPropertyDescriptors;var be=Object.getOwnPropertySymbols;var We=Object.prototype.hasOwnProperty,Xe=Object.prototype.propertyIsEnumerable;var Ae=(e,n,t)=>n in e?Ve(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t,ne=(e,n)=>{for(var t in n||(n={}))We.call(n,t)&&Ae(e,t,n[t]);if(be)for(var t of be(n))Xe.call(n,t)&&Ae(e,t,n[t]);return e},re=(e,n)=>Je(e,Ye(n));import{K as x,O as c,he as C,ag as w,dU as se,aL as L,q6 as qe,q7 as He,lV as Ke,de as Qe,a8 as et,U as _,Y as oe,fL as ae,iC as $e,fh as ie,gU as Fe,gV as Y,f_ as Re,h5 as le,g2 as tt,ai as Me,fJ as W,gl as Le,hr as nt,g1 as rt,aJ as Oe,aA as st,e5 as ot,lu as at,mO as it,at as lt,e8 as ce,b2 as ct,aD as A,aE as R,aF as ft,aP as fe,dT as ut,ee as pt}from"./vendor.ad8aa1ba.js";import{a as V,v as ue,g as pe,x as ht,k as X}from"./axisAngleDegrees.b485d69d.js";import{p as q,g as k}from"./MeshComponent.108c0a36.js";import{r as H,b as gt,x as mt,_ as dt,L as K}from"./georeference.71a009a0.js";import{o as xt}from"./triangulationUtils.2a6db60e.js";import{M as he,j as ge,k as me,O as de,h as xe,L as we}from"./projection.449ffa9e.js";import"./BufferView.9753ca35.js";import"./vec33.8a4fcb5c.js";import"./earcut.afc1d357.js";import"./deduplicate.dfa7fdf5.js";const ye=x.getLogger("esri.geometry.support.meshUtils.centerAt");function wt(e,n,t){var s;if(!e.vertexAttributes||!e.vertexAttributes.position)return;const r=(s=t==null?void 0:t.origin)!=null?s:e.origin;c(e.transform)?((t==null?void 0:t.geographic)!=null&&t.geographic!==e.transform.geographic&&ye.warn(`Specifying the 'geographic' parameter (${t.geographic}) different from the Mesh transform setting (${e.transform.geographic}) is not supported`),yt(e.transform,n,r)):H(e.spatialReference,t)?vt(e,n,r):bt(e,n,r)}function yt(e,n,t){const r=n.x-t.x,s=n.y-t.y,a=n.hasZ&&t.hasZ?n.z-t.z:0,o=e.origin;e.origin=[o[0]+r,o[1]+s,o[2]+a]}function vt(e,n,t){const r=gt(e.vertexAttributes,t,{geographic:!0}),{position:s,normal:a,tangent:o}=mt(r,n,{geographic:!0});e.vertexAttributes.position=s,e.vertexAttributes.normal=a,e.vertexAttributes.tangent=o,e.vertexAttributesChanged()}function bt(e,n,t){const r=Ft,s=$t;if(C(n,s,e.spatialReference)){if(!C(t,r,e.spatialReference)){const a=e.origin;r[0]=a.x,r[1]=a.y,r[2]=a.z,ye.error(`Failed to project specified origin (wkid:${t.spatialReference.wkid}) to mesh spatial reference (wkid:${e.spatialReference.wkid}).`)}At(e.vertexAttributes.position,s,r),e.vertexAttributesChanged()}else ye.error(`Failed to project centerAt location (wkid:${n.spatialReference.wkid}) to mesh spatial reference (wkid:${e.spatialReference.wkid})`)}function At(e,n,t){if(e)for(let r=0;r<e.length;r+=3)for(let s=0;s<3;s++)e[r+s]+=n[s]-t[s]}const $t=w(),Ft=w();async function Rt(e,n,t){const{loadGLTFMesh:r}=await se(import("./loadGLTFMesh.411c91ae.js"),t),s=await Pe(n,t),a=r(new L({x:0,y:0,z:0,spatialReference:e.spatialReference}),s.url,{resolveFile:Mt(s),useTransform:!0,signal:c(t)?t.signal:null});a.then(()=>s.dispose(),()=>s.dispose());const{vertexAttributes:o,components:i}=await a;e.vertexAttributes=o,e.components=i}function Mt(e){const n=He(e.url);return t=>{var a;const r=qe(t,n,n),s=r?r.replace(/^ *\.\//,""):null;return(a=s?e.files.get(s):null)!=null?a:t}}async function Pe(e,n){return e instanceof Blob?S.fromBlob(e):typeof e=="string"?new S(e):Array.isArray(e)?Lt(e,n):Ot(e,n)}async function Lt(e,n){const t=new Map;let r=null;const s=await Ke(e.map(async o=>({name:o.name,source:await Pe(o instanceof Blob?o:o.source,n)}))),a=[];for(const o of s)o&&(Qe(n)?o.source.dispose():a.push(o));et(n);for(const{name:o,source:i}of a)(_(r)||/\.(gltf|glb)/i.test(o))&&(r=i.url),t.set(o,i.url),i.files&&i.files.forEach((l,f)=>t.set(f,l));if(_(r))throw new oe("mesh-load-external:missing-files","Missing files to load external mesh source");return new S(r,()=>a.forEach(({source:o})=>o.dispose()),t)}async function Ot(e,n){const{default:t}=await se(import("./vendor.ad8aa1ba.js").then(function(s){return s.sq}),n),r=typeof e.multipart[0]=="string"?await Promise.all(e.multipart.map(async s=>(await t(s,{responseType:"array-buffer"})).data)):e.multipart;return S.fromBlob(new Blob(r))}class S{constructor(n,t=()=>{},r=new Map){this.url=n,this.dispose=t,this.files=r}static fromBlob(n){const t=URL.createObjectURL(n);return new S(t,()=>URL.revokeObjectURL(t))}}function Pt(e,n,t){e.vertexAttributes&&e.vertexAttributes.position&&(c(e.transform)?((t==null?void 0:t.geographic)!=null&&t.geographic!==e.transform.geographic&&x.getLogger("esri.geometry.support.meshUtils.offset").warn(`Specifying the 'geographic' parameter (${t.geographic}) different from the Mesh transform setting (${e.transform.geographic}) is not supported`),Ct(e.transform,n)):H(e.spatialReference,t)?Et(e,n):jt(e,n))}function Ct(e,n){const t=e.origin;e.origin=ae(w(),t,n)}function Et(e,n){const t=e.spatialReference,r=e.vertexAttributes.position,s=e.vertexAttributes.normal,a=e.vertexAttributes.tangent,o=new Float64Array(r.length),i=c(s)?new Float32Array(s.length):null,l=c(a)?new Float32Array(a.length):null,f=e.extent.center,u=It;$e(t,[f.x,f.y,f.z],Ee,ie(t)),Fe(je,Ee),Y(u,n,je),he(r,t,o),c(s)&&c(i)&&ge(s,r,o,t,i),c(a)&&c(l)&&me(a,r,o,t,l),Ce(o,u),de(o,r,t),c(s)&&c(i)&&xe(i,r,o,t,s),c(a)&&c(l)&&we(l,r,o,t,a),e.vertexAttributesChanged()}function jt(e,n){Ce(e.vertexAttributes.position,n),e.vertexAttributesChanged()}function Ce(e,n){if(e)for(let t=0;t<e.length;t+=3)for(let r=0;r<3;r++)e[t+r]+=n[r]}const It=w(),Ee=Re(),je=le();function zt(){const{faceDescriptions:e,faceVertexOffsets:n,uvScales:t}=Bt,r=4*e.length,s=new Float64Array(3*r),a=new Float32Array(3*r),o=new Float32Array(2*r),i=new Uint32Array(2*e.length*3);let l=0,f=0,u=0,h=0;for(let g=0;g<e.length;g++){const p=e[g],v=l/3;for(const d of n)i[h++]=v+d;const O=p.corners;for(let d=0;d<4;d++){const $=O[d];let b=0;o[u++]=.25*t[d][0]+p.uvOrigin[0],o[u++]=p.uvOrigin[1]-.25*t[d][1];for(let F=0;F<3;F++)p.axis[F]!==0?(s[l++]=.5*p.axis[F],a[f++]=p.axis[F]):(s[l++]=.5*$[b++],a[f++]=0)}}return{position:s,normal:a,uv:o,faces:i}}function kt(e,n){const t=e.components[0],r=t.faces,s=Zt[n],a=6*s,o=new Array(6),i=new Array(r.length-6);let l=0,f=0;for(let u=0;u<r.length;u++)u>=a&&u<a+6?o[l++]=r[u]:i[f++]=r[u];if(c(e.vertexAttributes.uv)){const u=new Float32Array(e.vertexAttributes.uv),h=4*s*2,g=[0,1,1,1,1,0,0,0];for(let p=0;p<g.length;p++)u[h+p]=g[p];e.vertexAttributes.uv=u}return e.components=[new k({faces:o,material:t.material}),new k({faces:i})],e}function St(e=0){const n=Math.round(8*2**e),t=2*n,r=(n-1)*(t+1)+2*t,s=new Float64Array(3*r),a=new Float32Array(3*r),o=new Float32Array(2*r),i=new Uint32Array(3*((n-1)*t*2));let l=0,f=0,u=0,h=0;for(let g=0;g<=n;g++){const p=g/n*Math.PI+.5*Math.PI,v=Math.cos(p),O=Math.sin(p);m[2]=O;const d=g===0||g===n,$=d?t-1:t;for(let b=0;b<=$;b++){const F=b/$*2*Math.PI;m[0]=-Math.sin(F)*v,m[1]=Math.cos(F)*v;for(let P=0;P<3;P++)s[l]=.5*m[P],a[l]=m[P],++l;o[f++]=(b+(d?.5:0))/t,o[f++]=g/n,g!==0&&b!==t&&(g!==n&&(i[u++]=h,i[u++]=h+1,i[u++]=h-t),g!==1&&(i[u++]=h,i[u++]=h-t,i[u++]=h-t-1)),h++}}return{position:s,normal:a,uv:o,faces:i}}function Dt(e=0){const n=5,t=Math.round(16*2**e),r=(n-1)*(t+1)+2*t,s=new Float64Array(3*r),a=new Float32Array(3*r),o=new Float32Array(2*r),i=new Uint32Array(3*(4*t));let l=0,f=0,u=0,h=0,g=0;for(let p=0;p<=n;p++){const v=p===0||p===n,O=p<=1||p>=n-1,d=p===2||p===4,$=v?t-1:t;for(let b=0;b<=$;b++){const F=b/$*2*Math.PI,P=v?0:.5;m[0]=P*Math.sin(F),m[1]=P*-Math.cos(F),m[2]=p<=2?.5:-.5;for(let z=0;z<3;z++)s[l++]=m[z],a[f++]=O?z===2?p<=1?1:-1:0:z===2?0:m[z]/P;o[u++]=(b+(v?.5:0))/t,o[u++]=p<=1?1*p/3:p<=3?1*(p-2)/3+1/3:1*(p-4)/3+2/3,d||p===0||b===t||(p!==n&&(i[h++]=g,i[h++]=g+1,i[h++]=g-t),p!==1&&(i[h++]=g,i[h++]=g-t,i[h++]=g-t-1)),g++}}return{position:s,normal:a,uv:o,faces:i}}function Tt(e,n){const t=typeof n=="number"?n:n!=null?n.width:1,r=typeof n=="number"?n:n!=null?n.height:1;switch(e){case"up":case"down":return{width:t,depth:r};case"north":case"south":return{width:t,height:r};case"east":case"west":return{depth:t,height:r}}}function Ut(e){const n=J.facingAxisOrderSwap[e],t=J.position,r=J.normal,s=new Float64Array(t.length),a=new Float32Array(r.length);let o=0;for(let i=0;i<4;i++){const l=o;for(let f=0;f<3;f++){const u=n[f],h=Math.abs(u)-1,g=u>=0?1:-1;s[o]=t[l+h]*g,a[o]=r[l+h]*g,o++}}return{position:s,normal:a,uv:new Float32Array(J.uv),faces:new Uint32Array(J.faces),isPlane:!0}}const D=1,T=2,U=3,J={position:[-.5,-.5,0,.5,-.5,0,.5,.5,0,-.5,.5,0],normal:[0,0,1,0,0,1,0,0,1,0,0,1],uv:[0,1,1,1,1,0,0,0],faces:[0,1,2,0,2,3],facingAxisOrderSwap:{east:[U,D,T],west:[-U,-D,T],north:[-D,U,T],south:[D,-U,T],up:[D,T,U],down:[D,-T,-U]}};function Q(e,n,t){e.isPlane||Nt(e),Gt(e,t==null?void 0:t.size);const{vertexAttributes:r,transform:s}=dt(e,n,t);return{vertexAttributes:new q(re(ne({},r),{uv:e.uv})),transform:s,components:[new k({faces:e.faces,material:t&&t.material||null})],spatialReference:n.spatialReference}}function Nt(e){for(let n=0;n<e.position.length;n+=3)e.position[n+2]+=.5}function Gt(e,n){if(n==null)return;const t=typeof n=="number"?[n,n,n]:[n.width!=null?n.width:1,n.depth!=null?n.depth:1,n.height!=null?n.height:1];E[0]=t[0],E[4]=t[1],E[8]=t[2];for(let r=0;r<e.position.length;r+=3){for(let s=0;s<3;s++)m[s]=e.position[r+s];Y(m,m,E);for(let s=0;s<3;s++)e.position[r+s]=m[s]}if(t[0]!==t[1]||t[1]!==t[2]){E[0]=1/t[0],E[4]=1/t[1],E[8]=1/t[2];for(let r=0;r<e.normal.length;r+=3){for(let s=0;s<3;s++)m[s]=e.normal[r+s];Y(m,m,E),tt(m,m);for(let s=0;s<3;s++)e.normal[r+s]=m[s]}}}const Bt={faceDescriptions:[{axis:[0,-1,0],uvOrigin:[0,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[1,0,0],uvOrigin:[.25,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,1,0],uvOrigin:[.5,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[-1,0,0],uvOrigin:[.75,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[0,0,1],uvOrigin:[0,.375],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,0,-1],uvOrigin:[0,.875],corners:[[-1,1],[1,1],[1,-1],[-1,-1]]}],uvScales:[[0,0],[1,0],[1,1],[0,1]],faceVertexOffsets:[0,1,2,0,2,3]},Zt={south:0,east:1,north:2,west:3,up:4,down:5},m=w(),E=le(),Ie=x.getLogger("esri.geometry.support.meshUtils.rotate");function _t(e,n,t){var s,a;if(!e.vertexAttributes||!e.vertexAttributes.position||n[3]===0)return;const r=e.spatialReference;if(c(e.transform)){(t==null?void 0:t.geographic)!=null&&t.geographic!==e.transform.geographic&&Ie.warn(`Specifying the 'geographic' parameter (${t.geographic}) different from the Mesh transform setting (${e.transform.geographic}) is not supported`);const o=(s=t==null?void 0:t.origin)!=null?s:e.transform.getOriginPoint(r);Vt(e.transform,n,o)}else{const o=(a=t==null?void 0:t.origin)!=null?a:e.origin;H(e.spatialReference,t)?Jt(e,n,o):Yt(e,n,o)}}function Vt(e,n,t){const r=Me(G,t.x,t.y,t.z),s=W(G,r,e.origin);e.applyLocalInverse(s,ze),e.rotation=ue(e.rotation,n,V()),e.applyLocalInverse(s,s),W(s,s,ze),e.translation=ae(w(),e.translation,s)}function Jt(e,n,t){const r=e.spatialReference,s=ie(r),a=De;C(t,a,s)||C(e.origin,a,s);const o=e.vertexAttributes.position,i=e.vertexAttributes.normal,l=e.vertexAttributes.tangent,f=new Float64Array(o.length),u=c(i)?new Float32Array(i.length):null,h=c(l)?new Float32Array(l.length):null;$e(s,a,ee,s),Fe(Se,ee);const g=ke;Y(pe(ke),pe(n),Se),g[3]=n[3],he(o,r,f),c(i)&&c(u)&&ge(i,o,f,r,u),c(l)&&c(h)&&me(l,o,f,r,h),N(f,g,3,a),de(f,o,r),c(i)&&c(u)&&(N(u,g,3),xe(u,o,f,r,i)),c(l)&&c(h)&&(N(h,g,4),we(h,o,f,r,l)),e.vertexAttributesChanged()}function Yt(e,n,t){const r=De;if(!C(t,r,e.spatialReference)){const s=e.origin;r[0]=s.x,r[1]=s.y,r[2]=s.z,Ie.error(`Failed to project specified origin (wkid:${t.spatialReference.wkid}) to mesh spatial reference (wkid:${e.spatialReference.wkid}).`)}N(e.vertexAttributes.position,n,3,r),N(e.vertexAttributes.normal,n,3),N(e.vertexAttributes.tangent,n,4),e.vertexAttributesChanged()}function N(e,n,t,r=Le){if(!_(e)){nt(ee,ht(n),pe(n));for(let s=0;s<e.length;s+=t){for(let a=0;a<3;a++)G[a]=e[s+a]-r[a];rt(G,G,ee);for(let a=0;a<3;a++)e[s+a]=G[a]+r[a]}}}const G=w(),ze=w(),ke=V(),ee=Re(),Se=le(),De=w(),Te=x.getLogger("esri.geometry.support.meshUtils.scale");function Wt(e,n,t){var s;if(!e.vertexAttributes||!e.vertexAttributes.position)return;const r=e.spatialReference;if(c(e.transform)){(t==null?void 0:t.geographic)!=null&&t.geographic!==e.transform.geographic&&Te.warn(`Specifying the 'geographic' parameter (${t.geographic}) different from the Mesh transform setting (${e.transform.geographic}) is not supported`);const a=(s=t==null?void 0:t.origin)!=null?s:e.transform.getOriginPoint(r);Xt(e.transform,n,a)}else{const a=H(e.spatialReference,t),o=t&&t.origin||e.origin;a?qt(e,n,o):Ht(e,n,o)}}function Xt(e,n,t){const r=Me(B,t.x,t.y,t.z),s=W(B,r,e.origin);e.applyLocalInverse(s,Ne);const a=Oe(w(),e.scale,n);e.scale=a,e.applyLocalInverse(s,s),W(s,s,Ne),e.translation=ae(w(),e.translation,s)}function qt(e,n,t){const r=e.spatialReference,s=ie(r),a=Ge;C(t,a,s)||C(e.origin,a,s);const o=e.vertexAttributes.position,i=e.vertexAttributes.normal,l=e.vertexAttributes.tangent,f=new Float64Array(o.length),u=c(i)?new Float32Array(i.length):null,h=c(l)?new Float32Array(l.length):null;he(o,r,f),c(i)&&c(u)&&ge(i,o,f,r,u),c(l)&&c(h)&&me(l,o,f,r,h),Ue(f,n,a),de(f,o,r),c(i)&&c(u)&&xe(u,o,f,r,i),c(l)&&c(h)&&we(h,o,f,r,l),e.vertexAttributesChanged()}function Ht(e,n,t){const r=Ge;if(!C(t,r,e.spatialReference)){const s=e.origin;r[0]=s.x,r[1]=s.y,r[2]=s.z,Te.error(`Failed to project specified origin (wkid:${t.spatialReference.wkid}) to mesh spatial reference (wkid:${e.spatialReference.wkid}).`)}Ue(e.vertexAttributes.position,n,r),e.vertexAttributesChanged()}function Ue(e,n,t=Le){if(e)for(let r=0;r<e.length;r+=3){for(let s=0;s<3;s++)B[s]=e[r+s]-t[s];Oe(B,B,n);for(let s=0;s<3;s++)e[r+s]=B[s]+t[s]}}const B=w(),Ne=w(),Ge=w();var M;const I="esri.geometry.Mesh";let y=M=class extends st(ot.LoadableMixin(at(it))){constructor(e){super(e),this.components=null,this.transform=null,this.external=null,this.hasZ=!0,this.hasM=!1,this.vertexAttributes=new q,this.type="mesh"}initialize(){(_(this.external)||this.vertexAttributes.position.length)&&(this.loadStatus="loaded"),this.when(()=>{this.handles.add(lt(()=>{var e;return{vertexAttributes:this.vertexAttributes,components:(e=this.components)==null?void 0:e.map(n=>n.clone())}},()=>this._set("external",null),{once:!0,sync:!0}))})}get hasExtent(){return!this.loaded&&c(this.external)&&c(this.external.extent)||this.loaded&&this.vertexAttributes.position.length>0&&(!this.components||this.components.length>0)}get _boundingInfo(){const e=this.vertexAttributes.position,n=this.spatialReference;if(e.length===0||this.components&&this.components.length===0)return{extent:new ce({xmin:0,ymin:0,zmin:0,xmax:0,ymax:0,zmax:0,spatialReference:n}),center:new L({x:0,y:0,z:0,spatialReference:n})};const t=c(this.transform)?this.transform.project(e,n):e;let r=1/0,s=1/0,a=1/0,o=-1/0,i=-1/0,l=-1/0,f=0,u=0,h=0;const g=t.length,p=1/(g/3);let v=0;for(;v<g;){const O=t[v++],d=t[v++],$=t[v++];r=Math.min(r,O),s=Math.min(s,d),a=Math.min(a,$),o=Math.max(o,O),i=Math.max(i,d),l=Math.max(l,$),f+=p*O,u+=p*d,h+=p*$}return{extent:new ce({xmin:r,ymin:s,zmin:a,xmax:o,ymax:i,zmax:l,spatialReference:n}),center:new L({x:f,y:u,z:h,spatialReference:n})}}get anchor(){if(c(this.transform))return this.transform.getOriginPoint(this.spatialReference);const e=this._boundingInfo;return new L({x:e.center.x,y:e.center.y,z:e.extent.zmin,spatialReference:this.spatialReference})}get origin(){return c(this.transform)?this.transform.getOriginPoint(this.spatialReference):this._boundingInfo.center}get extent(){return!this.loaded&&c(this.external)&&c(this.external.extent)?this.external.extent.clone():this._boundingInfo.extent}addComponent(e){this.loaded?(this.components||(this.components=[]),this.components.push(k.from(e)),this.notifyChange("components")):x.getLogger(this.declaredClass).error("addComponent()","Mesh must be loaded before applying operations")}removeComponent(e){if(this.loaded){if(this.components){const n=this.components.indexOf(e);if(n!==-1)return this.components.splice(n,1),void this.notifyChange("components")}x.getLogger(this.declaredClass).error("removeComponent()","Provided component is not part of the list of components")}else x.getLogger(this.declaredClass).error("removeComponent()","Mesh must be loaded before applying operations")}rotate(e,n,t,r){return X(ve.x,e,Z),X(ve.y,n,Be),X(ve.z,t,Ze),ue(Z,Be,Z),ue(Z,Ze,Z),_t(this,Z,r),this}offset(e,n,t,r){return this.loaded?(te[0]=e,te[1]=n,te[2]=t,Pt(this,te,r),this):(x.getLogger(this.declaredClass).error("offset()","Mesh must be loaded before applying operations"),this)}scale(e,n){return this.loaded?(Wt(this,e,n),this):(x.getLogger(this.declaredClass).error("scale()","Mesh must be loaded before applying operations"),this)}centerAt(e,n){return this.loaded?(wt(this,e,n),this):(x.getLogger(this.declaredClass).error("centerAt()","Mesh must be loaded before applying operations"),this)}load(e){return c(this.external)&&this.addResolvingPromise(Rt(this,this.external.source,e)),Promise.resolve(this)}updateExternalSource(e){this._set("external",e)}clone(){let e=null;if(this.components){const t=new Map,r=new Map;e=this.components.map(s=>s.cloneWithDeduplication(t,r))}const n={components:e,spatialReference:this.spatialReference,vertexAttributes:this.vertexAttributes.clone(),transform:c(this.transform)?this.transform.clone():null,external:c(this.external)?{source:this.external.source,extent:c(this.external.extent)?this.external.extent.clone():null}:null};return new M(n)}vertexAttributesChanged(){this.notifyChange("vertexAttributes")}async toBinaryGLTF(e){const n=import("./gltfexport.9d070c86.js"),t=this.load(),r=await Promise.all([n,t]),{toBinaryGLTF:s}=r[0];return s(this,e)}static createBox(e,n){if(!(e instanceof L))return x.getLogger(I).error(".createBox()","expected location to be a Point instance"),null;const t=new M(Q(zt(),e,n));return n&&n.imageFace&&n.imageFace!=="all"?kt(t,n.imageFace):t}static createSphere(e,n){return e instanceof L?new M(Q(St(n&&n.densificationFactor||0),e,n)):(x.getLogger(I).error(".createSphere()","expected location to be a Point instance"),null)}static createCylinder(e,n){return e instanceof L?new M(Q(Dt(n&&n.densificationFactor||0),e,n)):(x.getLogger(I).error(".createCylinder()","expected location to be a Point instance"),null)}static createPlane(e,n){var s;if(!(e instanceof L))return x.getLogger(I).error(".createPlane()","expected location to be a Point instance"),null;const t=(s=n==null?void 0:n.facing)!=null?s:"up",r=Tt(t,n==null?void 0:n.size);return new M(Q(Ut(t),e,re(ne({},n),{size:r})))}static createFromPolygon(e,n){var r;if(!(e instanceof ct))return x.getLogger(I).error(".createFromPolygon()","expected polygon to be a Polygon instance"),null;const t=xt(e);return new M({vertexAttributes:new q({position:t.position}),components:[new k({faces:t.faces,shading:"flat",material:(r=n==null?void 0:n.material)!=null?r:null})],spatialReference:e.spatialReference})}static async createFromGLTF(e,n,t){if(!(e instanceof L))throw x.getLogger(I).error(".createfromGLTF()","expected location to be a Point instance"),new oe("invalid-input","Expected location to be a Point instance");const{loadGLTFMesh:r}=await se(import("./loadGLTFMesh.411c91ae.js"),t);return new M(await r(e,n,t))}static createWithExternalSource(e,n,t){var o,i,l,f;const r=(o=t==null?void 0:t.extent)!=null?o:null,s=(l=(i=t==null?void 0:t.transform)==null?void 0:i.clone())!=null?l:new K;s.origin=[e.x,e.y,(f=e.z)!=null?f:0];const a=e.spatialReference;return new M({external:{source:n,extent:r},transform:s,spatialReference:a})}static createIncomplete(e,n){var a,o,i;const t=(o=(a=n==null?void 0:n.transform)==null?void 0:a.clone())!=null?o:new K;t.origin=[e.x,e.y,(i=e.z)!=null?i:0];const r=e.spatialReference,s=new M({transform:t,spatialReference:r});return s.addResolvingPromise(Promise.reject(new oe("mesh-incomplete","Mesh resources are not complete"))),s}};A([R({type:[k],json:{write:!0}})],y.prototype,"components",void 0),A([R({type:K,json:{write:!0}})],y.prototype,"transform",void 0),A([R({constructOnly:!0})],y.prototype,"external",void 0),A([R({readOnly:!0})],y.prototype,"hasExtent",null),A([R({readOnly:!0})],y.prototype,"_boundingInfo",null),A([R({readOnly:!0})],y.prototype,"anchor",null),A([R({readOnly:!0})],y.prototype,"origin",null),A([R({readOnly:!0,json:{read:!1}})],y.prototype,"extent",null),A([R({readOnly:!0,json:{read:!1,write:!0,default:!0}})],y.prototype,"hasZ",void 0),A([R({readOnly:!0,json:{read:!1,write:!0,default:!1}})],y.prototype,"hasM",void 0),A([R({type:q,nonNullable:!0,json:{write:!0}})],y.prototype,"vertexAttributes",void 0),y=M=A([ft(I)],y);const ve={x:fe(1,0,0),y:fe(0,1,0),z:fe(0,0,1)},Z=V(),Be=V(),Ze=V(),te=w(),_e=y;function dn(e,n,t){const r=t.features;t.features=[],delete t.geometryType;const s=ut.fromJSON(t);if(s.geometryType="mesh",!t.assetMaps)return s;const a=nn(n,t.assetMaps),o=s.spatialReference,i=t.globalIdFieldName,l=_(e.outFields)||!e.outFields.length?()=>({}):Kt(e.outFields.includes("*")?null:new Set(e.outFields));for(const f of r){const u=Qt(f,i,o,n,a);c(u)&&s.features.push(new pt({geometry:u,attributes:l(f)}))}return s}function Kt(e){return({attributes:n})=>{if(!n)return{};if(!e)return n;for(const t in n)e.has(t)||delete n[t];return n}}function Qt(e,n,t,r,s){const a=e.attributes[n],o=s.get(a);if(o==null||o.status===j.FAILED||o.url==null)return null;const i=en(e,t,r),l=ce.fromJSON(e.geometry);l.spatialReference=t;const f=tn(e.attributes,r,o.geographic);return o.status===j.PENDING?_e.createIncomplete(i,{extent:l,transform:f}):_e.createWithExternalSource(i,[{name:o.name,source:o.url}],{extent:l,transform:f})}function en({attributes:e},n,{transformFieldRoles:t}){return new L({x:e[t.originX],y:e[t.originY],z:e[t.originZ],spatialReference:n})}function tn(e,{transformFieldRoles:n},t){return new K({translation:[e[n.translationX],e[n.translationY],e[n.translationZ]],rotation:X([e[n.rotationX],e[n.rotationY],e[n.rotationZ]],e[n.rotationDeg]),scale:[e[n.scaleX],e[n.scaleY],e[n.scaleZ]],geographic:t})}var j;function nn(e,n){const t=new Map;for(const r of n){const s=r.parentGlobalId;if(s==null)continue;const a=r.assetName,o=r.assetURL,i=r.conversionStatus;let l=t.get(s);if(l!=null)throw new Error("multiple asset parts not expected.");switch(l={name:a,status:j.FAILED,url:o,geographic:rn(r.flags).projectVertices},t.set(s,l),i){case"COMPLETED":case"SUBMITTED":l.status=j.COMPLETED;break;case"INPROGRESS":l.status=j.PENDING;break;default:l.status=j.FAILED}}return t}function rn(e){return{projectVertices:e.includes("PROJECT_VERTICES")}}(function(e){e[e.FAILED=0]="FAILED",e[e.PENDING=1]="PENDING",e[e.COMPLETED=2]="COMPLETED"})(j||(j={}));export{dn as meshFeatureSetFromJSON};
